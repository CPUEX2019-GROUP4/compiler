----- syntax.print -----
LETREC print_int (VAR of )
  (n : VAR of )
  LET n (VAR of )
    IF
      NOT
        LE
          INT 0
          VAR n
      LET Tu1 (UNIT)
        OUT
          INT 45        0
      NEG
        VAR n
      VAR n
  IF
    NOT
      LE
        INT 10
        VAR n
    OUT
      VAR n    48
    LET m (VAR of )
      DIVIDE BY 10
        VAR n
    LET Tu2 (UNIT)
      APP
        VAR print_int
        VAR m
    OUT
      SUB
        VAR n
        MULTIPLE 10
          VAR m    48
LETREC print_newline (VAR of )
  (Tu3 : VAR of )
  OUT
    INT 0  10
LETREC sqrt (VAR of )
  (x : VAR of )
  LET t (VAR of )
    UNKNOWN APP      sqrt_init
      VAR x
  LET t (VAR of )
    FDIV
      FADD
        FMUL
          VAR t
          VAR t
        VAR x
      FADD
        VAR t
        VAR t
  LET t (VAR of )
    FDIV
      FADD
        FMUL
          VAR t
          VAR t
        VAR x
      FADD
        VAR t
        VAR t
  LET t (VAR of )
    FDIV
      FADD
        FMUL
          VAR t
          VAR t
        VAR x
      FADD
        VAR t
        VAR t
  VAR t
LETREC kernel_atan (VAR of )
  (a1 : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a1
      VAR a1
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a1
  LET a5 (VAR of )
    FMUL
      VAR a2
      VAR a3
  LET a7 (VAR of )
    FMUL
      VAR a2
      VAR a5
  LET a9 (VAR of )
    FMUL
      VAR a2
      VAR a7
  LET a11 (VAR of )
    FMUL
      VAR a2
      VAR a9
  LET a13 (VAR of )
    FMUL
      VAR a2
      VAR a11
  FADD
    FSUB
      FADD
        FSUB
          FADD
            FSUB
              VAR a1
              FMUL
                FLOAT 0.3333333
                VAR a3
            FMUL
              FLOAT 0.2
              VAR a5
          FMUL
            FLOAT 0.142857142
            VAR a7
        FMUL
          FLOAT 0.111111104
          VAR a9
      FMUL
        FLOAT 0.08976446
        VAR a11
    FMUL
      FLOAT 0.060035485
      VAR a13
LETREC atan (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      VAR flag
      VAR a
      NEG
        VAR a
  LET b (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.4375
      APP
        VAR kernel_atan
        VAR a
      IF
        FLt
          VAR a
          FLOAT 2.4375
        FADD
          FLOAT 0.785398163397
          APP
            VAR kernel_atan
            FDIV
              FSUB
                VAR a
                FLOAT 1.
              FADD
                VAR a
                FLOAT 1.
        FSUB
          FLOAT 1.57079632679
          APP
            VAR kernel_atan
            FDIV
              FLOAT 1.
              VAR a
  IF
    VAR flag
    VAR b
    NEG
      VAR b
LETREC floor (VAR of )
  (x : VAR of )
  LET a (VAR of )
    int_to_float
      float_to_int
        VAR x
  IF
    FLt
      VAR x
      VAR a
    FSUB
      VAR a
      FLOAT 1.
    VAR a
LETREC fabs (VAR of )
  (f : VAR of )
  IF
    FLt
      VAR f
      FLOAT 0.
    NEG
      VAR f
    VAR f
LETREC fhalf (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.5
LETREC fsqr (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    VAR x
LETREC fneg (VAR of )
  (x : VAR of )
  NEG
    VAR x
LETREC fless (VAR of )
  (a : VAR of ), (b : VAR of )
  FLt
    VAR a
    VAR b
LETREC abs_float (VAR of )
  (x : VAR of )
  APP
    VAR fabs
    VAR x
LETREC fispos (VAR of )
  (x : VAR of )
  FLt
    FLOAT 0.
    VAR x
LETREC fisneg (VAR of )
  (x : VAR of )
  FLt
    VAR x
    FLOAT 0.
LET n_objects (VAR of )
  ARRAY
    INT 1
    INT 0
LET objects (VAR of )
  LET dummy (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  ARRAY
    INT 60
    TUPLE
      INT 0
      INT 0
      INT 0
      INT 0
      VAR dummy
      VAR dummy
      BOOL false
      VAR dummy
      VAR dummy
      VAR dummy
      VAR dummy
LET screen (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET viewpoint (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET light (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET beam (VAR of )
  ARRAY
    INT 1
    FLOAT 255.
LET and_net (VAR of )
  ARRAY
    INT 50
    ARRAY
      INT 1
      NEG
        INT 1
LET or_net (VAR of )
  ARRAY
    INT 1
    ARRAY
      INT 1
      GET
        VAR and_net
        INT 0
LET solver_dist (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET intsec_rectside (VAR of )
  ARRAY
    INT 1
    INT 0
LET tmin (VAR of )
  ARRAY
    INT 1
    FLOAT 1000000000.
LET intersection_point (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET intersected_object_id (VAR of )
  ARRAY
    INT 1
    INT 0
LET nvector (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET texture_color (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET diffuse_ray (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET rgb (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET image_size (VAR of )
  ARRAY
    INT 2
    INT 0
LET image_center (VAR of )
  ARRAY
    INT 2
    INT 0
LET scan_pitch (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET startp (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET startp_fast (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenx_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screeny_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenz_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET ptrace_dirvec (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET dirvecs (VAR of )
  LET dummyf (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff (VAR of )
    ARRAY
      INT 0
      VAR dummyf
  LET dummy_vs (VAR of )
    ARRAY
      INT 0
      TUPLE
        VAR dummyf
        VAR dummyff
  ARRAY
    INT 5
    VAR dummy_vs
LET light_dirvec (VAR of )
  LET dummyf2 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      INT 60
      VAR dummyf2
  TUPLE
    VAR v3
    VAR consts
LET reflections (VAR of )
  LET dummyf3 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff3 (VAR of )
    ARRAY
      INT 0
      VAR dummyf3
  LET dummydv (VAR of )
    TUPLE
      VAR dummyf3
      VAR dummyff3
  ARRAY
    INT 180
    TUPLE
      INT 0
      VAR dummydv
      FLOAT 0.
LET n_reflections (VAR of )
  ARRAY
    INT 1
    INT 0
LETREC xor (VAR of )
  (x : VAR of ), (y : VAR of )
  IF
    VAR x
    NOT
      VAR y
    VAR y
LETREC sgn (VAR of )
  (x : VAR of )
  IF
    FZero?
      VAR x
    FLOAT 0.
    IF
      APP
        VAR fispos
        VAR x
      FLOAT 1.
      FLOAT -1.
LETREC fneg_cond (VAR of )
  (cond : VAR of ), (x : VAR of )
  IF
    VAR cond
    VAR x
    APP
      VAR fneg
      VAR x
LETREC add_mod5 (VAR of )
  (x : VAR of ), (y : VAR of )
  LET sum (VAR of )
    ADD
      VAR x
      VAR y
  IF
    LE
      INT 5
      VAR sum
    SUB
      VAR sum
      INT 5
    VAR sum
LETREC vecset (VAR of )
  (v : VAR of ), (x : VAR of ), (y : VAR of ), (z : VAR of )
  LET Tu5 (UNIT)
    PUT
      VAR v
      INT 0
      VAR x
  LET Tu4 (UNIT)
    PUT
      VAR v
      INT 1
      VAR y
  PUT
    VAR v
    INT 2
    VAR z
LETREC vecfill (VAR of )
  (v : VAR of ), (elem : VAR of )
  LET Tu7 (UNIT)
    PUT
      VAR v
      INT 0
      VAR elem
  LET Tu6 (UNIT)
    PUT
      VAR v
      INT 1
      VAR elem
  PUT
    VAR v
    INT 2
    VAR elem
LETREC vecbzero (VAR of )
  (v : VAR of )
  APP
    VAR vecfill
    VAR v
    FLOAT 0.
LETREC veccpy (VAR of )
  (dest : VAR of ), (src : VAR of )
  LET Tu9 (UNIT)
    PUT
      VAR dest
      INT 0
      GET
        VAR src
        INT 0
  LET Tu8 (UNIT)
    PUT
      VAR dest
      INT 1
      GET
        VAR src
        INT 1
  PUT
    VAR dest
    INT 2
    GET
      VAR src
      INT 2
LETREC vecdist2 (VAR of )
  (p : VAR of ), (q : VAR of )
  FADD
    FADD
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 0
          GET
            VAR q
            INT 0
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 1
          GET
            VAR q
            INT 1
    APP
      VAR fsqr
      FSUB
        GET
          VAR p
          INT 2
        GET
          VAR q
          INT 2
LETREC vecunit (VAR of )
  (v : VAR of )
  LET il (VAR of )
    FDIV
      FLOAT 1.
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              GET
                VAR v
                INT 0
            APP
              VAR fsqr
              GET
                VAR v
                INT 1
          APP
            VAR fsqr
            GET
              VAR v
              INT 2
  LET Tu11 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu10 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC vecunit_sgn (VAR of )
  (v : VAR of ), (inv : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FADD
          APP
            VAR fsqr
            GET
              VAR v
              INT 0
          APP
            VAR fsqr
            GET
              VAR v
              INT 1
        APP
          VAR fsqr
          GET
            VAR v
            INT 2
  LET il (VAR of )
    IF
      FZero?
        VAR l
      FLOAT 1.
      IF
        VAR inv
        FDIV
          FLOAT -1.
          VAR l
        FDIV
          FLOAT 1.
          VAR l
  LET Tu13 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu12 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC veciprod (VAR of )
  (v : VAR of ), (w : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        GET
          VAR w
          INT 0
      FMUL
        GET
          VAR v
          INT 1
        GET
          VAR w
          INT 1
    FMUL
      GET
        VAR v
        INT 2
      GET
        VAR w
        INT 2
LETREC veciprod2 (VAR of )
  (v : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        VAR w0
      FMUL
        GET
          VAR v
          INT 1
        VAR w1
    FMUL
      GET
        VAR v
        INT 2
      VAR w2
LETREC vecaccum (VAR of )
  (dest : VAR of ), (scale : VAR of ), (v : VAR of )
  LET Tu15 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          VAR scale
          GET
            VAR v
            INT 0
  LET Tu14 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          VAR scale
          GET
            VAR v
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        VAR scale
        GET
          VAR v
          INT 2
LETREC vecadd (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu17 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu16 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecmul (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu19 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu18 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecscale (VAR of )
  (dest : VAR of ), (scale : VAR of )
  LET Tu21 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        VAR scale
  LET Tu20 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        VAR scale
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      VAR scale
LETREC vecaccumv (VAR of )
  (dest : VAR of ), (v : VAR of ), (w : VAR of )
  LET Tu23 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          GET
            VAR v
            INT 0
          GET
            VAR w
            INT 0
  LET Tu22 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          GET
            VAR v
            INT 1
          GET
            VAR w
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        GET
          VAR v
          INT 2
        GET
          VAR w
          INT 2
LETREC o_texturetype (VAR of )
  (m : VAR of )
  (m_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_tex
LETREC o_form (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (m_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_shape
LETREC o_reflectiontype (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_surface
LETREC o_isinvert (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (m_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_invert
LETREC o_isrot (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (m_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_isrot
LETREC o_param_a (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 0
LETREC o_param_b (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 1
LETREC o_param_c (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 2
LETREC o_param_abc (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_abc
LETREC o_param_x (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 0
LETREC o_param_y (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 1
LETREC o_param_z (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 2
LETREC o_diffuse (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 0
LETREC o_hilight (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 1
LETREC o_color_red (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 0
LETREC o_color_green (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 1
LETREC o_color_blue (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 2
LETREC o_param_r1 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 0
LETREC o_param_r2 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 1
LETREC o_param_r3 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 2
LETREC o_param_ctbl (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (m_ctbl : VAR of )
    VAR m
    VAR m_ctbl
LETREC p_rgb (VAR of )
  (pixel : VAR of )
  (m_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_rgb
LETREC p_intersection_points (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (m_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_isect_ps
LETREC p_surface_ids (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (m_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_sids
LETREC p_calc_diffuse (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (m_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_cdif
LETREC p_energy (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (m_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_engy
LETREC p_received_ray_20percent (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (m_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_r20p
LETREC p_group_id (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    GET
      VAR m_gid
      INT 0
LETREC p_set_group_id (VAR of )
  (pixel : VAR of ), (id : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    PUT
      VAR m_gid
      INT 0
      VAR id
LETREC p_nvectors (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (m_nvectors : VAR of )
    VAR pixel
    VAR m_nvectors
LETREC d_vec (VAR of )
  (d : VAR of )
  (m_vec : VAR of ), (xm_const : VAR of )
    VAR d
    VAR m_vec
LETREC d_const (VAR of )
  (d : VAR of )
  (dm_vec : VAR of ), (m_const : VAR of )
    VAR d
    VAR m_const
LETREC r_surface_id (VAR of )
  (r : VAR of )
  (m_sid : VAR of ), (xm_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_sid
LETREC r_dvec (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (m_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_dvec
LETREC r_bright (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (xm_dvec : VAR of ), (m_br : VAR of )
    VAR r
    VAR m_br
LETREC rad (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.017453293
LETREC read_screen_settings (VAR of )
  (Tu24 : VAR of )
  LET Tu38 (UNIT)
    PUT
      VAR screen
      INT 0
      UNKNOWN APP        inflt
        UNIT
  LET Tu37 (UNIT)
    PUT
      VAR screen
      INT 1
      UNKNOWN APP        inflt
        UNIT
  LET Tu36 (UNIT)
    PUT
      VAR screen
      INT 2
      UNKNOWN APP        inflt
        UNIT
  LET v1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v1 (VAR of )
    APP
      VAR cos
      VAR v1
  LET sin_v1 (VAR of )
    APP
      VAR sin
      VAR v1
  LET v2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v2 (VAR of )
    APP
      VAR cos
      VAR v2
  LET sin_v2 (VAR of )
    APP
      VAR sin
      VAR v2
  LET Tu35 (UNIT)
    PUT
      VAR screenz_dir
      INT 0
      FMUL
        FMUL
          VAR cos_v1
          VAR sin_v2
        FLOAT 200.
  LET Tu34 (UNIT)
    PUT
      VAR screenz_dir
      INT 1
      FMUL
        VAR sin_v1
        FLOAT -200.
  LET Tu33 (UNIT)
    PUT
      VAR screenz_dir
      INT 2
      FMUL
        FMUL
          VAR cos_v1
          VAR cos_v2
        FLOAT 200.
  LET Tu32 (UNIT)
    PUT
      VAR screenx_dir
      INT 0
      VAR cos_v2
  LET Tu31 (UNIT)
    PUT
      VAR screenx_dir
      INT 1
      FLOAT 0.
  LET Tu30 (UNIT)
    PUT
      VAR screenx_dir
      INT 2
      APP
        VAR fneg
        VAR sin_v2
  LET Tu29 (UNIT)
    PUT
      VAR screeny_dir
      INT 0
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR sin_v2
  LET Tu28 (UNIT)
    PUT
      VAR screeny_dir
      INT 1
      APP
        VAR fneg
        VAR cos_v1
  LET Tu27 (UNIT)
    PUT
      VAR screeny_dir
      INT 2
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR cos_v2
  LET Tu26 (UNIT)
    PUT
      VAR viewpoint
      INT 0
      FSUB
        GET
          VAR screen
          INT 0
        GET
          VAR screenz_dir
          INT 0
  LET Tu25 (UNIT)
    PUT
      VAR viewpoint
      INT 1
      FSUB
        GET
          VAR screen
          INT 1
        GET
          VAR screenz_dir
          INT 1
  PUT
    VAR viewpoint
    INT 2
    FSUB
      GET
        VAR screen
        INT 2
      GET
        VAR screenz_dir
        INT 2
LETREC read_light (VAR of )
  (Tu39 : VAR of )
  LET nl (VAR of )
    UNKNOWN APP      inint
      UNIT
  LET l1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET sl1 (VAR of )
    APP
      VAR sin
      VAR l1
  LET Tu42 (UNIT)
    PUT
      VAR light
      INT 1
      APP
        VAR fneg
        VAR sl1
  LET l2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cl1 (VAR of )
    APP
      VAR cos
      VAR l1
  LET sl2 (VAR of )
    APP
      VAR sin
      VAR l2
  LET Tu41 (UNIT)
    PUT
      VAR light
      INT 0
      FMUL
        VAR cl1
        VAR sl2
  LET cl2 (VAR of )
    APP
      VAR cos
      VAR l2
  LET Tu40 (UNIT)
    PUT
      VAR light
      INT 2
      FMUL
        VAR cl1
        VAR cl2
  PUT
    VAR beam
    INT 0
    UNKNOWN APP      inflt
      UNIT
LETREC rotate_quadratic_matrix (VAR of )
  (abc : VAR of ), (rot : VAR of )
  LET cos_x (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 0
  LET sin_x (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 0
  LET cos_y (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 1
  LET sin_y (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 1
  LET cos_z (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 2
  LET sin_z (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 2
  LET m00 (VAR of )
    FMUL
      VAR cos_y
      VAR cos_z
  LET m01 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR cos_x
        VAR sin_z
  LET m02 (VAR of )
    FADD
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR sin_x
        VAR sin_z
  LET m10 (VAR of )
    FMUL
      VAR cos_y
      VAR sin_z
  LET m11 (VAR of )
    FADD
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR cos_x
        VAR cos_z
  LET m12 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR sin_x
        VAR cos_z
  LET m20 (VAR of )
    APP
      VAR fneg
      VAR sin_y
  LET m21 (VAR of )
    FMUL
      VAR sin_x
      VAR cos_y
  LET m22 (VAR of )
    FMUL
      VAR cos_x
      VAR cos_y
  LET ao (VAR of )
    GET
      VAR abc
      INT 0
  LET bo (VAR of )
    GET
      VAR abc
      INT 1
  LET co (VAR of )
    GET
      VAR abc
      INT 2
  LET Tu47 (UNIT)
    PUT
      VAR abc
      INT 0
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m00
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m10
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m20
  LET Tu46 (UNIT)
    PUT
      VAR abc
      INT 1
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m01
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m11
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m21
  LET Tu45 (UNIT)
    PUT
      VAR abc
      INT 2
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m02
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m12
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m22
  LET Tu44 (UNIT)
    PUT
      VAR rot
      INT 0
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m01
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m11
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m21
            VAR m22
  LET Tu43 (UNIT)
    PUT
      VAR rot
      INT 1
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m00
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m10
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m20
            VAR m22
  PUT
    VAR rot
    INT 2
    FMUL
      FLOAT 2.
      FADD
        FADD
          FMUL
            FMUL
              VAR ao
              VAR m00
            VAR m01
          FMUL
            FMUL
              VAR bo
              VAR m10
            VAR m11
        FMUL
          FMUL
            VAR co
            VAR m20
          VAR m21
LETREC read_nth_object (VAR of )
  (n : VAR of )
  LET texture (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    NOT
      EQ
        VAR texture
        NEG
          INT 1
    LET form (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET refltype (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET isrot_p (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET abc (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu66 (UNIT)
      PUT
        VAR abc
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu65 (UNIT)
      PUT
        VAR abc
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu64 (UNIT)
      PUT
        VAR abc
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET xyz (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu63 (UNIT)
      PUT
        VAR xyz
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu62 (UNIT)
      PUT
        VAR xyz
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu61 (UNIT)
      PUT
        VAR xyz
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET m_invert (VAR of )
      APP
        VAR fisneg
        UNKNOWN APP          inflt
          UNIT
    LET reflparam (VAR of )
      ARRAY
        INT 2
        FLOAT 0.
    LET Tu60 (UNIT)
      PUT
        VAR reflparam
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu59 (UNIT)
      PUT
        VAR reflparam
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET color (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu58 (UNIT)
      PUT
        VAR color
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu57 (UNIT)
      PUT
        VAR color
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu56 (UNIT)
      PUT
        VAR color
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET rotation (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu55 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        LET Tu49 (UNIT)
          PUT
            VAR rotation
            INT 0
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        LET Tu48 (UNIT)
          PUT
            VAR rotation
            INT 1
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        PUT
          VAR rotation
          INT 2
          APP
            VAR rad
            UNKNOWN APP              inflt
              UNIT
        UNIT
    LET m_invert2 (VAR of )
      IF
        EQ
          VAR form
          INT 2
        BOOL true
        VAR m_invert
    LET ctbl (VAR of )
      ARRAY
        INT 4
        FLOAT 0.
    LET obj (VAR of )
      TUPLE
        VAR texture
        VAR form
        VAR refltype
        VAR isrot_p
        VAR abc
        VAR xyz
        VAR m_invert2
        VAR reflparam
        VAR color
        VAR rotation
        VAR ctbl
    LET Tu54 (UNIT)
      PUT
        VAR objects
        VAR n
        VAR obj
    LET Tu53 (UNIT)
      IF
        EQ
          VAR form
          INT 3
        LET a (VAR of )
          GET
            VAR abc
            INT 0
        LET Tu51 (UNIT)
          PUT
            VAR abc
            INT 0
            IF
              FZero?
                VAR a
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR a
                APP
                  VAR fsqr
                  VAR a
        LET b (VAR of )
          GET
            VAR abc
            INT 1
        LET Tu50 (UNIT)
          PUT
            VAR abc
            INT 1
            IF
              FZero?
                VAR b
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR b
                APP
                  VAR fsqr
                  VAR b
        LET c (VAR of )
          GET
            VAR abc
            INT 2
        PUT
          VAR abc
          INT 2
          IF
            FZero?
              VAR c
            FLOAT 0.
            FDIV
              APP
                VAR sgn
                VAR c
              APP
                VAR fsqr
                VAR c
        IF
          EQ
            VAR form
            INT 2
          APP
            VAR vecunit_sgn
            VAR abc
            NOT
              VAR m_invert
          UNIT
    LET Tu52 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        APP
          VAR rotate_quadratic_matrix
          VAR abc
          VAR rotation
        UNIT
    BOOL true
    BOOL false
LETREC read_object (VAR of )
  (n : VAR of )
  IF
    NOT
      LE
        INT 60
        VAR n
    IF
      APP
        VAR read_nth_object
        VAR n
      APP
        VAR read_object
        ADD
          VAR n
          INT 1
      PUT
        VAR n_objects
        INT 0
        VAR n
    UNIT
LETREC read_all_object (VAR of )
  (Tu67 : VAR of )
  APP
    VAR read_object
    INT 0
LETREC read_net_item (VAR of )
  (length : VAR of )
  LET item (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    EQ
      VAR item
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      NEG
        INT 1
    LET v (VAR of )
      APP
        VAR read_net_item
        ADD
          VAR length
          INT 1
    LET Tu68 (UNIT)
      PUT
        VAR v
        VAR length
        VAR item
    VAR v
LETREC read_or_network (VAR of )
  (length : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      VAR net
    LET v (VAR of )
      APP
        VAR read_or_network
        ADD
          VAR length
          INT 1
    LET Tu69 (UNIT)
      PUT
        VAR v
        VAR length
        VAR net
    VAR v
LETREC read_and_network (VAR of )
  (n : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    UNIT
    LET Tu70 (UNIT)
      PUT
        VAR and_net
        VAR n
        VAR net
    APP
      VAR read_and_network
      ADD
        VAR n
        INT 1
LETREC read_parameter (VAR of )
  (Tu71 : VAR of )
  LET Tu75 (UNIT)
    APP
      VAR read_screen_settings
      UNIT
  LET Tu74 (UNIT)
    APP
      VAR read_light
      UNIT
  LET Tu73 (UNIT)
    APP
      VAR read_all_object
      UNIT
  LET Tu72 (UNIT)
    APP
      VAR read_and_network
      INT 0
  PUT
    VAR or_net
    INT 0
    APP
      VAR read_or_network
      INT 0
LETREC solver_rect_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of ), (i0 : VAR of ), (i1 : VAR of ), (i2 : VAR of )
  IF
    FZero?
      GET
        VAR dirvec
        VAR i0
    BOOL false
    LET abc (VAR of )
      APP
        VAR o_param_abc
        VAR m
    LET d (VAR of )
      APP
        VAR fneg_cond
        APP
          VAR xor
          APP
            VAR o_isinvert
            VAR m
          APP
            VAR fisneg
            GET
              VAR dirvec
              VAR i0
        GET
          VAR abc
          VAR i0
    LET d2 (VAR of )
      FDIV
        FSUB
          VAR d
          VAR b0
        GET
          VAR dirvec
          VAR i0
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d2
              GET
                VAR dirvec
                VAR i1
            VAR b1
        GET
          VAR abc
          VAR i1
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d2
                GET
                  VAR dirvec
                  VAR i2
              VAR b2
          GET
            VAR abc
            VAR i2
        LET Tu76 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        BOOL true
        BOOL false
      BOOL false
LETREC solver_rect (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR solver_rect_surface
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
      INT 0
      INT 1
      INT 2
    INT 1
    IF
      APP
        VAR solver_rect_surface
        VAR m
        VAR dirvec
        VAR b1
        VAR b2
        VAR b0
        INT 1
        INT 2
        INT 0
      INT 2
      IF
        APP
          VAR solver_rect_surface
          VAR m
          VAR dirvec
          VAR b2
          VAR b0
          VAR b1
          INT 2
          INT 0
          INT 1
        INT 3
        INT 0
LETREC solver_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET abc (VAR of )
    APP
      VAR o_param_abc
      VAR m
  LET d (VAR of )
    APP
      VAR veciprod
      VAR dirvec
      VAR abc
  IF
    APP
      VAR fispos
      VAR d
    LET Tu77 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FDIV
          APP
            VAR fneg
            APP
              VAR veciprod2
              VAR abc
              VAR b0
              VAR b1
              VAR b2
          VAR d
    INT 1
    INT 0
LETREC quadratic (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          APP
            VAR fsqr
            VAR v0
          APP
            VAR o_param_a
            VAR m
        FMUL
          APP
            VAR fsqr
            VAR v1
          APP
            VAR o_param_b
            VAR m
      FMUL
        APP
          VAR fsqr
          VAR v2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      FADD
        FADD
          VAR diag_part
          FMUL
            FMUL
              VAR v1
              VAR v2
            APP
              VAR o_param_r1
              VAR m
        FMUL
          FMUL
            VAR v2
            VAR v0
          APP
            VAR o_param_r2
            VAR m
      FMUL
        FMUL
          VAR v0
          VAR v1
        APP
          VAR o_param_r3
          VAR m
LETREC bilinear (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          FMUL
            VAR v0
            VAR w0
          APP
            VAR o_param_a
            VAR m
        FMUL
          FMUL
            VAR v1
            VAR w1
          APP
            VAR o_param_b
            VAR m
      FMUL
        FMUL
          VAR v2
          VAR w2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      VAR diag_part
      APP
        VAR fhalf
        FADD
          FADD
            FMUL
              FADD
                FMUL
                  VAR v2
                  VAR w1
                FMUL
                  VAR v1
                  VAR w2
              APP
                VAR o_param_r1
                VAR m
            FMUL
              FADD
                FMUL
                  VAR v0
                  VAR w2
                FMUL
                  VAR v2
                  VAR w0
              APP
                VAR o_param_r2
                VAR m
          FMUL
            FADD
              FMUL
                VAR v0
                VAR w1
              FMUL
                VAR v1
                VAR w0
            APP
              VAR o_param_r3
              VAR m
LETREC solver_second (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR dirvec
        INT 0
      GET
        VAR dirvec
        INT 1
      GET
        VAR dirvec
        INT 2
  IF
    FZero?
      VAR aa
    INT 0
    LET bb (VAR of )
      APP
        VAR bilinear
        VAR m
        GET
          VAR dirvec
          INT 0
        GET
          VAR dirvec
          INT 1
        GET
          VAR dirvec
          INT 2
        VAR b0
        VAR b1
        VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET sd (VAR of )
        APP
          VAR sqrt
          VAR d
      LET t1 (VAR of )
        IF
          APP
            VAR o_isinvert
            VAR m
          VAR sd
          APP
            VAR fneg
            VAR sd
      LET Tu78 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          FDIV
            FSUB
              VAR t1
              VAR bb
            VAR aa
      INT 1
      INT 0
LETREC solver (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
LETREC solver_rect_fast (VAR of )
  (m : VAR of ), (v : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET d0 (VAR of )
    FMUL
      FSUB
        GET
          VAR dconst
          INT 0
        VAR b0
      GET
        VAR dconst
        INT 1
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d0
              GET
                VAR v
                INT 1
            VAR b1
        APP
          VAR o_param_b
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d0
                GET
                  VAR v
                  INT 2
              VAR b2
          APP
            VAR o_param_c
            VAR m
        NOT
          FZero?
            GET
              VAR dconst
              INT 1
        BOOL false
      BOOL false
    LET Tu79 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        VAR d0
    INT 1
    LET d1 (VAR of )
      FMUL
        FSUB
          GET
            VAR dconst
            INT 2
          VAR b1
        GET
          VAR dconst
          INT 3
    IF
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d1
                GET
                  VAR v
                  INT 0
              VAR b0
          APP
            VAR o_param_a
            VAR m
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d1
                  GET
                    VAR v
                    INT 2
                VAR b2
            APP
              VAR o_param_c
              VAR m
          NOT
            FZero?
              GET
                VAR dconst
                INT 3
          BOOL false
        BOOL false
      LET Tu80 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          VAR d1
      INT 2
      LET d2 (VAR of )
        FMUL
          FSUB
            GET
              VAR dconst
              INT 4
            VAR b2
          GET
            VAR dconst
            INT 5
      IF
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d2
                  GET
                    VAR v
                    INT 0
                VAR b0
            APP
              VAR o_param_a
              VAR m
          IF
            APP
              VAR fless
              APP
                VAR fabs
                FADD
                  FMUL
                    VAR d2
                    GET
                      VAR v
                      INT 1
                  VAR b1
              APP
                VAR o_param_b
                VAR m
            NOT
              FZero?
                GET
                  VAR dconst
                  INT 5
            BOOL false
          BOOL false
        LET Tu81 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        INT 3
        INT 0
LETREC solver_surface_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu82 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FADD
          FADD
            FMUL
              GET
                VAR dconst
                INT 1
              VAR b0
            FMUL
              GET
                VAR dconst
                INT 2
              VAR b1
          FMUL
            GET
              VAR dconst
              INT 3
            VAR b2
    INT 1
    INT 0
LETREC solver_second_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu83 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
LETREC solver_surface_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu84 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FMUL
          GET
            VAR dconst
            INT 0
          GET
            VAR sconst
            INT 3
    INT 1
    INT 0
LETREC solver_second_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc (VAR of )
      GET
        VAR sconst
        INT 3
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu85 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast2 (VAR of )
  (index : VAR of ), (dirvec : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET sconst (VAR of )
    APP
      VAR o_param_ctbl
      VAR m
  LET b0 (VAR of )
    GET
      VAR sconst
      INT 0
  LET b1 (VAR of )
    GET
      VAR sconst
      INT 1
  LET b2 (VAR of )
    GET
      VAR sconst
      INT 2
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
LETREC setup_rect_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 6
      FLOAT 0.
  LET Tu91 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 0
      PUT
        VAR const
        INT 1
        FLOAT 0.
      LET Tu86 (UNIT)
        PUT
          VAR const
          INT 0
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 0
            APP
              VAR o_param_a
              VAR m
      PUT
        VAR const
        INT 1
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 0
  LET Tu90 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 1
      PUT
        VAR const
        INT 3
        FLOAT 0.
      LET Tu87 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 1
            APP
              VAR o_param_b
              VAR m
      PUT
        VAR const
        INT 3
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 1
  LET Tu89 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 2
      PUT
        VAR const
        INT 5
        FLOAT 0.
      LET Tu88 (UNIT)
        PUT
          VAR const
          INT 4
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 2
            APP
              VAR o_param_c
              VAR m
      PUT
        VAR const
        INT 5
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 2
  VAR const
LETREC setup_surface_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 4
      FLOAT 0.
  LET d (VAR of )
    FADD
      FADD
        FMUL
          GET
            VAR vec
            INT 0
          APP
            VAR o_param_a
            VAR m
        FMUL
          GET
            VAR vec
            INT 1
          APP
            VAR o_param_b
            VAR m
      FMUL
        GET
          VAR vec
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu95 (UNIT)
    IF
      APP
        VAR fispos
        VAR d
      LET Tu94 (UNIT)
        PUT
          VAR const
          INT 0
          FDIV
            FLOAT -1.
            VAR d
      LET Tu93 (UNIT)
        PUT
          VAR const
          INT 1
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_a
                VAR m
              VAR d
      LET Tu92 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_b
                VAR m
              VAR d
      PUT
        VAR const
        INT 3
        APP
          VAR fneg
          FDIV
            APP
              VAR o_param_c
              VAR m
            VAR d
      PUT
        VAR const
        INT 0
        FLOAT 0.
  VAR const
LETREC setup_second_table (VAR of )
  (v : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 5
      FLOAT 0.
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
      GET
        VAR v
        INT 2
  LET c1 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 0
        APP
          VAR o_param_a
          VAR m
  LET c2 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 1
        APP
          VAR o_param_b
          VAR m
  LET c3 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu102 (UNIT)
    PUT
      VAR const
      INT 0
      VAR aa
  LET Tu101 (UNIT)
    IF
      NOT
        EQ
          APP
            VAR o_isrot
            VAR m
          INT 0
      LET Tu97 (UNIT)
        PUT
          VAR const
          INT 1
          FSUB
            VAR c1
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r2
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 1
                  APP
                    VAR o_param_r3
                    VAR m
      LET Tu96 (UNIT)
        PUT
          VAR const
          INT 2
          FSUB
            VAR c2
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r1
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 0
                  APP
                    VAR o_param_r3
                    VAR m
      PUT
        VAR const
        INT 3
        FSUB
          VAR c3
          APP
            VAR fhalf
            FADD
              FMUL
                GET
                  VAR v
                  INT 1
                APP
                  VAR o_param_r1
                  VAR m
              FMUL
                GET
                  VAR v
                  INT 0
                APP
                  VAR o_param_r2
                  VAR m
      LET Tu99 (UNIT)
        PUT
          VAR const
          INT 1
          VAR c1
      LET Tu98 (UNIT)
        PUT
          VAR const
          INT 2
          VAR c2
      PUT
        VAR const
        INT 3
        VAR c3
  LET Tu100 (UNIT)
    IF
      NOT
        FZero?
          VAR aa
      PUT
        VAR const
        INT 4
        FDIV
          FLOAT 1.
          VAR aa
      UNIT
  VAR const
LETREC iter_setup_dirvec_constants (VAR of )
  (dirvec : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET m (VAR of )
      GET
        VAR objects
        VAR index
    LET dconst (VAR of )
      APP
        VAR d_const
        VAR dirvec
    LET v (VAR of )
      APP
        VAR d_vec
        VAR dirvec
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR m
    LET Tu103 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 1
        PUT
          VAR dconst
          VAR index
          APP
            VAR setup_rect_table
            VAR v
            VAR m
        IF
          EQ
            VAR m_shape
            INT 2
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_surface_table
              VAR v
              VAR m
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_second_table
              VAR v
              VAR m
    APP
      VAR iter_setup_dirvec_constants
      VAR dirvec
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_dirvec_constants (VAR of )
  (dirvec : VAR of )
  APP
    VAR iter_setup_dirvec_constants
    VAR dirvec
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC setup_startp_constants (VAR of )
  (p : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET obj (VAR of )
      GET
        VAR objects
        VAR index
    LET sconst (VAR of )
      APP
        VAR o_param_ctbl
        VAR obj
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR obj
    LET Tu107 (UNIT)
      PUT
        VAR sconst
        INT 0
        FSUB
          GET
            VAR p
            INT 0
          APP
            VAR o_param_x
            VAR obj
    LET Tu106 (UNIT)
      PUT
        VAR sconst
        INT 1
        FSUB
          GET
            VAR p
            INT 1
          APP
            VAR o_param_y
            VAR obj
    LET Tu105 (UNIT)
      PUT
        VAR sconst
        INT 2
        FSUB
          GET
            VAR p
            INT 2
          APP
            VAR o_param_z
            VAR obj
    LET Tu104 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 2
        PUT
          VAR sconst
          INT 3
          APP
            VAR veciprod2
            APP
              VAR o_param_abc
              VAR obj
            GET
              VAR sconst
              INT 0
            GET
              VAR sconst
              INT 1
            GET
              VAR sconst
              INT 2
        IF
          NOT
            LE
              VAR m_shape
              INT 2
          LET cc0 (VAR of )
            APP
              VAR quadratic
              VAR obj
              GET
                VAR sconst
                INT 0
              GET
                VAR sconst
                INT 1
              GET
                VAR sconst
                INT 2
          PUT
            VAR sconst
            INT 3
            IF
              EQ
                VAR m_shape
                INT 3
              FSUB
                VAR cc0
                FLOAT 1.
              VAR cc0
          UNIT
    APP
      VAR setup_startp_constants
      VAR p
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_startp (VAR of )
  (p : VAR of )
  LET Tu108 (UNIT)
    APP
      VAR veccpy
      VAR startp_fast
      VAR p
  APP
    VAR setup_startp_constants
    VAR p
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC is_rect_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          VAR p0
        APP
          VAR o_param_a
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            VAR p1
          APP
            VAR o_param_b
            VAR m
        APP
          VAR fless
          APP
            VAR fabs
            VAR p2
          APP
            VAR o_param_c
            VAR m
        BOOL false
      BOOL false
    APP
      VAR o_isinvert
      VAR m
    NOT
      APP
        VAR o_isinvert
        VAR m
LETREC is_plane_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR veciprod2
      APP
        VAR o_param_abc
        VAR m
      VAR p0
      VAR p1
      VAR p2
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w
LETREC is_second_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR quadratic
      VAR m
      VAR p0
      VAR p1
      VAR p2
  LET w2 (VAR of )
    IF
      EQ
        APP
          VAR o_form
          VAR m
        INT 3
      FSUB
        VAR w
        FLOAT 1.
      VAR w
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w2
LETREC is_outside (VAR of )
  (m : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET p0 (VAR of )
    FSUB
      VAR q0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      VAR q1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      VAR q2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR is_rect_outside
      VAR m
      VAR p0
      VAR p1
      VAR p2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR is_plane_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
      APP
        VAR is_second_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
LETREC check_all_inside (VAR of )
  (ofs : VAR of ), (iand : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET head (VAR of )
    GET
      VAR iand
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL true
    IF
      APP
        VAR is_outside
        GET
          VAR objects
          VAR head
        VAR q0
        VAR q1
        VAR q2
      BOOL false
      APP
        VAR check_all_inside
        ADD
          VAR ofs
          INT 1
        VAR iand
        VAR q0
        VAR q1
        VAR q2
LETREC shadow_check_and_group (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of )
  IF
    EQ
      GET
        VAR and_group
        VAR iand_ofs
      NEG
        INT 1
    BOOL false
    LET obj (VAR of )
      GET
        VAR and_group
        VAR iand_ofs
    LET t0 (VAR of )
      APP
        VAR solver_fast
        VAR obj
        VAR light_dirvec
        VAR intersection_point
    LET t0p (VAR of )
      GET
        VAR solver_dist
        INT 0
    IF
      IF
        NOT
          EQ
            VAR t0
            INT 0
        APP
          VAR fless
          VAR t0p
          FLOAT -0.2
        BOOL false
      LET t (VAR of )
        FADD
          VAR t0p
          FLOAT 0.01
      LET q0 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 0
            VAR t
          GET
            VAR intersection_point
            INT 0
      LET q1 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 1
            VAR t
          GET
            VAR intersection_point
            INT 1
      LET q2 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 2
            VAR t
          GET
            VAR intersection_point
            INT 2
      IF
        APP
          VAR check_all_inside
          INT 0
          VAR and_group
          VAR q0
          VAR q1
          VAR q2
        BOOL true
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR obj
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
        BOOL false
LETREC shadow_check_one_or_group (VAR of )
  (ofs : VAR of ), (or_group : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL false
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET shadow_p (VAR of )
      APP
        VAR shadow_check_and_group
        INT 0
        VAR and_group
    IF
      VAR shadow_p
      BOOL true
      APP
        VAR shadow_check_one_or_group
        ADD
          VAR ofs
          INT 1
        VAR or_group
LETREC shadow_check_one_or_matrix (VAR of )
  (ofs : VAR of ), (or_matrix : VAR of )
  LET head (VAR of )
    GET
      VAR or_matrix
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    BOOL false
    IF
      IF
        EQ
          VAR range_primitive
          INT 99
        BOOL true
        LET t (VAR of )
          APP
            VAR solver_fast
            VAR range_primitive
            VAR light_dirvec
            VAR intersection_point
        IF
          NOT
            EQ
              VAR t
              INT 0
          IF
            APP
              VAR fless
              GET
                VAR solver_dist
                INT 0
              FLOAT -0.1
            IF
              APP
                VAR shadow_check_one_or_group
                INT 1
                VAR head
              BOOL true
              BOOL false
            BOOL false
          BOOL false
      IF
        APP
          VAR shadow_check_one_or_group
          INT 1
          VAR head
        BOOL true
        APP
          VAR shadow_check_one_or_matrix
          ADD
            VAR ofs
            INT 1
          VAR or_matrix
      APP
        VAR shadow_check_one_or_matrix
        ADD
          VAR ofs
          INT 1
        VAR or_matrix
LETREC solve_each_element (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver
        VAR iobj
        VAR dirvec
        VAR startp
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu112 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 0
                  VAR t
                GET
                  VAR startp
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 1
                  VAR t
                GET
                  VAR startp
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 2
                  VAR t
                GET
                  VAR startp
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu111 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu110 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu109 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu113 (UNIT)
      APP
        VAR solve_each_element
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu114 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver
            VAR range_primitive
            VAR dirvec
            VAR startp
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection (VAR of )
  (dirvec : VAR of )
  LET Tu116 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu115 (UNIT)
    APP
      VAR trace_or_matrix
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC solve_each_element_fast (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET vec (VAR of )
    APP
      VAR d_vec
      VAR dirvec
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver_fast2
        VAR iobj
        VAR dirvec
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu120 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 0
                  VAR t
                GET
                  VAR startp_fast
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 1
                  VAR t
                GET
                  VAR startp_fast
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 2
                  VAR t
                GET
                  VAR startp_fast
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu119 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu118 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu117 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element_fast
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element_fast
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network_fast (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu121 (UNIT)
      APP
        VAR solve_each_element_fast
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network_fast
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix_fast (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu122 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network_fast
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver_fast2
            VAR range_primitive
            VAR dirvec
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network_fast
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix_fast
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection_fast (VAR of )
  (dirvec : VAR of )
  LET Tu124 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu123 (UNIT)
    APP
      VAR trace_or_matrix_fast
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC get_nvector_rect (VAR of )
  (dirvec : VAR of )
  LET rectside (VAR of )
    GET
      VAR intsec_rectside
      INT 0
  LET Tu125 (UNIT)
    APP
      VAR vecbzero
      VAR nvector
  PUT
    VAR nvector
    SUB
      VAR rectside
      INT 1
    APP
      VAR fneg
      APP
        VAR sgn
        GET
          VAR dirvec
          SUB
            VAR rectside
            INT 1
LETREC get_nvector_plane (VAR of )
  (m : VAR of )
  LET Tu127 (UNIT)
    PUT
      VAR nvector
      INT 0
      APP
        VAR fneg
        APP
          VAR o_param_a
          VAR m
  LET Tu126 (UNIT)
    PUT
      VAR nvector
      INT 1
      APP
        VAR fneg
        APP
          VAR o_param_b
          VAR m
  PUT
    VAR nvector
    INT 2
    APP
      VAR fneg
      APP
        VAR o_param_c
        VAR m
LETREC get_nvector_second (VAR of )
  (m : VAR of )
  LET p0 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET d0 (VAR of )
    FMUL
      VAR p0
      APP
        VAR o_param_a
        VAR m
  LET d1 (VAR of )
    FMUL
      VAR p1
      APP
        VAR o_param_b
        VAR m
  LET d2 (VAR of )
    FMUL
      VAR p2
      APP
        VAR o_param_c
        VAR m
  LET Tu132 (UNIT)
    IF
      EQ
        APP
          VAR o_isrot
          VAR m
        INT 0
      LET Tu129 (UNIT)
        PUT
          VAR nvector
          INT 0
          VAR d0
      LET Tu128 (UNIT)
        PUT
          VAR nvector
          INT 1
          VAR d1
      PUT
        VAR nvector
        INT 2
        VAR d2
      LET Tu131 (UNIT)
        PUT
          VAR nvector
          INT 0
          FADD
            VAR d0
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p1
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r2
                    VAR m
      LET Tu130 (UNIT)
        PUT
          VAR nvector
          INT 1
          FADD
            VAR d1
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p0
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r1
                    VAR m
      PUT
        VAR nvector
        INT 2
        FADD
          VAR d2
          APP
            VAR fhalf
            FADD
              FMUL
                VAR p0
                APP
                  VAR o_param_r2
                  VAR m
              FMUL
                VAR p1
                APP
                  VAR o_param_r1
                  VAR m
  APP
    VAR vecunit_sgn
    VAR nvector
    APP
      VAR o_isinvert
      VAR m
LETREC get_nvector (VAR of )
  (m : VAR of ), (dirvec : VAR of )
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR get_nvector_rect
      VAR dirvec
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR get_nvector_plane
        VAR m
      APP
        VAR get_nvector_second
        VAR m
LETREC utexture (VAR of )
  (m : VAR of ), (p : VAR of )
  LET m_tex (VAR of )
    APP
      VAR o_texturetype
      VAR m
  LET Tu137 (UNIT)
    PUT
      VAR texture_color
      INT 0
      APP
        VAR o_color_red
        VAR m
  LET Tu136 (UNIT)
    PUT
      VAR texture_color
      INT 1
      APP
        VAR o_color_green
        VAR m
  LET Tu135 (UNIT)
    PUT
      VAR texture_color
      INT 2
      APP
        VAR o_color_blue
        VAR m
  IF
    EQ
      VAR m_tex
      INT 1
    LET w1 (VAR of )
      FSUB
        GET
          VAR p
          INT 0
        APP
          VAR o_param_x
          VAR m
    LET flag1 (VAR of )
      LET d1 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w1
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w1
          VAR d1
        FLOAT 10.
    LET w3 (VAR of )
      FSUB
        GET
          VAR p
          INT 2
        APP
          VAR o_param_z
          VAR m
    LET flag2 (VAR of )
      LET d2 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w3
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w3
          VAR d2
        FLOAT 10.
    PUT
      VAR texture_color
      INT 1
      IF
        VAR flag1
        IF
          VAR flag2
          FLOAT 255.
          FLOAT 0.
        IF
          VAR flag2
          FLOAT 0.
          FLOAT 255.
    IF
      EQ
        VAR m_tex
        INT 2
      LET w2 (VAR of )
        APP
          VAR fsqr
          APP
            VAR sin
            FMUL
              GET
                VAR p
                INT 1
              FLOAT 0.25
      LET Tu133 (UNIT)
        PUT
          VAR texture_color
          INT 0
          FMUL
            FLOAT 255.
            VAR w2
      PUT
        VAR texture_color
        INT 1
        FMUL
          FLOAT 255.
          FSUB
            FLOAT 1.
            VAR w2
      IF
        EQ
          VAR m_tex
          INT 3
        LET w1 (VAR of )
          FSUB
            GET
              VAR p
              INT 0
            APP
              VAR o_param_x
              VAR m
        LET w3 (VAR of )
          FSUB
            GET
              VAR p
              INT 2
            APP
              VAR o_param_z
              VAR m
        LET w2 (VAR of )
          FDIV
            APP
              VAR sqrt
              FADD
                APP
                  VAR fsqr
                  VAR w1
                APP
                  VAR fsqr
                  VAR w3
            FLOAT 10.
        LET w4 (VAR of )
          FMUL
            FSUB
              VAR w2
              APP
                VAR floor
                VAR w2
            FLOAT 3.1415927
        LET cws (VAR of )
          APP
            VAR fsqr
            APP
              VAR cos
              VAR w4
        LET Tu134 (UNIT)
          PUT
            VAR texture_color
            INT 1
            FMUL
              VAR cws
              FLOAT 255.
        PUT
          VAR texture_color
          INT 2
          FMUL
            FSUB
              FLOAT 1.
              VAR cws
            FLOAT 255.
        IF
          EQ
            VAR m_tex
            INT 4
          LET w1 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 0
                APP
                  VAR o_param_x
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_a
                  VAR m
          LET w3 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 2
                APP
                  VAR o_param_z
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_c
                  VAR m
          LET w4 (VAR of )
            FADD
              APP
                VAR fsqr
                VAR w1
              APP
                VAR fsqr
                VAR w3
          LET w7 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w1
                FLOAT 0.0001
              FLOAT 15.
              LET w5 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w3
                    VAR w1
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w5
                  FLOAT 30.
                FLOAT 3.1415927
          LET w9 (VAR of )
            FSUB
              VAR w7
              APP
                VAR floor
                VAR w7
          LET w2 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 1
                APP
                  VAR o_param_y
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_b
                  VAR m
          LET w8 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w4
                FLOAT 0.0001
              FLOAT 15.
              LET w6 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w2
                    VAR w4
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w6
                  FLOAT 30.
                FLOAT 3.1415927
          LET w10 (VAR of )
            FSUB
              VAR w8
              APP
                VAR floor
                VAR w8
          LET w11 (VAR of )
            FSUB
              FSUB
                FLOAT 0.15
                APP
                  VAR fsqr
                  FSUB
                    FLOAT 0.5
                    VAR w9
              APP
                VAR fsqr
                FSUB
                  FLOAT 0.5
                  VAR w10
          LET w12 (VAR of )
            IF
              APP
                VAR fisneg
                VAR w11
              FLOAT 0.
              VAR w11
          PUT
            VAR texture_color
            INT 2
            FDIV
              FMUL
                FLOAT 255.
                VAR w12
              FLOAT 0.3
          UNIT
LETREC add_light (VAR of )
  (bright : VAR of ), (hilight : VAR of ), (hilight_scale : VAR of )
  LET Tu140 (UNIT)
    IF
      APP
        VAR fispos
        VAR bright
      APP
        VAR vecaccum
        VAR rgb
        VAR bright
        VAR texture_color
      UNIT
  IF
    APP
      VAR fispos
      VAR hilight
    LET ihl (VAR of )
      FMUL
        APP
          VAR fsqr
          APP
            VAR fsqr
            VAR hilight
        VAR hilight_scale
    LET Tu139 (UNIT)
      PUT
        VAR rgb
        INT 0
        FADD
          GET
            VAR rgb
            INT 0
          VAR ihl
    LET Tu138 (UNIT)
      PUT
        VAR rgb
        INT 1
        FADD
          GET
            VAR rgb
            INT 1
          VAR ihl
    PUT
      VAR rgb
      INT 2
      FADD
        GET
          VAR rgb
          INT 2
        VAR ihl
    UNIT
LETREC trace_reflections (VAR of )
  (index : VAR of ), (diffuse : VAR of ), (hilight_scale : VAR of ), (dirvec : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET rinfo (VAR of )
      GET
        VAR reflections
        VAR index
    LET dvec (VAR of )
      APP
        VAR r_dvec
        VAR rinfo
    LET Tu141 (UNIT)
      IF
        APP
          VAR judge_intersection_fast
          VAR dvec
        LET surface_id (VAR of )
          ADD
            MULTIPLE 4
              GET
                VAR intersected_object_id
                INT 0
            GET
              VAR intsec_rectside
              INT 0
        IF
          EQ
            VAR surface_id
            APP
              VAR r_surface_id
              VAR rinfo
          IF
            NOT
              APP
                VAR shadow_check_one_or_matrix
                INT 0
                GET
                  VAR or_net
                  INT 0
            LET p (VAR of )
              APP
                VAR veciprod
                VAR nvector
                APP
                  VAR d_vec
                  VAR dvec
            LET scale (VAR of )
              APP
                VAR r_bright
                VAR rinfo
            LET bright (VAR of )
              FMUL
                FMUL
                  VAR scale
                  VAR diffuse
                VAR p
            LET hilight (VAR of )
              FMUL
                VAR scale
                APP
                  VAR veciprod
                  VAR dirvec
                  APP
                    VAR d_vec
                    VAR dvec
            APP
              VAR add_light
              VAR bright
              VAR hilight
              VAR hilight_scale
            UNIT
          UNIT
        UNIT
    APP
      VAR trace_reflections
      SUB
        VAR index
        INT 1
      VAR diffuse
      VAR hilight_scale
      VAR dirvec
    UNIT
LETREC trace_ray (VAR of )
  (nref : VAR of ), (energy : VAR of ), (dirvec : VAR of ), (pixel : VAR of ), (dist : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      APP
        VAR judge_intersection
        VAR dirvec
      LET obj_id (VAR of )
        GET
          VAR intersected_object_id
          INT 0
      LET obj (VAR of )
        GET
          VAR objects
          VAR obj_id
      LET m_surface (VAR of )
        APP
          VAR o_reflectiontype
          VAR obj
      LET diffuse (VAR of )
        FMUL
          APP
            VAR o_diffuse
            VAR obj
          VAR energy
      LET Tu155 (UNIT)
        APP
          VAR get_nvector
          VAR obj
          VAR dirvec
      LET Tu154 (UNIT)
        APP
          VAR veccpy
          VAR startp
          VAR intersection_point
      LET Tu153 (UNIT)
        APP
          VAR utexture
          VAR obj
          VAR intersection_point
      LET Tu152 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          ADD
            MULTIPLE 4
              VAR obj_id
            GET
              VAR intsec_rectside
              INT 0
      LET intersection_points (VAR of )
        APP
          VAR p_intersection_points
          VAR pixel
      LET Tu151 (UNIT)
        APP
          VAR veccpy
          GET
            VAR intersection_points
            VAR nref
          VAR intersection_point
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu150 (UNIT)
        IF
          APP
            VAR fless
            APP
              VAR o_diffuse
              VAR obj
            FLOAT 0.5
          PUT
            VAR calc_diffuse
            VAR nref
            BOOL false
          LET Tu144 (UNIT)
            PUT
              VAR calc_diffuse
              VAR nref
              BOOL true
          LET energya (VAR of )
            APP
              VAR p_energy
              VAR pixel
          LET Tu143 (UNIT)
            APP
              VAR veccpy
              GET
                VAR energya
                VAR nref
              VAR texture_color
          LET Tu142 (UNIT)
            APP
              VAR vecscale
              GET
                VAR energya
                VAR nref
              FMUL
                FDIV
                  FLOAT 1.
                  FLOAT 256.
                VAR diffuse
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR nvectors
              VAR nref
            VAR nvector
      LET w (VAR of )
        FMUL
          FLOAT -2.
          APP
            VAR veciprod
            VAR dirvec
            VAR nvector
      LET Tu149 (UNIT)
        APP
          VAR vecaccum
          VAR dirvec
          VAR w
          VAR nvector
      LET hilight_scale (VAR of )
        FMUL
          VAR energy
          APP
            VAR o_hilight
            VAR obj
      LET Tu148 (UNIT)
        IF
          NOT
            APP
              VAR shadow_check_one_or_matrix
              INT 0
              GET
                VAR or_net
                INT 0
          LET bright (VAR of )
            FMUL
              APP
                VAR fneg
                APP
                  VAR veciprod
                  VAR nvector
                  VAR light
              VAR diffuse
          LET hilight (VAR of )
            APP
              VAR fneg
              APP
                VAR veciprod
                VAR dirvec
                VAR light
          APP
            VAR add_light
            VAR bright
            VAR hilight
            VAR hilight_scale
          UNIT
      LET Tu147 (UNIT)
        APP
          VAR setup_startp
          VAR intersection_point
      LET Tu146 (UNIT)
        APP
          VAR trace_reflections
          SUB
            GET
              VAR n_reflections
              INT 0
            INT 1
          VAR diffuse
          VAR hilight_scale
          VAR dirvec
      IF
        APP
          VAR fless
          FLOAT 0.1
          VAR energy
        LET Tu145 (UNIT)
          IF
            NOT
              LE
                INT 4
                VAR nref
            PUT
              VAR surface_ids
              ADD
                VAR nref
                INT 1
              NEG
                INT 1
            UNIT
        IF
          EQ
            VAR m_surface
            INT 2
          LET energy2 (VAR of )
            FMUL
              VAR energy
              FSUB
                FLOAT 1.
                APP
                  VAR o_diffuse
                  VAR obj
          APP
            VAR trace_ray
            ADD
              VAR nref
              INT 1
            VAR energy2
            VAR dirvec
            VAR pixel
            FADD
              VAR dist
              GET
                VAR tmin
                INT 0
          UNIT
        UNIT
      LET Tu158 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          NEG
            INT 1
      IF
        NOT
          EQ
            VAR nref
            INT 0
        LET hl (VAR of )
          APP
            VAR fneg
            APP
              VAR veciprod
              VAR dirvec
              VAR light
        IF
          APP
            VAR fispos
            VAR hl
          LET ihl (VAR of )
            FMUL
              FMUL
                FMUL
                  APP
                    VAR fsqr
                    VAR hl
                  VAR hl
                VAR energy
              GET
                VAR beam
                INT 0
          LET Tu157 (UNIT)
            PUT
              VAR rgb
              INT 0
              FADD
                GET
                  VAR rgb
                  INT 0
                VAR ihl
          LET Tu156 (UNIT)
            PUT
              VAR rgb
              INT 1
              FADD
                GET
                  VAR rgb
                  INT 1
                VAR ihl
          PUT
            VAR rgb
            INT 2
            FADD
              GET
                VAR rgb
                INT 2
              VAR ihl
          UNIT
        UNIT
    UNIT
LETREC trace_diffuse_ray (VAR of )
  (dirvec : VAR of ), (energy : VAR of )
  IF
    APP
      VAR judge_intersection_fast
      VAR dirvec
    LET obj (VAR of )
      GET
        VAR objects
        GET
          VAR intersected_object_id
          INT 0
    LET Tu160 (UNIT)
      APP
        VAR get_nvector
        VAR obj
        APP
          VAR d_vec
          VAR dirvec
    LET Tu159 (UNIT)
      APP
        VAR utexture
        VAR obj
        VAR intersection_point
    IF
      NOT
        APP
          VAR shadow_check_one_or_matrix
          INT 0
          GET
            VAR or_net
            INT 0
      LET br (VAR of )
        APP
          VAR fneg
          APP
            VAR veciprod
            VAR nvector
            VAR light
      LET bright (VAR of )
        IF
          APP
            VAR fispos
            VAR br
          VAR br
          FLOAT 0.
      APP
        VAR vecaccum
        VAR diffuse_ray
        FMUL
          FMUL
            VAR energy
            VAR bright
          APP
            VAR o_diffuse
            VAR obj
        VAR texture_color
      UNIT
    UNIT
LETREC iter_trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET p (VAR of )
      APP
        VAR veciprod
        APP
          VAR d_vec
          GET
            VAR dirvec_group
            VAR index
        VAR nvector
    LET Tu161 (UNIT)
      IF
        APP
          VAR fisneg
          VAR p
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            ADD
              VAR index
              INT 1
          FDIV
            VAR p
            FLOAT -150.
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            VAR index
          FDIV
            VAR p
            FLOAT 150.
    APP
      VAR iter_trace_diffuse_rays
      VAR dirvec_group
      VAR nvector
      VAR org
      SUB
        VAR index
        INT 2
    UNIT
LETREC trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu162 (UNIT)
    APP
      VAR setup_startp
      VAR org
  APP
    VAR iter_trace_diffuse_rays
    VAR dirvec_group
    VAR nvector
    VAR org
    INT 118
LETREC trace_diffuse_ray_80percent (VAR of )
  (group_id : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu166 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 0
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 0
        VAR nvector
        VAR org
      UNIT
  LET Tu165 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 1
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 1
        VAR nvector
        VAR org
      UNIT
  LET Tu164 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 2
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 2
        VAR nvector
        VAR org
      UNIT
  LET Tu163 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 3
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 3
        VAR nvector
        VAR org
      UNIT
  IF
    NOT
      EQ
        VAR group_id
        INT 4
    APP
      VAR trace_diffuse_rays
      GET
        VAR dirvecs
        INT 4
      VAR nvector
      VAR org
    UNIT
LETREC calc_diffuse_using_1point (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  LET ray20p (VAR of )
    APP
      VAR p_received_ray_20percent
      VAR pixel
  LET nvectors (VAR of )
    APP
      VAR p_nvectors
      VAR pixel
  LET intersection_points (VAR of )
    APP
      VAR p_intersection_points
      VAR pixel
  LET energya (VAR of )
    APP
      VAR p_energy
      VAR pixel
  LET Tu168 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR ray20p
        VAR nref
  LET Tu167 (UNIT)
    APP
      VAR trace_diffuse_ray_80percent
      APP
        VAR p_group_id
        VAR pixel
      GET
        VAR nvectors
        VAR nref
      GET
        VAR intersection_points
        VAR nref
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC calc_diffuse_using_5points (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET r_up (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR prev
        VAR x
  LET r_left (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        SUB
          VAR x
          INT 1
  LET r_center (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        VAR x
  LET r_right (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        ADD
          VAR x
          INT 1
  LET r_down (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR next
        VAR x
  LET Tu173 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR r_up
        VAR nref
  LET Tu172 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_left
        VAR nref
  LET Tu171 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_center
        VAR nref
  LET Tu170 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_right
        VAR nref
  LET Tu169 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_down
        VAR nref
  LET energya (VAR of )
    APP
      VAR p_energy
      GET
        VAR cur
        VAR x
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC do_without_neighbors (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      LE
        INT 0
        GET
          VAR surface_ids
          VAR nref
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu174 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          APP
            VAR calc_diffuse_using_1point
            VAR pixel
            VAR nref
          UNIT
      APP
        VAR do_without_neighbors
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC neighbors_exist (VAR of )
  (x : VAR of ), (y : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        ADD
          VAR y
          INT 1
    IF
      NOT
        LE
          VAR y
          INT 0
      IF
        NOT
          LE
            GET
              VAR image_size
              INT 0
            ADD
              VAR x
              INT 1
        IF
          NOT
            LE
              VAR x
              INT 0
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC get_surface_id (VAR of )
  (pixel : VAR of ), (index : VAR of )
  LET surface_ids (VAR of )
    APP
      VAR p_surface_ids
      VAR pixel
  GET
    VAR surface_ids
    VAR index
LETREC neighbors_are_available (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET sid_center (VAR of )
    APP
      VAR get_surface_id
      GET
        VAR cur
        VAR x
      VAR nref
  IF
    EQ
      APP
        VAR get_surface_id
        GET
          VAR prev
          VAR x
        VAR nref
      VAR sid_center
    IF
      EQ
        APP
          VAR get_surface_id
          GET
            VAR next
            VAR x
          VAR nref
        VAR sid_center
      IF
        EQ
          APP
            VAR get_surface_id
            GET
              VAR cur
              SUB
                VAR x
                INT 1
            VAR nref
          VAR sid_center
        IF
          EQ
            APP
              VAR get_surface_id
              GET
                VAR cur
                ADD
                  VAR x
                  INT 1
              VAR nref
            VAR sid_center
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC try_exploit_neighbors (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET pixel (VAR of )
    GET
      VAR cur
      VAR x
  IF
    LE
      VAR nref
      INT 4
    IF
      LE
        INT 0
        APP
          VAR get_surface_id
          VAR pixel
          VAR nref
      IF
        APP
          VAR neighbors_are_available
          VAR x
          VAR prev
          VAR cur
          VAR next
          VAR nref
        LET calc_diffuse (VAR of )
          APP
            VAR p_calc_diffuse
            VAR pixel
        LET Tu175 (UNIT)
          IF
            GET
              VAR calc_diffuse
              VAR nref
            APP
              VAR calc_diffuse_using_5points
              VAR x
              VAR prev
              VAR cur
              VAR next
              VAR nref
            UNIT
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          ADD
            VAR nref
            INT 1
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          VAR nref
      UNIT
    UNIT
LETREC write_ppm_header (VAR of )
  (Tu176 : VAR of )
  LET Tu184 (UNIT)
    OUT
      INT 80    0
  LET Tu183 (UNIT)
    OUT
      ADD
        INT 48
        INT 6    0
  LET Tu182 (UNIT)
    OUT
      INT 10    0
  LET Tu181 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 0
  LET Tu180 (UNIT)
    OUT
      INT 32    0
  LET Tu179 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 1
  LET Tu178 (UNIT)
    OUT
      INT 32    0
  LET Tu177 (UNIT)
    APP
      VAR print_int
      INT 255
  OUT
    INT 10  0
LETREC write_rgb_element (VAR of )
  (x : VAR of )
  LET ix (VAR of )
    float_to_int
      VAR x
  LET elem (VAR of )
    IF
      NOT
        LE
          VAR ix
          INT 255
      INT 255
      IF
        NOT
          LE
            INT 0
            VAR ix
        INT 0
        VAR ix
  OUT
    VAR elem  0
LETREC write_rgb (VAR of )
  (Tu185 : VAR of )
  LET Tu187 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 0
  LET Tu186 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 1
  APP
    VAR write_rgb_element
    GET
      VAR rgb
      INT 2
LETREC pretrace_diffuse_rays (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET sid (VAR of )
      APP
        VAR get_surface_id
        VAR pixel
        VAR nref
    IF
      LE
        INT 0
        VAR sid
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu190 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          LET group_id (VAR of )
            APP
              VAR p_group_id
              VAR pixel
          LET Tu189 (UNIT)
            APP
              VAR vecbzero
              VAR diffuse_ray
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          LET intersection_points (VAR of )
            APP
              VAR p_intersection_points
              VAR pixel
          LET Tu188 (UNIT)
            APP
              VAR trace_diffuse_rays
              GET
                VAR dirvecs
                VAR group_id
              GET
                VAR nvectors
                VAR nref
              GET
                VAR intersection_points
                VAR nref
          LET ray20p (VAR of )
            APP
              VAR p_received_ray_20percent
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR ray20p
              VAR nref
            VAR diffuse_ray
          UNIT
      APP
        VAR pretrace_diffuse_rays
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC pretrace_pixels (VAR of )
  (line : VAR of ), (x : VAR of ), (group_id : VAR of ), (lc0 : VAR of ), (lc1 : VAR of ), (lc2 : VAR of )
  IF
    LE
      INT 0
      VAR x
    LET xdisp (VAR of )
      FMUL
        GET
          VAR scan_pitch
          INT 0
        int_to_float
          SUB
            VAR x
            GET
              VAR image_center
              INT 0
    LET Tu200 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 0
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 0
          VAR lc0
    LET Tu199 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 1
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 1
          VAR lc1
    LET Tu198 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 2
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 2
          VAR lc2
    LET Tu197 (UNIT)
      APP
        VAR vecunit_sgn
        VAR ptrace_dirvec
        BOOL false
    LET Tu196 (UNIT)
      APP
        VAR vecbzero
        VAR rgb
    LET Tu195 (UNIT)
      APP
        VAR veccpy
        VAR startp
        VAR viewpoint
    LET Tu194 (UNIT)
      APP
        VAR trace_ray
        INT 0
        FLOAT 1.
        VAR ptrace_dirvec
        GET
          VAR line
          VAR x
        FLOAT 0.
    LET Tu193 (UNIT)
      APP
        VAR veccpy
        APP
          VAR p_rgb
          GET
            VAR line
            VAR x
        VAR rgb
    LET Tu192 (UNIT)
      APP
        VAR p_set_group_id
        GET
          VAR line
          VAR x
        VAR group_id
    LET Tu191 (UNIT)
      APP
        VAR pretrace_diffuse_rays
        GET
          VAR line
          VAR x
        INT 0
    APP
      VAR pretrace_pixels
      VAR line
      SUB
        VAR x
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR lc0
      VAR lc1
      VAR lc2
    UNIT
LETREC pretrace_line (VAR of )
  (line : VAR of ), (y : VAR of ), (group_id : VAR of )
  LET ydisp (VAR of )
    FMUL
      GET
        VAR scan_pitch
        INT 0
      int_to_float
        SUB
          VAR y
          GET
            VAR image_center
            INT 1
  LET lc0 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 0
      GET
        VAR screenz_dir
        INT 0
  LET lc1 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 1
      GET
        VAR screenz_dir
        INT 1
  LET lc2 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 2
      GET
        VAR screenz_dir
        INT 2
  APP
    VAR pretrace_pixels
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 1
    VAR group_id
    VAR lc0
    VAR lc1
    VAR lc2
LETREC scan_pixel (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 0
        VAR x
    LET Tu203 (UNIT)
      APP
        VAR veccpy
        VAR rgb
        APP
          VAR p_rgb
          GET
            VAR cur
            VAR x
    LET Tu202 (UNIT)
      IF
        APP
          VAR neighbors_exist
          VAR x
          VAR y
          VAR next
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          INT 0
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          INT 0
    LET Tu201 (UNIT)
      APP
        VAR write_rgb
        UNIT
    APP
      VAR scan_pixel
      ADD
        VAR x
        INT 1
      VAR y
      VAR prev
      VAR cur
      VAR next
    UNIT
LETREC scan_line (VAR of )
  (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (group_id : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        VAR y
    LET Tu205 (UNIT)
      IF
        NOT
          LE
            SUB
              GET
                VAR image_size
                INT 1
              INT 1
            VAR y
        APP
          VAR pretrace_line
          VAR next
          ADD
            VAR y
            INT 1
          VAR group_id
        UNIT
    LET Tu204 (UNIT)
      APP
        VAR scan_pixel
        INT 0
        VAR y
        VAR prev
        VAR cur
        VAR next
    APP
      VAR scan_line
      ADD
        VAR y
        INT 1
      VAR cur
      VAR next
      VAR prev
      APP
        VAR add_mod5
        VAR group_id
        INT 2
    UNIT
LETREC create_float5x3array (VAR of )
  (Tu206 : VAR of )
  LET vec (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET array (VAR of )
    ARRAY
      INT 5
      VAR vec
  LET Tu210 (UNIT)
    PUT
      VAR array
      INT 1
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu209 (UNIT)
    PUT
      VAR array
      INT 2
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu208 (UNIT)
    PUT
      VAR array
      INT 3
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu207 (UNIT)
    PUT
      VAR array
      INT 4
      ARRAY
        INT 3
        FLOAT 0.
  VAR array
LETREC create_pixel (VAR of )
  (Tu211 : VAR of )
  LET m_rgb (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET m_isect_ps (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_sids (VAR of )
    ARRAY
      INT 5
      INT 0
  LET m_cdif (VAR of )
    ARRAY
      INT 5
      BOOL false
  LET m_engy (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_r20p (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_gid (VAR of )
    ARRAY
      INT 1
      INT 0
  LET m_nvectors (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  TUPLE
    VAR m_rgb
    VAR m_isect_ps
    VAR m_sids
    VAR m_cdif
    VAR m_engy
    VAR m_r20p
    VAR m_gid
    VAR m_nvectors
LETREC init_line_elements (VAR of )
  (line : VAR of ), (n : VAR of )
  IF
    LE
      INT 0
      VAR n
    LET Tu212 (UNIT)
      PUT
        VAR line
        VAR n
        APP
          VAR create_pixel
          UNIT
    APP
      VAR init_line_elements
      VAR line
      SUB
        VAR n
        INT 1
    VAR line
LETREC create_pixelline (VAR of )
  (Tu213 : VAR of )
  LET line (VAR of )
    ARRAY
      GET
        VAR image_size
        INT 0
      APP
        VAR create_pixel
        UNIT
  APP
    VAR init_line_elements
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 2
LETREC tan (VAR of )
  (x : VAR of )
  FDIV
    APP
      VAR sin
      VAR x
    APP
      VAR cos
      VAR x
LETREC adjust_position (VAR of )
  (h : VAR of ), (ratio : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FMUL
          VAR h
          VAR h
        FLOAT 0.1
  LET tan_h (VAR of )
    FDIV
      FLOAT 1.
      VAR l
  LET theta_h (VAR of )
    APP
      VAR atan
      VAR tan_h
  LET tan_m (VAR of )
    APP
      VAR tan
      FMUL
        VAR theta_h
        VAR ratio
  FMUL
    VAR tan_m
    VAR l
LETREC calc_dirvec (VAR of )
  (icount : VAR of ), (x : VAR of ), (y : VAR of ), (rx : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 5
      VAR icount
    LET l (VAR of )
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              VAR x
            APP
              VAR fsqr
              VAR y
          FLOAT 1.
    LET vx (VAR of )
      FDIV
        VAR x
        VAR l
    LET vy (VAR of )
      FDIV
        VAR y
        VAR l
    LET vz (VAR of )
      FDIV
        FLOAT 1.
        VAR l
    LET dgroup (VAR of )
      GET
        VAR dirvecs
        VAR group_id
    LET Tu218 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            VAR index
        VAR vx
        VAR vy
        VAR vz
    LET Tu217 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 40
        VAR vx
        VAR vz
        APP
          VAR fneg
          VAR vy
    LET Tu216 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 80
        VAR vz
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
    LET Tu215 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 1
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
        APP
          VAR fneg
          VAR vz
    LET Tu214 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 41
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vz
        VAR vy
    APP
      VAR vecset
      APP
        VAR d_vec
        GET
          VAR dgroup
          ADD
            VAR index
            INT 81
      APP
        VAR fneg
        VAR vz
      VAR vx
      VAR vy
    LET x2 (VAR of )
      APP
        VAR adjust_position
        VAR y
        VAR rx
    APP
      VAR calc_dirvec
      ADD
        VAR icount
        INT 1
      VAR x2
      APP
        VAR adjust_position
        VAR x2
        VAR ry
      VAR rx
      VAR ry
      VAR group_id
      VAR index
LETREC calc_dirvecs (VAR of )
  (col : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR col
    LET rx (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.9
    LET Tu220 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx
        VAR ry
        VAR group_id
        VAR index
    LET rx2 (VAR of )
      FADD
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.1
    LET Tu219 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx2
        VAR ry
        VAR group_id
        ADD
          VAR index
          INT 2
    APP
      VAR calc_dirvecs
      SUB
        VAR col
        INT 1
      VAR ry
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR index
    UNIT
LETREC calc_dirvec_rows (VAR of )
  (row : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR row
    LET ry (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR row
          FLOAT 0.2
        FLOAT 0.9
    LET Tu221 (UNIT)
      APP
        VAR calc_dirvecs
        INT 4
        VAR ry
        VAR group_id
        VAR index
    APP
      VAR calc_dirvec_rows
      SUB
        VAR row
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 2
      ADD
        VAR index
        INT 4
    UNIT
LETREC create_dirvec (VAR of )
  (Tu222 : VAR of )
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      GET
        VAR n_objects
        INT 0
      VAR v3
  TUPLE
    VAR v3
    VAR consts
LETREC create_dirvec_elements (VAR of )
  (d : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu223 (UNIT)
      PUT
        VAR d
        VAR index
        APP
          VAR create_dirvec
          UNIT
    APP
      VAR create_dirvec_elements
      VAR d
      SUB
        VAR index
        INT 1
    UNIT
LETREC create_dirvecs (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu225 (UNIT)
      PUT
        VAR dirvecs
        VAR index
        ARRAY
          INT 120
          APP
            VAR create_dirvec
            UNIT
    LET Tu224 (UNIT)
      APP
        VAR create_dirvec_elements
        GET
          VAR dirvecs
          VAR index
        INT 118
    APP
      VAR create_dirvecs
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvec_constants (VAR of )
  (vecset : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu226 (UNIT)
      APP
        VAR setup_dirvec_constants
        GET
          VAR vecset
          VAR index
    APP
      VAR init_dirvec_constants
      VAR vecset
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_vecset_constants (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu227 (UNIT)
      APP
        VAR init_dirvec_constants
        GET
          VAR dirvecs
          VAR index
        INT 119
    APP
      VAR init_vecset_constants
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvecs (VAR of )
  (Tu228 : VAR of )
  LET Tu230 (UNIT)
    APP
      VAR create_dirvecs
      INT 4
  LET Tu229 (UNIT)
    APP
      VAR calc_dirvec_rows
      INT 9
      INT 0
      INT 0
  APP
    VAR init_vecset_constants
    INT 4
LETREC add_reflection (VAR of )
  (index : VAR of ), (surface_id : VAR of ), (bright : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET dvec (VAR of )
    APP
      VAR create_dirvec
      UNIT
  LET Tu232 (UNIT)
    APP
      VAR vecset
      APP
        VAR d_vec
        VAR dvec
      VAR v0
      VAR v1
      VAR v2
  LET Tu231 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR dvec
  PUT
    VAR reflections
    VAR index
    TUPLE
      VAR surface_id
      VAR dvec
      VAR bright
LETREC setup_rect_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    MULTIPLE 4
      VAR obj_id
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET n0 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 0
  LET n1 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 1
  LET n2 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 2
  LET Tu235 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      ADD
        VAR sid
        INT 1
      VAR br
      GET
        VAR light
        INT 0
      VAR n1
      VAR n2
  LET Tu234 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 1
      ADD
        VAR sid
        INT 2
      VAR br
      VAR n0
      GET
        VAR light
        INT 1
      VAR n2
  LET Tu233 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 2
      ADD
        VAR sid
        INT 3
      VAR br
      VAR n0
      VAR n1
      GET
        VAR light
        INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 3
LETREC setup_surface_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    ADD
      MULTIPLE 4
        VAR obj_id
      INT 1
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET p (VAR of )
    APP
      VAR veciprod
      VAR light
      APP
        VAR o_param_abc
        VAR obj
  LET Tu236 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      VAR sid
      VAR br
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_a
              VAR obj
          VAR p
        GET
          VAR light
          INT 0
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_b
              VAR obj
          VAR p
        GET
          VAR light
          INT 1
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_c
              VAR obj
          VAR p
        GET
          VAR light
          INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 1
LETREC setup_reflections (VAR of )
  (obj_id : VAR of )
  IF
    LE
      INT 0
      VAR obj_id
    LET obj (VAR of )
      GET
        VAR objects
        VAR obj_id
    IF
      EQ
        APP
          VAR o_reflectiontype
          VAR obj
        INT 2
      IF
        APP
          VAR fless
          APP
            VAR o_diffuse
            VAR obj
          FLOAT 1.
        LET m_shape (VAR of )
          APP
            VAR o_form
            VAR obj
        IF
          EQ
            VAR m_shape
            INT 1
          APP
            VAR setup_rect_reflection
            VAR obj_id
            VAR obj
          IF
            EQ
              VAR m_shape
              INT 2
            APP
              VAR setup_surface_reflection
              VAR obj_id
              VAR obj
            UNIT
        UNIT
      UNIT
    UNIT
LETREC rt (VAR of )
  (size_x : VAR of ), (size_y : VAR of )
  LET Tu248 (UNIT)
    PUT
      VAR image_size
      INT 0
      VAR size_x
  LET Tu247 (UNIT)
    PUT
      VAR image_size
      INT 1
      VAR size_y
  LET Tu246 (UNIT)
    PUT
      VAR image_center
      INT 0
      DIVIDE BY 2
        VAR size_x
  LET Tu245 (UNIT)
    PUT
      VAR image_center
      INT 1
      DIVIDE BY 2
        VAR size_y
  LET Tu244 (UNIT)
    PUT
      VAR scan_pitch
      INT 0
      FDIV
        FLOAT 128.
        int_to_float
          VAR size_x
  LET prev (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET cur (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET next (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET Tu243 (UNIT)
    APP
      VAR read_parameter
      UNIT
  LET Tu242 (UNIT)
    APP
      VAR write_ppm_header
      UNIT
  LET Tu241 (UNIT)
    APP
      VAR init_dirvecs
      UNIT
  LET Tu240 (UNIT)
    APP
      VAR veccpy
      APP
        VAR d_vec
        VAR light_dirvec
      VAR light
  LET Tu239 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR light_dirvec
  LET Tu238 (UNIT)
    APP
      VAR setup_reflections
      SUB
        GET
          VAR n_objects
          INT 0
        INT 1
  LET Tu237 (UNIT)
    APP
      VAR pretrace_line
      VAR cur
      INT 0
      INT 0
  APP
    VAR scan_line
    INT 0
    VAR prev
    VAR cur
    VAR next
    INT 2
APP
  VAR rt
  INT 512
  INT 512

----- kNormal.print -----
letrec print_int : (INT -> UNIT) =
variables : (n : INT)
  let n : INT =
    let Ti2438 : INT =
      int 0
    in
    if Ti2438 <= n
      n
      let Tu1 : UNIT =
        let Ti2439 : INT =
          int 45
        in
        out Ti2439 0
      in
      neg n
  in
  let Ti2440 : INT =
    int 10
  in
  if Ti2440 <= n
    let m : INT =
      div n 10
    in
    let Tu2 : UNIT =
      app
        print_int
        m
    in
    let Ti2442 : INT =
      let Ti2441 : INT =
        mul m 10
      in
      sub n Ti2441
    in
    out Ti2442 48
    out n 48
in
letrec print_newline : (INT -> UNIT) =
variables : (Tu3 : INT)
  let Ti2437 : INT =
    int 0
  in
  out Ti2437 10
in
letrec sqrt : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let t : FLOAT =
    unknown sqrt_init x
  in
  let t : FLOAT =
    let Td2429 : FLOAT =
      let Td2428 : FLOAT =
        fmul t t
      in
      fadd Td2428 x
    in
    let Td2430 : FLOAT =
      fadd t t
    in
    fdiv Td2429 Td2430
  in
  let t : FLOAT =
    let Td2432 : FLOAT =
      let Td2431 : FLOAT =
        fmul t t
      in
      fadd Td2431 x
    in
    let Td2433 : FLOAT =
      fadd t t
    in
    fdiv Td2432 Td2433
  in
  let t : FLOAT =
    let Td2435 : FLOAT =
      let Td2434 : FLOAT =
        fmul t t
      in
      fadd Td2434 x
    in
    let Td2436 : FLOAT =
      fadd t t
    in
    fdiv Td2435 Td2436
  in
  t
in
letrec kernel_atan : (FLOAT -> FLOAT) =
variables : (a1 : FLOAT)
  let a2 : FLOAT =
    fmul a1 a1
  in
  let a3 : FLOAT =
    fmul a2 a1
  in
  let a5 : FLOAT =
    fmul a2 a3
  in
  let a7 : FLOAT =
    fmul a2 a5
  in
  let a9 : FLOAT =
    fmul a2 a7
  in
  let a11 : FLOAT =
    fmul a2 a9
  in
  let a13 : FLOAT =
    fmul a2 a11
  in
  let Td2425 : FLOAT =
    let Td2422 : FLOAT =
      let Td2419 : FLOAT =
        let Td2416 : FLOAT =
          let Td2413 : FLOAT =
            let Td2412 : FLOAT =
              let Td2411 : FLOAT =
                float 0.3333333
              in
              fmul Td2411 a3
            in
            fsub a1 Td2412
          in
          let Td2415 : FLOAT =
            let Td2414 : FLOAT =
              float 0.2
            in
            fmul Td2414 a5
          in
          fadd Td2413 Td2415
        in
        let Td2418 : FLOAT =
          let Td2417 : FLOAT =
            float 0.142857142
          in
          fmul Td2417 a7
        in
        fsub Td2416 Td2418
      in
      let Td2421 : FLOAT =
        let Td2420 : FLOAT =
          float 0.111111104
        in
        fmul Td2420 a9
      in
      fadd Td2419 Td2421
    in
    let Td2424 : FLOAT =
      let Td2423 : FLOAT =
        float 0.08976446
      in
      fmul Td2423 a11
    in
    fsub Td2422 Td2424
  in
  let Td2427 : FLOAT =
    let Td2426 : FLOAT =
      float 0.060035485
    in
    fmul Td2426 a13
  in
  fadd Td2425 Td2427
in
letrec atan : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2395 : FLOAT =
      float 0.
    in
    if Td2395 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Ti2396 : INT =
      int 0
    in
    if flag == Ti2396
      fneg a
      a
  in
  let b : FLOAT =
    let Td2397 : FLOAT =
      float 0.4375
    in
    if a <. Td2397
      app
        kernel_atan
        a
      let Td2398 : FLOAT =
        float 2.4375
      in
      if a <. Td2398
        let Td2399 : FLOAT =
          float 0.785398163397
        in
        let Td2405 : FLOAT =
          let Td2404 : FLOAT =
            let Td2401 : FLOAT =
              let Td2400 : FLOAT =
                float 1.
              in
              fsub a Td2400
            in
            let Td2403 : FLOAT =
              let Td2402 : FLOAT =
                float 1.
              in
              fadd a Td2402
            in
            fdiv Td2401 Td2403
          in
          app
            kernel_atan
            Td2404
        in
        fadd Td2399 Td2405
        let Td2406 : FLOAT =
          float 1.57079632679
        in
        let Td2409 : FLOAT =
          let Td2408 : FLOAT =
            let Td2407 : FLOAT =
              float 1.
            in
            fdiv Td2407 a
          in
          app
            kernel_atan
            Td2408
        in
        fsub Td2406 Td2409
  in
  let Ti2410 : INT =
    int 0
  in
  if flag == Ti2410
    fneg b
    b
in
letrec floor : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let a : FLOAT =
    let Ti2393 : INT =
      ftoi x
    in
    itof Ti2393
  in
  if x <. a
    let Td2394 : FLOAT =
      float 1.
    in
    fsub a Td2394
    a
in
letrec fabs : (FLOAT -> FLOAT) =
variables : (f : FLOAT)
  let Td2392 : FLOAT =
    float 0.
  in
  if f <. Td2392
    fneg f
    f
in
letrec fhalf : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2391 : FLOAT =
    float 0.5
  in
  fmul x Td2391
in
letrec fsqr : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fmul x x
in
letrec fneg : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fneg x
in
letrec fless : (FLOAT -> (FLOAT -> BOOL)) =
variables : (a : FLOAT), (b : FLOAT)
  if a <. b
    int 1
    int 0
in
letrec abs_float : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  app
    fabs
    x
in
letrec fispos : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2390 : FLOAT =
    float 0.
  in
  if Td2390 <. x
    int 1
    int 0
in
letrec fisneg : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2389 : FLOAT =
    float 0.
  in
  if x <. Td2389
    int 1
    int 0
in
let n_objects : Array of INT =
  let Ti249 : INT =
    int 1
  in
  let Ti250 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti249
    Ti250
in
let objects : Array of (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
  let dummy : Array of FLOAT =
    let Ti251 : INT =
      int 0
    in
    let Td252 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti251
      Td252
  in
  let Ti253 : INT =
    int 60
  in
  let Tt259 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * INT * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    let Ti254 : INT =
      int 0
    in
    let Ti255 : INT =
      int 0
    in
    let Ti256 : INT =
      int 0
    in
    let Ti257 : INT =
      int 0
    in
    let Ti258 : INT =
      int 0
    in
    Tuple
      Ti254
      Ti255
      Ti256
      Ti257
      dummy
      dummy
      Ti258
      dummy
      dummy
      dummy
      dummy
  in
  extfunapp
    create_array
    Ti253
    Tt259
in
let screen : Array of FLOAT =
  let Ti260 : INT =
    int 3
  in
  let Td261 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti260
    Td261
in
let viewpoint : Array of FLOAT =
  let Ti262 : INT =
    int 3
  in
  let Td263 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti262
    Td263
in
let light : Array of FLOAT =
  let Ti264 : INT =
    int 3
  in
  let Td265 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti264
    Td265
in
let beam : Array of FLOAT =
  let Ti266 : INT =
    int 1
  in
  let Td267 : FLOAT =
    float 255.
  in
  extfunapp
    create_float_array
    Ti266
    Td267
in
let and_net : Array of Array of INT =
  let Ti268 : INT =
    int 50
  in
  let Ta272 : Array of INT =
    let Ti269 : INT =
      int 1
    in
    let Ti271 : INT =
      let Ti270 : INT =
        int 1
      in
      neg Ti270
    in
    extfunapp
      create_array
      Ti269
      Ti271
  in
  extfunapp
    create_array
    Ti268
    Ta272
in
let or_net : Array of Array of Array of INT =
  let Ti273 : INT =
    int 1
  in
  let Ta277 : Array of Array of INT =
    let Ti274 : INT =
      int 1
    in
    let Ta276 : Array of INT =
      let Ti275 : INT =
        int 0
      in
      and_net.(Ti275)
    in
    extfunapp
      create_array
      Ti274
      Ta276
  in
  extfunapp
    create_array
    Ti273
    Ta277
in
let solver_dist : Array of FLOAT =
  let Ti278 : INT =
    int 1
  in
  let Td279 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti278
    Td279
in
let intsec_rectside : Array of INT =
  let Ti280 : INT =
    int 1
  in
  let Ti281 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti280
    Ti281
in
let tmin : Array of FLOAT =
  let Ti282 : INT =
    int 1
  in
  let Td283 : FLOAT =
    float 1000000000.
  in
  extfunapp
    create_float_array
    Ti282
    Td283
in
let intersection_point : Array of FLOAT =
  let Ti284 : INT =
    int 3
  in
  let Td285 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti284
    Td285
in
let intersected_object_id : Array of INT =
  let Ti286 : INT =
    int 1
  in
  let Ti287 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti286
    Ti287
in
let nvector : Array of FLOAT =
  let Ti288 : INT =
    int 3
  in
  let Td289 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti288
    Td289
in
let texture_color : Array of FLOAT =
  let Ti290 : INT =
    int 3
  in
  let Td291 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti290
    Td291
in
let diffuse_ray : Array of FLOAT =
  let Ti292 : INT =
    int 3
  in
  let Td293 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti292
    Td293
in
let rgb : Array of FLOAT =
  let Ti294 : INT =
    int 3
  in
  let Td295 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti294
    Td295
in
let image_size : Array of INT =
  let Ti296 : INT =
    int 2
  in
  let Ti297 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti296
    Ti297
in
let image_center : Array of INT =
  let Ti298 : INT =
    int 2
  in
  let Ti299 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti298
    Ti299
in
let scan_pitch : Array of FLOAT =
  let Ti300 : INT =
    int 1
  in
  let Td301 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti300
    Td301
in
let startp : Array of FLOAT =
  let Ti302 : INT =
    int 3
  in
  let Td303 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti302
    Td303
in
let startp_fast : Array of FLOAT =
  let Ti304 : INT =
    int 3
  in
  let Td305 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti304
    Td305
in
let screenx_dir : Array of FLOAT =
  let Ti306 : INT =
    int 3
  in
  let Td307 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti306
    Td307
in
let screeny_dir : Array of FLOAT =
  let Ti308 : INT =
    int 3
  in
  let Td309 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti308
    Td309
in
let screenz_dir : Array of FLOAT =
  let Ti310 : INT =
    int 3
  in
  let Td311 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti310
    Td311
in
let ptrace_dirvec : Array of FLOAT =
  let Ti312 : INT =
    int 3
  in
  let Td313 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti312
    Td313
in
let dirvecs : Array of Array of (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf : Array of FLOAT =
    let Ti314 : INT =
      int 0
    in
    let Td315 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti314
      Td315
  in
  let dummyff : Array of Array of FLOAT =
    let Ti316 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti316
      dummyf
  in
  let dummy_vs : Array of (Array of FLOAT * Array of Array of FLOAT) =
    let Ti317 : INT =
      int 0
    in
    let Tt318 : (Array of FLOAT * Array of Array of FLOAT) =
      Tuple
        dummyf
        dummyff
    in
    extfunapp
      create_array
      Ti317
      Tt318
  in
  let Ti319 : INT =
    int 5
  in
  extfunapp
    create_array
    Ti319
    dummy_vs
in
let light_dirvec : (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf2 : Array of FLOAT =
    let Ti320 : INT =
      int 0
    in
    let Td321 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti320
      Td321
  in
  let v3 : Array of FLOAT =
    let Ti322 : INT =
      int 3
    in
    let Td323 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti322
      Td323
  in
  let consts : Array of Array of FLOAT =
    let Ti324 : INT =
      int 60
    in
    extfunapp
      create_array
      Ti324
      dummyf2
  in
  Tuple
    v3
    consts
in
let reflections : Array of (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
  let dummyf3 : Array of FLOAT =
    let Ti325 : INT =
      int 0
    in
    let Td326 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti325
      Td326
  in
  let dummyff3 : Array of Array of FLOAT =
    let Ti327 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti327
      dummyf3
  in
  let dummydv : (Array of FLOAT * Array of Array of FLOAT) =
    Tuple
      dummyf3
      dummyff3
  in
  let Ti328 : INT =
    int 180
  in
  let Tt331 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    let Ti329 : INT =
      int 0
    in
    let Td330 : FLOAT =
      float 0.
    in
    Tuple
      Ti329
      dummydv
      Td330
  in
  extfunapp
    create_array
    Ti328
    Tt331
in
let n_reflections : Array of INT =
  let Ti332 : INT =
    int 1
  in
  let Ti333 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti332
    Ti333
in
letrec xor : (BOOL -> (BOOL -> BOOL)) =
variables : (x : BOOL), (y : BOOL)
  let Ti2387 : INT =
    int 0
  in
  if x == Ti2387
    y
    let Ti2388 : INT =
      int 0
    in
    if y == Ti2388
      int 1
      int 0
in
letrec sgn : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  if x == 0.0 
    float 0.
    let Tb2385 : BOOL =
      app
        fispos
        x
    in
    let Ti2386 : INT =
      int 0
    in
    if Tb2385 == Ti2386
      float -1.
      float 1.
in
letrec fneg_cond : (BOOL -> (FLOAT -> FLOAT)) =
variables : (cond : BOOL), (x : FLOAT)
  let Ti2384 : INT =
    int 0
  in
  if cond == Ti2384
    app
      fneg
      x
    x
in
letrec add_mod5 : (INT -> (INT -> INT)) =
variables : (x : INT), (y : INT)
  let sum : INT =
    add x y
  in
  let Ti2382 : INT =
    int 5
  in
  if Ti2382 <= sum
    let Ti2383 : INT =
      int 5
    in
    sub sum Ti2383
    sum
in
letrec vecset : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))) =
variables : (v : Array of FLOAT), (x : FLOAT), (y : FLOAT), (z : FLOAT)
  let Tu5 : UNIT =
    let Ti2379 : INT =
      int 0
    in
    v.(Ti2379) <- x
  in
  let Tu4 : UNIT =
    let Ti2380 : INT =
      int 1
    in
    v.(Ti2380) <- y
  in
  let Ti2381 : INT =
    int 2
  in
  v.(Ti2381) <- z
in
letrec vecfill : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (v : Array of FLOAT), (elem : FLOAT)
  let Tu7 : UNIT =
    let Ti2376 : INT =
      int 0
    in
    v.(Ti2376) <- elem
  in
  let Tu6 : UNIT =
    let Ti2377 : INT =
      int 1
    in
    v.(Ti2377) <- elem
  in
  let Ti2378 : INT =
    int 2
  in
  v.(Ti2378) <- elem
in
letrec vecbzero : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2375 : FLOAT =
    float 0.
  in
  app
    vecfill
    v
    Td2375
in
letrec veccpy : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (src : Array of FLOAT)
  let Tu9 : UNIT =
    let Ti2366 : INT =
      int 0
    in
    let Td2368 : FLOAT =
      let Ti2367 : INT =
        int 0
      in
      src.(Ti2367)
    in
    dest.(Ti2366) <- Td2368
  in
  let Tu8 : UNIT =
    let Ti2369 : INT =
      int 1
    in
    let Td2371 : FLOAT =
      let Ti2370 : INT =
        int 1
      in
      src.(Ti2370)
    in
    dest.(Ti2369) <- Td2371
  in
  let Ti2372 : INT =
    int 2
  in
  let Td2374 : FLOAT =
    let Ti2373 : INT =
      int 2
    in
    src.(Ti2373)
  in
  dest.(Ti2372) <- Td2374
in
letrec vecdist2 : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (p : Array of FLOAT), (q : Array of FLOAT)
  let Td2359 : FLOAT =
    let Td2352 : FLOAT =
      let Td2351 : FLOAT =
        let Td2348 : FLOAT =
          let Ti2347 : INT =
            int 0
          in
          p.(Ti2347)
        in
        let Td2350 : FLOAT =
          let Ti2349 : INT =
            int 0
          in
          q.(Ti2349)
        in
        fsub Td2348 Td2350
      in
      app
        fsqr
        Td2351
    in
    let Td2358 : FLOAT =
      let Td2357 : FLOAT =
        let Td2354 : FLOAT =
          let Ti2353 : INT =
            int 1
          in
          p.(Ti2353)
        in
        let Td2356 : FLOAT =
          let Ti2355 : INT =
            int 1
          in
          q.(Ti2355)
        in
        fsub Td2354 Td2356
      in
      app
        fsqr
        Td2357
    in
    fadd Td2352 Td2358
  in
  let Td2365 : FLOAT =
    let Td2364 : FLOAT =
      let Td2361 : FLOAT =
        let Ti2360 : INT =
          int 2
        in
        p.(Ti2360)
      in
      let Td2363 : FLOAT =
        let Ti2362 : INT =
          int 2
        in
        q.(Ti2362)
      in
      fsub Td2361 Td2363
    in
    app
      fsqr
      Td2364
  in
  fadd Td2359 Td2365
in
letrec vecunit : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let il : FLOAT =
    let Td2322 : FLOAT =
      float 1.
    in
    let Td2334 : FLOAT =
      let Td2333 : FLOAT =
        let Td2329 : FLOAT =
          let Td2325 : FLOAT =
            let Td2324 : FLOAT =
              let Ti2323 : INT =
                int 0
              in
              v.(Ti2323)
            in
            app
              fsqr
              Td2324
          in
          let Td2328 : FLOAT =
            let Td2327 : FLOAT =
              let Ti2326 : INT =
                int 1
              in
              v.(Ti2326)
            in
            app
              fsqr
              Td2327
          in
          fadd Td2325 Td2328
        in
        let Td2332 : FLOAT =
          let Td2331 : FLOAT =
            let Ti2330 : INT =
              int 2
            in
            v.(Ti2330)
          in
          app
            fsqr
            Td2331
        in
        fadd Td2329 Td2332
      in
      app
        sqrt
        Td2333
    in
    fdiv Td2322 Td2334
  in
  let Tu11 : UNIT =
    let Ti2335 : INT =
      int 0
    in
    let Td2338 : FLOAT =
      let Td2337 : FLOAT =
        let Ti2336 : INT =
          int 0
        in
        v.(Ti2336)
      in
      fmul Td2337 il
    in
    v.(Ti2335) <- Td2338
  in
  let Tu10 : UNIT =
    let Ti2339 : INT =
      int 1
    in
    let Td2342 : FLOAT =
      let Td2341 : FLOAT =
        let Ti2340 : INT =
          int 1
        in
        v.(Ti2340)
      in
      fmul Td2341 il
    in
    v.(Ti2339) <- Td2342
  in
  let Ti2343 : INT =
    int 2
  in
  let Td2346 : FLOAT =
    let Td2345 : FLOAT =
      let Ti2344 : INT =
        int 2
      in
      v.(Ti2344)
    in
    fmul Td2345 il
  in
  v.(Ti2343) <- Td2346
in
letrec vecunit_sgn : (Array of FLOAT -> (BOOL -> UNIT)) =
variables : (v : Array of FLOAT), (inv : BOOL)
  let l : FLOAT =
    let Td2306 : FLOAT =
      let Td2302 : FLOAT =
        let Td2298 : FLOAT =
          let Td2297 : FLOAT =
            let Ti2296 : INT =
              int 0
            in
            v.(Ti2296)
          in
          app
            fsqr
            Td2297
        in
        let Td2301 : FLOAT =
          let Td2300 : FLOAT =
            let Ti2299 : INT =
              int 1
            in
            v.(Ti2299)
          in
          app
            fsqr
            Td2300
        in
        fadd Td2298 Td2301
      in
      let Td2305 : FLOAT =
        let Td2304 : FLOAT =
          let Ti2303 : INT =
            int 2
          in
          v.(Ti2303)
        in
        app
          fsqr
          Td2304
      in
      fadd Td2302 Td2305
    in
    app
      sqrt
      Td2306
  in
  let il : FLOAT =
    if l == 0.0 
      float 1.
      let Ti2307 : INT =
        int 0
      in
      if inv == Ti2307
        let Td2308 : FLOAT =
          float 1.
        in
        fdiv Td2308 l
        let Td2309 : FLOAT =
          float -1.
        in
        fdiv Td2309 l
  in
  let Tu13 : UNIT =
    let Ti2310 : INT =
      int 0
    in
    let Td2313 : FLOAT =
      let Td2312 : FLOAT =
        let Ti2311 : INT =
          int 0
        in
        v.(Ti2311)
      in
      fmul Td2312 il
    in
    v.(Ti2310) <- Td2313
  in
  let Tu12 : UNIT =
    let Ti2314 : INT =
      int 1
    in
    let Td2317 : FLOAT =
      let Td2316 : FLOAT =
        let Ti2315 : INT =
          int 1
        in
        v.(Ti2315)
      in
      fmul Td2316 il
    in
    v.(Ti2314) <- Td2317
  in
  let Ti2318 : INT =
    int 2
  in
  let Td2321 : FLOAT =
    let Td2320 : FLOAT =
      let Ti2319 : INT =
        int 2
      in
      v.(Ti2319)
    in
    fmul Td2320 il
  in
  v.(Ti2318) <- Td2321
in
letrec veciprod : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (v : Array of FLOAT), (w : Array of FLOAT)
  let Td2290 : FLOAT =
    let Td2284 : FLOAT =
      let Td2281 : FLOAT =
        let Ti2280 : INT =
          int 0
        in
        v.(Ti2280)
      in
      let Td2283 : FLOAT =
        let Ti2282 : INT =
          int 0
        in
        w.(Ti2282)
      in
      fmul Td2281 Td2283
    in
    let Td2289 : FLOAT =
      let Td2286 : FLOAT =
        let Ti2285 : INT =
          int 1
        in
        v.(Ti2285)
      in
      let Td2288 : FLOAT =
        let Ti2287 : INT =
          int 1
        in
        w.(Ti2287)
      in
      fmul Td2286 Td2288
    in
    fadd Td2284 Td2289
  in
  let Td2295 : FLOAT =
    let Td2292 : FLOAT =
      let Ti2291 : INT =
        int 2
      in
      v.(Ti2291)
    in
    let Td2294 : FLOAT =
      let Ti2293 : INT =
        int 2
      in
      w.(Ti2293)
    in
    fmul Td2292 Td2294
  in
  fadd Td2290 Td2295
in
letrec veciprod2 : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (v : Array of FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let Td2276 : FLOAT =
    let Td2272 : FLOAT =
      let Td2271 : FLOAT =
        let Ti2270 : INT =
          int 0
        in
        v.(Ti2270)
      in
      fmul Td2271 w0
    in
    let Td2275 : FLOAT =
      let Td2274 : FLOAT =
        let Ti2273 : INT =
          int 1
        in
        v.(Ti2273)
      in
      fmul Td2274 w1
    in
    fadd Td2272 Td2275
  in
  let Td2279 : FLOAT =
    let Td2278 : FLOAT =
      let Ti2277 : INT =
        int 2
      in
      v.(Ti2277)
    in
    fmul Td2278 w2
  in
  fadd Td2276 Td2279
in
letrec vecaccum : (Array of FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (scale : FLOAT), (v : Array of FLOAT)
  let Tu15 : UNIT =
    let Ti2249 : INT =
      int 0
    in
    let Td2255 : FLOAT =
      let Td2251 : FLOAT =
        let Ti2250 : INT =
          int 0
        in
        dest.(Ti2250)
      in
      let Td2254 : FLOAT =
        let Td2253 : FLOAT =
          let Ti2252 : INT =
            int 0
          in
          v.(Ti2252)
        in
        fmul scale Td2253
      in
      fadd Td2251 Td2254
    in
    dest.(Ti2249) <- Td2255
  in
  let Tu14 : UNIT =
    let Ti2256 : INT =
      int 1
    in
    let Td2262 : FLOAT =
      let Td2258 : FLOAT =
        let Ti2257 : INT =
          int 1
        in
        dest.(Ti2257)
      in
      let Td2261 : FLOAT =
        let Td2260 : FLOAT =
          let Ti2259 : INT =
            int 1
          in
          v.(Ti2259)
        in
        fmul scale Td2260
      in
      fadd Td2258 Td2261
    in
    dest.(Ti2256) <- Td2262
  in
  let Ti2263 : INT =
    int 2
  in
  let Td2269 : FLOAT =
    let Td2265 : FLOAT =
      let Ti2264 : INT =
        int 2
      in
      dest.(Ti2264)
    in
    let Td2268 : FLOAT =
      let Td2267 : FLOAT =
        let Ti2266 : INT =
          int 2
        in
        v.(Ti2266)
      in
      fmul scale Td2267
    in
    fadd Td2265 Td2268
  in
  dest.(Ti2263) <- Td2269
in
letrec vecadd : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu17 : UNIT =
    let Ti2231 : INT =
      int 0
    in
    let Td2236 : FLOAT =
      let Td2233 : FLOAT =
        let Ti2232 : INT =
          int 0
        in
        dest.(Ti2232)
      in
      let Td2235 : FLOAT =
        let Ti2234 : INT =
          int 0
        in
        v.(Ti2234)
      in
      fadd Td2233 Td2235
    in
    dest.(Ti2231) <- Td2236
  in
  let Tu16 : UNIT =
    let Ti2237 : INT =
      int 1
    in
    let Td2242 : FLOAT =
      let Td2239 : FLOAT =
        let Ti2238 : INT =
          int 1
        in
        dest.(Ti2238)
      in
      let Td2241 : FLOAT =
        let Ti2240 : INT =
          int 1
        in
        v.(Ti2240)
      in
      fadd Td2239 Td2241
    in
    dest.(Ti2237) <- Td2242
  in
  let Ti2243 : INT =
    int 2
  in
  let Td2248 : FLOAT =
    let Td2245 : FLOAT =
      let Ti2244 : INT =
        int 2
      in
      dest.(Ti2244)
    in
    let Td2247 : FLOAT =
      let Ti2246 : INT =
        int 2
      in
      v.(Ti2246)
    in
    fadd Td2245 Td2247
  in
  dest.(Ti2243) <- Td2248
in
letrec vecmul : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu19 : UNIT =
    let Ti2213 : INT =
      int 0
    in
    let Td2218 : FLOAT =
      let Td2215 : FLOAT =
        let Ti2214 : INT =
          int 0
        in
        dest.(Ti2214)
      in
      let Td2217 : FLOAT =
        let Ti2216 : INT =
          int 0
        in
        v.(Ti2216)
      in
      fmul Td2215 Td2217
    in
    dest.(Ti2213) <- Td2218
  in
  let Tu18 : UNIT =
    let Ti2219 : INT =
      int 1
    in
    let Td2224 : FLOAT =
      let Td2221 : FLOAT =
        let Ti2220 : INT =
          int 1
        in
        dest.(Ti2220)
      in
      let Td2223 : FLOAT =
        let Ti2222 : INT =
          int 1
        in
        v.(Ti2222)
      in
      fmul Td2221 Td2223
    in
    dest.(Ti2219) <- Td2224
  in
  let Ti2225 : INT =
    int 2
  in
  let Td2230 : FLOAT =
    let Td2227 : FLOAT =
      let Ti2226 : INT =
        int 2
      in
      dest.(Ti2226)
    in
    let Td2229 : FLOAT =
      let Ti2228 : INT =
        int 2
      in
      v.(Ti2228)
    in
    fmul Td2227 Td2229
  in
  dest.(Ti2225) <- Td2230
in
letrec vecscale : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (scale : FLOAT)
  let Tu21 : UNIT =
    let Ti2201 : INT =
      int 0
    in
    let Td2204 : FLOAT =
      let Td2203 : FLOAT =
        let Ti2202 : INT =
          int 0
        in
        dest.(Ti2202)
      in
      fmul Td2203 scale
    in
    dest.(Ti2201) <- Td2204
  in
  let Tu20 : UNIT =
    let Ti2205 : INT =
      int 1
    in
    let Td2208 : FLOAT =
      let Td2207 : FLOAT =
        let Ti2206 : INT =
          int 1
        in
        dest.(Ti2206)
      in
      fmul Td2207 scale
    in
    dest.(Ti2205) <- Td2208
  in
  let Ti2209 : INT =
    int 2
  in
  let Td2212 : FLOAT =
    let Td2211 : FLOAT =
      let Ti2210 : INT =
        int 2
      in
      dest.(Ti2210)
    in
    fmul Td2211 scale
  in
  dest.(Ti2209) <- Td2212
in
letrec vecaccumv : (Array of FLOAT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT), (w : Array of FLOAT)
  let Tu23 : UNIT =
    let Ti2174 : INT =
      int 0
    in
    let Td2182 : FLOAT =
      let Td2176 : FLOAT =
        let Ti2175 : INT =
          int 0
        in
        dest.(Ti2175)
      in
      let Td2181 : FLOAT =
        let Td2178 : FLOAT =
          let Ti2177 : INT =
            int 0
          in
          v.(Ti2177)
        in
        let Td2180 : FLOAT =
          let Ti2179 : INT =
            int 0
          in
          w.(Ti2179)
        in
        fmul Td2178 Td2180
      in
      fadd Td2176 Td2181
    in
    dest.(Ti2174) <- Td2182
  in
  let Tu22 : UNIT =
    let Ti2183 : INT =
      int 1
    in
    let Td2191 : FLOAT =
      let Td2185 : FLOAT =
        let Ti2184 : INT =
          int 1
        in
        dest.(Ti2184)
      in
      let Td2190 : FLOAT =
        let Td2187 : FLOAT =
          let Ti2186 : INT =
            int 1
          in
          v.(Ti2186)
        in
        let Td2189 : FLOAT =
          let Ti2188 : INT =
            int 1
          in
          w.(Ti2188)
        in
        fmul Td2187 Td2189
      in
      fadd Td2185 Td2190
    in
    dest.(Ti2183) <- Td2191
  in
  let Ti2192 : INT =
    int 2
  in
  let Td2200 : FLOAT =
    let Td2194 : FLOAT =
      let Ti2193 : INT =
        int 2
      in
      dest.(Ti2193)
    in
    let Td2199 : FLOAT =
      let Td2196 : FLOAT =
        let Ti2195 : INT =
          int 2
        in
        v.(Ti2195)
      in
      let Td2198 : FLOAT =
        let Ti2197 : INT =
          int 2
        in
        w.(Ti2197)
      in
      fmul Td2196 Td2198
    in
    fadd Td2194 Td2199
  in
  dest.(Ti2192) <- Td2200
in
letrec o_texturetype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (m_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_tex
in
letrec o_form : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (m_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_shape
in
letrec o_reflectiontype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_surface
in
letrec o_isinvert : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> BOOL) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (m_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_invert
in
letrec o_isrot : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (m_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_isrot
in
letrec o_param_a : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2173 : INT =
      int 0
    in
    m_abc.(Ti2173)
in
letrec o_param_b : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2172 : INT =
      int 1
    in
    m_abc.(Ti2172)
in
letrec o_param_c : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2171 : INT =
      int 2
    in
    m_abc.(Ti2171)
in
letrec o_param_abc : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_abc
in
letrec o_param_x : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2170 : INT =
      int 0
    in
    m_xyz.(Ti2170)
in
letrec o_param_y : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2169 : INT =
      int 1
    in
    m_xyz.(Ti2169)
in
letrec o_param_z : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2168 : INT =
      int 2
    in
    m_xyz.(Ti2168)
in
letrec o_diffuse : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2167 : INT =
      int 0
    in
    m_surfparams.(Ti2167)
in
letrec o_hilight : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2166 : INT =
      int 1
    in
    m_surfparams.(Ti2166)
in
letrec o_color_red : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2165 : INT =
      int 0
    in
    m_color.(Ti2165)
in
letrec o_color_green : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2164 : INT =
      int 1
    in
    m_color.(Ti2164)
in
letrec o_color_blue : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2163 : INT =
      int 2
    in
    m_color.(Ti2163)
in
letrec o_param_r1 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2162 : INT =
      int 0
    in
    m_rot123.(Ti2162)
in
letrec o_param_r2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2161 : INT =
      int 1
    in
    m_rot123.(Ti2161)
in
letrec o_param_r3 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2160 : INT =
      int 2
    in
    m_rot123.(Ti2160)
in
letrec o_param_ctbl : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (m_ctbl : Array of FLOAT)
    m
  in
    m_ctbl
in
letrec p_rgb : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (m_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_rgb
in
letrec p_intersection_points : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (m_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_isect_ps
in
letrec p_surface_ids : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (m_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_sids
in
letrec p_calc_diffuse : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of BOOL) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (m_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_cdif
in
letrec p_energy : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (m_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_engy
in
letrec p_received_ray_20percent : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (m_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_r20p
in
letrec p_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2159 : INT =
      int 0
    in
    m_gid.(Ti2159)
in
letrec p_set_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (id : INT)
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2158 : INT =
      int 0
    in
    m_gid.(Ti2158) <- id
in
letrec p_nvectors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (m_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_nvectors
in
letrec d_vec : ((Array of FLOAT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (m_vec : Array of FLOAT), (xm_const : Array of Array of FLOAT)
    d
  in
    m_vec
in
letrec d_const : ((Array of FLOAT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (dm_vec : Array of FLOAT), (m_const : Array of Array of FLOAT)
    d
  in
    m_const
in
letrec r_surface_id : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> INT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (m_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_sid
in
letrec r_dvec : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (m_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_dvec
in
letrec r_bright : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> FLOAT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (m_br : FLOAT)
    r
  in
    m_br
in
letrec rad : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2157 : FLOAT =
    float 0.017453293
  in
  fmul x Td2157
in
letrec read_screen_settings : (UNIT -> UNIT) =
variables : (Tu24 : UNIT)
  let Tu38 : UNIT =
    let Ti2102 : INT =
      int 0
    in
    let Td2104 : FLOAT =
      let Tu2103 : UNIT =
        unit ()
      in
      unknown inflt Tu2103
    in
    screen.(Ti2102) <- Td2104
  in
  let Tu37 : UNIT =
    let Ti2105 : INT =
      int 1
    in
    let Td2107 : FLOAT =
      let Tu2106 : UNIT =
        unit ()
      in
      unknown inflt Tu2106
    in
    screen.(Ti2105) <- Td2107
  in
  let Tu36 : UNIT =
    let Ti2108 : INT =
      int 2
    in
    let Td2110 : FLOAT =
      let Tu2109 : UNIT =
        unit ()
      in
      unknown inflt Tu2109
    in
    screen.(Ti2108) <- Td2110
  in
  let v1 : FLOAT =
    let Td2112 : FLOAT =
      let Tu2111 : UNIT =
        unit ()
      in
      unknown inflt Tu2111
    in
    app
      rad
      Td2112
  in
  let cos_v1 : FLOAT =
    extfunapp
      cos
      v1
  in
  let sin_v1 : FLOAT =
    extfunapp
      sin
      v1
  in
  let v2 : FLOAT =
    let Td2114 : FLOAT =
      let Tu2113 : UNIT =
        unit ()
      in
      unknown inflt Tu2113
    in
    app
      rad
      Td2114
  in
  let cos_v2 : FLOAT =
    extfunapp
      cos
      v2
  in
  let sin_v2 : FLOAT =
    extfunapp
      sin
      v2
  in
  let Tu35 : UNIT =
    let Ti2115 : INT =
      int 0
    in
    let Td2118 : FLOAT =
      let Td2116 : FLOAT =
        fmul cos_v1 sin_v2
      in
      let Td2117 : FLOAT =
        float 200.
      in
      fmul Td2116 Td2117
    in
    screenz_dir.(Ti2115) <- Td2118
  in
  let Tu34 : UNIT =
    let Ti2119 : INT =
      int 1
    in
    let Td2121 : FLOAT =
      let Td2120 : FLOAT =
        float -200.
      in
      fmul sin_v1 Td2120
    in
    screenz_dir.(Ti2119) <- Td2121
  in
  let Tu33 : UNIT =
    let Ti2122 : INT =
      int 2
    in
    let Td2125 : FLOAT =
      let Td2123 : FLOAT =
        fmul cos_v1 cos_v2
      in
      let Td2124 : FLOAT =
        float 200.
      in
      fmul Td2123 Td2124
    in
    screenz_dir.(Ti2122) <- Td2125
  in
  let Tu32 : UNIT =
    let Ti2126 : INT =
      int 0
    in
    screenx_dir.(Ti2126) <- cos_v2
  in
  let Tu31 : UNIT =
    let Ti2127 : INT =
      int 1
    in
    let Td2128 : FLOAT =
      float 0.
    in
    screenx_dir.(Ti2127) <- Td2128
  in
  let Tu30 : UNIT =
    let Ti2129 : INT =
      int 2
    in
    let Td2130 : FLOAT =
      app
        fneg
        sin_v2
    in
    screenx_dir.(Ti2129) <- Td2130
  in
  let Tu29 : UNIT =
    let Ti2131 : INT =
      int 0
    in
    let Td2133 : FLOAT =
      let Td2132 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2132 sin_v2
    in
    screeny_dir.(Ti2131) <- Td2133
  in
  let Tu28 : UNIT =
    let Ti2134 : INT =
      int 1
    in
    let Td2135 : FLOAT =
      app
        fneg
        cos_v1
    in
    screeny_dir.(Ti2134) <- Td2135
  in
  let Tu27 : UNIT =
    let Ti2136 : INT =
      int 2
    in
    let Td2138 : FLOAT =
      let Td2137 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2137 cos_v2
    in
    screeny_dir.(Ti2136) <- Td2138
  in
  let Tu26 : UNIT =
    let Ti2139 : INT =
      int 0
    in
    let Td2144 : FLOAT =
      let Td2141 : FLOAT =
        let Ti2140 : INT =
          int 0
        in
        screen.(Ti2140)
      in
      let Td2143 : FLOAT =
        let Ti2142 : INT =
          int 0
        in
        screenz_dir.(Ti2142)
      in
      fsub Td2141 Td2143
    in
    viewpoint.(Ti2139) <- Td2144
  in
  let Tu25 : UNIT =
    let Ti2145 : INT =
      int 1
    in
    let Td2150 : FLOAT =
      let Td2147 : FLOAT =
        let Ti2146 : INT =
          int 1
        in
        screen.(Ti2146)
      in
      let Td2149 : FLOAT =
        let Ti2148 : INT =
          int 1
        in
        screenz_dir.(Ti2148)
      in
      fsub Td2147 Td2149
    in
    viewpoint.(Ti2145) <- Td2150
  in
  let Ti2151 : INT =
    int 2
  in
  let Td2156 : FLOAT =
    let Td2153 : FLOAT =
      let Ti2152 : INT =
        int 2
      in
      screen.(Ti2152)
    in
    let Td2155 : FLOAT =
      let Ti2154 : INT =
        int 2
      in
      screenz_dir.(Ti2154)
    in
    fsub Td2153 Td2155
  in
  viewpoint.(Ti2151) <- Td2156
in
letrec read_light : (UNIT -> UNIT) =
variables : (Tu39 : UNIT)
  let nl : INT =
    let Tu2088 : UNIT =
      unit ()
    in
    unknown inint Tu2088
  in
  let l1 : FLOAT =
    let Td2090 : FLOAT =
      let Tu2089 : UNIT =
        unit ()
      in
      unknown inflt Tu2089
    in
    app
      rad
      Td2090
  in
  let sl1 : FLOAT =
    extfunapp
      sin
      l1
  in
  let Tu42 : UNIT =
    let Ti2091 : INT =
      int 1
    in
    let Td2092 : FLOAT =
      app
        fneg
        sl1
    in
    light.(Ti2091) <- Td2092
  in
  let l2 : FLOAT =
    let Td2094 : FLOAT =
      let Tu2093 : UNIT =
        unit ()
      in
      unknown inflt Tu2093
    in
    app
      rad
      Td2094
  in
  let cl1 : FLOAT =
    extfunapp
      cos
      l1
  in
  let sl2 : FLOAT =
    extfunapp
      sin
      l2
  in
  let Tu41 : UNIT =
    let Ti2095 : INT =
      int 0
    in
    let Td2096 : FLOAT =
      fmul cl1 sl2
    in
    light.(Ti2095) <- Td2096
  in
  let cl2 : FLOAT =
    extfunapp
      cos
      l2
  in
  let Tu40 : UNIT =
    let Ti2097 : INT =
      int 2
    in
    let Td2098 : FLOAT =
      fmul cl1 cl2
    in
    light.(Ti2097) <- Td2098
  in
  let Ti2099 : INT =
    int 0
  in
  let Td2101 : FLOAT =
    let Tu2100 : UNIT =
      unit ()
    in
    unknown inflt Tu2100
  in
  beam.(Ti2099) <- Td2101
in
letrec rotate_quadratic_matrix : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (abc : Array of FLOAT), (rot : Array of FLOAT)
  let cos_x : FLOAT =
    let Td2002 : FLOAT =
      let Ti2001 : INT =
        int 0
      in
      rot.(Ti2001)
    in
    extfunapp
      cos
      Td2002
  in
  let sin_x : FLOAT =
    let Td2004 : FLOAT =
      let Ti2003 : INT =
        int 0
      in
      rot.(Ti2003)
    in
    extfunapp
      sin
      Td2004
  in
  let cos_y : FLOAT =
    let Td2006 : FLOAT =
      let Ti2005 : INT =
        int 1
      in
      rot.(Ti2005)
    in
    extfunapp
      cos
      Td2006
  in
  let sin_y : FLOAT =
    let Td2008 : FLOAT =
      let Ti2007 : INT =
        int 1
      in
      rot.(Ti2007)
    in
    extfunapp
      sin
      Td2008
  in
  let cos_z : FLOAT =
    let Td2010 : FLOAT =
      let Ti2009 : INT =
        int 2
      in
      rot.(Ti2009)
    in
    extfunapp
      cos
      Td2010
  in
  let sin_z : FLOAT =
    let Td2012 : FLOAT =
      let Ti2011 : INT =
        int 2
      in
      rot.(Ti2011)
    in
    extfunapp
      sin
      Td2012
  in
  let m00 : FLOAT =
    fmul cos_y cos_z
  in
  let m01 : FLOAT =
    let Td2014 : FLOAT =
      let Td2013 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2013 cos_z
    in
    let Td2015 : FLOAT =
      fmul cos_x sin_z
    in
    fsub Td2014 Td2015
  in
  let m02 : FLOAT =
    let Td2017 : FLOAT =
      let Td2016 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2016 cos_z
    in
    let Td2018 : FLOAT =
      fmul sin_x sin_z
    in
    fadd Td2017 Td2018
  in
  let m10 : FLOAT =
    fmul cos_y sin_z
  in
  let m11 : FLOAT =
    let Td2020 : FLOAT =
      let Td2019 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2019 sin_z
    in
    let Td2021 : FLOAT =
      fmul cos_x cos_z
    in
    fadd Td2020 Td2021
  in
  let m12 : FLOAT =
    let Td2023 : FLOAT =
      let Td2022 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2022 sin_z
    in
    let Td2024 : FLOAT =
      fmul sin_x cos_z
    in
    fsub Td2023 Td2024
  in
  let m20 : FLOAT =
    app
      fneg
      sin_y
  in
  let m21 : FLOAT =
    fmul sin_x cos_y
  in
  let m22 : FLOAT =
    fmul cos_x cos_y
  in
  let ao : FLOAT =
    let Ti2025 : INT =
      int 0
    in
    abc.(Ti2025)
  in
  let bo : FLOAT =
    let Ti2026 : INT =
      int 1
    in
    abc.(Ti2026)
  in
  let co : FLOAT =
    let Ti2027 : INT =
      int 2
    in
    abc.(Ti2027)
  in
  let Tu47 : UNIT =
    let Ti2028 : INT =
      int 0
    in
    let Td2036 : FLOAT =
      let Td2033 : FLOAT =
        let Td2030 : FLOAT =
          let Td2029 : FLOAT =
            app
              fsqr
              m00
          in
          fmul ao Td2029
        in
        let Td2032 : FLOAT =
          let Td2031 : FLOAT =
            app
              fsqr
              m10
          in
          fmul bo Td2031
        in
        fadd Td2030 Td2032
      in
      let Td2035 : FLOAT =
        let Td2034 : FLOAT =
          app
            fsqr
            m20
        in
        fmul co Td2034
      in
      fadd Td2033 Td2035
    in
    abc.(Ti2028) <- Td2036
  in
  let Tu46 : UNIT =
    let Ti2037 : INT =
      int 1
    in
    let Td2045 : FLOAT =
      let Td2042 : FLOAT =
        let Td2039 : FLOAT =
          let Td2038 : FLOAT =
            app
              fsqr
              m01
          in
          fmul ao Td2038
        in
        let Td2041 : FLOAT =
          let Td2040 : FLOAT =
            app
              fsqr
              m11
          in
          fmul bo Td2040
        in
        fadd Td2039 Td2041
      in
      let Td2044 : FLOAT =
        let Td2043 : FLOAT =
          app
            fsqr
            m21
        in
        fmul co Td2043
      in
      fadd Td2042 Td2044
    in
    abc.(Ti2037) <- Td2045
  in
  let Tu45 : UNIT =
    let Ti2046 : INT =
      int 2
    in
    let Td2054 : FLOAT =
      let Td2051 : FLOAT =
        let Td2048 : FLOAT =
          let Td2047 : FLOAT =
            app
              fsqr
              m02
          in
          fmul ao Td2047
        in
        let Td2050 : FLOAT =
          let Td2049 : FLOAT =
            app
              fsqr
              m12
          in
          fmul bo Td2049
        in
        fadd Td2048 Td2050
      in
      let Td2053 : FLOAT =
        let Td2052 : FLOAT =
          app
            fsqr
            m22
        in
        fmul co Td2052
      in
      fadd Td2051 Td2053
    in
    abc.(Ti2046) <- Td2054
  in
  let Tu44 : UNIT =
    let Ti2055 : INT =
      int 0
    in
    let Td2065 : FLOAT =
      let Td2056 : FLOAT =
        float 2.
      in
      let Td2064 : FLOAT =
        let Td2061 : FLOAT =
          let Td2058 : FLOAT =
            let Td2057 : FLOAT =
              fmul ao m01
            in
            fmul Td2057 m02
          in
          let Td2060 : FLOAT =
            let Td2059 : FLOAT =
              fmul bo m11
            in
            fmul Td2059 m12
          in
          fadd Td2058 Td2060
        in
        let Td2063 : FLOAT =
          let Td2062 : FLOAT =
            fmul co m21
          in
          fmul Td2062 m22
        in
        fadd Td2061 Td2063
      in
      fmul Td2056 Td2064
    in
    rot.(Ti2055) <- Td2065
  in
  let Tu43 : UNIT =
    let Ti2066 : INT =
      int 1
    in
    let Td2076 : FLOAT =
      let Td2067 : FLOAT =
        float 2.
      in
      let Td2075 : FLOAT =
        let Td2072 : FLOAT =
          let Td2069 : FLOAT =
            let Td2068 : FLOAT =
              fmul ao m00
            in
            fmul Td2068 m02
          in
          let Td2071 : FLOAT =
            let Td2070 : FLOAT =
              fmul bo m10
            in
            fmul Td2070 m12
          in
          fadd Td2069 Td2071
        in
        let Td2074 : FLOAT =
          let Td2073 : FLOAT =
            fmul co m20
          in
          fmul Td2073 m22
        in
        fadd Td2072 Td2074
      in
      fmul Td2067 Td2075
    in
    rot.(Ti2066) <- Td2076
  in
  let Ti2077 : INT =
    int 2
  in
  let Td2087 : FLOAT =
    let Td2078 : FLOAT =
      float 2.
    in
    let Td2086 : FLOAT =
      let Td2083 : FLOAT =
        let Td2080 : FLOAT =
          let Td2079 : FLOAT =
            fmul ao m00
          in
          fmul Td2079 m01
        in
        let Td2082 : FLOAT =
          let Td2081 : FLOAT =
            fmul bo m10
          in
          fmul Td2081 m11
        in
        fadd Td2080 Td2082
      in
      let Td2085 : FLOAT =
        let Td2084 : FLOAT =
          fmul co m20
        in
        fmul Td2084 m21
      in
      fadd Td2083 Td2085
    in
    fmul Td2078 Td2086
  in
  rot.(Ti2077) <- Td2087
in
letrec read_nth_object : (INT -> BOOL) =
variables : (n : INT)
  let texture : INT =
    let Tu1914 : UNIT =
      unit ()
    in
    unknown inint Tu1914
  in
  let Ti1916 : INT =
    let Ti1915 : INT =
      int 1
    in
    neg Ti1915
  in
  if texture == Ti1916
    int 0
    let form : INT =
      let Tu1917 : UNIT =
        unit ()
      in
      unknown inint Tu1917
    in
    let refltype : INT =
      let Tu1918 : UNIT =
        unit ()
      in
      unknown inint Tu1918
    in
    let isrot_p : INT =
      let Tu1919 : UNIT =
        unit ()
      in
      unknown inint Tu1919
    in
    let abc : Array of FLOAT =
      let Ti1920 : INT =
        int 3
      in
      let Td1921 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1920
        Td1921
    in
    let Tu66 : UNIT =
      let Ti1922 : INT =
        int 0
      in
      let Td1924 : FLOAT =
        let Tu1923 : UNIT =
          unit ()
        in
        unknown inflt Tu1923
      in
      abc.(Ti1922) <- Td1924
    in
    let Tu65 : UNIT =
      let Ti1925 : INT =
        int 1
      in
      let Td1927 : FLOAT =
        let Tu1926 : UNIT =
          unit ()
        in
        unknown inflt Tu1926
      in
      abc.(Ti1925) <- Td1927
    in
    let Tu64 : UNIT =
      let Ti1928 : INT =
        int 2
      in
      let Td1930 : FLOAT =
        let Tu1929 : UNIT =
          unit ()
        in
        unknown inflt Tu1929
      in
      abc.(Ti1928) <- Td1930
    in
    let xyz : Array of FLOAT =
      let Ti1931 : INT =
        int 3
      in
      let Td1932 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1931
        Td1932
    in
    let Tu63 : UNIT =
      let Ti1933 : INT =
        int 0
      in
      let Td1935 : FLOAT =
        let Tu1934 : UNIT =
          unit ()
        in
        unknown inflt Tu1934
      in
      xyz.(Ti1933) <- Td1935
    in
    let Tu62 : UNIT =
      let Ti1936 : INT =
        int 1
      in
      let Td1938 : FLOAT =
        let Tu1937 : UNIT =
          unit ()
        in
        unknown inflt Tu1937
      in
      xyz.(Ti1936) <- Td1938
    in
    let Tu61 : UNIT =
      let Ti1939 : INT =
        int 2
      in
      let Td1941 : FLOAT =
        let Tu1940 : UNIT =
          unit ()
        in
        unknown inflt Tu1940
      in
      xyz.(Ti1939) <- Td1941
    in
    let m_invert : BOOL =
      let Td1943 : FLOAT =
        let Tu1942 : UNIT =
          unit ()
        in
        unknown inflt Tu1942
      in
      app
        fisneg
        Td1943
    in
    let reflparam : Array of FLOAT =
      let Ti1944 : INT =
        int 2
      in
      let Td1945 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1944
        Td1945
    in
    let Tu60 : UNIT =
      let Ti1946 : INT =
        int 0
      in
      let Td1948 : FLOAT =
        let Tu1947 : UNIT =
          unit ()
        in
        unknown inflt Tu1947
      in
      reflparam.(Ti1946) <- Td1948
    in
    let Tu59 : UNIT =
      let Ti1949 : INT =
        int 1
      in
      let Td1951 : FLOAT =
        let Tu1950 : UNIT =
          unit ()
        in
        unknown inflt Tu1950
      in
      reflparam.(Ti1949) <- Td1951
    in
    let color : Array of FLOAT =
      let Ti1952 : INT =
        int 3
      in
      let Td1953 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1952
        Td1953
    in
    let Tu58 : UNIT =
      let Ti1954 : INT =
        int 0
      in
      let Td1956 : FLOAT =
        let Tu1955 : UNIT =
          unit ()
        in
        unknown inflt Tu1955
      in
      color.(Ti1954) <- Td1956
    in
    let Tu57 : UNIT =
      let Ti1957 : INT =
        int 1
      in
      let Td1959 : FLOAT =
        let Tu1958 : UNIT =
          unit ()
        in
        unknown inflt Tu1958
      in
      color.(Ti1957) <- Td1959
    in
    let Tu56 : UNIT =
      let Ti1960 : INT =
        int 2
      in
      let Td1962 : FLOAT =
        let Tu1961 : UNIT =
          unit ()
        in
        unknown inflt Tu1961
      in
      color.(Ti1960) <- Td1962
    in
    let rotation : Array of FLOAT =
      let Ti1963 : INT =
        int 3
      in
      let Td1964 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1963
        Td1964
    in
    let Tu55 : UNIT =
      let Ti1965 : INT =
        int 0
      in
      if isrot_p == Ti1965
        unit ()
        let Tu49 : UNIT =
          let Ti1966 : INT =
            int 0
          in
          let Td1969 : FLOAT =
            let Td1968 : FLOAT =
              let Tu1967 : UNIT =
                unit ()
              in
              unknown inflt Tu1967
            in
            app
              rad
              Td1968
          in
          rotation.(Ti1966) <- Td1969
        in
        let Tu48 : UNIT =
          let Ti1970 : INT =
            int 1
          in
          let Td1973 : FLOAT =
            let Td1972 : FLOAT =
              let Tu1971 : UNIT =
                unit ()
              in
              unknown inflt Tu1971
            in
            app
              rad
              Td1972
          in
          rotation.(Ti1970) <- Td1973
        in
        let Ti1974 : INT =
          int 2
        in
        let Td1977 : FLOAT =
          let Td1976 : FLOAT =
            let Tu1975 : UNIT =
              unit ()
            in
            unknown inflt Tu1975
          in
          app
            rad
            Td1976
        in
        rotation.(Ti1974) <- Td1977
    in
    let m_invert2 : BOOL =
      let Ti1978 : INT =
        int 2
      in
      if form == Ti1978
        int 1
        m_invert
    in
    let ctbl : Array of FLOAT =
      let Ti1979 : INT =
        int 4
      in
      let Td1980 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1979
        Td1980
    in
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      Tuple
        texture
        form
        refltype
        isrot_p
        abc
        xyz
        m_invert2
        reflparam
        color
        rotation
        ctbl
    in
    let Tu54 : UNIT =
      objects.(n) <- obj
    in
    let Tu53 : UNIT =
      let Ti1981 : INT =
        int 3
      in
      if form == Ti1981
        let a : FLOAT =
          let Ti1982 : INT =
            int 0
          in
          abc.(Ti1982)
        in
        let Tu51 : UNIT =
          let Ti1983 : INT =
            int 0
          in
          let Td1986 : FLOAT =
            if a == 0.0 
              float 0.
              let Td1984 : FLOAT =
                app
                  sgn
                  a
              in
              let Td1985 : FLOAT =
                app
                  fsqr
                  a
              in
              fdiv Td1984 Td1985
          in
          abc.(Ti1983) <- Td1986
        in
        let b : FLOAT =
          let Ti1987 : INT =
            int 1
          in
          abc.(Ti1987)
        in
        let Tu50 : UNIT =
          let Ti1988 : INT =
            int 1
          in
          let Td1991 : FLOAT =
            if b == 0.0 
              float 0.
              let Td1989 : FLOAT =
                app
                  sgn
                  b
              in
              let Td1990 : FLOAT =
                app
                  fsqr
                  b
              in
              fdiv Td1989 Td1990
          in
          abc.(Ti1988) <- Td1991
        in
        let c : FLOAT =
          let Ti1992 : INT =
            int 2
          in
          abc.(Ti1992)
        in
        let Ti1993 : INT =
          int 2
        in
        let Td1996 : FLOAT =
          if c == 0.0 
            float 0.
            let Td1994 : FLOAT =
              app
                sgn
                c
            in
            let Td1995 : FLOAT =
              app
                fsqr
                c
            in
            fdiv Td1994 Td1995
        in
        abc.(Ti1993) <- Td1996
        let Ti1997 : INT =
          int 2
        in
        if form == Ti1997
          let Ti1999 : INT =
            let Ti1998 : INT =
              int 0
            in
            if m_invert == Ti1998
              int 1
              int 0
          in
          app
            vecunit_sgn
            abc
            Ti1999
          unit ()
    in
    let Tu52 : UNIT =
      let Ti2000 : INT =
        int 0
      in
      if isrot_p == Ti2000
        unit ()
        app
          rotate_quadratic_matrix
          abc
          rotation
    in
    int 1
in
letrec read_object : (INT -> UNIT) =
variables : (n : INT)
  let Ti1908 : INT =
    int 60
  in
  if Ti1908 <= n
    unit ()
    let Tb1909 : BOOL =
      app
        read_nth_object
        n
    in
    let Ti1910 : INT =
      int 0
    in
    if Tb1909 == Ti1910
      let Ti1911 : INT =
        int 0
      in
      n_objects.(Ti1911) <- n
      let Ti1913 : INT =
        let Ti1912 : INT =
          int 1
        in
        add n Ti1912
      in
      app
        read_object
        Ti1913
in
letrec read_all_object : (UNIT -> UNIT) =
variables : (Tu67 : UNIT)
  let Ti1907 : INT =
    int 0
  in
  app
    read_object
    Ti1907
in
letrec read_net_item : (INT -> Array of INT) =
variables : (length : INT)
  let item : INT =
    let Tu1898 : UNIT =
      unit ()
    in
    unknown inint Tu1898
  in
  let Ti1900 : INT =
    let Ti1899 : INT =
      int 1
    in
    neg Ti1899
  in
  if item == Ti1900
    let Ti1902 : INT =
      let Ti1901 : INT =
        int 1
      in
      add length Ti1901
    in
    let Ti1904 : INT =
      let Ti1903 : INT =
        int 1
      in
      neg Ti1903
    in
    extfunapp
      create_array
      Ti1902
      Ti1904
    let v : Array of INT =
      let Ti1906 : INT =
        let Ti1905 : INT =
          int 1
        in
        add length Ti1905
      in
      app
        read_net_item
        Ti1906
    in
    let Tu68 : UNIT =
      v.(length) <- item
    in
    v
in
letrec read_or_network : (INT -> Array of Array of INT) =
variables : (length : INT)
  let net : Array of INT =
    let Ti1889 : INT =
      int 0
    in
    app
      read_net_item
      Ti1889
  in
  let Ti1891 : INT =
    let Ti1890 : INT =
      int 0
    in
    net.(Ti1890)
  in
  let Ti1893 : INT =
    let Ti1892 : INT =
      int 1
    in
    neg Ti1892
  in
  if Ti1891 == Ti1893
    let Ti1895 : INT =
      let Ti1894 : INT =
        int 1
      in
      add length Ti1894
    in
    extfunapp
      create_array
      Ti1895
      net
    let v : Array of Array of INT =
      let Ti1897 : INT =
        let Ti1896 : INT =
          int 1
        in
        add length Ti1896
      in
      app
        read_or_network
        Ti1897
    in
    let Tu69 : UNIT =
      v.(length) <- net
    in
    v
in
letrec read_and_network : (INT -> UNIT) =
variables : (n : INT)
  let net : Array of INT =
    let Ti1882 : INT =
      int 0
    in
    app
      read_net_item
      Ti1882
  in
  let Ti1884 : INT =
    let Ti1883 : INT =
      int 0
    in
    net.(Ti1883)
  in
  let Ti1886 : INT =
    let Ti1885 : INT =
      int 1
    in
    neg Ti1885
  in
  if Ti1884 == Ti1886
    unit ()
    let Tu70 : UNIT =
      and_net.(n) <- net
    in
    let Ti1888 : INT =
      let Ti1887 : INT =
        int 1
      in
      add n Ti1887
    in
    app
      read_and_network
      Ti1888
in
letrec read_parameter : (UNIT -> UNIT) =
variables : (Tu71 : UNIT)
  let Tu75 : UNIT =
    let Tu1875 : UNIT =
      unit ()
    in
    app
      read_screen_settings
      Tu1875
  in
  let Tu74 : UNIT =
    let Tu1876 : UNIT =
      unit ()
    in
    app
      read_light
      Tu1876
  in
  let Tu73 : UNIT =
    let Tu1877 : UNIT =
      unit ()
    in
    app
      read_all_object
      Tu1877
  in
  let Tu72 : UNIT =
    let Ti1878 : INT =
      int 0
    in
    app
      read_and_network
      Ti1878
  in
  let Ti1879 : INT =
    int 0
  in
  let Ta1881 : Array of Array of INT =
    let Ti1880 : INT =
      int 0
    in
    app
      read_or_network
      Ti1880
  in
  or_net.(Ti1879) <- Ta1881
in
letrec solver_rect_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> (INT -> BOOL)))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT), (i0 : INT), (i1 : INT), (i2 : INT)
  let Td1852 : FLOAT =
    dirvec.(i0)
  in
  if Td1852 == 0.0 
    int 0
    let abc : Array of FLOAT =
      app
        o_param_abc
        m
    in
    let d : FLOAT =
      let Tb1856 : BOOL =
        let Tb1853 : BOOL =
          app
            o_isinvert
            m
        in
        let Tb1855 : BOOL =
          let Td1854 : FLOAT =
            dirvec.(i0)
          in
          app
            fisneg
            Td1854
        in
        app
          xor
          Tb1853
          Tb1855
      in
      let Td1857 : FLOAT =
        abc.(i0)
      in
      app
        fneg_cond
        Tb1856
        Td1857
    in
    let d2 : FLOAT =
      let Td1858 : FLOAT =
        fsub d b0
      in
      let Td1859 : FLOAT =
        dirvec.(i0)
      in
      fdiv Td1858 Td1859
    in
    let Tb1865 : BOOL =
      let Td1863 : FLOAT =
        let Td1862 : FLOAT =
          let Td1861 : FLOAT =
            let Td1860 : FLOAT =
              dirvec.(i1)
            in
            fmul d2 Td1860
          in
          fadd Td1861 b1
        in
        app
          fabs
          Td1862
      in
      let Td1864 : FLOAT =
        abc.(i1)
      in
      app
        fless
        Td1863
        Td1864
    in
    let Ti1866 : INT =
      int 0
    in
    if Tb1865 == Ti1866
      int 0
      let Tb1872 : BOOL =
        let Td1870 : FLOAT =
          let Td1869 : FLOAT =
            let Td1868 : FLOAT =
              let Td1867 : FLOAT =
                dirvec.(i2)
              in
              fmul d2 Td1867
            in
            fadd Td1868 b2
          in
          app
            fabs
            Td1869
        in
        let Td1871 : FLOAT =
          abc.(i2)
        in
        app
          fless
          Td1870
          Td1871
      in
      let Ti1873 : INT =
        int 0
      in
      if Tb1872 == Ti1873
        int 0
        let Tu76 : UNIT =
          let Ti1874 : INT =
            int 0
          in
          solver_dist.(Ti1874) <- d2
        in
        int 1
in
letrec solver_rect : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1840 : BOOL =
    let Ti1837 : INT =
      int 0
    in
    let Ti1838 : INT =
      int 1
    in
    let Ti1839 : INT =
      int 2
    in
    app
      solver_rect_surface
      m
      dirvec
      b0
      b1
      b2
      Ti1837
      Ti1838
      Ti1839
  in
  let Ti1841 : INT =
    int 0
  in
  if Tb1840 == Ti1841
    let Tb1845 : BOOL =
      let Ti1842 : INT =
        int 1
      in
      let Ti1843 : INT =
        int 2
      in
      let Ti1844 : INT =
        int 0
      in
      app
        solver_rect_surface
        m
        dirvec
        b1
        b2
        b0
        Ti1842
        Ti1843
        Ti1844
    in
    let Ti1846 : INT =
      int 0
    in
    if Tb1845 == Ti1846
      let Tb1850 : BOOL =
        let Ti1847 : INT =
          int 2
        in
        let Ti1848 : INT =
          int 0
        in
        let Ti1849 : INT =
          int 1
        in
        app
          solver_rect_surface
          m
          dirvec
          b2
          b0
          b1
          Ti1847
          Ti1848
          Ti1849
      in
      let Ti1851 : INT =
        int 0
      in
      if Tb1850 == Ti1851
        int 0
        int 3
      int 2
    int 1
in
letrec solver_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let abc : Array of FLOAT =
    app
      o_param_abc
      m
  in
  let d : FLOAT =
    app
      veciprod
      dirvec
      abc
  in
  let Tb1831 : BOOL =
    app
      fispos
      d
  in
  let Ti1832 : INT =
    int 0
  in
  if Tb1831 == Ti1832
    int 0
    let Tu77 : UNIT =
      let Ti1833 : INT =
        int 0
      in
      let Td1836 : FLOAT =
        let Td1835 : FLOAT =
          let Td1834 : FLOAT =
            app
              veciprod2
              abc
              b0
              b1
              b2
          in
          app
            fneg
            Td1834
        in
        fdiv Td1835 d
      in
      solver_dist.(Ti1833) <- Td1836
    in
    int 1
in
letrec quadratic : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let diag_part : FLOAT =
    let Td1814 : FLOAT =
      let Td1810 : FLOAT =
        let Td1808 : FLOAT =
          app
            fsqr
            v0
        in
        let Td1809 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1808 Td1809
      in
      let Td1813 : FLOAT =
        let Td1811 : FLOAT =
          app
            fsqr
            v1
        in
        let Td1812 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1811 Td1812
      in
      fadd Td1810 Td1813
    in
    let Td1817 : FLOAT =
      let Td1815 : FLOAT =
        app
          fsqr
          v2
      in
      let Td1816 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1815 Td1816
    in
    fadd Td1814 Td1817
  in
  let Ti1818 : INT =
    app
      o_isrot
      m
  in
  let Ti1819 : INT =
    int 0
  in
  if Ti1818 == Ti1819
    diag_part
    let Td1827 : FLOAT =
      let Td1823 : FLOAT =
        let Td1822 : FLOAT =
          let Td1820 : FLOAT =
            fmul v1 v2
          in
          let Td1821 : FLOAT =
            app
              o_param_r1
              m
          in
          fmul Td1820 Td1821
        in
        fadd diag_part Td1822
      in
      let Td1826 : FLOAT =
        let Td1824 : FLOAT =
          fmul v2 v0
        in
        let Td1825 : FLOAT =
          app
            o_param_r2
            m
        in
        fmul Td1824 Td1825
      in
      fadd Td1823 Td1826
    in
    let Td1830 : FLOAT =
      let Td1828 : FLOAT =
        fmul v0 v1
      in
      let Td1829 : FLOAT =
        app
          o_param_r3
          m
      in
      fmul Td1828 Td1829
    in
    fadd Td1827 Td1830
in
letrec bilinear : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let diag_part : FLOAT =
    let Td1784 : FLOAT =
      let Td1780 : FLOAT =
        let Td1778 : FLOAT =
          fmul v0 w0
        in
        let Td1779 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1778 Td1779
      in
      let Td1783 : FLOAT =
        let Td1781 : FLOAT =
          fmul v1 w1
        in
        let Td1782 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1781 Td1782
      in
      fadd Td1780 Td1783
    in
    let Td1787 : FLOAT =
      let Td1785 : FLOAT =
        fmul v2 w2
      in
      let Td1786 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1785 Td1786
    in
    fadd Td1784 Td1787
  in
  let Ti1788 : INT =
    app
      o_isrot
      m
  in
  let Ti1789 : INT =
    int 0
  in
  if Ti1788 == Ti1789
    diag_part
    let Td1807 : FLOAT =
      let Td1806 : FLOAT =
        let Td1800 : FLOAT =
          let Td1794 : FLOAT =
            let Td1792 : FLOAT =
              let Td1790 : FLOAT =
                fmul v2 w1
              in
              let Td1791 : FLOAT =
                fmul v1 w2
              in
              fadd Td1790 Td1791
            in
            let Td1793 : FLOAT =
              app
                o_param_r1
                m
            in
            fmul Td1792 Td1793
          in
          let Td1799 : FLOAT =
            let Td1797 : FLOAT =
              let Td1795 : FLOAT =
                fmul v0 w2
              in
              let Td1796 : FLOAT =
                fmul v2 w0
              in
              fadd Td1795 Td1796
            in
            let Td1798 : FLOAT =
              app
                o_param_r2
                m
            in
            fmul Td1797 Td1798
          in
          fadd Td1794 Td1799
        in
        let Td1805 : FLOAT =
          let Td1803 : FLOAT =
            let Td1801 : FLOAT =
              fmul v0 w1
            in
            let Td1802 : FLOAT =
              fmul v1 w0
            in
            fadd Td1801 Td1802
          in
          let Td1804 : FLOAT =
            app
              o_param_r3
              m
          in
          fmul Td1803 Td1804
        in
        fadd Td1800 Td1805
      in
      app
        fhalf
        Td1806
    in
    fadd diag_part Td1807
in
letrec solver_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Td1755 : FLOAT =
      let Ti1754 : INT =
        int 0
      in
      dirvec.(Ti1754)
    in
    let Td1757 : FLOAT =
      let Ti1756 : INT =
        int 1
      in
      dirvec.(Ti1756)
    in
    let Td1759 : FLOAT =
      let Ti1758 : INT =
        int 2
      in
      dirvec.(Ti1758)
    in
    app
      quadratic
      m
      Td1755
      Td1757
      Td1759
  in
  if aa == 0.0 
    int 0
    let bb : FLOAT =
      let Td1761 : FLOAT =
        let Ti1760 : INT =
          int 0
        in
        dirvec.(Ti1760)
      in
      let Td1763 : FLOAT =
        let Ti1762 : INT =
          int 1
        in
        dirvec.(Ti1762)
      in
      let Td1765 : FLOAT =
        let Ti1764 : INT =
          int 2
        in
        dirvec.(Ti1764)
      in
      app
        bilinear
        m
        Td1761
        Td1763
        Td1765
        b0
        b1
        b2
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1766 : INT =
        app
          o_form
          m
      in
      let Ti1767 : INT =
        int 3
      in
      if Ti1766 == Ti1767
        let Td1768 : FLOAT =
          float 1.
        in
        fsub cc0 Td1768
        cc0
    in
    let d : FLOAT =
      let Td1769 : FLOAT =
        app
          fsqr
          bb
      in
      let Td1770 : FLOAT =
        fmul aa cc
      in
      fsub Td1769 Td1770
    in
    let Tb1771 : BOOL =
      app
        fispos
        d
    in
    let Ti1772 : INT =
      int 0
    in
    if Tb1771 == Ti1772
      int 0
      let sd : FLOAT =
        app
          sqrt
          d
      in
      let t1 : FLOAT =
        let Tb1773 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1774 : INT =
          int 0
        in
        if Tb1773 == Ti1774
          app
            fneg
            sd
          sd
      in
      let Tu78 : UNIT =
        let Ti1775 : INT =
          int 0
        in
        let Td1777 : FLOAT =
          let Td1776 : FLOAT =
            fsub t1 bb
          in
          fdiv Td1776 aa
        in
        solver_dist.(Ti1775) <- Td1777
      in
      int 1
in
letrec solver : (INT -> (Array of FLOAT -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : Array of FLOAT), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1744 : FLOAT =
      let Ti1743 : INT =
        int 0
      in
      org.(Ti1743)
    in
    let Td1745 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1744 Td1745
  in
  let b1 : FLOAT =
    let Td1747 : FLOAT =
      let Ti1746 : INT =
        int 1
      in
      org.(Ti1746)
    in
    let Td1748 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1747 Td1748
  in
  let b2 : FLOAT =
    let Td1750 : FLOAT =
      let Ti1749 : INT =
        int 2
      in
      org.(Ti1749)
    in
    let Td1751 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1750 Td1751
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1752 : INT =
    int 1
  in
  if m_shape == Ti1752
    app
      solver_rect
      m
      dirvec
      b0
      b1
      b2
    let Ti1753 : INT =
      int 2
    in
    if m_shape == Ti1753
      app
        solver_surface
        m
        dirvec
        b0
        b1
        b2
      app
        solver_second
        m
        dirvec
        b0
        b1
        b2
in
letrec solver_rect_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v : Array of FLOAT), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let d0 : FLOAT =
    let Td1667 : FLOAT =
      let Td1666 : FLOAT =
        let Ti1665 : INT =
          int 0
        in
        dconst.(Ti1665)
      in
      fsub Td1666 b0
    in
    let Td1669 : FLOAT =
      let Ti1668 : INT =
        int 1
      in
      dconst.(Ti1668)
    in
    fmul Td1667 Td1669
  in
  let Ti1688 : INT =
    let Tb1676 : BOOL =
      let Td1674 : FLOAT =
        let Td1673 : FLOAT =
          let Td1672 : FLOAT =
            let Td1671 : FLOAT =
              let Ti1670 : INT =
                int 1
              in
              v.(Ti1670)
            in
            fmul d0 Td1671
          in
          fadd Td1672 b1
        in
        app
          fabs
          Td1673
      in
      let Td1675 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fless
        Td1674
        Td1675
    in
    let Ti1677 : INT =
      int 0
    in
    if Tb1676 == Ti1677
      int 0
      let Tb1684 : BOOL =
        let Td1682 : FLOAT =
          let Td1681 : FLOAT =
            let Td1680 : FLOAT =
              let Td1679 : FLOAT =
                let Ti1678 : INT =
                  int 2
                in
                v.(Ti1678)
              in
              fmul d0 Td1679
            in
            fadd Td1680 b2
          in
          app
            fabs
            Td1681
        in
        let Td1683 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1682
          Td1683
      in
      let Ti1685 : INT =
        int 0
      in
      if Tb1684 == Ti1685
        int 0
        let Td1687 : FLOAT =
          let Ti1686 : INT =
            int 1
          in
          dconst.(Ti1686)
        in
        if Td1687 == 0.0 
          int 0
          int 1
  in
  let Ti1689 : INT =
    int 0
  in
  if Ti1688 == Ti1689
    let d1 : FLOAT =
      let Td1692 : FLOAT =
        let Td1691 : FLOAT =
          let Ti1690 : INT =
            int 2
          in
          dconst.(Ti1690)
        in
        fsub Td1691 b1
      in
      let Td1694 : FLOAT =
        let Ti1693 : INT =
          int 3
        in
        dconst.(Ti1693)
      in
      fmul Td1692 Td1694
    in
    let Ti1713 : INT =
      let Tb1701 : BOOL =
        let Td1699 : FLOAT =
          let Td1698 : FLOAT =
            let Td1697 : FLOAT =
              let Td1696 : FLOAT =
                let Ti1695 : INT =
                  int 0
                in
                v.(Ti1695)
              in
              fmul d1 Td1696
            in
            fadd Td1697 b0
          in
          app
            fabs
            Td1698
        in
        let Td1700 : FLOAT =
          app
            o_param_a
            m
        in
        app
          fless
          Td1699
          Td1700
      in
      let Ti1702 : INT =
        int 0
      in
      if Tb1701 == Ti1702
        int 0
        let Tb1709 : BOOL =
          let Td1707 : FLOAT =
            let Td1706 : FLOAT =
              let Td1705 : FLOAT =
                let Td1704 : FLOAT =
                  let Ti1703 : INT =
                    int 2
                  in
                  v.(Ti1703)
                in
                fmul d1 Td1704
              in
              fadd Td1705 b2
            in
            app
              fabs
              Td1706
          in
          let Td1708 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fless
            Td1707
            Td1708
        in
        let Ti1710 : INT =
          int 0
        in
        if Tb1709 == Ti1710
          int 0
          let Td1712 : FLOAT =
            let Ti1711 : INT =
              int 3
            in
            dconst.(Ti1711)
          in
          if Td1712 == 0.0 
            int 0
            int 1
    in
    let Ti1714 : INT =
      int 0
    in
    if Ti1713 == Ti1714
      let d2 : FLOAT =
        let Td1717 : FLOAT =
          let Td1716 : FLOAT =
            let Ti1715 : INT =
              int 4
            in
            dconst.(Ti1715)
          in
          fsub Td1716 b2
        in
        let Td1719 : FLOAT =
          let Ti1718 : INT =
            int 5
          in
          dconst.(Ti1718)
        in
        fmul Td1717 Td1719
      in
      let Ti1738 : INT =
        let Tb1726 : BOOL =
          let Td1724 : FLOAT =
            let Td1723 : FLOAT =
              let Td1722 : FLOAT =
                let Td1721 : FLOAT =
                  let Ti1720 : INT =
                    int 0
                  in
                  v.(Ti1720)
                in
                fmul d2 Td1721
              in
              fadd Td1722 b0
            in
            app
              fabs
              Td1723
          in
          let Td1725 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fless
            Td1724
            Td1725
        in
        let Ti1727 : INT =
          int 0
        in
        if Tb1726 == Ti1727
          int 0
          let Tb1734 : BOOL =
            let Td1732 : FLOAT =
              let Td1731 : FLOAT =
                let Td1730 : FLOAT =
                  let Td1729 : FLOAT =
                    let Ti1728 : INT =
                      int 1
                    in
                    v.(Ti1728)
                  in
                  fmul d2 Td1729
                in
                fadd Td1730 b1
              in
              app
                fabs
                Td1731
            in
            let Td1733 : FLOAT =
              app
                o_param_b
                m
            in
            app
              fless
              Td1732
              Td1733
          in
          let Ti1735 : INT =
            int 0
          in
          if Tb1734 == Ti1735
            int 0
            let Td1737 : FLOAT =
              let Ti1736 : INT =
                int 5
              in
              dconst.(Ti1736)
            in
            if Td1737 == 0.0 
              int 0
              int 1
      in
      let Ti1739 : INT =
        int 0
      in
      if Ti1738 == Ti1739
        int 0
        let Tu81 : UNIT =
          let Ti1740 : INT =
            int 0
          in
          solver_dist.(Ti1740) <- d2
        in
        int 3
      let Tu80 : UNIT =
        let Ti1741 : INT =
          int 0
        in
        solver_dist.(Ti1741) <- d1
      in
      int 2
    let Tu79 : UNIT =
      let Ti1742 : INT =
        int 0
      in
      solver_dist.(Ti1742) <- d0
    in
    int 1
in
letrec solver_surface_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1651 : BOOL =
    let Td1650 : FLOAT =
      let Ti1649 : INT =
        int 0
      in
      dconst.(Ti1649)
    in
    app
      fisneg
      Td1650
  in
  let Ti1652 : INT =
    int 0
  in
  if Tb1651 == Ti1652
    int 0
    let Tu82 : UNIT =
      let Ti1653 : INT =
        int 0
      in
      let Td1664 : FLOAT =
        let Td1660 : FLOAT =
          let Td1656 : FLOAT =
            let Td1655 : FLOAT =
              let Ti1654 : INT =
                int 1
              in
              dconst.(Ti1654)
            in
            fmul Td1655 b0
          in
          let Td1659 : FLOAT =
            let Td1658 : FLOAT =
              let Ti1657 : INT =
                int 2
              in
              dconst.(Ti1657)
            in
            fmul Td1658 b1
          in
          fadd Td1656 Td1659
        in
        let Td1663 : FLOAT =
          let Td1662 : FLOAT =
            let Ti1661 : INT =
              int 3
            in
            dconst.(Ti1661)
          in
          fmul Td1662 b2
        in
        fadd Td1660 Td1663
      in
      solver_dist.(Ti1653) <- Td1664
    in
    int 1
in
letrec solver_second_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1617 : INT =
      int 0
    in
    dconst.(Ti1617)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1624 : FLOAT =
        let Td1620 : FLOAT =
          let Td1619 : FLOAT =
            let Ti1618 : INT =
              int 1
            in
            dconst.(Ti1618)
          in
          fmul Td1619 b0
        in
        let Td1623 : FLOAT =
          let Td1622 : FLOAT =
            let Ti1621 : INT =
              int 2
            in
            dconst.(Ti1621)
          in
          fmul Td1622 b1
        in
        fadd Td1620 Td1623
      in
      let Td1627 : FLOAT =
        let Td1626 : FLOAT =
          let Ti1625 : INT =
            int 3
          in
          dconst.(Ti1625)
        in
        fmul Td1626 b2
      in
      fadd Td1624 Td1627
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1628 : INT =
        app
          o_form
          m
      in
      let Ti1629 : INT =
        int 3
      in
      if Ti1628 == Ti1629
        let Td1630 : FLOAT =
          float 1.
        in
        fsub cc0 Td1630
        cc0
    in
    let d : FLOAT =
      let Td1631 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1632 : FLOAT =
        fmul aa cc
      in
      fsub Td1631 Td1632
    in
    let Tb1633 : BOOL =
      app
        fispos
        d
    in
    let Ti1634 : INT =
      int 0
    in
    if Tb1633 == Ti1634
      int 0
      let Tu83 : UNIT =
        let Tb1635 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1636 : INT =
          int 0
        in
        if Tb1635 == Ti1636
          let Ti1637 : INT =
            int 0
          in
          let Td1642 : FLOAT =
            let Td1639 : FLOAT =
              let Td1638 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1638
            in
            let Td1641 : FLOAT =
              let Ti1640 : INT =
                int 4
              in
              dconst.(Ti1640)
            in
            fmul Td1639 Td1641
          in
          solver_dist.(Ti1637) <- Td1642
          let Ti1643 : INT =
            int 0
          in
          let Td1648 : FLOAT =
            let Td1645 : FLOAT =
              let Td1644 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1644
            in
            let Td1647 : FLOAT =
              let Ti1646 : INT =
                int 4
              in
              dconst.(Ti1646)
            in
            fmul Td1645 Td1647
          in
          solver_dist.(Ti1643) <- Td1648
      in
      int 1
in
letrec solver_fast : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1606 : FLOAT =
      let Ti1605 : INT =
        int 0
      in
      org.(Ti1605)
    in
    let Td1607 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1606 Td1607
  in
  let b1 : FLOAT =
    let Td1609 : FLOAT =
      let Ti1608 : INT =
        int 1
      in
      org.(Ti1608)
    in
    let Td1610 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1609 Td1610
  in
  let b2 : FLOAT =
    let Td1612 : FLOAT =
      let Ti1611 : INT =
        int 2
      in
      org.(Ti1611)
    in
    let Td1613 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1612 Td1613
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1614 : INT =
    int 1
  in
  if m_shape == Ti1614
    let Ta1615 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1615
      dconst
      b0
      b1
      b2
    let Ti1616 : INT =
      int 2
    in
    if m_shape == Ti1616
      app
        solver_surface_fast
        m
        dconst
        b0
        b1
        b2
      app
        solver_second_fast
        m
        dconst
        b0
        b1
        b2
in
letrec solver_surface_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1597 : BOOL =
    let Td1596 : FLOAT =
      let Ti1595 : INT =
        int 0
      in
      dconst.(Ti1595)
    in
    app
      fisneg
      Td1596
  in
  let Ti1598 : INT =
    int 0
  in
  if Tb1597 == Ti1598
    int 0
    let Tu84 : UNIT =
      let Ti1599 : INT =
        int 0
      in
      let Td1604 : FLOAT =
        let Td1601 : FLOAT =
          let Ti1600 : INT =
            int 0
          in
          dconst.(Ti1600)
        in
        let Td1603 : FLOAT =
          let Ti1602 : INT =
            int 3
          in
          sconst.(Ti1602)
        in
        fmul Td1601 Td1603
      in
      solver_dist.(Ti1599) <- Td1604
    in
    int 1
in
letrec solver_second_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1565 : INT =
      int 0
    in
    dconst.(Ti1565)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1572 : FLOAT =
        let Td1568 : FLOAT =
          let Td1567 : FLOAT =
            let Ti1566 : INT =
              int 1
            in
            dconst.(Ti1566)
          in
          fmul Td1567 b0
        in
        let Td1571 : FLOAT =
          let Td1570 : FLOAT =
            let Ti1569 : INT =
              int 2
            in
            dconst.(Ti1569)
          in
          fmul Td1570 b1
        in
        fadd Td1568 Td1571
      in
      let Td1575 : FLOAT =
        let Td1574 : FLOAT =
          let Ti1573 : INT =
            int 3
          in
          dconst.(Ti1573)
        in
        fmul Td1574 b2
      in
      fadd Td1572 Td1575
    in
    let cc : FLOAT =
      let Ti1576 : INT =
        int 3
      in
      sconst.(Ti1576)
    in
    let d : FLOAT =
      let Td1577 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1578 : FLOAT =
        fmul aa cc
      in
      fsub Td1577 Td1578
    in
    let Tb1579 : BOOL =
      app
        fispos
        d
    in
    let Ti1580 : INT =
      int 0
    in
    if Tb1579 == Ti1580
      int 0
      let Tu85 : UNIT =
        let Tb1581 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1582 : INT =
          int 0
        in
        if Tb1581 == Ti1582
          let Ti1583 : INT =
            int 0
          in
          let Td1588 : FLOAT =
            let Td1585 : FLOAT =
              let Td1584 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1584
            in
            let Td1587 : FLOAT =
              let Ti1586 : INT =
                int 4
              in
              dconst.(Ti1586)
            in
            fmul Td1585 Td1587
          in
          solver_dist.(Ti1583) <- Td1588
          let Ti1589 : INT =
            int 0
          in
          let Td1594 : FLOAT =
            let Td1591 : FLOAT =
              let Td1590 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1590
            in
            let Td1593 : FLOAT =
              let Ti1592 : INT =
                int 4
              in
              dconst.(Ti1592)
            in
            fmul Td1591 Td1593
          in
          solver_dist.(Ti1589) <- Td1594
      in
      int 1
in
letrec solver_fast2 : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> INT)) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let sconst : Array of FLOAT =
    app
      o_param_ctbl
      m
  in
  let b0 : FLOAT =
    let Ti1559 : INT =
      int 0
    in
    sconst.(Ti1559)
  in
  let b1 : FLOAT =
    let Ti1560 : INT =
      int 1
    in
    sconst.(Ti1560)
  in
  let b2 : FLOAT =
    let Ti1561 : INT =
      int 2
    in
    sconst.(Ti1561)
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1562 : INT =
    int 1
  in
  if m_shape == Ti1562
    let Ta1563 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1563
      dconst
      b0
      b1
      b2
    let Ti1564 : INT =
      int 2
    in
    if m_shape == Ti1564
      app
        solver_surface_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
      app
        solver_second_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
in
letrec setup_rect_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1506 : INT =
      int 6
    in
    let Td1507 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1506
      Td1507
  in
  let Tu91 : UNIT =
    let Td1509 : FLOAT =
      let Ti1508 : INT =
        int 0
      in
      vec.(Ti1508)
    in
    if Td1509 == 0.0 
      let Ti1510 : INT =
        int 1
      in
      let Td1511 : FLOAT =
        float 0.
      in
      const.(Ti1510) <- Td1511
      let Tu86 : UNIT =
        let Ti1512 : INT =
          int 0
        in
        let Td1519 : FLOAT =
          let Tb1517 : BOOL =
            let Tb1513 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1516 : BOOL =
              let Td1515 : FLOAT =
                let Ti1514 : INT =
                  int 0
                in
                vec.(Ti1514)
              in
              app
                fisneg
                Td1515
            in
            app
              xor
              Tb1513
              Tb1516
          in
          let Td1518 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fneg_cond
            Tb1517
            Td1518
        in
        const.(Ti1512) <- Td1519
      in
      let Ti1520 : INT =
        int 1
      in
      let Td1524 : FLOAT =
        let Td1521 : FLOAT =
          float 1.
        in
        let Td1523 : FLOAT =
          let Ti1522 : INT =
            int 0
          in
          vec.(Ti1522)
        in
        fdiv Td1521 Td1523
      in
      const.(Ti1520) <- Td1524
  in
  let Tu90 : UNIT =
    let Td1526 : FLOAT =
      let Ti1525 : INT =
        int 1
      in
      vec.(Ti1525)
    in
    if Td1526 == 0.0 
      let Ti1527 : INT =
        int 3
      in
      let Td1528 : FLOAT =
        float 0.
      in
      const.(Ti1527) <- Td1528
      let Tu87 : UNIT =
        let Ti1529 : INT =
          int 2
        in
        let Td1536 : FLOAT =
          let Tb1534 : BOOL =
            let Tb1530 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1533 : BOOL =
              let Td1532 : FLOAT =
                let Ti1531 : INT =
                  int 1
                in
                vec.(Ti1531)
              in
              app
                fisneg
                Td1532
            in
            app
              xor
              Tb1530
              Tb1533
          in
          let Td1535 : FLOAT =
            app
              o_param_b
              m
          in
          app
            fneg_cond
            Tb1534
            Td1535
        in
        const.(Ti1529) <- Td1536
      in
      let Ti1537 : INT =
        int 3
      in
      let Td1541 : FLOAT =
        let Td1538 : FLOAT =
          float 1.
        in
        let Td1540 : FLOAT =
          let Ti1539 : INT =
            int 1
          in
          vec.(Ti1539)
        in
        fdiv Td1538 Td1540
      in
      const.(Ti1537) <- Td1541
  in
  let Tu89 : UNIT =
    let Td1543 : FLOAT =
      let Ti1542 : INT =
        int 2
      in
      vec.(Ti1542)
    in
    if Td1543 == 0.0 
      let Ti1544 : INT =
        int 5
      in
      let Td1545 : FLOAT =
        float 0.
      in
      const.(Ti1544) <- Td1545
      let Tu88 : UNIT =
        let Ti1546 : INT =
          int 4
        in
        let Td1553 : FLOAT =
          let Tb1551 : BOOL =
            let Tb1547 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1550 : BOOL =
              let Td1549 : FLOAT =
                let Ti1548 : INT =
                  int 2
                in
                vec.(Ti1548)
              in
              app
                fisneg
                Td1549
            in
            app
              xor
              Tb1547
              Tb1550
          in
          let Td1552 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fneg_cond
            Tb1551
            Td1552
        in
        const.(Ti1546) <- Td1553
      in
      let Ti1554 : INT =
        int 5
      in
      let Td1558 : FLOAT =
        let Td1555 : FLOAT =
          float 1.
        in
        let Td1557 : FLOAT =
          let Ti1556 : INT =
            int 2
          in
          vec.(Ti1556)
        in
        fdiv Td1555 Td1557
      in
      const.(Ti1554) <- Td1558
  in
  const
in
letrec setup_surface_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1472 : INT =
      int 4
    in
    let Td1473 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1472
      Td1473
  in
  let d : FLOAT =
    let Td1482 : FLOAT =
      let Td1477 : FLOAT =
        let Td1475 : FLOAT =
          let Ti1474 : INT =
            int 0
          in
          vec.(Ti1474)
        in
        let Td1476 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1475 Td1476
      in
      let Td1481 : FLOAT =
        let Td1479 : FLOAT =
          let Ti1478 : INT =
            int 1
          in
          vec.(Ti1478)
        in
        let Td1480 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1479 Td1480
      in
      fadd Td1477 Td1481
    in
    let Td1486 : FLOAT =
      let Td1484 : FLOAT =
        let Ti1483 : INT =
          int 2
        in
        vec.(Ti1483)
      in
      let Td1485 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1484 Td1485
    in
    fadd Td1482 Td1486
  in
  let Tu95 : UNIT =
    let Tb1487 : BOOL =
      app
        fispos
        d
    in
    let Ti1488 : INT =
      int 0
    in
    if Tb1487 == Ti1488
      let Ti1489 : INT =
        int 0
      in
      let Td1490 : FLOAT =
        float 0.
      in
      const.(Ti1489) <- Td1490
      let Tu94 : UNIT =
        let Ti1491 : INT =
          int 0
        in
        let Td1493 : FLOAT =
          let Td1492 : FLOAT =
            float -1.
          in
          fdiv Td1492 d
        in
        const.(Ti1491) <- Td1493
      in
      let Tu93 : UNIT =
        let Ti1494 : INT =
          int 1
        in
        let Td1497 : FLOAT =
          let Td1496 : FLOAT =
            let Td1495 : FLOAT =
              app
                o_param_a
                m
            in
            fdiv Td1495 d
          in
          app
            fneg
            Td1496
        in
        const.(Ti1494) <- Td1497
      in
      let Tu92 : UNIT =
        let Ti1498 : INT =
          int 2
        in
        let Td1501 : FLOAT =
          let Td1500 : FLOAT =
            let Td1499 : FLOAT =
              app
                o_param_b
                m
            in
            fdiv Td1499 d
          in
          app
            fneg
            Td1500
        in
        const.(Ti1498) <- Td1501
      in
      let Ti1502 : INT =
        int 3
      in
      let Td1505 : FLOAT =
        let Td1504 : FLOAT =
          let Td1503 : FLOAT =
            app
              o_param_c
              m
          in
          fdiv Td1503 d
        in
        app
          fneg
          Td1504
      in
      const.(Ti1502) <- Td1505
  in
  const
in
letrec setup_second_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (v : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1407 : INT =
      int 5
    in
    let Td1408 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1407
      Td1408
  in
  let aa : FLOAT =
    let Td1410 : FLOAT =
      let Ti1409 : INT =
        int 0
      in
      v.(Ti1409)
    in
    let Td1412 : FLOAT =
      let Ti1411 : INT =
        int 1
      in
      v.(Ti1411)
    in
    let Td1414 : FLOAT =
      let Ti1413 : INT =
        int 2
      in
      v.(Ti1413)
    in
    app
      quadratic
      m
      Td1410
      Td1412
      Td1414
  in
  let c1 : FLOAT =
    let Td1418 : FLOAT =
      let Td1416 : FLOAT =
        let Ti1415 : INT =
          int 0
        in
        v.(Ti1415)
      in
      let Td1417 : FLOAT =
        app
          o_param_a
          m
      in
      fmul Td1416 Td1417
    in
    app
      fneg
      Td1418
  in
  let c2 : FLOAT =
    let Td1422 : FLOAT =
      let Td1420 : FLOAT =
        let Ti1419 : INT =
          int 1
        in
        v.(Ti1419)
      in
      let Td1421 : FLOAT =
        app
          o_param_b
          m
      in
      fmul Td1420 Td1421
    in
    app
      fneg
      Td1422
  in
  let c3 : FLOAT =
    let Td1426 : FLOAT =
      let Td1424 : FLOAT =
        let Ti1423 : INT =
          int 2
        in
        v.(Ti1423)
      in
      let Td1425 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1424 Td1425
    in
    app
      fneg
      Td1426
  in
  let Tu102 : UNIT =
    let Ti1427 : INT =
      int 0
    in
    const.(Ti1427) <- aa
  in
  let Tu101 : UNIT =
    let Ti1428 : INT =
      app
        o_isrot
        m
    in
    let Ti1429 : INT =
      int 0
    in
    if Ti1428 == Ti1429
      let Tu99 : UNIT =
        let Ti1430 : INT =
          int 1
        in
        const.(Ti1430) <- c1
      in
      let Tu98 : UNIT =
        let Ti1431 : INT =
          int 2
        in
        const.(Ti1431) <- c2
      in
      let Ti1432 : INT =
        int 3
      in
      const.(Ti1432) <- c3
      let Tu97 : UNIT =
        let Ti1433 : INT =
          int 1
        in
        let Td1444 : FLOAT =
          let Td1443 : FLOAT =
            let Td1442 : FLOAT =
              let Td1437 : FLOAT =
                let Td1435 : FLOAT =
                  let Ti1434 : INT =
                    int 2
                  in
                  v.(Ti1434)
                in
                let Td1436 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul Td1435 Td1436
              in
              let Td1441 : FLOAT =
                let Td1439 : FLOAT =
                  let Ti1438 : INT =
                    int 1
                  in
                  v.(Ti1438)
                in
                let Td1440 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1439 Td1440
              in
              fadd Td1437 Td1441
            in
            app
              fhalf
              Td1442
          in
          fsub c1 Td1443
        in
        const.(Ti1433) <- Td1444
      in
      let Tu96 : UNIT =
        let Ti1445 : INT =
          int 2
        in
        let Td1456 : FLOAT =
          let Td1455 : FLOAT =
            let Td1454 : FLOAT =
              let Td1449 : FLOAT =
                let Td1447 : FLOAT =
                  let Ti1446 : INT =
                    int 2
                  in
                  v.(Ti1446)
                in
                let Td1448 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul Td1447 Td1448
              in
              let Td1453 : FLOAT =
                let Td1451 : FLOAT =
                  let Ti1450 : INT =
                    int 0
                  in
                  v.(Ti1450)
                in
                let Td1452 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1451 Td1452
              in
              fadd Td1449 Td1453
            in
            app
              fhalf
              Td1454
          in
          fsub c2 Td1455
        in
        const.(Ti1445) <- Td1456
      in
      let Ti1457 : INT =
        int 3
      in
      let Td1468 : FLOAT =
        let Td1467 : FLOAT =
          let Td1466 : FLOAT =
            let Td1461 : FLOAT =
              let Td1459 : FLOAT =
                let Ti1458 : INT =
                  int 1
                in
                v.(Ti1458)
              in
              let Td1460 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul Td1459 Td1460
            in
            let Td1465 : FLOAT =
              let Td1463 : FLOAT =
                let Ti1462 : INT =
                  int 0
                in
                v.(Ti1462)
              in
              let Td1464 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul Td1463 Td1464
            in
            fadd Td1461 Td1465
          in
          app
            fhalf
            Td1466
        in
        fsub c3 Td1467
      in
      const.(Ti1457) <- Td1468
  in
  let Tu100 : UNIT =
    if aa == 0.0 
      unit ()
      let Ti1469 : INT =
        int 4
      in
      let Td1471 : FLOAT =
        let Td1470 : FLOAT =
          float 1.
        in
        fdiv Td1470 aa
      in
      const.(Ti1469) <- Td1471
  in
  const
in
letrec iter_setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti1399 : INT =
    int 0
  in
  if Ti1399 <= index
    let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let dconst : Array of Array of FLOAT =
      app
        d_const
        dirvec
    in
    let v : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    let m_shape : INT =
      app
        o_form
        m
    in
    let Tu103 : UNIT =
      let Ti1400 : INT =
        int 1
      in
      if m_shape == Ti1400
        let Ta1401 : Array of FLOAT =
          app
            setup_rect_table
            v
            m
        in
        dconst.(index) <- Ta1401
        let Ti1402 : INT =
          int 2
        in
        if m_shape == Ti1402
          let Ta1403 : Array of FLOAT =
            app
              setup_surface_table
              v
              m
          in
          dconst.(index) <- Ta1403
          let Ta1404 : Array of FLOAT =
            app
              setup_second_table
              v
              m
          in
          dconst.(index) <- Ta1404
    in
    let Ti1406 : INT =
      let Ti1405 : INT =
        int 1
      in
      sub index Ti1405
    in
    app
      iter_setup_dirvec_constants
      dirvec
      Ti1406
    unit ()
in
letrec setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> UNIT) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Ti1398 : INT =
    let Ti1396 : INT =
      let Ti1395 : INT =
        int 0
      in
      n_objects.(Ti1395)
    in
    let Ti1397 : INT =
      int 1
    in
    sub Ti1396 Ti1397
  in
  app
    iter_setup_dirvec_constants
    dirvec
    Ti1398
in
letrec setup_startp_constants : (Array of FLOAT -> (INT -> UNIT)) =
variables : (p : Array of FLOAT), (index : INT)
  let Ti1356 : INT =
    int 0
  in
  if Ti1356 <= index
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let sconst : Array of FLOAT =
      app
        o_param_ctbl
        obj
    in
    let m_shape : INT =
      app
        o_form
        obj
    in
    let Tu107 : UNIT =
      let Ti1357 : INT =
        int 0
      in
      let Td1361 : FLOAT =
        let Td1359 : FLOAT =
          let Ti1358 : INT =
            int 0
          in
          p.(Ti1358)
        in
        let Td1360 : FLOAT =
          app
            o_param_x
            obj
        in
        fsub Td1359 Td1360
      in
      sconst.(Ti1357) <- Td1361
    in
    let Tu106 : UNIT =
      let Ti1362 : INT =
        int 1
      in
      let Td1366 : FLOAT =
        let Td1364 : FLOAT =
          let Ti1363 : INT =
            int 1
          in
          p.(Ti1363)
        in
        let Td1365 : FLOAT =
          app
            o_param_y
            obj
        in
        fsub Td1364 Td1365
      in
      sconst.(Ti1362) <- Td1366
    in
    let Tu105 : UNIT =
      let Ti1367 : INT =
        int 2
      in
      let Td1371 : FLOAT =
        let Td1369 : FLOAT =
          let Ti1368 : INT =
            int 2
          in
          p.(Ti1368)
        in
        let Td1370 : FLOAT =
          app
            o_param_z
            obj
        in
        fsub Td1369 Td1370
      in
      sconst.(Ti1367) <- Td1371
    in
    let Tu104 : UNIT =
      let Ti1372 : INT =
        int 2
      in
      if m_shape == Ti1372
        let Ti1373 : INT =
          int 3
        in
        let Td1381 : FLOAT =
          let Ta1374 : Array of FLOAT =
            app
              o_param_abc
              obj
          in
          let Td1376 : FLOAT =
            let Ti1375 : INT =
              int 0
            in
            sconst.(Ti1375)
          in
          let Td1378 : FLOAT =
            let Ti1377 : INT =
              int 1
            in
            sconst.(Ti1377)
          in
          let Td1380 : FLOAT =
            let Ti1379 : INT =
              int 2
            in
            sconst.(Ti1379)
          in
          app
            veciprod2
            Ta1374
            Td1376
            Td1378
            Td1380
        in
        sconst.(Ti1373) <- Td1381
        let Ti1382 : INT =
          int 2
        in
        if m_shape <= Ti1382
          unit ()
          let cc0 : FLOAT =
            let Td1384 : FLOAT =
              let Ti1383 : INT =
                int 0
              in
              sconst.(Ti1383)
            in
            let Td1386 : FLOAT =
              let Ti1385 : INT =
                int 1
              in
              sconst.(Ti1385)
            in
            let Td1388 : FLOAT =
              let Ti1387 : INT =
                int 2
              in
              sconst.(Ti1387)
            in
            app
              quadratic
              obj
              Td1384
              Td1386
              Td1388
          in
          let Ti1389 : INT =
            int 3
          in
          let Td1392 : FLOAT =
            let Ti1390 : INT =
              int 3
            in
            if m_shape == Ti1390
              let Td1391 : FLOAT =
                float 1.
              in
              fsub cc0 Td1391
              cc0
          in
          sconst.(Ti1389) <- Td1392
    in
    let Ti1394 : INT =
      let Ti1393 : INT =
        int 1
      in
      sub index Ti1393
    in
    app
      setup_startp_constants
      p
      Ti1394
    unit ()
in
letrec setup_startp : (Array of FLOAT -> UNIT) =
variables : (p : Array of FLOAT)
  let Tu108 : UNIT =
    app
      veccpy
      startp_fast
      p
  in
  let Ti1355 : INT =
    let Ti1353 : INT =
      let Ti1352 : INT =
        int 0
      in
      n_objects.(Ti1352)
    in
    let Ti1354 : INT =
      int 1
    in
    sub Ti1353 Ti1354
  in
  app
    setup_startp_constants
    p
    Ti1355
in
letrec is_rect_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let Ti1348 : INT =
    let Tb1340 : BOOL =
      let Td1338 : FLOAT =
        app
          fabs
          p0
      in
      let Td1339 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fless
        Td1338
        Td1339
    in
    let Ti1341 : INT =
      int 0
    in
    if Tb1340 == Ti1341
      int 0
      let Tb1344 : BOOL =
        let Td1342 : FLOAT =
          app
            fabs
            p1
        in
        let Td1343 : FLOAT =
          app
            o_param_b
            m
        in
        app
          fless
          Td1342
          Td1343
      in
      let Ti1345 : INT =
        int 0
      in
      if Tb1344 == Ti1345
        int 0
        let Td1346 : FLOAT =
          app
            fabs
            p2
        in
        let Td1347 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1346
          Td1347
  in
  let Ti1349 : INT =
    int 0
  in
  if Ti1348 == Ti1349
    let Tb1350 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1351 : INT =
      int 0
    in
    if Tb1350 == Ti1351
      int 1
      int 0
    app
      o_isinvert
      m
in
letrec is_plane_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    let Ta1333 : Array of FLOAT =
      app
        o_param_abc
        m
    in
    app
      veciprod2
      Ta1333
      p0
      p1
      p2
  in
  let Tb1336 : BOOL =
    let Tb1334 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1335 : BOOL =
      app
        fisneg
        w
    in
    app
      xor
      Tb1334
      Tb1335
  in
  let Ti1337 : INT =
    int 0
  in
  if Tb1336 == Ti1337
    int 1
    int 0
in
letrec is_second_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    app
      quadratic
      m
      p0
      p1
      p2
  in
  let w2 : FLOAT =
    let Ti1326 : INT =
      app
        o_form
        m
    in
    let Ti1327 : INT =
      int 3
    in
    if Ti1326 == Ti1327
      let Td1328 : FLOAT =
        float 1.
      in
      fsub w Td1328
      w
  in
  let Tb1331 : BOOL =
    let Tb1329 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1330 : BOOL =
      app
        fisneg
        w2
    in
    app
      xor
      Tb1329
      Tb1330
  in
  let Ti1332 : INT =
    int 0
  in
  if Tb1331 == Ti1332
    int 1
    int 0
in
letrec is_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let p0 : FLOAT =
    let Td1321 : FLOAT =
      app
        o_param_x
        m
    in
    fsub q0 Td1321
  in
  let p1 : FLOAT =
    let Td1322 : FLOAT =
      app
        o_param_y
        m
    in
    fsub q1 Td1322
  in
  let p2 : FLOAT =
    let Td1323 : FLOAT =
      app
        o_param_z
        m
    in
    fsub q2 Td1323
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1324 : INT =
    int 1
  in
  if m_shape == Ti1324
    app
      is_rect_outside
      m
      p0
      p1
      p2
    let Ti1325 : INT =
      int 2
    in
    if m_shape == Ti1325
      app
        is_plane_outside
        m
        p0
        p1
        p2
      app
        is_second_outside
        m
        p0
        p1
        p2
in
letrec check_all_inside : (INT -> (Array of INT -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL))))) =
variables : (ofs : INT), (iand : Array of INT), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let head : INT =
    iand.(ofs)
  in
  let Ti1315 : INT =
    let Ti1314 : INT =
      int 1
    in
    neg Ti1314
  in
  if head == Ti1315
    int 1
    let Tb1317 : BOOL =
      let Tt1316 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(head)
      in
      app
        is_outside
        Tt1316
        q0
        q1
        q2
    in
    let Ti1318 : INT =
      int 0
    in
    if Tb1317 == Ti1318
      let Ti1320 : INT =
        let Ti1319 : INT =
          int 1
        in
        add ofs Ti1319
      in
      app
        check_all_inside
        Ti1320
        iand
        q0
        q1
        q2
      int 0
in
letrec shadow_check_and_group : (INT -> (Array of INT -> BOOL)) =
variables : (iand_ofs : INT), (and_group : Array of INT)
  let Ti1280 : INT =
    and_group.(iand_ofs)
  in
  let Ti1282 : INT =
    let Ti1281 : INT =
      int 1
    in
    neg Ti1281
  in
  if Ti1280 == Ti1282
    int 0
    let obj : INT =
      and_group.(iand_ofs)
    in
    let t0 : INT =
      app
        solver_fast
        obj
        light_dirvec
        intersection_point
    in
    let t0p : FLOAT =
      let Ti1283 : INT =
        int 0
      in
      solver_dist.(Ti1283)
    in
    let Ti1286 : INT =
      let Ti1284 : INT =
        int 0
      in
      if t0 == Ti1284
        int 0
        let Td1285 : FLOAT =
          float -0.2
        in
        app
          fless
          t0p
          Td1285
    in
    let Ti1287 : INT =
      int 0
    in
    if Ti1286 == Ti1287
      let Tb1289 : BOOL =
        let Tt1288 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(obj)
        in
        app
          o_isinvert
          Tt1288
      in
      let Ti1290 : INT =
        int 0
      in
      if Tb1289 == Ti1290
        int 0
        let Ti1292 : INT =
          let Ti1291 : INT =
            int 1
          in
          add iand_ofs Ti1291
        in
        app
          shadow_check_and_group
          Ti1292
          and_group
      let t : FLOAT =
        let Td1293 : FLOAT =
          float 0.01
        in
        fadd t0p Td1293
      in
      let q0 : FLOAT =
        let Td1296 : FLOAT =
          let Td1295 : FLOAT =
            let Ti1294 : INT =
              int 0
            in
            light.(Ti1294)
          in
          fmul Td1295 t
        in
        let Td1298 : FLOAT =
          let Ti1297 : INT =
            int 0
          in
          intersection_point.(Ti1297)
        in
        fadd Td1296 Td1298
      in
      let q1 : FLOAT =
        let Td1301 : FLOAT =
          let Td1300 : FLOAT =
            let Ti1299 : INT =
              int 1
            in
            light.(Ti1299)
          in
          fmul Td1300 t
        in
        let Td1303 : FLOAT =
          let Ti1302 : INT =
            int 1
          in
          intersection_point.(Ti1302)
        in
        fadd Td1301 Td1303
      in
      let q2 : FLOAT =
        let Td1306 : FLOAT =
          let Td1305 : FLOAT =
            let Ti1304 : INT =
              int 2
            in
            light.(Ti1304)
          in
          fmul Td1305 t
        in
        let Td1308 : FLOAT =
          let Ti1307 : INT =
            int 2
          in
          intersection_point.(Ti1307)
        in
        fadd Td1306 Td1308
      in
      let Tb1310 : BOOL =
        let Ti1309 : INT =
          int 0
        in
        app
          check_all_inside
          Ti1309
          and_group
          q0
          q1
          q2
      in
      let Ti1311 : INT =
        int 0
      in
      if Tb1310 == Ti1311
        let Ti1313 : INT =
          let Ti1312 : INT =
            int 1
          in
          add iand_ofs Ti1312
        in
        app
          shadow_check_and_group
          Ti1313
          and_group
        int 1
in
letrec shadow_check_one_or_group : (INT -> (Array of INT -> BOOL)) =
variables : (ofs : INT), (or_group : Array of INT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1275 : INT =
    let Ti1274 : INT =
      int 1
    in
    neg Ti1274
  in
  if head == Ti1275
    int 0
    let and_group : Array of INT =
      and_net.(head)
    in
    let shadow_p : BOOL =
      let Ti1276 : INT =
        int 0
      in
      app
        shadow_check_and_group
        Ti1276
        and_group
    in
    let Ti1277 : INT =
      int 0
    in
    if shadow_p == Ti1277
      let Ti1279 : INT =
        let Ti1278 : INT =
          int 1
        in
        add ofs Ti1278
      in
      app
        shadow_check_one_or_group
        Ti1279
        or_group
      int 1
in
letrec shadow_check_one_or_matrix : (INT -> (Array of Array of INT -> BOOL)) =
variables : (ofs : INT), (or_matrix : Array of Array of INT)
  let head : Array of INT =
    or_matrix.(ofs)
  in
  let range_primitive : INT =
    let Ti1252 : INT =
      int 0
    in
    head.(Ti1252)
  in
  let Ti1254 : INT =
    let Ti1253 : INT =
      int 1
    in
    neg Ti1253
  in
  if range_primitive == Ti1254
    int 0
    let Ti1265 : INT =
      let Ti1255 : INT =
        int 99
      in
      if range_primitive == Ti1255
        int 1
        let t : INT =
          app
            solver_fast
            range_primitive
            light_dirvec
            intersection_point
        in
        let Ti1256 : INT =
          int 0
        in
        if t == Ti1256
          int 0
          let Tb1260 : BOOL =
            let Td1258 : FLOAT =
              let Ti1257 : INT =
                int 0
              in
              solver_dist.(Ti1257)
            in
            let Td1259 : FLOAT =
              float -0.1
            in
            app
              fless
              Td1258
              Td1259
          in
          let Ti1261 : INT =
            int 0
          in
          if Tb1260 == Ti1261
            int 0
            let Tb1263 : BOOL =
              let Ti1262 : INT =
                int 1
              in
              app
                shadow_check_one_or_group
                Ti1262
                head
            in
            let Ti1264 : INT =
              int 0
            in
            if Tb1263 == Ti1264
              int 0
              int 1
    in
    let Ti1266 : INT =
      int 0
    in
    if Ti1265 == Ti1266
      let Ti1268 : INT =
        let Ti1267 : INT =
          int 1
        in
        add ofs Ti1267
      in
      app
        shadow_check_one_or_matrix
        Ti1268
        or_matrix
      let Tb1270 : BOOL =
        let Ti1269 : INT =
          int 1
        in
        app
          shadow_check_one_or_group
          Ti1269
          head
      in
      let Ti1271 : INT =
        int 0
      in
      if Tb1270 == Ti1271
        let Ti1273 : INT =
          let Ti1272 : INT =
            int 1
          in
          add ofs Ti1272
        in
        app
          shadow_check_one_or_matrix
          Ti1273
          or_matrix
        int 1
in
letrec solve_each_element : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : Array of FLOAT)
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1213 : INT =
    let Ti1212 : INT =
      int 1
    in
    neg Ti1212
  in
  if iobj == Ti1213
    unit ()
    let t0 : INT =
      app
        solver
        iobj
        dirvec
        startp
    in
    let Ti1214 : INT =
      int 0
    in
    if t0 == Ti1214
      let Tb1216 : BOOL =
        let Tt1215 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1215
      in
      let Ti1217 : INT =
        int 0
      in
      if Tb1216 == Ti1217
        unit ()
        let Ti1219 : INT =
          let Ti1218 : INT =
            int 1
          in
          add iand_ofs Ti1218
        in
        app
          solve_each_element
          Ti1219
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1220 : INT =
          int 0
        in
        solver_dist.(Ti1220)
      in
      let Tu112 : UNIT =
        let Tb1222 : BOOL =
          let Td1221 : FLOAT =
            float 0.
          in
          app
            fless
            Td1221
            t0p
        in
        let Ti1223 : INT =
          int 0
        in
        if Tb1222 == Ti1223
          unit ()
          let Tb1226 : BOOL =
            let Td1225 : FLOAT =
              let Ti1224 : INT =
                int 0
              in
              tmin.(Ti1224)
            in
            app
              fless
              t0p
              Td1225
          in
          let Ti1227 : INT =
            int 0
          in
          if Tb1226 == Ti1227
            unit ()
            let t : FLOAT =
              let Td1228 : FLOAT =
                float 0.01
              in
              fadd t0p Td1228
            in
            let q0 : FLOAT =
              let Td1231 : FLOAT =
                let Td1230 : FLOAT =
                  let Ti1229 : INT =
                    int 0
                  in
                  dirvec.(Ti1229)
                in
                fmul Td1230 t
              in
              let Td1233 : FLOAT =
                let Ti1232 : INT =
                  int 0
                in
                startp.(Ti1232)
              in
              fadd Td1231 Td1233
            in
            let q1 : FLOAT =
              let Td1236 : FLOAT =
                let Td1235 : FLOAT =
                  let Ti1234 : INT =
                    int 1
                  in
                  dirvec.(Ti1234)
                in
                fmul Td1235 t
              in
              let Td1238 : FLOAT =
                let Ti1237 : INT =
                  int 1
                in
                startp.(Ti1237)
              in
              fadd Td1236 Td1238
            in
            let q2 : FLOAT =
              let Td1241 : FLOAT =
                let Td1240 : FLOAT =
                  let Ti1239 : INT =
                    int 2
                  in
                  dirvec.(Ti1239)
                in
                fmul Td1240 t
              in
              let Td1243 : FLOAT =
                let Ti1242 : INT =
                  int 2
                in
                startp.(Ti1242)
              in
              fadd Td1241 Td1243
            in
            let Tb1245 : BOOL =
              let Ti1244 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1244
                and_group
                q0
                q1
                q2
            in
            let Ti1246 : INT =
              int 0
            in
            if Tb1245 == Ti1246
              unit ()
              let Tu111 : UNIT =
                let Ti1247 : INT =
                  int 0
                in
                tmin.(Ti1247) <- t
              in
              let Tu110 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu109 : UNIT =
                let Ti1248 : INT =
                  int 0
                in
                intersected_object_id.(Ti1248) <- iobj
              in
              let Ti1249 : INT =
                int 0
              in
              intsec_rectside.(Ti1249) <- t0
      in
      let Ti1251 : INT =
        let Ti1250 : INT =
          int 1
        in
        add iand_ofs Ti1250
      in
      app
        solve_each_element
        Ti1251
        and_group
        dirvec
in
letrec solve_one_or_network : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : Array of FLOAT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1208 : INT =
    let Ti1207 : INT =
      int 1
    in
    neg Ti1207
  in
  if head == Ti1208
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu113 : UNIT =
      let Ti1209 : INT =
        int 0
      in
      app
        solve_each_element
        Ti1209
        and_group
        dirvec
    in
    let Ti1211 : INT =
      let Ti1210 : INT =
        int 1
      in
      add ofs Ti1210
    in
    app
      solve_one_or_network
      Ti1211
      or_group
      dirvec
in
letrec trace_or_matrix : (INT -> (Array of Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : Array of FLOAT)
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1193 : INT =
      int 0
    in
    head.(Ti1193)
  in
  let Ti1195 : INT =
    let Ti1194 : INT =
      int 1
    in
    neg Ti1194
  in
  if range_primitive == Ti1195
    unit ()
    let Tu114 : UNIT =
      let Ti1196 : INT =
        int 99
      in
      if range_primitive == Ti1196
        let Ti1197 : INT =
          int 1
        in
        app
          solve_one_or_network
          Ti1197
          head
          dirvec
        let t : INT =
          app
            solver
            range_primitive
            dirvec
            startp
        in
        let Ti1198 : INT =
          int 0
        in
        if t == Ti1198
          unit ()
          let tp : FLOAT =
            let Ti1199 : INT =
              int 0
            in
            solver_dist.(Ti1199)
          in
          let Tb1202 : BOOL =
            let Td1201 : FLOAT =
              let Ti1200 : INT =
                int 0
              in
              tmin.(Ti1200)
            in
            app
              fless
              tp
              Td1201
          in
          let Ti1203 : INT =
            int 0
          in
          if Tb1202 == Ti1203
            unit ()
            let Ti1204 : INT =
              int 1
            in
            app
              solve_one_or_network
              Ti1204
              head
              dirvec
    in
    let Ti1206 : INT =
      let Ti1205 : INT =
        int 1
      in
      add ofs Ti1205
    in
    app
      trace_or_matrix
      Ti1206
      or_network
      dirvec
in
letrec judge_intersection : (Array of FLOAT -> BOOL) =
variables : (dirvec : Array of FLOAT)
  let Tu116 : UNIT =
    let Ti1183 : INT =
      int 0
    in
    let Td1184 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1183) <- Td1184
  in
  let Tu115 : UNIT =
    let Ti1185 : INT =
      int 0
    in
    let Ta1187 : Array of Array of INT =
      let Ti1186 : INT =
        int 0
      in
      or_net.(Ti1186)
    in
    app
      trace_or_matrix
      Ti1185
      Ta1187
      dirvec
  in
  let t : FLOAT =
    let Ti1188 : INT =
      int 0
    in
    tmin.(Ti1188)
  in
  let Tb1190 : BOOL =
    let Td1189 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1189
      t
  in
  let Ti1191 : INT =
    int 0
  in
  if Tb1190 == Ti1191
    int 0
    let Td1192 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1192
in
letrec solve_each_element_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let vec : Array of FLOAT =
    app
      d_vec
      dirvec
  in
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1144 : INT =
    let Ti1143 : INT =
      int 1
    in
    neg Ti1143
  in
  if iobj == Ti1144
    unit ()
    let t0 : INT =
      app
        solver_fast2
        iobj
        dirvec
    in
    let Ti1145 : INT =
      int 0
    in
    if t0 == Ti1145
      let Tb1147 : BOOL =
        let Tt1146 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1146
      in
      let Ti1148 : INT =
        int 0
      in
      if Tb1147 == Ti1148
        unit ()
        let Ti1150 : INT =
          let Ti1149 : INT =
            int 1
          in
          add iand_ofs Ti1149
        in
        app
          solve_each_element_fast
          Ti1150
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1151 : INT =
          int 0
        in
        solver_dist.(Ti1151)
      in
      let Tu120 : UNIT =
        let Tb1153 : BOOL =
          let Td1152 : FLOAT =
            float 0.
          in
          app
            fless
            Td1152
            t0p
        in
        let Ti1154 : INT =
          int 0
        in
        if Tb1153 == Ti1154
          unit ()
          let Tb1157 : BOOL =
            let Td1156 : FLOAT =
              let Ti1155 : INT =
                int 0
              in
              tmin.(Ti1155)
            in
            app
              fless
              t0p
              Td1156
          in
          let Ti1158 : INT =
            int 0
          in
          if Tb1157 == Ti1158
            unit ()
            let t : FLOAT =
              let Td1159 : FLOAT =
                float 0.01
              in
              fadd t0p Td1159
            in
            let q0 : FLOAT =
              let Td1162 : FLOAT =
                let Td1161 : FLOAT =
                  let Ti1160 : INT =
                    int 0
                  in
                  vec.(Ti1160)
                in
                fmul Td1161 t
              in
              let Td1164 : FLOAT =
                let Ti1163 : INT =
                  int 0
                in
                startp_fast.(Ti1163)
              in
              fadd Td1162 Td1164
            in
            let q1 : FLOAT =
              let Td1167 : FLOAT =
                let Td1166 : FLOAT =
                  let Ti1165 : INT =
                    int 1
                  in
                  vec.(Ti1165)
                in
                fmul Td1166 t
              in
              let Td1169 : FLOAT =
                let Ti1168 : INT =
                  int 1
                in
                startp_fast.(Ti1168)
              in
              fadd Td1167 Td1169
            in
            let q2 : FLOAT =
              let Td1172 : FLOAT =
                let Td1171 : FLOAT =
                  let Ti1170 : INT =
                    int 2
                  in
                  vec.(Ti1170)
                in
                fmul Td1171 t
              in
              let Td1174 : FLOAT =
                let Ti1173 : INT =
                  int 2
                in
                startp_fast.(Ti1173)
              in
              fadd Td1172 Td1174
            in
            let Tb1176 : BOOL =
              let Ti1175 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1175
                and_group
                q0
                q1
                q2
            in
            let Ti1177 : INT =
              int 0
            in
            if Tb1176 == Ti1177
              unit ()
              let Tu119 : UNIT =
                let Ti1178 : INT =
                  int 0
                in
                tmin.(Ti1178) <- t
              in
              let Tu118 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu117 : UNIT =
                let Ti1179 : INT =
                  int 0
                in
                intersected_object_id.(Ti1179) <- iobj
              in
              let Ti1180 : INT =
                int 0
              in
              intsec_rectside.(Ti1180) <- t0
      in
      let Ti1182 : INT =
        let Ti1181 : INT =
          int 1
        in
        add iand_ofs Ti1181
      in
      app
        solve_each_element_fast
        Ti1182
        and_group
        dirvec
in
letrec solve_one_or_network_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : INT =
    or_group.(ofs)
  in
  let Ti1139 : INT =
    let Ti1138 : INT =
      int 1
    in
    neg Ti1138
  in
  if head == Ti1139
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu121 : UNIT =
      let Ti1140 : INT =
        int 0
      in
      app
        solve_each_element_fast
        Ti1140
        and_group
        dirvec
    in
    let Ti1142 : INT =
      let Ti1141 : INT =
        int 1
      in
      add ofs Ti1141
    in
    app
      solve_one_or_network_fast
      Ti1142
      or_group
      dirvec
in
letrec trace_or_matrix_fast : (INT -> (Array of Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1124 : INT =
      int 0
    in
    head.(Ti1124)
  in
  let Ti1126 : INT =
    let Ti1125 : INT =
      int 1
    in
    neg Ti1125
  in
  if range_primitive == Ti1126
    unit ()
    let Tu122 : UNIT =
      let Ti1127 : INT =
        int 99
      in
      if range_primitive == Ti1127
        let Ti1128 : INT =
          int 1
        in
        app
          solve_one_or_network_fast
          Ti1128
          head
          dirvec
        let t : INT =
          app
            solver_fast2
            range_primitive
            dirvec
        in
        let Ti1129 : INT =
          int 0
        in
        if t == Ti1129
          unit ()
          let tp : FLOAT =
            let Ti1130 : INT =
              int 0
            in
            solver_dist.(Ti1130)
          in
          let Tb1133 : BOOL =
            let Td1132 : FLOAT =
              let Ti1131 : INT =
                int 0
              in
              tmin.(Ti1131)
            in
            app
              fless
              tp
              Td1132
          in
          let Ti1134 : INT =
            int 0
          in
          if Tb1133 == Ti1134
            unit ()
            let Ti1135 : INT =
              int 1
            in
            app
              solve_one_or_network_fast
              Ti1135
              head
              dirvec
    in
    let Ti1137 : INT =
      let Ti1136 : INT =
        int 1
      in
      add ofs Ti1136
    in
    app
      trace_or_matrix_fast
      Ti1137
      or_network
      dirvec
in
letrec judge_intersection_fast : ((Array of FLOAT * Array of Array of FLOAT) -> BOOL) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Tu124 : UNIT =
    let Ti1114 : INT =
      int 0
    in
    let Td1115 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1114) <- Td1115
  in
  let Tu123 : UNIT =
    let Ti1116 : INT =
      int 0
    in
    let Ta1118 : Array of Array of INT =
      let Ti1117 : INT =
        int 0
      in
      or_net.(Ti1117)
    in
    app
      trace_or_matrix_fast
      Ti1116
      Ta1118
      dirvec
  in
  let t : FLOAT =
    let Ti1119 : INT =
      int 0
    in
    tmin.(Ti1119)
  in
  let Tb1121 : BOOL =
    let Td1120 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1120
      t
  in
  let Ti1122 : INT =
    int 0
  in
  if Tb1121 == Ti1122
    int 0
    let Td1123 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1123
in
letrec get_nvector_rect : (Array of FLOAT -> UNIT) =
variables : (dirvec : Array of FLOAT)
  let rectside : INT =
    let Ti1106 : INT =
      int 0
    in
    intsec_rectside.(Ti1106)
  in
  let Tu125 : UNIT =
    app
      vecbzero
      nvector
  in
  let Ti1108 : INT =
    let Ti1107 : INT =
      int 1
    in
    sub rectside Ti1107
  in
  let Td1113 : FLOAT =
    let Td1112 : FLOAT =
      let Td1111 : FLOAT =
        let Ti1110 : INT =
          let Ti1109 : INT =
            int 1
          in
          sub rectside Ti1109
        in
        dirvec.(Ti1110)
      in
      app
        sgn
        Td1111
    in
    app
      fneg
      Td1112
  in
  nvector.(Ti1108) <- Td1113
in
letrec get_nvector_plane : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let Tu127 : UNIT =
    let Ti1097 : INT =
      int 0
    in
    let Td1099 : FLOAT =
      let Td1098 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fneg
        Td1098
    in
    nvector.(Ti1097) <- Td1099
  in
  let Tu126 : UNIT =
    let Ti1100 : INT =
      int 1
    in
    let Td1102 : FLOAT =
      let Td1101 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fneg
        Td1101
    in
    nvector.(Ti1100) <- Td1102
  in
  let Ti1103 : INT =
    int 2
  in
  let Td1105 : FLOAT =
    let Td1104 : FLOAT =
      app
        o_param_c
        m
    in
    app
      fneg
      Td1104
  in
  nvector.(Ti1103) <- Td1105
in
letrec get_nvector_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let p0 : FLOAT =
    let Td1056 : FLOAT =
      let Ti1055 : INT =
        int 0
      in
      intersection_point.(Ti1055)
    in
    let Td1057 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1056 Td1057
  in
  let p1 : FLOAT =
    let Td1059 : FLOAT =
      let Ti1058 : INT =
        int 1
      in
      intersection_point.(Ti1058)
    in
    let Td1060 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1059 Td1060
  in
  let p2 : FLOAT =
    let Td1062 : FLOAT =
      let Ti1061 : INT =
        int 2
      in
      intersection_point.(Ti1061)
    in
    let Td1063 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1062 Td1063
  in
  let d0 : FLOAT =
    let Td1064 : FLOAT =
      app
        o_param_a
        m
    in
    fmul p0 Td1064
  in
  let d1 : FLOAT =
    let Td1065 : FLOAT =
      app
        o_param_b
        m
    in
    fmul p1 Td1065
  in
  let d2 : FLOAT =
    let Td1066 : FLOAT =
      app
        o_param_c
        m
    in
    fmul p2 Td1066
  in
  let Tu132 : UNIT =
    let Ti1067 : INT =
      app
        o_isrot
        m
    in
    let Ti1068 : INT =
      int 0
    in
    if Ti1067 == Ti1068
      let Tu129 : UNIT =
        let Ti1069 : INT =
          int 0
        in
        nvector.(Ti1069) <- d0
      in
      let Tu128 : UNIT =
        let Ti1070 : INT =
          int 1
        in
        nvector.(Ti1070) <- d1
      in
      let Ti1071 : INT =
        int 2
      in
      nvector.(Ti1071) <- d2
      let Tu131 : UNIT =
        let Ti1072 : INT =
          int 0
        in
        let Td1079 : FLOAT =
          let Td1078 : FLOAT =
            let Td1077 : FLOAT =
              let Td1074 : FLOAT =
                let Td1073 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p1 Td1073
              in
              let Td1076 : FLOAT =
                let Td1075 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul p2 Td1075
              in
              fadd Td1074 Td1076
            in
            app
              fhalf
              Td1077
          in
          fadd d0 Td1078
        in
        nvector.(Ti1072) <- Td1079
      in
      let Tu130 : UNIT =
        let Ti1080 : INT =
          int 1
        in
        let Td1087 : FLOAT =
          let Td1086 : FLOAT =
            let Td1085 : FLOAT =
              let Td1082 : FLOAT =
                let Td1081 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p0 Td1081
              in
              let Td1084 : FLOAT =
                let Td1083 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul p2 Td1083
              in
              fadd Td1082 Td1084
            in
            app
              fhalf
              Td1085
          in
          fadd d1 Td1086
        in
        nvector.(Ti1080) <- Td1087
      in
      let Ti1088 : INT =
        int 2
      in
      let Td1095 : FLOAT =
        let Td1094 : FLOAT =
          let Td1093 : FLOAT =
            let Td1090 : FLOAT =
              let Td1089 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul p0 Td1089
            in
            let Td1092 : FLOAT =
              let Td1091 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul p1 Td1091
            in
            fadd Td1090 Td1092
          in
          app
            fhalf
            Td1093
        in
        fadd d2 Td1094
      in
      nvector.(Ti1088) <- Td1095
  in
  let Tb1096 : BOOL =
    app
      o_isinvert
      m
  in
  app
    vecunit_sgn
    nvector
    Tb1096
in
letrec get_nvector : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT)
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1053 : INT =
    int 1
  in
  if m_shape == Ti1053
    app
      get_nvector_rect
      dirvec
    let Ti1054 : INT =
      int 2
    in
    if m_shape == Ti1054
      app
        get_nvector_plane
        m
      app
        get_nvector_second
        m
in
letrec utexture : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p : Array of FLOAT)
  let m_tex : INT =
    app
      o_texturetype
      m
  in
  let Tu137 : UNIT =
    let Ti929 : INT =
      int 0
    in
    let Td930 : FLOAT =
      app
        o_color_red
        m
    in
    texture_color.(Ti929) <- Td930
  in
  let Tu136 : UNIT =
    let Ti931 : INT =
      int 1
    in
    let Td932 : FLOAT =
      app
        o_color_green
        m
    in
    texture_color.(Ti931) <- Td932
  in
  let Tu135 : UNIT =
    let Ti933 : INT =
      int 2
    in
    let Td934 : FLOAT =
      app
        o_color_blue
        m
    in
    texture_color.(Ti933) <- Td934
  in
  let Ti935 : INT =
    int 1
  in
  if m_tex == Ti935
    let w1 : FLOAT =
      let Td937 : FLOAT =
        let Ti936 : INT =
          int 0
        in
        p.(Ti936)
      in
      let Td938 : FLOAT =
        app
          o_param_x
          m
      in
      fsub Td937 Td938
    in
    let flag1 : BOOL =
      let d1 : FLOAT =
        let Td941 : FLOAT =
          let Td940 : FLOAT =
            let Td939 : FLOAT =
              float 0.05
            in
            fmul w1 Td939
          in
          app
            floor
            Td940
        in
        let Td942 : FLOAT =
          float 20.
        in
        fmul Td941 Td942
      in
      let Td943 : FLOAT =
        fsub w1 d1
      in
      let Td944 : FLOAT =
        float 10.
      in
      app
        fless
        Td943
        Td944
    in
    let w3 : FLOAT =
      let Td946 : FLOAT =
        let Ti945 : INT =
          int 2
        in
        p.(Ti945)
      in
      let Td947 : FLOAT =
        app
          o_param_z
          m
      in
      fsub Td946 Td947
    in
    let flag2 : BOOL =
      let d2 : FLOAT =
        let Td950 : FLOAT =
          let Td949 : FLOAT =
            let Td948 : FLOAT =
              float 0.05
            in
            fmul w3 Td948
          in
          app
            floor
            Td949
        in
        let Td951 : FLOAT =
          float 20.
        in
        fmul Td950 Td951
      in
      let Td952 : FLOAT =
        fsub w3 d2
      in
      let Td953 : FLOAT =
        float 10.
      in
      app
        fless
        Td952
        Td953
    in
    let Ti954 : INT =
      int 1
    in
    let Td958 : FLOAT =
      let Ti955 : INT =
        int 0
      in
      if flag1 == Ti955
        let Ti956 : INT =
          int 0
        in
        if flag2 == Ti956
          float 255.
          float 0.
        let Ti957 : INT =
          int 0
        in
        if flag2 == Ti957
          float 0.
          float 255.
    in
    texture_color.(Ti954) <- Td958
    let Ti959 : INT =
      int 2
    in
    if m_tex == Ti959
      let w2 : FLOAT =
        let Td964 : FLOAT =
          let Td963 : FLOAT =
            let Td961 : FLOAT =
              let Ti960 : INT =
                int 1
              in
              p.(Ti960)
            in
            let Td962 : FLOAT =
              float 0.25
            in
            fmul Td961 Td962
          in
          extfunapp
            sin
            Td963
        in
        app
          fsqr
          Td964
      in
      let Tu133 : UNIT =
        let Ti965 : INT =
          int 0
        in
        let Td967 : FLOAT =
          let Td966 : FLOAT =
            float 255.
          in
          fmul Td966 w2
        in
        texture_color.(Ti965) <- Td967
      in
      let Ti968 : INT =
        int 1
      in
      let Td972 : FLOAT =
        let Td969 : FLOAT =
          float 255.
        in
        let Td971 : FLOAT =
          let Td970 : FLOAT =
            float 1.
          in
          fsub Td970 w2
        in
        fmul Td969 Td971
      in
      texture_color.(Ti968) <- Td972
      let Ti973 : INT =
        int 3
      in
      if m_tex == Ti973
        let w1 : FLOAT =
          let Td975 : FLOAT =
            let Ti974 : INT =
              int 0
            in
            p.(Ti974)
          in
          let Td976 : FLOAT =
            app
              o_param_x
              m
          in
          fsub Td975 Td976
        in
        let w3 : FLOAT =
          let Td978 : FLOAT =
            let Ti977 : INT =
              int 2
            in
            p.(Ti977)
          in
          let Td979 : FLOAT =
            app
              o_param_z
              m
          in
          fsub Td978 Td979
        in
        let w2 : FLOAT =
          let Td983 : FLOAT =
            let Td982 : FLOAT =
              let Td980 : FLOAT =
                app
                  fsqr
                  w1
              in
              let Td981 : FLOAT =
                app
                  fsqr
                  w3
              in
              fadd Td980 Td981
            in
            app
              sqrt
              Td982
          in
          let Td984 : FLOAT =
            float 10.
          in
          fdiv Td983 Td984
        in
        let w4 : FLOAT =
          let Td986 : FLOAT =
            let Td985 : FLOAT =
              app
                floor
                w2
            in
            fsub w2 Td985
          in
          let Td987 : FLOAT =
            float 3.1415927
          in
          fmul Td986 Td987
        in
        let cws : FLOAT =
          let Td988 : FLOAT =
            extfunapp
              cos
              w4
          in
          app
            fsqr
            Td988
        in
        let Tu134 : UNIT =
          let Ti989 : INT =
            int 1
          in
          let Td991 : FLOAT =
            let Td990 : FLOAT =
              float 255.
            in
            fmul cws Td990
          in
          texture_color.(Ti989) <- Td991
        in
        let Ti992 : INT =
          int 2
        in
        let Td996 : FLOAT =
          let Td994 : FLOAT =
            let Td993 : FLOAT =
              float 1.
            in
            fsub Td993 cws
          in
          let Td995 : FLOAT =
            float 255.
          in
          fmul Td994 Td995
        in
        texture_color.(Ti992) <- Td996
        let Ti997 : INT =
          int 4
        in
        if m_tex == Ti997
          let w1 : FLOAT =
            let Td1001 : FLOAT =
              let Td999 : FLOAT =
                let Ti998 : INT =
                  int 0
                in
                p.(Ti998)
              in
              let Td1000 : FLOAT =
                app
                  o_param_x
                  m
              in
              fsub Td999 Td1000
            in
            let Td1003 : FLOAT =
              let Td1002 : FLOAT =
                app
                  o_param_a
                  m
              in
              app
                sqrt
                Td1002
            in
            fmul Td1001 Td1003
          in
          let w3 : FLOAT =
            let Td1007 : FLOAT =
              let Td1005 : FLOAT =
                let Ti1004 : INT =
                  int 2
                in
                p.(Ti1004)
              in
              let Td1006 : FLOAT =
                app
                  o_param_z
                  m
              in
              fsub Td1005 Td1006
            in
            let Td1009 : FLOAT =
              let Td1008 : FLOAT =
                app
                  o_param_c
                  m
              in
              app
                sqrt
                Td1008
            in
            fmul Td1007 Td1009
          in
          let w4 : FLOAT =
            let Td1010 : FLOAT =
              app
                fsqr
                w1
            in
            let Td1011 : FLOAT =
              app
                fsqr
                w3
            in
            fadd Td1010 Td1011
          in
          let w7 : FLOAT =
            let Tb1014 : BOOL =
              let Td1012 : FLOAT =
                app
                  fabs
                  w1
              in
              let Td1013 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1012
                Td1013
            in
            let Ti1015 : INT =
              int 0
            in
            if Tb1014 == Ti1015
              let w5 : FLOAT =
                let Td1016 : FLOAT =
                  fdiv w3 w1
                in
                app
                  fabs
                  Td1016
              in
              let Td1019 : FLOAT =
                let Td1017 : FLOAT =
                  app
                    atan
                    w5
                in
                let Td1018 : FLOAT =
                  float 30.
                in
                fmul Td1017 Td1018
              in
              let Td1020 : FLOAT =
                float 3.1415927
              in
              fdiv Td1019 Td1020
              float 15.
          in
          let w9 : FLOAT =
            let Td1021 : FLOAT =
              app
                floor
                w7
            in
            fsub w7 Td1021
          in
          let w2 : FLOAT =
            let Td1025 : FLOAT =
              let Td1023 : FLOAT =
                let Ti1022 : INT =
                  int 1
                in
                p.(Ti1022)
              in
              let Td1024 : FLOAT =
                app
                  o_param_y
                  m
              in
              fsub Td1023 Td1024
            in
            let Td1027 : FLOAT =
              let Td1026 : FLOAT =
                app
                  o_param_b
                  m
              in
              app
                sqrt
                Td1026
            in
            fmul Td1025 Td1027
          in
          let w8 : FLOAT =
            let Tb1030 : BOOL =
              let Td1028 : FLOAT =
                app
                  fabs
                  w4
              in
              let Td1029 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1028
                Td1029
            in
            let Ti1031 : INT =
              int 0
            in
            if Tb1030 == Ti1031
              let w6 : FLOAT =
                let Td1032 : FLOAT =
                  fdiv w2 w4
                in
                app
                  fabs
                  Td1032
              in
              let Td1035 : FLOAT =
                let Td1033 : FLOAT =
                  app
                    atan
                    w6
                in
                let Td1034 : FLOAT =
                  float 30.
                in
                fmul Td1033 Td1034
              in
              let Td1036 : FLOAT =
                float 3.1415927
              in
              fdiv Td1035 Td1036
              float 15.
          in
          let w10 : FLOAT =
            let Td1037 : FLOAT =
              app
                floor
                w8
            in
            fsub w8 Td1037
          in
          let w11 : FLOAT =
            let Td1042 : FLOAT =
              let Td1038 : FLOAT =
                float 0.15
              in
              let Td1041 : FLOAT =
                let Td1040 : FLOAT =
                  let Td1039 : FLOAT =
                    float 0.5
                  in
                  fsub Td1039 w9
                in
                app
                  fsqr
                  Td1040
              in
              fsub Td1038 Td1041
            in
            let Td1045 : FLOAT =
              let Td1044 : FLOAT =
                let Td1043 : FLOAT =
                  float 0.5
                in
                fsub Td1043 w10
              in
              app
                fsqr
                Td1044
            in
            fsub Td1042 Td1045
          in
          let w12 : FLOAT =
            let Tb1046 : BOOL =
              app
                fisneg
                w11
            in
            let Ti1047 : INT =
              int 0
            in
            if Tb1046 == Ti1047
              w11
              float 0.
          in
          let Ti1048 : INT =
            int 2
          in
          let Td1052 : FLOAT =
            let Td1050 : FLOAT =
              let Td1049 : FLOAT =
                float 255.
              in
              fmul Td1049 w12
            in
            let Td1051 : FLOAT =
              float 0.3
            in
            fdiv Td1050 Td1051
          in
          texture_color.(Ti1048) <- Td1052
          unit ()
in
letrec add_light : (FLOAT -> (FLOAT -> (FLOAT -> UNIT))) =
variables : (bright : FLOAT), (hilight : FLOAT), (hilight_scale : FLOAT)
  let Tu140 : UNIT =
    let Tb911 : BOOL =
      app
        fispos
        bright
    in
    let Ti912 : INT =
      int 0
    in
    if Tb911 == Ti912
      unit ()
      app
        vecaccum
        rgb
        bright
        texture_color
  in
  let Tb913 : BOOL =
    app
      fispos
      hilight
  in
  let Ti914 : INT =
    int 0
  in
  if Tb913 == Ti914
    unit ()
    let ihl : FLOAT =
      let Td916 : FLOAT =
        let Td915 : FLOAT =
          app
            fsqr
            hilight
        in
        app
          fsqr
          Td915
      in
      fmul Td916 hilight_scale
    in
    let Tu139 : UNIT =
      let Ti917 : INT =
        int 0
      in
      let Td920 : FLOAT =
        let Td919 : FLOAT =
          let Ti918 : INT =
            int 0
          in
          rgb.(Ti918)
        in
        fadd Td919 ihl
      in
      rgb.(Ti917) <- Td920
    in
    let Tu138 : UNIT =
      let Ti921 : INT =
        int 1
      in
      let Td924 : FLOAT =
        let Td923 : FLOAT =
          let Ti922 : INT =
            int 1
          in
          rgb.(Ti922)
        in
        fadd Td923 ihl
      in
      rgb.(Ti921) <- Td924
    in
    let Ti925 : INT =
      int 2
    in
    let Td928 : FLOAT =
      let Td927 : FLOAT =
        let Ti926 : INT =
          int 2
        in
        rgb.(Ti926)
      in
      fadd Td927 ihl
    in
    rgb.(Ti925) <- Td928
in
letrec trace_reflections : (INT -> (FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT)))) =
variables : (index : INT), (diffuse : FLOAT), (hilight_scale : FLOAT), (dirvec : Array of FLOAT)
  let Ti891 : INT =
    int 0
  in
  if Ti891 <= index
    let rinfo : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
      reflections.(index)
    in
    let dvec : (Array of FLOAT * Array of Array of FLOAT) =
      app
        r_dvec
        rinfo
    in
    let Tu141 : UNIT =
      let Tb892 : BOOL =
        app
          judge_intersection_fast
          dvec
      in
      let Ti893 : INT =
        int 0
      in
      if Tb892 == Ti893
        unit ()
        let surface_id : INT =
          let Ti896 : INT =
            let Ti895 : INT =
              let Ti894 : INT =
                int 0
              in
              intersected_object_id.(Ti894)
            in
            mul Ti895 4
          in
          let Ti898 : INT =
            let Ti897 : INT =
              int 0
            in
            intsec_rectside.(Ti897)
          in
          add Ti896 Ti898
        in
        let Ti899 : INT =
          app
            r_surface_id
            rinfo
        in
        if surface_id == Ti899
          let Tb903 : BOOL =
            let Ti900 : INT =
              int 0
            in
            let Ta902 : Array of Array of INT =
              let Ti901 : INT =
                int 0
              in
              or_net.(Ti901)
            in
            app
              shadow_check_one_or_matrix
              Ti900
              Ta902
          in
          let Ti904 : INT =
            int 0
          in
          if Tb903 == Ti904
            let p : FLOAT =
              let Ta905 : Array of FLOAT =
                app
                  d_vec
                  dvec
              in
              app
                veciprod
                nvector
                Ta905
            in
            let scale : FLOAT =
              app
                r_bright
                rinfo
            in
            let bright : FLOAT =
              let Td906 : FLOAT =
                fmul scale diffuse
              in
              fmul Td906 p
            in
            let hilight : FLOAT =
              let Td908 : FLOAT =
                let Ta907 : Array of FLOAT =
                  app
                    d_vec
                    dvec
                in
                app
                  veciprod
                  dirvec
                  Ta907
              in
              fmul scale Td908
            in
            app
              add_light
              bright
              hilight
              hilight_scale
            unit ()
          unit ()
    in
    let Ti910 : INT =
      let Ti909 : INT =
        int 1
      in
      sub index Ti909
    in
    app
      trace_reflections
      Ti910
      diffuse
      hilight_scale
      dirvec
    unit ()
in
letrec trace_ray : (INT -> (FLOAT -> (Array of FLOAT -> ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (FLOAT -> UNIT))))) =
variables : (nref : INT), (energy : FLOAT), (dirvec : Array of FLOAT), (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (dist : FLOAT)
  let Ti813 : INT =
    int 4
  in
  if nref <= Ti813
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Tb814 : BOOL =
      app
        judge_intersection
        dirvec
    in
    let Ti815 : INT =
      int 0
    in
    if Tb814 == Ti815
      let Tu158 : UNIT =
        let Ti817 : INT =
          let Ti816 : INT =
            int 1
          in
          neg Ti816
        in
        surface_ids.(nref) <- Ti817
      in
      let Ti818 : INT =
        int 0
      in
      if nref == Ti818
        unit ()
        let hl : FLOAT =
          let Td819 : FLOAT =
            app
              veciprod
              dirvec
              light
          in
          app
            fneg
            Td819
        in
        let Tb820 : BOOL =
          app
            fispos
            hl
        in
        let Ti821 : INT =
          int 0
        in
        if Tb820 == Ti821
          unit ()
          let ihl : FLOAT =
            let Td824 : FLOAT =
              let Td823 : FLOAT =
                let Td822 : FLOAT =
                  app
                    fsqr
                    hl
                in
                fmul Td822 hl
              in
              fmul Td823 energy
            in
            let Td826 : FLOAT =
              let Ti825 : INT =
                int 0
              in
              beam.(Ti825)
            in
            fmul Td824 Td826
          in
          let Tu157 : UNIT =
            let Ti827 : INT =
              int 0
            in
            let Td830 : FLOAT =
              let Td829 : FLOAT =
                let Ti828 : INT =
                  int 0
                in
                rgb.(Ti828)
              in
              fadd Td829 ihl
            in
            rgb.(Ti827) <- Td830
          in
          let Tu156 : UNIT =
            let Ti831 : INT =
              int 1
            in
            let Td834 : FLOAT =
              let Td833 : FLOAT =
                let Ti832 : INT =
                  int 1
                in
                rgb.(Ti832)
              in
              fadd Td833 ihl
            in
            rgb.(Ti831) <- Td834
          in
          let Ti835 : INT =
            int 2
          in
          let Td838 : FLOAT =
            let Td837 : FLOAT =
              let Ti836 : INT =
                int 2
              in
              rgb.(Ti836)
            in
            fadd Td837 ihl
          in
          rgb.(Ti835) <- Td838
      let obj_id : INT =
        let Ti839 : INT =
          int 0
        in
        intersected_object_id.(Ti839)
      in
      let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(obj_id)
      in
      let m_surface : INT =
        app
          o_reflectiontype
          obj
      in
      let diffuse : FLOAT =
        let Td840 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td840 energy
      in
      let Tu155 : UNIT =
        app
          get_nvector
          obj
          dirvec
      in
      let Tu154 : UNIT =
        app
          veccpy
          startp
          intersection_point
      in
      let Tu153 : UNIT =
        app
          utexture
          obj
          intersection_point
      in
      let Tu152 : UNIT =
        let Ti844 : INT =
          let Ti841 : INT =
            mul obj_id 4
          in
          let Ti843 : INT =
            let Ti842 : INT =
              int 0
            in
            intsec_rectside.(Ti842)
          in
          add Ti841 Ti843
        in
        surface_ids.(nref) <- Ti844
      in
      let intersection_points : Array of Array of FLOAT =
        app
          p_intersection_points
          pixel
      in
      let Tu151 : UNIT =
        let Ta845 : Array of FLOAT =
          intersection_points.(nref)
        in
        app
          veccpy
          Ta845
          intersection_point
      in
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu150 : UNIT =
        let Tb848 : BOOL =
          let Td846 : FLOAT =
            app
              o_diffuse
              obj
          in
          let Td847 : FLOAT =
            float 0.5
          in
          app
            fless
            Td846
            Td847
        in
        let Ti849 : INT =
          int 0
        in
        if Tb848 == Ti849
          let Tu144 : UNIT =
            let Ti850 : INT =
              int 1
            in
            calc_diffuse.(nref) <- Ti850
          in
          let energya : Array of Array of FLOAT =
            app
              p_energy
              pixel
          in
          let Tu143 : UNIT =
            let Ta851 : Array of FLOAT =
              energya.(nref)
            in
            app
              veccpy
              Ta851
              texture_color
          in
          let Tu142 : UNIT =
            let Ta852 : Array of FLOAT =
              energya.(nref)
            in
            let Td856 : FLOAT =
              let Td855 : FLOAT =
                let Td853 : FLOAT =
                  float 1.
                in
                let Td854 : FLOAT =
                  float 256.
                in
                fdiv Td853 Td854
              in
              fmul Td855 diffuse
            in
            app
              vecscale
              Ta852
              Td856
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let Ta857 : Array of FLOAT =
            nvectors.(nref)
          in
          app
            veccpy
            Ta857
            nvector
          let Ti858 : INT =
            int 0
          in
          calc_diffuse.(nref) <- Ti858
      in
      let w : FLOAT =
        let Td859 : FLOAT =
          float -2.
        in
        let Td860 : FLOAT =
          app
            veciprod
            dirvec
            nvector
        in
        fmul Td859 Td860
      in
      let Tu149 : UNIT =
        app
          vecaccum
          dirvec
          w
          nvector
      in
      let hilight_scale : FLOAT =
        let Td861 : FLOAT =
          app
            o_hilight
            obj
        in
        fmul energy Td861
      in
      let Tu148 : UNIT =
        let Tb865 : BOOL =
          let Ti862 : INT =
            int 0
          in
          let Ta864 : Array of Array of INT =
            let Ti863 : INT =
              int 0
            in
            or_net.(Ti863)
          in
          app
            shadow_check_one_or_matrix
            Ti862
            Ta864
        in
        let Ti866 : INT =
          int 0
        in
        if Tb865 == Ti866
          let bright : FLOAT =
            let Td868 : FLOAT =
              let Td867 : FLOAT =
                app
                  veciprod
                  nvector
                  light
              in
              app
                fneg
                Td867
            in
            fmul Td868 diffuse
          in
          let hilight : FLOAT =
            let Td869 : FLOAT =
              app
                veciprod
                dirvec
                light
            in
            app
              fneg
              Td869
          in
          app
            add_light
            bright
            hilight
            hilight_scale
          unit ()
      in
      let Tu147 : UNIT =
        app
          setup_startp
          intersection_point
      in
      let Tu146 : UNIT =
        let Ti873 : INT =
          let Ti871 : INT =
            let Ti870 : INT =
              int 0
            in
            n_reflections.(Ti870)
          in
          let Ti872 : INT =
            int 1
          in
          sub Ti871 Ti872
        in
        app
          trace_reflections
          Ti873
          diffuse
          hilight_scale
          dirvec
      in
      let Tb875 : BOOL =
        let Td874 : FLOAT =
          float 0.1
        in
        app
          fless
          Td874
          energy
      in
      let Ti876 : INT =
        int 0
      in
      if Tb875 == Ti876
        unit ()
        let Tu145 : UNIT =
          let Ti877 : INT =
            int 4
          in
          if Ti877 <= nref
            unit ()
            let Ti879 : INT =
              let Ti878 : INT =
                int 1
              in
              add nref Ti878
            in
            let Ti881 : INT =
              let Ti880 : INT =
                int 1
              in
              neg Ti880
            in
            surface_ids.(Ti879) <- Ti881
        in
        let Ti882 : INT =
          int 2
        in
        if m_surface == Ti882
          let energy2 : FLOAT =
            let Td885 : FLOAT =
              let Td883 : FLOAT =
                float 1.
              in
              let Td884 : FLOAT =
                app
                  o_diffuse
                  obj
              in
              fsub Td883 Td884
            in
            fmul energy Td885
          in
          let Ti887 : INT =
            let Ti886 : INT =
              int 1
            in
            add nref Ti886
          in
          let Td890 : FLOAT =
            let Td889 : FLOAT =
              let Ti888 : INT =
                int 0
              in
              tmin.(Ti888)
            in
            fadd dist Td889
          in
          app
            trace_ray
            Ti887
            energy2
            dirvec
            pixel
            Td890
          unit ()
    unit ()
in
letrec trace_diffuse_ray : ((Array of FLOAT * Array of Array of FLOAT) -> (FLOAT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (energy : FLOAT)
  let Tb797 : BOOL =
    app
      judge_intersection_fast
      dirvec
  in
  let Ti798 : INT =
    int 0
  in
  if Tb797 == Ti798
    unit ()
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      let Ti800 : INT =
        let Ti799 : INT =
          int 0
        in
        intersected_object_id.(Ti799)
      in
      objects.(Ti800)
    in
    let Tu160 : UNIT =
      let Ta801 : Array of FLOAT =
        app
          d_vec
          dirvec
      in
      app
        get_nvector
        obj
        Ta801
    in
    let Tu159 : UNIT =
      app
        utexture
        obj
        intersection_point
    in
    let Tb805 : BOOL =
      let Ti802 : INT =
        int 0
      in
      let Ta804 : Array of Array of INT =
        let Ti803 : INT =
          int 0
        in
        or_net.(Ti803)
      in
      app
        shadow_check_one_or_matrix
        Ti802
        Ta804
    in
    let Ti806 : INT =
      int 0
    in
    if Tb805 == Ti806
      let br : FLOAT =
        let Td807 : FLOAT =
          app
            veciprod
            nvector
            light
        in
        app
          fneg
          Td807
      in
      let bright : FLOAT =
        let Tb808 : BOOL =
          app
            fispos
            br
        in
        let Ti809 : INT =
          int 0
        in
        if Tb808 == Ti809
          float 0.
          br
      in
      let Td812 : FLOAT =
        let Td810 : FLOAT =
          fmul energy bright
        in
        let Td811 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td810 Td811
      in
      app
        vecaccum
        diffuse_ray
        Td812
        texture_color
      unit ()
in
letrec iter_trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (INT -> UNIT)))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT), (index : INT)
  let Ti782 : INT =
    int 0
  in
  if Ti782 <= index
    let p : FLOAT =
      let Ta784 : Array of FLOAT =
        let Tt783 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        app
          d_vec
          Tt783
      in
      app
        veciprod
        Ta784
        nvector
    in
    let Tu161 : UNIT =
      let Tb785 : BOOL =
        app
          fisneg
          p
      in
      let Ti786 : INT =
        int 0
      in
      if Tb785 == Ti786
        let Tt787 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        let Td789 : FLOAT =
          let Td788 : FLOAT =
            float 150.
          in
          fdiv p Td788
        in
        app
          trace_diffuse_ray
          Tt787
          Td789
        let Tt792 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti791 : INT =
            let Ti790 : INT =
              int 1
            in
            add index Ti790
          in
          dirvec_group.(Ti791)
        in
        let Td794 : FLOAT =
          let Td793 : FLOAT =
            float -150.
          in
          fdiv p Td793
        in
        app
          trace_diffuse_ray
          Tt792
          Td794
    in
    let Ti796 : INT =
      let Ti795 : INT =
        int 2
      in
      sub index Ti795
    in
    app
      iter_trace_diffuse_rays
      dirvec_group
      nvector
      org
      Ti796
    unit ()
in
letrec trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu162 : UNIT =
    app
      setup_startp
      org
  in
  let Ti781 : INT =
    int 118
  in
  app
    iter_trace_diffuse_rays
    dirvec_group
    nvector
    org
    Ti781
in
letrec trace_diffuse_ray_80percent : (INT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (group_id : INT), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu166 : UNIT =
    let Ti766 : INT =
      int 0
    in
    if group_id == Ti766
      unit ()
      let Ta768 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti767 : INT =
          int 0
        in
        dirvecs.(Ti767)
      in
      app
        trace_diffuse_rays
        Ta768
        nvector
        org
  in
  let Tu165 : UNIT =
    let Ti769 : INT =
      int 1
    in
    if group_id == Ti769
      unit ()
      let Ta771 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti770 : INT =
          int 1
        in
        dirvecs.(Ti770)
      in
      app
        trace_diffuse_rays
        Ta771
        nvector
        org
  in
  let Tu164 : UNIT =
    let Ti772 : INT =
      int 2
    in
    if group_id == Ti772
      unit ()
      let Ta774 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti773 : INT =
          int 2
        in
        dirvecs.(Ti773)
      in
      app
        trace_diffuse_rays
        Ta774
        nvector
        org
  in
  let Tu163 : UNIT =
    let Ti775 : INT =
      int 3
    in
    if group_id == Ti775
      unit ()
      let Ta777 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti776 : INT =
          int 3
        in
        dirvecs.(Ti776)
      in
      app
        trace_diffuse_rays
        Ta777
        nvector
        org
  in
  let Ti778 : INT =
    int 4
  in
  if group_id == Ti778
    unit ()
    let Ta780 : Array of (Array of FLOAT * Array of Array of FLOAT) =
      let Ti779 : INT =
        int 4
      in
      dirvecs.(Ti779)
    in
    app
      trace_diffuse_rays
      Ta780
      nvector
      org
in
letrec calc_diffuse_using_1point : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let ray20p : Array of Array of FLOAT =
    app
      p_received_ray_20percent
      pixel
  in
  let nvectors : Array of Array of FLOAT =
    app
      p_nvectors
      pixel
  in
  let intersection_points : Array of Array of FLOAT =
    app
      p_intersection_points
      pixel
  in
  let energya : Array of Array of FLOAT =
    app
      p_energy
      pixel
  in
  let Tu168 : UNIT =
    let Ta761 : Array of FLOAT =
      ray20p.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta761
  in
  let Tu167 : UNIT =
    let Ti762 : INT =
      app
        p_group_id
        pixel
    in
    let Ta763 : Array of FLOAT =
      nvectors.(nref)
    in
    let Ta764 : Array of FLOAT =
      intersection_points.(nref)
    in
    app
      trace_diffuse_ray_80percent
      Ti762
      Ta763
      Ta764
  in
  let Ta765 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta765
    diffuse_ray
in
letrec calc_diffuse_using_5points : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let r_up : Array of Array of FLOAT =
    let Tt745 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      p_received_ray_20percent
      Tt745
  in
  let r_left : Array of Array of FLOAT =
    let Tt748 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti747 : INT =
        let Ti746 : INT =
          int 1
        in
        sub x Ti746
      in
      cur.(Ti747)
    in
    app
      p_received_ray_20percent
      Tt748
  in
  let r_center : Array of Array of FLOAT =
    let Tt749 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_received_ray_20percent
      Tt749
  in
  let r_right : Array of Array of FLOAT =
    let Tt752 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti751 : INT =
        let Ti750 : INT =
          int 1
        in
        add x Ti750
      in
      cur.(Ti751)
    in
    app
      p_received_ray_20percent
      Tt752
  in
  let r_down : Array of Array of FLOAT =
    let Tt753 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      next.(x)
    in
    app
      p_received_ray_20percent
      Tt753
  in
  let Tu173 : UNIT =
    let Ta754 : Array of FLOAT =
      r_up.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta754
  in
  let Tu172 : UNIT =
    let Ta755 : Array of FLOAT =
      r_left.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta755
  in
  let Tu171 : UNIT =
    let Ta756 : Array of FLOAT =
      r_center.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta756
  in
  let Tu170 : UNIT =
    let Ta757 : Array of FLOAT =
      r_right.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta757
  in
  let Tu169 : UNIT =
    let Ta758 : Array of FLOAT =
      r_down.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta758
  in
  let energya : Array of Array of FLOAT =
    let Tt759 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_energy
      Tt759
  in
  let Ta760 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta760
    diffuse_ray
in
letrec do_without_neighbors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti738 : INT =
    int 4
  in
  if nref <= Ti738
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Ti739 : INT =
      int 0
    in
    let Ti740 : INT =
      surface_ids.(nref)
    in
    if Ti739 <= Ti740
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu174 : UNIT =
        let Tb741 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti742 : INT =
          int 0
        in
        if Tb741 == Ti742
          unit ()
          app
            calc_diffuse_using_1point
            pixel
            nref
      in
      let Ti744 : INT =
        let Ti743 : INT =
          int 1
        in
        add nref Ti743
      in
      app
        do_without_neighbors
        pixel
        Ti744
      unit ()
    unit ()
in
letrec neighbors_exist : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> BOOL))) =
variables : (x : INT), (y : INT), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti729 : INT =
    let Ti728 : INT =
      int 1
    in
    image_size.(Ti728)
  in
  let Ti731 : INT =
    let Ti730 : INT =
      int 1
    in
    add y Ti730
  in
  if Ti729 <= Ti731
    int 0
    let Ti732 : INT =
      int 0
    in
    if y <= Ti732
      int 0
      let Ti734 : INT =
        let Ti733 : INT =
          int 0
        in
        image_size.(Ti733)
      in
      let Ti736 : INT =
        let Ti735 : INT =
          int 1
        in
        add x Ti735
      in
      if Ti734 <= Ti736
        int 0
        let Ti737 : INT =
          int 0
        in
        if x <= Ti737
          int 0
          int 1
in
letrec get_surface_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> INT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (index : INT)
  let surface_ids : Array of INT =
    app
      p_surface_ids
      pixel
  in
  surface_ids.(index)
in
letrec neighbors_are_available : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> BOOL))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let sid_center : INT =
    let Tt715 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      get_surface_id
      Tt715
      nref
  in
  let Ti717 : INT =
    let Tt716 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      get_surface_id
      Tt716
      nref
  in
  if Ti717 == sid_center
    let Ti719 : INT =
      let Tt718 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        next.(x)
      in
      app
        get_surface_id
        Tt718
        nref
    in
    if Ti719 == sid_center
      let Ti723 : INT =
        let Tt722 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          let Ti721 : INT =
            let Ti720 : INT =
              int 1
            in
            sub x Ti720
          in
          cur.(Ti721)
        in
        app
          get_surface_id
          Tt722
          nref
      in
      if Ti723 == sid_center
        let Ti727 : INT =
          let Tt726 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
            let Ti725 : INT =
              let Ti724 : INT =
                int 1
              in
              add x Ti724
            in
            cur.(Ti725)
          in
          app
            get_surface_id
            Tt726
            nref
        in
        if Ti727 == sid_center
          int 1
          int 0
        int 0
      int 0
    int 0
in
letrec try_exploit_neighbors : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    cur.(x)
  in
  let Ti705 : INT =
    int 4
  in
  if nref <= Ti705
    let Ti706 : INT =
      int 0
    in
    let Ti707 : INT =
      app
        get_surface_id
        pixel
        nref
    in
    if Ti706 <= Ti707
      let Tb708 : BOOL =
        app
          neighbors_are_available
          x
          prev
          cur
          next
          nref
      in
      let Ti709 : INT =
        int 0
      in
      if Tb708 == Ti709
        let Tt710 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          do_without_neighbors
          Tt710
          nref
        let calc_diffuse : Array of BOOL =
          app
            p_calc_diffuse
            pixel
        in
        let Tu175 : UNIT =
          let Tb711 : BOOL =
            calc_diffuse.(nref)
          in
          let Ti712 : INT =
            int 0
          in
          if Tb711 == Ti712
            unit ()
            app
              calc_diffuse_using_5points
              x
              prev
              cur
              next
              nref
        in
        let Ti714 : INT =
          let Ti713 : INT =
            int 1
          in
          add nref Ti713
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti714
      unit ()
    unit ()
in
letrec write_ppm_header : (UNIT -> UNIT) =
variables : (Tu176 : UNIT)
  let Tu184 : UNIT =
    let Ti692 : INT =
      int 80
    in
    out Ti692 0
  in
  let Tu183 : UNIT =
    let Ti695 : INT =
      let Ti693 : INT =
        int 48
      in
      let Ti694 : INT =
        int 6
      in
      add Ti693 Ti694
    in
    out Ti695 0
  in
  let Tu182 : UNIT =
    let Ti696 : INT =
      int 10
    in
    out Ti696 0
  in
  let Tu181 : UNIT =
    let Ti698 : INT =
      let Ti697 : INT =
        int 0
      in
      image_size.(Ti697)
    in
    app
      print_int
      Ti698
  in
  let Tu180 : UNIT =
    let Ti699 : INT =
      int 32
    in
    out Ti699 0
  in
  let Tu179 : UNIT =
    let Ti701 : INT =
      let Ti700 : INT =
        int 1
      in
      image_size.(Ti700)
    in
    app
      print_int
      Ti701
  in
  let Tu178 : UNIT =
    let Ti702 : INT =
      int 32
    in
    out Ti702 0
  in
  let Tu177 : UNIT =
    let Ti703 : INT =
      int 255
    in
    app
      print_int
      Ti703
  in
  let Ti704 : INT =
    int 10
  in
  out Ti704 0
in
letrec write_rgb_element : (FLOAT -> UNIT) =
variables : (x : FLOAT)
  let ix : INT =
    ftoi x
  in
  let elem : INT =
    let Ti690 : INT =
      int 255
    in
    if ix <= Ti690
      let Ti691 : INT =
        int 0
      in
      if Ti691 <= ix
        ix
        int 0
      int 255
  in
  out elem 0
in
letrec write_rgb : (UNIT -> UNIT) =
variables : (Tu185 : UNIT)
  let Tu187 : UNIT =
    let Td685 : FLOAT =
      let Ti684 : INT =
        int 0
      in
      rgb.(Ti684)
    in
    app
      write_rgb_element
      Td685
  in
  let Tu186 : UNIT =
    let Td687 : FLOAT =
      let Ti686 : INT =
        int 1
      in
      rgb.(Ti686)
    in
    app
      write_rgb_element
      Td687
  in
  let Td689 : FLOAT =
    let Ti688 : INT =
      int 2
    in
    rgb.(Ti688)
  in
  app
    write_rgb_element
    Td689
in
letrec pretrace_diffuse_rays : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti674 : INT =
    int 4
  in
  if nref <= Ti674
    let sid : INT =
      app
        get_surface_id
        pixel
        nref
    in
    let Ti675 : INT =
      int 0
    in
    if Ti675 <= sid
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu190 : UNIT =
        let Tb676 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti677 : INT =
          int 0
        in
        if Tb676 == Ti677
          unit ()
          let group_id : INT =
            app
              p_group_id
              pixel
          in
          let Tu189 : UNIT =
            app
              vecbzero
              diffuse_ray
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let intersection_points : Array of Array of FLOAT =
            app
              p_intersection_points
              pixel
          in
          let Tu188 : UNIT =
            let Ta678 : Array of (Array of FLOAT * Array of Array of FLOAT) =
              dirvecs.(group_id)
            in
            let Ta679 : Array of FLOAT =
              nvectors.(nref)
            in
            let Ta680 : Array of FLOAT =
              intersection_points.(nref)
            in
            app
              trace_diffuse_rays
              Ta678
              Ta679
              Ta680
          in
          let ray20p : Array of Array of FLOAT =
            app
              p_received_ray_20percent
              pixel
          in
          let Ta681 : Array of FLOAT =
            ray20p.(nref)
          in
          app
            veccpy
            Ta681
            diffuse_ray
      in
      let Ti683 : INT =
        let Ti682 : INT =
          int 1
        in
        add nref Ti682
      in
      app
        pretrace_diffuse_rays
        pixel
        Ti683
      unit ()
    unit ()
in
letrec pretrace_pixels : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (x : INT), (group_id : INT), (lc0 : FLOAT), (lc1 : FLOAT), (lc2 : FLOAT)
  let Ti638 : INT =
    int 0
  in
  if Ti638 <= x
    let xdisp : FLOAT =
      let Td640 : FLOAT =
        let Ti639 : INT =
          int 0
        in
        scan_pitch.(Ti639)
      in
      let Td644 : FLOAT =
        let Ti643 : INT =
          let Ti642 : INT =
            let Ti641 : INT =
              int 0
            in
            image_center.(Ti641)
          in
          sub x Ti642
        in
        itof Ti643
      in
      fmul Td640 Td644
    in
    let Tu200 : UNIT =
      let Ti645 : INT =
        int 0
      in
      let Td649 : FLOAT =
        let Td648 : FLOAT =
          let Td647 : FLOAT =
            let Ti646 : INT =
              int 0
            in
            screenx_dir.(Ti646)
          in
          fmul xdisp Td647
        in
        fadd Td648 lc0
      in
      ptrace_dirvec.(Ti645) <- Td649
    in
    let Tu199 : UNIT =
      let Ti650 : INT =
        int 1
      in
      let Td654 : FLOAT =
        let Td653 : FLOAT =
          let Td652 : FLOAT =
            let Ti651 : INT =
              int 1
            in
            screenx_dir.(Ti651)
          in
          fmul xdisp Td652
        in
        fadd Td653 lc1
      in
      ptrace_dirvec.(Ti650) <- Td654
    in
    let Tu198 : UNIT =
      let Ti655 : INT =
        int 2
      in
      let Td659 : FLOAT =
        let Td658 : FLOAT =
          let Td657 : FLOAT =
            let Ti656 : INT =
              int 2
            in
            screenx_dir.(Ti656)
          in
          fmul xdisp Td657
        in
        fadd Td658 lc2
      in
      ptrace_dirvec.(Ti655) <- Td659
    in
    let Tu197 : UNIT =
      let Ti660 : INT =
        int 0
      in
      app
        vecunit_sgn
        ptrace_dirvec
        Ti660
    in
    let Tu196 : UNIT =
      app
        vecbzero
        rgb
    in
    let Tu195 : UNIT =
      app
        veccpy
        startp
        viewpoint
    in
    let Tu194 : UNIT =
      let Ti661 : INT =
        int 0
      in
      let Td662 : FLOAT =
        float 1.
      in
      let Tt663 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Td664 : FLOAT =
        float 0.
      in
      app
        trace_ray
        Ti661
        Td662
        ptrace_dirvec
        Tt663
        Td664
    in
    let Tu193 : UNIT =
      let Ta666 : Array of FLOAT =
        let Tt665 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          line.(x)
        in
        app
          p_rgb
          Tt665
      in
      app
        veccpy
        Ta666
        rgb
    in
    let Tu192 : UNIT =
      let Tt667 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      app
        p_set_group_id
        Tt667
        group_id
    in
    let Tu191 : UNIT =
      let Tt668 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Ti669 : INT =
        int 0
      in
      app
        pretrace_diffuse_rays
        Tt668
        Ti669
    in
    let Ti671 : INT =
      let Ti670 : INT =
        int 1
      in
      sub x Ti670
    in
    let Ti673 : INT =
      let Ti672 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti672
    in
    app
      pretrace_pixels
      line
      Ti671
      Ti673
      lc0
      lc1
      lc2
    unit ()
in
letrec pretrace_line : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> UNIT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (y : INT), (group_id : INT)
  let ydisp : FLOAT =
    let Td614 : FLOAT =
      let Ti613 : INT =
        int 0
      in
      scan_pitch.(Ti613)
    in
    let Td618 : FLOAT =
      let Ti617 : INT =
        let Ti616 : INT =
          let Ti615 : INT =
            int 1
          in
          image_center.(Ti615)
        in
        sub y Ti616
      in
      itof Ti617
    in
    fmul Td614 Td618
  in
  let lc0 : FLOAT =
    let Td621 : FLOAT =
      let Td620 : FLOAT =
        let Ti619 : INT =
          int 0
        in
        screeny_dir.(Ti619)
      in
      fmul ydisp Td620
    in
    let Td623 : FLOAT =
      let Ti622 : INT =
        int 0
      in
      screenz_dir.(Ti622)
    in
    fadd Td621 Td623
  in
  let lc1 : FLOAT =
    let Td626 : FLOAT =
      let Td625 : FLOAT =
        let Ti624 : INT =
          int 1
        in
        screeny_dir.(Ti624)
      in
      fmul ydisp Td625
    in
    let Td628 : FLOAT =
      let Ti627 : INT =
        int 1
      in
      screenz_dir.(Ti627)
    in
    fadd Td626 Td628
  in
  let lc2 : FLOAT =
    let Td631 : FLOAT =
      let Td630 : FLOAT =
        let Ti629 : INT =
          int 2
        in
        screeny_dir.(Ti629)
      in
      fmul ydisp Td630
    in
    let Td633 : FLOAT =
      let Ti632 : INT =
        int 2
      in
      screenz_dir.(Ti632)
    in
    fadd Td631 Td633
  in
  let Ti637 : INT =
    let Ti635 : INT =
      let Ti634 : INT =
        int 0
      in
      image_size.(Ti634)
    in
    let Ti636 : INT =
      int 1
    in
    sub Ti635 Ti636
  in
  app
    pretrace_pixels
    line
    Ti637
    group_id
    lc0
    lc1
    lc2
in
letrec scan_pixel : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> UNIT))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti602 : INT =
    let Ti601 : INT =
      int 0
    in
    image_size.(Ti601)
  in
  if Ti602 <= x
    unit ()
    let Tu203 : UNIT =
      let Ta604 : Array of FLOAT =
        let Tt603 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          p_rgb
          Tt603
      in
      app
        veccpy
        rgb
        Ta604
    in
    let Tu202 : UNIT =
      let Tb605 : BOOL =
        app
          neighbors_exist
          x
          y
          next
      in
      let Ti606 : INT =
        int 0
      in
      if Tb605 == Ti606
        let Tt607 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        let Ti608 : INT =
          int 0
        in
        app
          do_without_neighbors
          Tt607
          Ti608
        let Ti609 : INT =
          int 0
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti609
    in
    let Tu201 : UNIT =
      let Tu610 : UNIT =
        unit ()
      in
      app
        write_rgb
        Tu610
    in
    let Ti612 : INT =
      let Ti611 : INT =
        int 1
      in
      add x Ti611
    in
    app
      scan_pixel
      Ti612
      y
      prev
      cur
      next
in
letrec scan_line : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (group_id : INT)
  let Ti589 : INT =
    let Ti588 : INT =
      int 1
    in
    image_size.(Ti588)
  in
  if Ti589 <= y
    unit ()
    let Tu205 : UNIT =
      let Ti593 : INT =
        let Ti591 : INT =
          let Ti590 : INT =
            int 1
          in
          image_size.(Ti590)
        in
        let Ti592 : INT =
          int 1
        in
        sub Ti591 Ti592
      in
      if Ti593 <= y
        unit ()
        let Ti595 : INT =
          let Ti594 : INT =
            int 1
          in
          add y Ti594
        in
        app
          pretrace_line
          next
          Ti595
          group_id
    in
    let Tu204 : UNIT =
      let Ti596 : INT =
        int 0
      in
      app
        scan_pixel
        Ti596
        y
        prev
        cur
        next
    in
    let Ti598 : INT =
      let Ti597 : INT =
        int 1
      in
      add y Ti597
    in
    let Ti600 : INT =
      let Ti599 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti599
    in
    app
      scan_line
      Ti598
      cur
      next
      prev
      Ti600
in
letrec create_float5x3array : (UNIT -> Array of Array of FLOAT) =
variables : (Tu206 : UNIT)
  let vec : Array of FLOAT =
    let Ti569 : INT =
      int 3
    in
    let Td570 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti569
      Td570
  in
  let array : Array of Array of FLOAT =
    let Ti571 : INT =
      int 5
    in
    extfunapp
      create_array
      Ti571
      vec
  in
  let Tu210 : UNIT =
    let Ti572 : INT =
      int 1
    in
    let Ta575 : Array of FLOAT =
      let Ti573 : INT =
        int 3
      in
      let Td574 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti573
        Td574
    in
    array.(Ti572) <- Ta575
  in
  let Tu209 : UNIT =
    let Ti576 : INT =
      int 2
    in
    let Ta579 : Array of FLOAT =
      let Ti577 : INT =
        int 3
      in
      let Td578 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti577
        Td578
    in
    array.(Ti576) <- Ta579
  in
  let Tu208 : UNIT =
    let Ti580 : INT =
      int 3
    in
    let Ta583 : Array of FLOAT =
      let Ti581 : INT =
        int 3
      in
      let Td582 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti581
        Td582
    in
    array.(Ti580) <- Ta583
  in
  let Tu207 : UNIT =
    let Ti584 : INT =
      int 4
    in
    let Ta587 : Array of FLOAT =
      let Ti585 : INT =
        int 3
      in
      let Td586 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti585
        Td586
    in
    array.(Ti584) <- Ta587
  in
  array
in
letrec create_pixel : (UNIT -> (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu211 : UNIT)
  let m_rgb : Array of FLOAT =
    let Ti557 : INT =
      int 3
    in
    let Td558 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti557
      Td558
  in
  let m_isect_ps : Array of Array of FLOAT =
    let Tu559 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu559
  in
  let m_sids : Array of INT =
    let Ti560 : INT =
      int 5
    in
    let Ti561 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti560
      Ti561
  in
  let m_cdif : Array of BOOL =
    let Ti562 : INT =
      int 5
    in
    let Ti563 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti562
      Ti563
  in
  let m_engy : Array of Array of FLOAT =
    let Tu564 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu564
  in
  let m_r20p : Array of Array of FLOAT =
    let Tu565 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu565
  in
  let m_gid : Array of INT =
    let Ti566 : INT =
      int 1
    in
    let Ti567 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti566
      Ti567
  in
  let m_nvectors : Array of Array of FLOAT =
    let Tu568 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu568
  in
  Tuple
    m_rgb
    m_isect_ps
    m_sids
    m_cdif
    m_engy
    m_r20p
    m_gid
    m_nvectors
in
letrec init_line_elements : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (n : INT)
  let Ti552 : INT =
    int 0
  in
  if Ti552 <= n
    let Tu212 : UNIT =
      let Tt554 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        let Tu553 : UNIT =
          unit ()
        in
        app
          create_pixel
          Tu553
      in
      line.(n) <- Tt554
    in
    let Ti556 : INT =
      let Ti555 : INT =
        int 1
      in
      sub n Ti555
    in
    app
      init_line_elements
      line
      Ti556
    line
in
letrec create_pixelline : (UNIT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu213 : UNIT)
  let line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Ti545 : INT =
      let Ti544 : INT =
        int 0
      in
      image_size.(Ti544)
    in
    let Tt547 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Tu546 : UNIT =
        unit ()
      in
      app
        create_pixel
        Tu546
    in
    extfunapp
      create_array
      Ti545
      Tt547
  in
  let Ti551 : INT =
    let Ti549 : INT =
      let Ti548 : INT =
        int 0
      in
      image_size.(Ti548)
    in
    let Ti550 : INT =
      int 2
    in
    sub Ti549 Ti550
  in
  app
    init_line_elements
    line
    Ti551
in
letrec tan : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td542 : FLOAT =
    extfunapp
      sin
      x
  in
  let Td543 : FLOAT =
    extfunapp
      cos
      x
  in
  fdiv Td542 Td543
in
letrec adjust_position : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (h : FLOAT), (ratio : FLOAT)
  let l : FLOAT =
    let Td539 : FLOAT =
      let Td537 : FLOAT =
        fmul h h
      in
      let Td538 : FLOAT =
        float 0.1
      in
      fadd Td537 Td538
    in
    app
      sqrt
      Td539
  in
  let tan_h : FLOAT =
    let Td540 : FLOAT =
      float 1.
    in
    fdiv Td540 l
  in
  let theta_h : FLOAT =
    app
      atan
      tan_h
  in
  let tan_m : FLOAT =
    let Td541 : FLOAT =
      fmul theta_h ratio
    in
    app
      tan
      Td541
  in
  fmul tan_m l
in
letrec calc_dirvec : (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> UNIT))))))) =
variables : (icount : INT), (x : FLOAT), (y : FLOAT), (rx : FLOAT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti496 : INT =
    int 5
  in
  if Ti496 <= icount
    let l : FLOAT =
      let Td501 : FLOAT =
        let Td499 : FLOAT =
          let Td497 : FLOAT =
            app
              fsqr
              x
          in
          let Td498 : FLOAT =
            app
              fsqr
              y
          in
          fadd Td497 Td498
        in
        let Td500 : FLOAT =
          float 1.
        in
        fadd Td499 Td500
      in
      app
        sqrt
        Td501
    in
    let vx : FLOAT =
      fdiv x l
    in
    let vy : FLOAT =
      fdiv y l
    in
    let vz : FLOAT =
      let Td502 : FLOAT =
        float 1.
      in
      fdiv Td502 l
    in
    let dgroup : Array of (Array of FLOAT * Array of Array of FLOAT) =
      dirvecs.(group_id)
    in
    let Tu218 : UNIT =
      let Ta504 : Array of FLOAT =
        let Tt503 : (Array of FLOAT * Array of Array of FLOAT) =
          dgroup.(index)
        in
        app
          d_vec
          Tt503
      in
      app
        vecset
        Ta504
        vx
        vy
        vz
    in
    let Tu217 : UNIT =
      let Ta508 : Array of FLOAT =
        let Tt507 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti506 : INT =
            let Ti505 : INT =
              int 40
            in
            add index Ti505
          in
          dgroup.(Ti506)
        in
        app
          d_vec
          Tt507
      in
      let Td509 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta508
        vx
        vz
        Td509
    in
    let Tu216 : UNIT =
      let Ta513 : Array of FLOAT =
        let Tt512 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti511 : INT =
            let Ti510 : INT =
              int 80
            in
            add index Ti510
          in
          dgroup.(Ti511)
        in
        app
          d_vec
          Tt512
      in
      let Td514 : FLOAT =
        app
          fneg
          vx
      in
      let Td515 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta513
        vz
        Td514
        Td515
    in
    let Tu215 : UNIT =
      let Ta519 : Array of FLOAT =
        let Tt518 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti517 : INT =
            let Ti516 : INT =
              int 1
            in
            add index Ti516
          in
          dgroup.(Ti517)
        in
        app
          d_vec
          Tt518
      in
      let Td520 : FLOAT =
        app
          fneg
          vx
      in
      let Td521 : FLOAT =
        app
          fneg
          vy
      in
      let Td522 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta519
        Td520
        Td521
        Td522
    in
    let Tu214 : UNIT =
      let Ta526 : Array of FLOAT =
        let Tt525 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti524 : INT =
            let Ti523 : INT =
              int 41
            in
            add index Ti523
          in
          dgroup.(Ti524)
        in
        app
          d_vec
          Tt525
      in
      let Td527 : FLOAT =
        app
          fneg
          vx
      in
      let Td528 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta526
        Td527
        Td528
        vy
    in
    let Ta532 : Array of FLOAT =
      let Tt531 : (Array of FLOAT * Array of Array of FLOAT) =
        let Ti530 : INT =
          let Ti529 : INT =
            int 81
          in
          add index Ti529
        in
        dgroup.(Ti530)
      in
      app
        d_vec
        Tt531
    in
    let Td533 : FLOAT =
      app
        fneg
        vz
    in
    app
      vecset
      Ta532
      Td533
      vx
      vy
    let x2 : FLOAT =
      app
        adjust_position
        y
        rx
    in
    let Ti535 : INT =
      let Ti534 : INT =
        int 1
      in
      add icount Ti534
    in
    let Td536 : FLOAT =
      app
        adjust_position
        x2
        ry
    in
    app
      calc_dirvec
      Ti535
      x2
      Td536
      rx
      ry
      group_id
      index
in
letrec calc_dirvecs : (INT -> (FLOAT -> (INT -> (INT -> UNIT)))) =
variables : (col : INT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti475 : INT =
    int 0
  in
  if Ti475 <= col
    let rx : FLOAT =
      let Td478 : FLOAT =
        let Td476 : FLOAT =
          itof col
        in
        let Td477 : FLOAT =
          float 0.2
        in
        fmul Td476 Td477
      in
      let Td479 : FLOAT =
        float 0.9
      in
      fsub Td478 Td479
    in
    let Tu220 : UNIT =
      let Ti480 : INT =
        int 0
      in
      let Td481 : FLOAT =
        float 0.
      in
      let Td482 : FLOAT =
        float 0.
      in
      app
        calc_dirvec
        Ti480
        Td481
        Td482
        rx
        ry
        group_id
        index
    in
    let rx2 : FLOAT =
      let Td485 : FLOAT =
        let Td483 : FLOAT =
          itof col
        in
        let Td484 : FLOAT =
          float 0.2
        in
        fmul Td483 Td484
      in
      let Td486 : FLOAT =
        float 0.1
      in
      fadd Td485 Td486
    in
    let Tu219 : UNIT =
      let Ti487 : INT =
        int 0
      in
      let Td488 : FLOAT =
        float 0.
      in
      let Td489 : FLOAT =
        float 0.
      in
      let Ti491 : INT =
        let Ti490 : INT =
          int 2
        in
        add index Ti490
      in
      app
        calc_dirvec
        Ti487
        Td488
        Td489
        rx2
        ry
        group_id
        Ti491
    in
    let Ti493 : INT =
      let Ti492 : INT =
        int 1
      in
      sub col Ti492
    in
    let Ti495 : INT =
      let Ti494 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti494
    in
    app
      calc_dirvecs
      Ti493
      ry
      Ti495
      index
    unit ()
in
letrec calc_dirvec_rows : (INT -> (INT -> (INT -> UNIT))) =
variables : (row : INT), (group_id : INT), (index : INT)
  let Ti463 : INT =
    int 0
  in
  if Ti463 <= row
    let ry : FLOAT =
      let Td466 : FLOAT =
        let Td464 : FLOAT =
          itof row
        in
        let Td465 : FLOAT =
          float 0.2
        in
        fmul Td464 Td465
      in
      let Td467 : FLOAT =
        float 0.9
      in
      fsub Td466 Td467
    in
    let Tu221 : UNIT =
      let Ti468 : INT =
        int 4
      in
      app
        calc_dirvecs
        Ti468
        ry
        group_id
        index
    in
    let Ti470 : INT =
      let Ti469 : INT =
        int 1
      in
      sub row Ti469
    in
    let Ti472 : INT =
      let Ti471 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti471
    in
    let Ti474 : INT =
      let Ti473 : INT =
        int 4
      in
      add index Ti473
    in
    app
      calc_dirvec_rows
      Ti470
      Ti472
      Ti474
    unit ()
in
letrec create_dirvec : (UNIT -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (Tu222 : UNIT)
  let v3 : Array of FLOAT =
    let Ti459 : INT =
      int 3
    in
    let Td460 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti459
      Td460
  in
  let consts : Array of Array of FLOAT =
    let Ti462 : INT =
      let Ti461 : INT =
        int 0
      in
      n_objects.(Ti461)
    in
    extfunapp
      create_array
      Ti462
      v3
  in
  Tuple
    v3
    consts
in
letrec create_dirvec_elements : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (d : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti454 : INT =
    int 0
  in
  if Ti454 <= index
    let Tu223 : UNIT =
      let Tt456 : (Array of FLOAT * Array of Array of FLOAT) =
        let Tu455 : UNIT =
          unit ()
        in
        app
          create_dirvec
          Tu455
      in
      d.(index) <- Tt456
    in
    let Ti458 : INT =
      let Ti457 : INT =
        int 1
      in
      sub index Ti457
    in
    app
      create_dirvec_elements
      d
      Ti458
    unit ()
in
letrec create_dirvecs : (INT -> UNIT) =
variables : (index : INT)
  let Ti445 : INT =
    int 0
  in
  if Ti445 <= index
    let Tu225 : UNIT =
      let Ta449 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti446 : INT =
          int 120
        in
        let Tt448 : (Array of FLOAT * Array of Array of FLOAT) =
          let Tu447 : UNIT =
            unit ()
          in
          app
            create_dirvec
            Tu447
        in
        extfunapp
          create_array
          Ti446
          Tt448
      in
      dirvecs.(index) <- Ta449
    in
    let Tu224 : UNIT =
      let Ta450 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti451 : INT =
        int 118
      in
      app
        create_dirvec_elements
        Ta450
        Ti451
    in
    let Ti453 : INT =
      let Ti452 : INT =
        int 1
      in
      sub index Ti452
    in
    app
      create_dirvecs
      Ti453
    unit ()
in
letrec init_dirvec_constants : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (vecset : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti441 : INT =
    int 0
  in
  if Ti441 <= index
    let Tu226 : UNIT =
      let Tt442 : (Array of FLOAT * Array of Array of FLOAT) =
        vecset.(index)
      in
      app
        setup_dirvec_constants
        Tt442
    in
    let Ti444 : INT =
      let Ti443 : INT =
        int 1
      in
      sub index Ti443
    in
    app
      init_dirvec_constants
      vecset
      Ti444
    unit ()
in
letrec init_vecset_constants : (INT -> UNIT) =
variables : (index : INT)
  let Ti436 : INT =
    int 0
  in
  if Ti436 <= index
    let Tu227 : UNIT =
      let Ta437 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti438 : INT =
        int 119
      in
      app
        init_dirvec_constants
        Ta437
        Ti438
    in
    let Ti440 : INT =
      let Ti439 : INT =
        int 1
      in
      sub index Ti439
    in
    app
      init_vecset_constants
      Ti440
    unit ()
in
letrec init_dirvecs : (UNIT -> UNIT) =
variables : (Tu228 : UNIT)
  let Tu230 : UNIT =
    let Ti431 : INT =
      int 4
    in
    app
      create_dirvecs
      Ti431
  in
  let Tu229 : UNIT =
    let Ti432 : INT =
      int 9
    in
    let Ti433 : INT =
      int 0
    in
    let Ti434 : INT =
      int 0
    in
    app
      calc_dirvec_rows
      Ti432
      Ti433
      Ti434
  in
  let Ti435 : INT =
    int 4
  in
  app
    init_vecset_constants
    Ti435
in
letrec add_reflection : (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (index : INT), (surface_id : INT), (bright : FLOAT), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let dvec : (Array of FLOAT * Array of Array of FLOAT) =
    let Tu428 : UNIT =
      unit ()
    in
    app
      create_dirvec
      Tu428
  in
  let Tu232 : UNIT =
    let Ta429 : Array of FLOAT =
      app
        d_vec
        dvec
    in
    app
      vecset
      Ta429
      v0
      v1
      v2
  in
  let Tu231 : UNIT =
    app
      setup_dirvec_constants
      dvec
  in
  let Tt430 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    Tuple
      surface_id
      dvec
      bright
  in
  reflections.(index) <- Tt430
in
letrec setup_rect_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    mul obj_id 4
  in
  let nr : INT =
    let Ti400 : INT =
      int 0
    in
    n_reflections.(Ti400)
  in
  let br : FLOAT =
    let Td401 : FLOAT =
      float 1.
    in
    let Td402 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td401 Td402
  in
  let n0 : FLOAT =
    let Td404 : FLOAT =
      let Ti403 : INT =
        int 0
      in
      light.(Ti403)
    in
    app
      fneg
      Td404
  in
  let n1 : FLOAT =
    let Td406 : FLOAT =
      let Ti405 : INT =
        int 1
      in
      light.(Ti405)
    in
    app
      fneg
      Td406
  in
  let n2 : FLOAT =
    let Td408 : FLOAT =
      let Ti407 : INT =
        int 2
      in
      light.(Ti407)
    in
    app
      fneg
      Td408
  in
  let Tu235 : UNIT =
    let Ti410 : INT =
      let Ti409 : INT =
        int 1
      in
      add sid Ti409
    in
    let Td412 : FLOAT =
      let Ti411 : INT =
        int 0
      in
      light.(Ti411)
    in
    app
      add_reflection
      nr
      Ti410
      br
      Td412
      n1
      n2
  in
  let Tu234 : UNIT =
    let Ti414 : INT =
      let Ti413 : INT =
        int 1
      in
      add nr Ti413
    in
    let Ti416 : INT =
      let Ti415 : INT =
        int 2
      in
      add sid Ti415
    in
    let Td418 : FLOAT =
      let Ti417 : INT =
        int 1
      in
      light.(Ti417)
    in
    app
      add_reflection
      Ti414
      Ti416
      br
      n0
      Td418
      n2
  in
  let Tu233 : UNIT =
    let Ti420 : INT =
      let Ti419 : INT =
        int 2
      in
      add nr Ti419
    in
    let Ti422 : INT =
      let Ti421 : INT =
        int 3
      in
      add sid Ti421
    in
    let Td424 : FLOAT =
      let Ti423 : INT =
        int 2
      in
      light.(Ti423)
    in
    app
      add_reflection
      Ti420
      Ti422
      br
      n0
      n1
      Td424
  in
  let Ti425 : INT =
    int 0
  in
  let Ti427 : INT =
    let Ti426 : INT =
      int 3
    in
    add nr Ti426
  in
  n_reflections.(Ti425) <- Ti427
in
letrec setup_surface_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    let Ti370 : INT =
      mul obj_id 4
    in
    let Ti371 : INT =
      int 1
    in
    add Ti370 Ti371
  in
  let nr : INT =
    let Ti372 : INT =
      int 0
    in
    n_reflections.(Ti372)
  in
  let br : FLOAT =
    let Td373 : FLOAT =
      float 1.
    in
    let Td374 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td373 Td374
  in
  let p : FLOAT =
    let Ta375 : Array of FLOAT =
      app
        o_param_abc
        obj
    in
    app
      veciprod
      light
      Ta375
  in
  let Tu236 : UNIT =
    let Td382 : FLOAT =
      let Td379 : FLOAT =
        let Td378 : FLOAT =
          let Td376 : FLOAT =
            float 2.
          in
          let Td377 : FLOAT =
            app
              o_param_a
              obj
          in
          fmul Td376 Td377
        in
        fmul Td378 p
      in
      let Td381 : FLOAT =
        let Ti380 : INT =
          int 0
        in
        light.(Ti380)
      in
      fsub Td379 Td381
    in
    let Td389 : FLOAT =
      let Td386 : FLOAT =
        let Td385 : FLOAT =
          let Td383 : FLOAT =
            float 2.
          in
          let Td384 : FLOAT =
            app
              o_param_b
              obj
          in
          fmul Td383 Td384
        in
        fmul Td385 p
      in
      let Td388 : FLOAT =
        let Ti387 : INT =
          int 1
        in
        light.(Ti387)
      in
      fsub Td386 Td388
    in
    let Td396 : FLOAT =
      let Td393 : FLOAT =
        let Td392 : FLOAT =
          let Td390 : FLOAT =
            float 2.
          in
          let Td391 : FLOAT =
            app
              o_param_c
              obj
          in
          fmul Td390 Td391
        in
        fmul Td392 p
      in
      let Td395 : FLOAT =
        let Ti394 : INT =
          int 2
        in
        light.(Ti394)
      in
      fsub Td393 Td395
    in
    app
      add_reflection
      nr
      sid
      br
      Td382
      Td389
      Td396
  in
  let Ti397 : INT =
    int 0
  in
  let Ti399 : INT =
    let Ti398 : INT =
      int 1
    in
    add nr Ti398
  in
  n_reflections.(Ti397) <- Ti399
in
letrec setup_reflections : (INT -> UNIT) =
variables : (obj_id : INT)
  let Ti361 : INT =
    int 0
  in
  if Ti361 <= obj_id
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(obj_id)
    in
    let Ti362 : INT =
      app
        o_reflectiontype
        obj
    in
    let Ti363 : INT =
      int 2
    in
    if Ti362 == Ti363
      let Tb366 : BOOL =
        let Td364 : FLOAT =
          app
            o_diffuse
            obj
        in
        let Td365 : FLOAT =
          float 1.
        in
        app
          fless
          Td364
          Td365
      in
      let Ti367 : INT =
        int 0
      in
      if Tb366 == Ti367
        unit ()
        let m_shape : INT =
          app
            o_form
            obj
        in
        let Ti368 : INT =
          int 1
        in
        if m_shape == Ti368
          app
            setup_rect_reflection
            obj_id
            obj
          let Ti369 : INT =
            int 2
          in
          if m_shape == Ti369
            app
              setup_surface_reflection
              obj_id
              obj
            unit ()
      unit ()
    unit ()
in
letrec rt : (INT -> (INT -> UNIT)) =
variables : (size_x : INT), (size_y : INT)
  let Tu248 : UNIT =
    let Ti336 : INT =
      int 0
    in
    image_size.(Ti336) <- size_x
  in
  let Tu247 : UNIT =
    let Ti337 : INT =
      int 1
    in
    image_size.(Ti337) <- size_y
  in
  let Tu246 : UNIT =
    let Ti338 : INT =
      int 0
    in
    let Ti339 : INT =
      div size_x 2
    in
    image_center.(Ti338) <- Ti339
  in
  let Tu245 : UNIT =
    let Ti340 : INT =
      int 1
    in
    let Ti341 : INT =
      div size_y 2
    in
    image_center.(Ti340) <- Ti341
  in
  let Tu244 : UNIT =
    let Ti342 : INT =
      int 0
    in
    let Td345 : FLOAT =
      let Td343 : FLOAT =
        float 128.
      in
      let Td344 : FLOAT =
        itof size_x
      in
      fdiv Td343 Td344
    in
    scan_pitch.(Ti342) <- Td345
  in
  let prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu346 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu346
  in
  let cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu347 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu347
  in
  let next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu348 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu348
  in
  let Tu243 : UNIT =
    let Tu349 : UNIT =
      unit ()
    in
    app
      read_parameter
      Tu349
  in
  let Tu242 : UNIT =
    let Tu350 : UNIT =
      unit ()
    in
    app
      write_ppm_header
      Tu350
  in
  let Tu241 : UNIT =
    let Tu351 : UNIT =
      unit ()
    in
    app
      init_dirvecs
      Tu351
  in
  let Tu240 : UNIT =
    let Ta352 : Array of FLOAT =
      app
        d_vec
        light_dirvec
    in
    app
      veccpy
      Ta352
      light
  in
  let Tu239 : UNIT =
    app
      setup_dirvec_constants
      light_dirvec
  in
  let Tu238 : UNIT =
    let Ti356 : INT =
      let Ti354 : INT =
        let Ti353 : INT =
          int 0
        in
        n_objects.(Ti353)
      in
      let Ti355 : INT =
        int 1
      in
      sub Ti354 Ti355
    in
    app
      setup_reflections
      Ti356
  in
  let Tu237 : UNIT =
    let Ti357 : INT =
      int 0
    in
    let Ti358 : INT =
      int 0
    in
    app
      pretrace_line
      cur
      Ti357
      Ti358
  in
  let Ti359 : INT =
    int 0
  in
  let Ti360 : INT =
    int 2
  in
  app
    scan_line
    Ti359
    prev
    cur
    next
    Ti360
in
let Ti334 : INT =
  int 512
in
let Ti335 : INT =
  int 512
in
app
  rt
  Ti334
  Ti335
