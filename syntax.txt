----- syntax.print -----
LETREC print_int (VAR of )
  (n : VAR of )
  LET n (VAR of )
    IF
      NOT
        LE
          INT 0
          VAR n
      LET Tu1 (UNIT)
        OUT
          INT 45        0
      NEG
        VAR n
      VAR n
  IF
    NOT
      LE
        INT 10
        VAR n
    OUT
      VAR n    48
    LET m (VAR of )
      DIVIDE BY 10
        VAR n
    LET Tu2 (UNIT)
      APP
        VAR print_int
        VAR m
    OUT
      SUB
        VAR n
        MULTIPLE 10
          VAR m    48
LETREC print_char (VAR of )
  (c : VAR of )
  OUT
    VAR c  0
LETREC reduction_2pi_sub1 (VAR of )
  (a : VAR of ), (p : VAR of )
  IF
    FLt
      VAR a
      VAR p
    VAR p
    APP
      VAR reduction_2pi_sub1
      VAR a
      FADD
        VAR p
        VAR p
LETREC reduction_2pi_sub2 (VAR of )
  (a : VAR of ), (p : VAR of )
  IF
    FLt
      FLOAT 6.28318530718
      VAR a
    LET a (VAR of )
      IF
        FLt
          VAR p
          VAR a
        FSUB
          VAR a
          VAR p
        FADD
          VAR a
          FLOAT 0.
    LET p (VAR of )
      FDIV
        VAR p
        FLOAT 2.
    APP
      VAR reduction_2pi_sub2
      VAR a
      VAR p
    FADD
      VAR a
      FLOAT 0.
LETREC reduction_2pi (VAR of )
  (a : VAR of )
  LET p (VAR of )
    FLOAT 6.28318530718
  LET p (VAR of )
    APP
      VAR reduction_2pi_sub1
      VAR a
      VAR p
  APP
    VAR reduction_2pi_sub2
    VAR a
    VAR p
LETREC kernel_sin (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a
  LET a5 (VAR of )
    FMUL
      VAR a3
      VAR a2
  LET a7 (VAR of )
    FMUL
      VAR a5
      VAR a2
  FADD
    FSUB
      FADD
        NEG
          FMUL
            FLOAT 0.000198411698413
            VAR a7
        FMUL
          FLOAT 0.0083333333333
          VAR a5
      FMUL
        FLOAT 0.166666666667
        VAR a3
    VAR a
LETREC kernel_cos (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a4 (VAR of )
    FMUL
      VAR a2
      VAR a2
  LET a6 (VAR of )
    FMUL
      VAR a4
      VAR a2
  FADD
    FSUB
      FADD
        NEG
          FMUL
            FLOAT 0.00138888888889
            VAR a6
        FMUL
          FLOAT 0.0416666666667
          VAR a4
      FMUL
        FLOAT 0.5
        VAR a2
    FLOAT 1.
LETREC sin (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      FADD
        VAR a
        FLOAT 0.
  LET a (VAR of )
    APP
      VAR reduction_2pi
      VAR a
  (a : VAR of ), (flag : VAR of )
    IF
      FLt
        FLOAT 3.14159265359
        VAR a
      TUPLE
        FSUB
          VAR a
          FLOAT 3.14159265359
        NOT
          VAR flag
      TUPLE
        FADD
          VAR a
          FLOAT 0.
        VAR flag
    LET a (VAR of )
      IF
        FLt
          FLOAT 1.57079632679
          VAR a
        FSUB
          FLOAT 3.14159265359
          VAR a
        FADD
          VAR a
          FLOAT 0.
    LET a (VAR of )
      IF
        FLt
          VAR a
          FLOAT 0.785398163397
        APP
          VAR kernel_cos
          FSUB
            FLOAT 1.57079632679
            VAR a
        APP
          VAR kernel_sin
          VAR a
    IF
      VAR flag
      FADD
        VAR a
        FLOAT 0.
      NEG
        VAR a
LETREC cos (VAR of )
  (a : VAR of )
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      FADD
        VAR a
        FLOAT 0.
  LET a (VAR of )
    APP
      VAR reduction_2pi
      VAR a
  (a : VAR of ), (flag : VAR of )
    IF
      FLt
        FLOAT 3.14159265359
        VAR a
      TUPLE
        FSUB
          VAR a
          FLOAT 3.14159265359
        BOOL false
      TUPLE
        VAR a
        BOOL true
    (a : VAR of ), (flag : VAR of )
      IF
        FLt
          FLOAT 1.57079632679
          VAR a
        TUPLE
          FSUB
            FLOAT 3.14159265359
            VAR a
          NOT
            VAR flag
        TUPLE
          FADD
            VAR a
            FLOAT 0.
          VAR flag
      LET a (VAR of )
        IF
          FLt
            FLOAT 0.785398163397
            VAR a
          APP
            VAR kernel_cos
            VAR a
          APP
            VAR kernel_sin
            FSUB
              FLOAT 1.57079632679
              VAR a
      IF
        VAR flag
        FADD
          VAR a
          FLOAT 0.
        NEG
          VAR a
LETREC sqrt (VAR of )
  (x : VAR of )
  LETREC inner (VAR of )
    (t : VAR of ), (i : VAR of )
    IF
      EQ
        VAR i
        INT 0
      VAR t
      APP
        VAR inner
        FDIV
          FADD
            FMUL
              VAR t
              VAR t
            VAR x
          FMUL
            FLOAT 2.
            VAR t
        SUB
          VAR i
          INT 1
  APP
    VAR inner
    UNKNOWN APP      sqrt_init
      VAR x
    INT 5
LETREC kernel_atan (VAR of )
  (a1 : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a1
      VAR a1
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a1
  LET a5 (VAR of )
    FMUL
      VAR a2
      VAR a3
  LET a7 (VAR of )
    FMUL
      VAR a2
      VAR a5
  LET a9 (VAR of )
    FMUL
      VAR a2
      VAR a7
  LET a11 (VAR of )
    FMUL
      VAR a2
      VAR a9
  LET a13 (VAR of )
    FMUL
      VAR a2
      VAR a11
  FADD
    FSUB
      FADD
        FSUB
          FADD
            FSUB
              VAR a1
              FMUL
                FLOAT 0.3333333
                VAR a3
            FMUL
              FLOAT 0.2
              VAR a5
          FMUL
            FLOAT 0.142857142
            VAR a7
        FMUL
          FLOAT 0.111111104
          VAR a9
      FMUL
        FLOAT 0.08976446
        VAR a11
    FMUL
      FLOAT 0.060035485
      VAR a13
LETREC atan (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      VAR flag
      FADD
        VAR a
        FLOAT 0.
      NEG
        VAR a
  LET b (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.4375
      APP
        VAR kernel_atan
        VAR a
      FADD
        IF
          FLt
            VAR a
            FLOAT 2.4375
          FADD
            FLOAT 0.785398163397
            APP
              VAR kernel_atan
              FDIV
                FSUB
                  VAR a
                  FLOAT 1.
                FADD
                  VAR a
                  FLOAT 1.
          FSUB
            FLOAT 1.57079632679
            APP
              VAR kernel_atan
              FDIV
                FLOAT 1.
                VAR a
        FLOAT 0.
  IF
    VAR flag
    FADD
      FLOAT 0.
      VAR b
    NEG
      VAR b
LETREC floor (VAR of )
  (x : VAR of )
  LET a (VAR of )
    int_to_float
      float_to_int
        VAR x
  IF
    FLt
      VAR x
      VAR a
    FSUB
      VAR a
      FLOAT 1.
    VAR a
LETREC fabs (VAR of )
  (f : VAR of )
  IF
    FLt
      VAR f
      FLOAT 0.
    NEG
      VAR f
    VAR f
LETREC fhalf (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.5
LETREC fsqr (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    VAR x
LETREC fless (VAR of )
  (a : VAR of ), (b : VAR of )
  FLt
    VAR a
    VAR b
LETREC abs_float (VAR of )
  (x : VAR of )
  APP
    VAR fabs
    VAR x
LET n_objects (VAR of )
  ARRAY
    INT 1
    INT 0
LET objects (VAR of )
  LET dummy (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  ARRAY
    INT 60
    TUPLE
      INT 0
      INT 0
      INT 0
      INT 0
      VAR dummy
      VAR dummy
      BOOL false
      VAR dummy
      VAR dummy
      VAR dummy
      VAR dummy
LET screen (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET viewpoint (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET light (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET beam (VAR of )
  ARRAY
    INT 1
    FLOAT 255.
LET and_net (VAR of )
  ARRAY
    INT 50
    ARRAY
      INT 1
      NEG
        INT 1
LET or_net (VAR of )
  ARRAY
    INT 1
    ARRAY
      INT 1
      GET
        VAR and_net
        INT 0
LET solver_dist (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET intsec_rectside (VAR of )
  ARRAY
    INT 1
    INT 0
LET tmin (VAR of )
  ARRAY
    INT 1
    FLOAT 1000000000.
LET intersection_point (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET intersected_object_id (VAR of )
  ARRAY
    INT 1
    INT 0
LET nvector (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET texture_color (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET diffuse_ray (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET rgb (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET image_size (VAR of )
  ARRAY
    INT 2
    INT 0
LET image_center (VAR of )
  ARRAY
    INT 2
    INT 0
LET scan_pitch (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET startp (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET startp_fast (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenx_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screeny_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenz_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET ptrace_dirvec (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET dirvecs (VAR of )
  LET dummyf (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff (VAR of )
    ARRAY
      INT 0
      VAR dummyf
  LET dummy_vs (VAR of )
    ARRAY
      INT 0
      TUPLE
        VAR dummyf
        VAR dummyff
  ARRAY
    INT 5
    VAR dummy_vs
LET light_dirvec (VAR of )
  LET dummyf2 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      INT 60
      VAR dummyf2
  TUPLE
    VAR v3
    VAR consts
LET reflections (VAR of )
  LET dummyf3 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff3 (VAR of )
    ARRAY
      INT 0
      VAR dummyf3
  LET dummydv (VAR of )
    TUPLE
      VAR dummyf3
      VAR dummyff3
  ARRAY
    INT 180
    TUPLE
      INT 0
      VAR dummydv
      FLOAT 0.
LET n_reflections (VAR of )
  ARRAY
    INT 1
    INT 0
LETREC xor (VAR of )
  (x : VAR of ), (y : VAR of )
  IF
    VAR x
    NOT
      VAR y
    VAR y
LETREC sgn (VAR of )
  (x : VAR of )
  IF
    FZero?
      VAR x
    FLOAT 0.
    IF
      FLt
        FLOAT 0.
        VAR x
      FLOAT 1.
      FLOAT -1.
LETREC fneg_cond (VAR of )
  (cond : VAR of ), (x : VAR of )
  IF
    VAR cond
    VAR x
    NEG
      VAR x
LETREC add_mod5 (VAR of )
  (x : VAR of ), (y : VAR of )
  LET sum (VAR of )
    ADD
      VAR x
      VAR y
  IF
    LE
      INT 5
      VAR sum
    SUB
      VAR sum
      INT 5
    VAR sum
LETREC vecset (VAR of )
  (v : VAR of ), (x : VAR of ), (y : VAR of ), (z : VAR of )
  LET Tu4 (UNIT)
    PUT
      VAR v
      INT 0
      VAR x
  LET Tu3 (UNIT)
    PUT
      VAR v
      INT 1
      VAR y
  PUT
    VAR v
    INT 2
    VAR z
LETREC vecfill (VAR of )
  (v : VAR of ), (elem : VAR of )
  LET Tu6 (UNIT)
    PUT
      VAR v
      INT 0
      VAR elem
  LET Tu5 (UNIT)
    PUT
      VAR v
      INT 1
      VAR elem
  PUT
    VAR v
    INT 2
    VAR elem
LETREC vecbzero (VAR of )
  (v : VAR of )
  APP
    VAR vecfill
    VAR v
    FLOAT 0.
LETREC veccpy (VAR of )
  (dest : VAR of ), (src : VAR of )
  LET Tu8 (UNIT)
    PUT
      VAR dest
      INT 0
      GET
        VAR src
        INT 0
  LET Tu7 (UNIT)
    PUT
      VAR dest
      INT 1
      GET
        VAR src
        INT 1
  PUT
    VAR dest
    INT 2
    GET
      VAR src
      INT 2
LETREC vecdist2 (VAR of )
  (p : VAR of ), (q : VAR of )
  FADD
    FADD
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 0
          GET
            VAR q
            INT 0
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 1
          GET
            VAR q
            INT 1
    APP
      VAR fsqr
      FSUB
        GET
          VAR p
          INT 2
        GET
          VAR q
          INT 2
LETREC vecunit (VAR of )
  (v : VAR of )
  LET il (VAR of )
    FDIV
      FLOAT 1.
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              GET
                VAR v
                INT 0
            APP
              VAR fsqr
              GET
                VAR v
                INT 1
          APP
            VAR fsqr
            GET
              VAR v
              INT 2
  LET Tu10 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu9 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC vecunit_sgn (VAR of )
  (v : VAR of ), (inv : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FADD
          APP
            VAR fsqr
            GET
              VAR v
              INT 0
          APP
            VAR fsqr
            GET
              VAR v
              INT 1
        APP
          VAR fsqr
          GET
            VAR v
            INT 2
  LET il (VAR of )
    IF
      FZero?
        VAR l
      FLOAT 1.
      IF
        VAR inv
        FDIV
          FLOAT -1.
          VAR l
        FDIV
          FLOAT 1.
          VAR l
  LET Tu12 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu11 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC veciprod (VAR of )
  (v : VAR of ), (w : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        GET
          VAR w
          INT 0
      FMUL
        GET
          VAR v
          INT 1
        GET
          VAR w
          INT 1
    FMUL
      GET
        VAR v
        INT 2
      GET
        VAR w
        INT 2
LETREC veciprod2 (VAR of )
  (v : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        VAR w0
      FMUL
        GET
          VAR v
          INT 1
        VAR w1
    FMUL
      GET
        VAR v
        INT 2
      VAR w2
LETREC vecaccum (VAR of )
  (dest : VAR of ), (scale : VAR of ), (v : VAR of )
  LET Tu14 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          VAR scale
          GET
            VAR v
            INT 0
  LET Tu13 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          VAR scale
          GET
            VAR v
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        VAR scale
        GET
          VAR v
          INT 2
LETREC vecadd (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu16 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu15 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecmul (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu18 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu17 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecscale (VAR of )
  (dest : VAR of ), (scale : VAR of )
  LET Tu20 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        VAR scale
  LET Tu19 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        VAR scale
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      VAR scale
LETREC vecaccumv (VAR of )
  (dest : VAR of ), (v : VAR of ), (w : VAR of )
  LET Tu22 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          GET
            VAR v
            INT 0
          GET
            VAR w
            INT 0
  LET Tu21 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          GET
            VAR v
            INT 1
          GET
            VAR w
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        GET
          VAR v
          INT 2
        GET
          VAR w
          INT 2
LETREC o_texturetype (VAR of )
  (m : VAR of )
  (m_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_tex
LETREC o_form (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (m_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_shape
LETREC o_reflectiontype (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_surface
LETREC o_isinvert (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (m_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_invert
LETREC o_isrot (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (m_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_isrot
LETREC o_param_a (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 0
LETREC o_param_b (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 1
LETREC o_param_c (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 2
LETREC o_param_abc (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_abc
LETREC o_param_x (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 0
LETREC o_param_y (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 1
LETREC o_param_z (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 2
LETREC o_diffuse (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 0
LETREC o_hilight (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 1
LETREC o_color_red (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 0
LETREC o_color_green (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 1
LETREC o_color_blue (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 2
LETREC o_param_r1 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 0
LETREC o_param_r2 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 1
LETREC o_param_r3 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 2
LETREC o_param_ctbl (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (m_ctbl : VAR of )
    VAR m
    VAR m_ctbl
LETREC p_rgb (VAR of )
  (pixel : VAR of )
  (m_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_rgb
LETREC p_intersection_points (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (m_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_isect_ps
LETREC p_surface_ids (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (m_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_sids
LETREC p_calc_diffuse (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (m_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_cdif
LETREC p_energy (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (m_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_engy
LETREC p_received_ray_20percent (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (m_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_r20p
LETREC p_group_id (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    GET
      VAR m_gid
      INT 0
LETREC p_set_group_id (VAR of )
  (pixel : VAR of ), (id : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    PUT
      VAR m_gid
      INT 0
      VAR id
LETREC p_nvectors (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (m_nvectors : VAR of )
    VAR pixel
    VAR m_nvectors
LETREC d_vec (VAR of )
  (d : VAR of )
  (m_vec : VAR of ), (xm_const : VAR of )
    VAR d
    VAR m_vec
LETREC d_const (VAR of )
  (d : VAR of )
  (dm_vec : VAR of ), (m_const : VAR of )
    VAR d
    VAR m_const
LETREC r_surface_id (VAR of )
  (r : VAR of )
  (m_sid : VAR of ), (xm_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_sid
LETREC r_dvec (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (m_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_dvec
LETREC r_bright (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (xm_dvec : VAR of ), (m_br : VAR of )
    VAR r
    VAR m_br
LETREC rad (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.017453293
LETREC read_screen_settings (VAR of )
  (Tu23 : VAR of )
  LET Tu37 (UNIT)
    PUT
      VAR screen
      INT 0
      UNKNOWN APP        inflt
        UNIT
  LET Tu36 (UNIT)
    PUT
      VAR screen
      INT 1
      UNKNOWN APP        inflt
        UNIT
  LET Tu35 (UNIT)
    PUT
      VAR screen
      INT 2
      UNKNOWN APP        inflt
        UNIT
  LET v1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v1 (VAR of )
    APP
      VAR cos
      VAR v1
  LET sin_v1 (VAR of )
    APP
      VAR sin
      VAR v1
  LET v2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v2 (VAR of )
    APP
      VAR cos
      VAR v2
  LET sin_v2 (VAR of )
    APP
      VAR sin
      VAR v2
  LET Tu34 (UNIT)
    PUT
      VAR screenz_dir
      INT 0
      FMUL
        FMUL
          VAR cos_v1
          VAR sin_v2
        FLOAT 200.
  LET Tu33 (UNIT)
    PUT
      VAR screenz_dir
      INT 1
      FMUL
        VAR sin_v1
        FLOAT -200.
  LET Tu32 (UNIT)
    PUT
      VAR screenz_dir
      INT 2
      FMUL
        FMUL
          VAR cos_v1
          VAR cos_v2
        FLOAT 200.
  LET Tu31 (UNIT)
    PUT
      VAR screenx_dir
      INT 0
      VAR cos_v2
  LET Tu30 (UNIT)
    PUT
      VAR screenx_dir
      INT 1
      FLOAT 0.
  LET Tu29 (UNIT)
    PUT
      VAR screenx_dir
      INT 2
      NEG
        VAR sin_v2
  LET Tu28 (UNIT)
    PUT
      VAR screeny_dir
      INT 0
      FMUL
        NEG
          VAR sin_v1
        VAR sin_v2
  LET Tu27 (UNIT)
    PUT
      VAR screeny_dir
      INT 1
      NEG
        VAR cos_v1
  LET Tu26 (UNIT)
    PUT
      VAR screeny_dir
      INT 2
      FMUL
        NEG
          VAR sin_v1
        VAR cos_v2
  LET Tu25 (UNIT)
    PUT
      VAR viewpoint
      INT 0
      FSUB
        GET
          VAR screen
          INT 0
        GET
          VAR screenz_dir
          INT 0
  LET Tu24 (UNIT)
    PUT
      VAR viewpoint
      INT 1
      FSUB
        GET
          VAR screen
          INT 1
        GET
          VAR screenz_dir
          INT 1
  PUT
    VAR viewpoint
    INT 2
    FSUB
      GET
        VAR screen
        INT 2
      GET
        VAR screenz_dir
        INT 2
LETREC read_light (VAR of )
  (Tu38 : VAR of )
  LET nl (VAR of )
    UNKNOWN APP      inint
      UNIT
  LET l1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET sl1 (VAR of )
    APP
      VAR sin
      VAR l1
  LET Tu41 (UNIT)
    PUT
      VAR light
      INT 1
      NEG
        VAR sl1
  LET l2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cl1 (VAR of )
    APP
      VAR cos
      VAR l1
  LET sl2 (VAR of )
    APP
      VAR sin
      VAR l2
  LET Tu40 (UNIT)
    PUT
      VAR light
      INT 0
      FMUL
        VAR cl1
        VAR sl2
  LET cl2 (VAR of )
    APP
      VAR cos
      VAR l2
  LET Tu39 (UNIT)
    PUT
      VAR light
      INT 2
      FMUL
        VAR cl1
        VAR cl2
  PUT
    VAR beam
    INT 0
    UNKNOWN APP      inflt
      UNIT
LETREC rotate_quadratic_matrix (VAR of )
  (abc : VAR of ), (rot : VAR of )
  LET cos_x (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 0
  LET sin_x (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 0
  LET cos_y (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 1
  LET sin_y (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 1
  LET cos_z (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 2
  LET sin_z (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 2
  LET m00 (VAR of )
    FMUL
      VAR cos_y
      VAR cos_z
  LET m01 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR cos_x
        VAR sin_z
  LET m02 (VAR of )
    FADD
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR sin_x
        VAR sin_z
  LET m10 (VAR of )
    FMUL
      VAR cos_y
      VAR sin_z
  LET m11 (VAR of )
    FADD
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR cos_x
        VAR cos_z
  LET m12 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR sin_x
        VAR cos_z
  LET m20 (VAR of )
    NEG
      VAR sin_y
  LET m21 (VAR of )
    FMUL
      VAR sin_x
      VAR cos_y
  LET m22 (VAR of )
    FMUL
      VAR cos_x
      VAR cos_y
  LET ao (VAR of )
    GET
      VAR abc
      INT 0
  LET bo (VAR of )
    GET
      VAR abc
      INT 1
  LET co (VAR of )
    GET
      VAR abc
      INT 2
  LET Tu46 (UNIT)
    PUT
      VAR abc
      INT 0
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m00
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m10
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m20
  LET Tu45 (UNIT)
    PUT
      VAR abc
      INT 1
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m01
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m11
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m21
  LET Tu44 (UNIT)
    PUT
      VAR abc
      INT 2
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m02
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m12
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m22
  LET Tu43 (UNIT)
    PUT
      VAR rot
      INT 0
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m01
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m11
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m21
            VAR m22
  LET Tu42 (UNIT)
    PUT
      VAR rot
      INT 1
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m00
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m10
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m20
            VAR m22
  PUT
    VAR rot
    INT 2
    FMUL
      FLOAT 2.
      FADD
        FADD
          FMUL
            FMUL
              VAR ao
              VAR m00
            VAR m01
          FMUL
            FMUL
              VAR bo
              VAR m10
            VAR m11
        FMUL
          FMUL
            VAR co
            VAR m20
          VAR m21
LETREC read_nth_object (VAR of )
  (n : VAR of )
  LET texture (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    NOT
      EQ
        VAR texture
        NEG
          INT 1
    LET form (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET refltype (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET isrot_p (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET abc (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu65 (UNIT)
      PUT
        VAR abc
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu64 (UNIT)
      PUT
        VAR abc
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu63 (UNIT)
      PUT
        VAR abc
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET xyz (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu62 (UNIT)
      PUT
        VAR xyz
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu61 (UNIT)
      PUT
        VAR xyz
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu60 (UNIT)
      PUT
        VAR xyz
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET m_invert (VAR of )
      FLt
        UNKNOWN APP          inflt
          UNIT
        FLOAT 0.
    LET reflparam (VAR of )
      ARRAY
        INT 2
        FLOAT 0.
    LET Tu59 (UNIT)
      PUT
        VAR reflparam
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu58 (UNIT)
      PUT
        VAR reflparam
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET color (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu57 (UNIT)
      PUT
        VAR color
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu56 (UNIT)
      PUT
        VAR color
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu55 (UNIT)
      PUT
        VAR color
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET rotation (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu54 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        LET Tu48 (UNIT)
          PUT
            VAR rotation
            INT 0
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        LET Tu47 (UNIT)
          PUT
            VAR rotation
            INT 1
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        PUT
          VAR rotation
          INT 2
          APP
            VAR rad
            UNKNOWN APP              inflt
              UNIT
        UNIT
    LET m_invert2 (VAR of )
      IF
        EQ
          VAR form
          INT 2
        BOOL true
        VAR m_invert
    LET ctbl (VAR of )
      ARRAY
        INT 4
        FLOAT 0.
    LET obj (VAR of )
      TUPLE
        VAR texture
        VAR form
        VAR refltype
        VAR isrot_p
        VAR abc
        VAR xyz
        VAR m_invert2
        VAR reflparam
        VAR color
        VAR rotation
        VAR ctbl
    LET Tu53 (UNIT)
      PUT
        VAR objects
        VAR n
        VAR obj
    LET Tu52 (UNIT)
      IF
        EQ
          VAR form
          INT 3
        LET a (VAR of )
          GET
            VAR abc
            INT 0
        LET Tu50 (UNIT)
          PUT
            VAR abc
            INT 0
            IF
              FZero?
                VAR a
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR a
                APP
                  VAR fsqr
                  VAR a
        LET b (VAR of )
          GET
            VAR abc
            INT 1
        LET Tu49 (UNIT)
          PUT
            VAR abc
            INT 1
            IF
              FZero?
                VAR b
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR b
                APP
                  VAR fsqr
                  VAR b
        LET c (VAR of )
          GET
            VAR abc
            INT 2
        PUT
          VAR abc
          INT 2
          IF
            FZero?
              VAR c
            FLOAT 0.
            FDIV
              APP
                VAR sgn
                VAR c
              APP
                VAR fsqr
                VAR c
        IF
          EQ
            VAR form
            INT 2
          APP
            VAR vecunit_sgn
            VAR abc
            NOT
              VAR m_invert
          UNIT
    LET Tu51 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        APP
          VAR rotate_quadratic_matrix
          VAR abc
          VAR rotation
        UNIT
    BOOL true
    BOOL false
LETREC read_object (VAR of )
  (n : VAR of )
  IF
    NOT
      LE
        INT 60
        VAR n
    IF
      APP
        VAR read_nth_object
        VAR n
      APP
        VAR read_object
        ADD
          VAR n
          INT 1
      PUT
        VAR n_objects
        INT 0
        VAR n
    UNIT
LETREC read_all_object (VAR of )
  (Tu66 : VAR of )
  APP
    VAR read_object
    INT 0
LETREC read_net_item (VAR of )
  (length : VAR of )
  LET item (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    EQ
      VAR item
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      NEG
        INT 1
    LET v (VAR of )
      APP
        VAR read_net_item
        ADD
          VAR length
          INT 1
    LET Tu67 (UNIT)
      PUT
        VAR v
        VAR length
        VAR item
    VAR v
LETREC read_or_network (VAR of )
  (length : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      VAR net
    LET v (VAR of )
      APP
        VAR read_or_network
        ADD
          VAR length
          INT 1
    LET Tu68 (UNIT)
      PUT
        VAR v
        VAR length
        VAR net
    VAR v
LETREC read_and_network (VAR of )
  (n : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    UNIT
    LET Tu69 (UNIT)
      PUT
        VAR and_net
        VAR n
        VAR net
    APP
      VAR read_and_network
      ADD
        VAR n
        INT 1
LETREC read_parameter (VAR of )
  (Tu70 : VAR of )
  LET Tu74 (UNIT)
    APP
      VAR read_screen_settings
      UNIT
  LET Tu73 (UNIT)
    APP
      VAR read_light
      UNIT
  LET Tu72 (UNIT)
    APP
      VAR read_all_object
      UNIT
  LET Tu71 (UNIT)
    APP
      VAR read_and_network
      INT 0
  PUT
    VAR or_net
    INT 0
    APP
      VAR read_or_network
      INT 0
LETREC solver_rect_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of ), (i0 : VAR of ), (i1 : VAR of ), (i2 : VAR of )
  IF
    FZero?
      GET
        VAR dirvec
        VAR i0
    BOOL false
    LET abc (VAR of )
      APP
        VAR o_param_abc
        VAR m
    LET d (VAR of )
      APP
        VAR fneg_cond
        APP
          VAR xor
          APP
            VAR o_isinvert
            VAR m
          FLt
            GET
              VAR dirvec
              VAR i0
            FLOAT 0.
        GET
          VAR abc
          VAR i0
    LET d2 (VAR of )
      FDIV
        FSUB
          VAR d
          VAR b0
        GET
          VAR dirvec
          VAR i0
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d2
              GET
                VAR dirvec
                VAR i1
            VAR b1
        GET
          VAR abc
          VAR i1
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d2
                GET
                  VAR dirvec
                  VAR i2
              VAR b2
          GET
            VAR abc
            VAR i2
        LET Tu75 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        BOOL true
        BOOL false
      BOOL false
LETREC solver_rect (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR solver_rect_surface
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
      INT 0
      INT 1
      INT 2
    INT 1
    IF
      APP
        VAR solver_rect_surface
        VAR m
        VAR dirvec
        VAR b1
        VAR b2
        VAR b0
        INT 1
        INT 2
        INT 0
      INT 2
      IF
        APP
          VAR solver_rect_surface
          VAR m
          VAR dirvec
          VAR b2
          VAR b0
          VAR b1
          INT 2
          INT 0
          INT 1
        INT 3
        INT 0
LETREC solver_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET abc (VAR of )
    APP
      VAR o_param_abc
      VAR m
  LET d (VAR of )
    APP
      VAR veciprod
      VAR dirvec
      VAR abc
  IF
    FLt
      FLOAT 0.
      VAR d
    LET Tu76 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FDIV
          NEG
            APP
              VAR veciprod2
              VAR abc
              VAR b0
              VAR b1
              VAR b2
          VAR d
    INT 1
    INT 0
LETREC quadratic (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          APP
            VAR fsqr
            VAR v0
          APP
            VAR o_param_a
            VAR m
        FMUL
          APP
            VAR fsqr
            VAR v1
          APP
            VAR o_param_b
            VAR m
      FMUL
        APP
          VAR fsqr
          VAR v2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      FADD
        FADD
          VAR diag_part
          FMUL
            FMUL
              VAR v1
              VAR v2
            APP
              VAR o_param_r1
              VAR m
        FMUL
          FMUL
            VAR v2
            VAR v0
          APP
            VAR o_param_r2
            VAR m
      FMUL
        FMUL
          VAR v0
          VAR v1
        APP
          VAR o_param_r3
          VAR m
LETREC bilinear (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          FMUL
            VAR v0
            VAR w0
          APP
            VAR o_param_a
            VAR m
        FMUL
          FMUL
            VAR v1
            VAR w1
          APP
            VAR o_param_b
            VAR m
      FMUL
        FMUL
          VAR v2
          VAR w2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      VAR diag_part
      APP
        VAR fhalf
        FADD
          FADD
            FMUL
              FADD
                FMUL
                  VAR v2
                  VAR w1
                FMUL
                  VAR v1
                  VAR w2
              APP
                VAR o_param_r1
                VAR m
            FMUL
              FADD
                FMUL
                  VAR v0
                  VAR w2
                FMUL
                  VAR v2
                  VAR w0
              APP
                VAR o_param_r2
                VAR m
          FMUL
            FADD
              FMUL
                VAR v0
                VAR w1
              FMUL
                VAR v1
                VAR w0
            APP
              VAR o_param_r3
              VAR m
LETREC solver_second (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR dirvec
        INT 0
      GET
        VAR dirvec
        INT 1
      GET
        VAR dirvec
        INT 2
  IF
    FZero?
      VAR aa
    INT 0
    LET bb (VAR of )
      APP
        VAR bilinear
        VAR m
        GET
          VAR dirvec
          INT 0
        GET
          VAR dirvec
          INT 1
        GET
          VAR dirvec
          INT 2
        VAR b0
        VAR b1
        VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR bb
        FMUL
          VAR aa
          VAR cc
    IF
      FLt
        FLOAT 0.
        VAR d
      LET sd (VAR of )
        APP
          VAR sqrt
          VAR d
      LET t1 (VAR of )
        IF
          APP
            VAR o_isinvert
            VAR m
          VAR sd
          NEG
            VAR sd
      LET Tu77 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          FDIV
            FSUB
              VAR t1
              VAR bb
            VAR aa
      INT 1
      INT 0
LETREC solver (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
LETREC solver_rect_fast (VAR of )
  (m : VAR of ), (v : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET d0 (VAR of )
    FMUL
      FSUB
        GET
          VAR dconst
          INT 0
        VAR b0
      GET
        VAR dconst
        INT 1
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d0
              GET
                VAR v
                INT 1
            VAR b1
        APP
          VAR o_param_b
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d0
                GET
                  VAR v
                  INT 2
              VAR b2
          APP
            VAR o_param_c
            VAR m
        NOT
          FZero?
            GET
              VAR dconst
              INT 1
        BOOL false
      BOOL false
    LET Tu78 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        VAR d0
    INT 1
    LET d1 (VAR of )
      FMUL
        FSUB
          GET
            VAR dconst
            INT 2
          VAR b1
        GET
          VAR dconst
          INT 3
    IF
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d1
                GET
                  VAR v
                  INT 0
              VAR b0
          APP
            VAR o_param_a
            VAR m
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d1
                  GET
                    VAR v
                    INT 2
                VAR b2
            APP
              VAR o_param_c
              VAR m
          NOT
            FZero?
              GET
                VAR dconst
                INT 3
          BOOL false
        BOOL false
      LET Tu79 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          VAR d1
      INT 2
      LET d2 (VAR of )
        FMUL
          FSUB
            GET
              VAR dconst
              INT 4
            VAR b2
          GET
            VAR dconst
            INT 5
      IF
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d2
                  GET
                    VAR v
                    INT 0
                VAR b0
            APP
              VAR o_param_a
              VAR m
          IF
            APP
              VAR fless
              APP
                VAR fabs
                FADD
                  FMUL
                    VAR d2
                    GET
                      VAR v
                      INT 1
                  VAR b1
              APP
                VAR o_param_b
                VAR m
            NOT
              FZero?
                GET
                  VAR dconst
                  INT 5
            BOOL false
          BOOL false
        LET Tu80 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        INT 3
        INT 0
LETREC solver_surface_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    FLt
      GET
        VAR dconst
        INT 0
      FLOAT 0.
    LET Tu81 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FADD
          FADD
            FMUL
              GET
                VAR dconst
                INT 1
              VAR b0
            FMUL
              GET
                VAR dconst
                INT 2
              VAR b1
          FMUL
            GET
              VAR dconst
              INT 3
            VAR b2
    INT 1
    INT 0
LETREC solver_second_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      FLt
        FLOAT 0.
        VAR d
      LET Tu82 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
LETREC solver_surface_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    FLt
      GET
        VAR dconst
        INT 0
      FLOAT 0.
    LET Tu83 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FMUL
          GET
            VAR dconst
            INT 0
          GET
            VAR sconst
            INT 3
    INT 1
    INT 0
LETREC solver_second_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc (VAR of )
      GET
        VAR sconst
        INT 3
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      FLt
        FLOAT 0.
        VAR d
      LET Tu84 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast2 (VAR of )
  (index : VAR of ), (dirvec : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET sconst (VAR of )
    APP
      VAR o_param_ctbl
      VAR m
  LET b0 (VAR of )
    GET
      VAR sconst
      INT 0
  LET b1 (VAR of )
    GET
      VAR sconst
      INT 1
  LET b2 (VAR of )
    GET
      VAR sconst
      INT 2
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
LETREC setup_rect_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 6
      FLOAT 0.
  LET Tu90 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 0
      PUT
        VAR const
        INT 1
        FLOAT 0.
      LET Tu85 (UNIT)
        PUT
          VAR const
          INT 0
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              FLt
                GET
                  VAR vec
                  INT 0
                FLOAT 0.
            APP
              VAR o_param_a
              VAR m
      PUT
        VAR const
        INT 1
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 0
  LET Tu89 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 1
      PUT
        VAR const
        INT 3
        FLOAT 0.
      LET Tu86 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              FLt
                GET
                  VAR vec
                  INT 1
                FLOAT 0.
            APP
              VAR o_param_b
              VAR m
      PUT
        VAR const
        INT 3
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 1
  LET Tu88 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 2
      PUT
        VAR const
        INT 5
        FLOAT 0.
      LET Tu87 (UNIT)
        PUT
          VAR const
          INT 4
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              FLt
                GET
                  VAR vec
                  INT 2
                FLOAT 0.
            APP
              VAR o_param_c
              VAR m
      PUT
        VAR const
        INT 5
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 2
  VAR const
LETREC setup_surface_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 4
      FLOAT 0.
  LET d (VAR of )
    FADD
      FADD
        FMUL
          GET
            VAR vec
            INT 0
          APP
            VAR o_param_a
            VAR m
        FMUL
          GET
            VAR vec
            INT 1
          APP
            VAR o_param_b
            VAR m
      FMUL
        GET
          VAR vec
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu94 (UNIT)
    IF
      FLt
        FLOAT 0.
        VAR d
      LET Tu93 (UNIT)
        PUT
          VAR const
          INT 0
          FDIV
            FLOAT -1.
            VAR d
      LET Tu92 (UNIT)
        PUT
          VAR const
          INT 1
          NEG
            FDIV
              APP
                VAR o_param_a
                VAR m
              VAR d
      LET Tu91 (UNIT)
        PUT
          VAR const
          INT 2
          NEG
            FDIV
              APP
                VAR o_param_b
                VAR m
              VAR d
      PUT
        VAR const
        INT 3
        NEG
          FDIV
            APP
              VAR o_param_c
              VAR m
            VAR d
      PUT
        VAR const
        INT 0
        FLOAT 0.
  VAR const
LETREC setup_second_table (VAR of )
  (v : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 5
      FLOAT 0.
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
      GET
        VAR v
        INT 2
  LET c1 (VAR of )
    NEG
      FMUL
        GET
          VAR v
          INT 0
        APP
          VAR o_param_a
          VAR m
  LET c2 (VAR of )
    NEG
      FMUL
        GET
          VAR v
          INT 1
        APP
          VAR o_param_b
          VAR m
  LET c3 (VAR of )
    NEG
      FMUL
        GET
          VAR v
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu101 (UNIT)
    PUT
      VAR const
      INT 0
      VAR aa
  LET Tu100 (UNIT)
    IF
      NOT
        EQ
          APP
            VAR o_isrot
            VAR m
          INT 0
      LET Tu96 (UNIT)
        PUT
          VAR const
          INT 1
          FSUB
            VAR c1
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r2
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 1
                  APP
                    VAR o_param_r3
                    VAR m
      LET Tu95 (UNIT)
        PUT
          VAR const
          INT 2
          FSUB
            VAR c2
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r1
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 0
                  APP
                    VAR o_param_r3
                    VAR m
      PUT
        VAR const
        INT 3
        FSUB
          VAR c3
          APP
            VAR fhalf
            FADD
              FMUL
                GET
                  VAR v
                  INT 1
                APP
                  VAR o_param_r1
                  VAR m
              FMUL
                GET
                  VAR v
                  INT 0
                APP
                  VAR o_param_r2
                  VAR m
      LET Tu98 (UNIT)
        PUT
          VAR const
          INT 1
          VAR c1
      LET Tu97 (UNIT)
        PUT
          VAR const
          INT 2
          VAR c2
      PUT
        VAR const
        INT 3
        VAR c3
  LET Tu99 (UNIT)
    IF
      NOT
        FZero?
          VAR aa
      PUT
        VAR const
        INT 4
        FDIV
          FLOAT 1.
          VAR aa
      UNIT
  VAR const
LETREC iter_setup_dirvec_constants (VAR of )
  (dirvec : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET m (VAR of )
      GET
        VAR objects
        VAR index
    LET dconst (VAR of )
      APP
        VAR d_const
        VAR dirvec
    LET v (VAR of )
      APP
        VAR d_vec
        VAR dirvec
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR m
    LET Tu102 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 1
        PUT
          VAR dconst
          VAR index
          APP
            VAR setup_rect_table
            VAR v
            VAR m
        IF
          EQ
            VAR m_shape
            INT 2
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_surface_table
              VAR v
              VAR m
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_second_table
              VAR v
              VAR m
    APP
      VAR iter_setup_dirvec_constants
      VAR dirvec
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_dirvec_constants (VAR of )
  (dirvec : VAR of )
  APP
    VAR iter_setup_dirvec_constants
    VAR dirvec
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC setup_startp_constants (VAR of )
  (p : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET obj (VAR of )
      GET
        VAR objects
        VAR index
    LET sconst (VAR of )
      APP
        VAR o_param_ctbl
        VAR obj
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR obj
    LET Tu106 (UNIT)
      PUT
        VAR sconst
        INT 0
        FSUB
          GET
            VAR p
            INT 0
          APP
            VAR o_param_x
            VAR obj
    LET Tu105 (UNIT)
      PUT
        VAR sconst
        INT 1
        FSUB
          GET
            VAR p
            INT 1
          APP
            VAR o_param_y
            VAR obj
    LET Tu104 (UNIT)
      PUT
        VAR sconst
        INT 2
        FSUB
          GET
            VAR p
            INT 2
          APP
            VAR o_param_z
            VAR obj
    LET Tu103 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 2
        PUT
          VAR sconst
          INT 3
          APP
            VAR veciprod2
            APP
              VAR o_param_abc
              VAR obj
            GET
              VAR sconst
              INT 0
            GET
              VAR sconst
              INT 1
            GET
              VAR sconst
              INT 2
        IF
          NOT
            LE
              VAR m_shape
              INT 2
          LET cc0 (VAR of )
            APP
              VAR quadratic
              VAR obj
              GET
                VAR sconst
                INT 0
              GET
                VAR sconst
                INT 1
              GET
                VAR sconst
                INT 2
          PUT
            VAR sconst
            INT 3
            IF
              EQ
                VAR m_shape
                INT 3
              FSUB
                VAR cc0
                FLOAT 1.
              VAR cc0
          UNIT
    APP
      VAR setup_startp_constants
      VAR p
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_startp (VAR of )
  (p : VAR of )
  LET Tu107 (UNIT)
    APP
      VAR veccpy
      VAR startp_fast
      VAR p
  APP
    VAR setup_startp_constants
    VAR p
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC is_rect_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          VAR p0
        APP
          VAR o_param_a
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            VAR p1
          APP
            VAR o_param_b
            VAR m
        APP
          VAR fless
          APP
            VAR fabs
            VAR p2
          APP
            VAR o_param_c
            VAR m
        BOOL false
      BOOL false
    APP
      VAR o_isinvert
      VAR m
    NOT
      APP
        VAR o_isinvert
        VAR m
LETREC is_plane_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR veciprod2
      APP
        VAR o_param_abc
        VAR m
      VAR p0
      VAR p1
      VAR p2
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      FLt
        VAR w
        FLOAT 0.
LETREC is_second_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR quadratic
      VAR m
      VAR p0
      VAR p1
      VAR p2
  LET w2 (VAR of )
    IF
      EQ
        APP
          VAR o_form
          VAR m
        INT 3
      FSUB
        VAR w
        FLOAT 1.
      VAR w
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      FLt
        VAR w2
        FLOAT 0.
LETREC is_outside (VAR of )
  (m : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET p0 (VAR of )
    FSUB
      VAR q0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      VAR q1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      VAR q2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR is_rect_outside
      VAR m
      VAR p0
      VAR p1
      VAR p2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR is_plane_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
      APP
        VAR is_second_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
LETREC check_all_inside (VAR of )
  (ofs : VAR of ), (iand : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET head (VAR of )
    GET
      VAR iand
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL true
    IF
      APP
        VAR is_outside
        GET
          VAR objects
          VAR head
        VAR q0
        VAR q1
        VAR q2
      BOOL false
      APP
        VAR check_all_inside
        ADD
          VAR ofs
          INT 1
        VAR iand
        VAR q0
        VAR q1
        VAR q2
LETREC shadow_check_and_group (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of )
  IF
    EQ
      GET
        VAR and_group
        VAR iand_ofs
      NEG
        INT 1
    BOOL false
    LET obj (VAR of )
      GET
        VAR and_group
        VAR iand_ofs
    LET t0 (VAR of )
      APP
        VAR solver_fast
        VAR obj
        VAR light_dirvec
        VAR intersection_point
    LET t0p (VAR of )
      GET
        VAR solver_dist
        INT 0
    IF
      IF
        NOT
          EQ
            VAR t0
            INT 0
        APP
          VAR fless
          VAR t0p
          FLOAT -0.2
        BOOL false
      LET t (VAR of )
        FADD
          VAR t0p
          FLOAT 0.01
      LET q0 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 0
            VAR t
          GET
            VAR intersection_point
            INT 0
      LET q1 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 1
            VAR t
          GET
            VAR intersection_point
            INT 1
      LET q2 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 2
            VAR t
          GET
            VAR intersection_point
            INT 2
      IF
        APP
          VAR check_all_inside
          INT 0
          VAR and_group
          VAR q0
          VAR q1
          VAR q2
        BOOL true
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR obj
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
        BOOL false
LETREC shadow_check_one_or_group (VAR of )
  (ofs : VAR of ), (or_group : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL false
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET shadow_p (VAR of )
      APP
        VAR shadow_check_and_group
        INT 0
        VAR and_group
    IF
      VAR shadow_p
      BOOL true
      APP
        VAR shadow_check_one_or_group
        ADD
          VAR ofs
          INT 1
        VAR or_group
LETREC shadow_check_one_or_matrix (VAR of )
  (ofs : VAR of ), (or_matrix : VAR of )
  LET head (VAR of )
    GET
      VAR or_matrix
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    BOOL false
    IF
      IF
        EQ
          VAR range_primitive
          INT 99
        BOOL true
        LET t (VAR of )
          APP
            VAR solver_fast
            VAR range_primitive
            VAR light_dirvec
            VAR intersection_point
        IF
          NOT
            EQ
              VAR t
              INT 0
          IF
            APP
              VAR fless
              GET
                VAR solver_dist
                INT 0
              FLOAT -0.1
            IF
              APP
                VAR shadow_check_one_or_group
                INT 1
                VAR head
              BOOL true
              BOOL false
            BOOL false
          BOOL false
      IF
        APP
          VAR shadow_check_one_or_group
          INT 1
          VAR head
        BOOL true
        APP
          VAR shadow_check_one_or_matrix
          ADD
            VAR ofs
            INT 1
          VAR or_matrix
      APP
        VAR shadow_check_one_or_matrix
        ADD
          VAR ofs
          INT 1
        VAR or_matrix
LETREC solve_each_element (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver
        VAR iobj
        VAR dirvec
        VAR startp
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu111 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 0
                  VAR t
                GET
                  VAR startp
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 1
                  VAR t
                GET
                  VAR startp
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 2
                  VAR t
                GET
                  VAR startp
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu110 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu109 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu108 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu112 (UNIT)
      APP
        VAR solve_each_element
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu113 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver
            VAR range_primitive
            VAR dirvec
            VAR startp
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection (VAR of )
  (dirvec : VAR of )
  LET Tu115 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu114 (UNIT)
    APP
      VAR trace_or_matrix
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC solve_each_element_fast (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET vec (VAR of )
    APP
      VAR d_vec
      VAR dirvec
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver_fast2
        VAR iobj
        VAR dirvec
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu119 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 0
                  VAR t
                GET
                  VAR startp_fast
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 1
                  VAR t
                GET
                  VAR startp_fast
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 2
                  VAR t
                GET
                  VAR startp_fast
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu118 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu117 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu116 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element_fast
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element_fast
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network_fast (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu120 (UNIT)
      APP
        VAR solve_each_element_fast
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network_fast
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix_fast (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu121 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network_fast
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver_fast2
            VAR range_primitive
            VAR dirvec
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network_fast
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix_fast
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection_fast (VAR of )
  (dirvec : VAR of )
  LET Tu123 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu122 (UNIT)
    APP
      VAR trace_or_matrix_fast
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC get_nvector_rect (VAR of )
  (dirvec : VAR of )
  LET rectside (VAR of )
    GET
      VAR intsec_rectside
      INT 0
  LET Tu124 (UNIT)
    APP
      VAR vecbzero
      VAR nvector
  PUT
    VAR nvector
    SUB
      VAR rectside
      INT 1
    NEG
      APP
        VAR sgn
        GET
          VAR dirvec
          SUB
            VAR rectside
            INT 1
LETREC get_nvector_plane (VAR of )
  (m : VAR of )
  LET Tu126 (UNIT)
    PUT
      VAR nvector
      INT 0
      NEG
        APP
          VAR o_param_a
          VAR m
  LET Tu125 (UNIT)
    PUT
      VAR nvector
      INT 1
      NEG
        APP
          VAR o_param_b
          VAR m
  PUT
    VAR nvector
    INT 2
    NEG
      APP
        VAR o_param_c
        VAR m
LETREC get_nvector_second (VAR of )
  (m : VAR of )
  LET p0 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET d0 (VAR of )
    FMUL
      VAR p0
      APP
        VAR o_param_a
        VAR m
  LET d1 (VAR of )
    FMUL
      VAR p1
      APP
        VAR o_param_b
        VAR m
  LET d2 (VAR of )
    FMUL
      VAR p2
      APP
        VAR o_param_c
        VAR m
  LET Tu131 (UNIT)
    IF
      EQ
        APP
          VAR o_isrot
          VAR m
        INT 0
      LET Tu128 (UNIT)
        PUT
          VAR nvector
          INT 0
          VAR d0
      LET Tu127 (UNIT)
        PUT
          VAR nvector
          INT 1
          VAR d1
      PUT
        VAR nvector
        INT 2
        VAR d2
      LET Tu130 (UNIT)
        PUT
          VAR nvector
          INT 0
          FADD
            VAR d0
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p1
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r2
                    VAR m
      LET Tu129 (UNIT)
        PUT
          VAR nvector
          INT 1
          FADD
            VAR d1
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p0
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r1
                    VAR m
      PUT
        VAR nvector
        INT 2
        FADD
          VAR d2
          APP
            VAR fhalf
            FADD
              FMUL
                VAR p0
                APP
                  VAR o_param_r2
                  VAR m
              FMUL
                VAR p1
                APP
                  VAR o_param_r1
                  VAR m
  APP
    VAR vecunit_sgn
    VAR nvector
    APP
      VAR o_isinvert
      VAR m
LETREC get_nvector (VAR of )
  (m : VAR of ), (dirvec : VAR of )
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR get_nvector_rect
      VAR dirvec
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR get_nvector_plane
        VAR m
      APP
        VAR get_nvector_second
        VAR m
LETREC utexture (VAR of )
  (m : VAR of ), (p : VAR of )
  LET m_tex (VAR of )
    APP
      VAR o_texturetype
      VAR m
  LET Tu136 (UNIT)
    PUT
      VAR texture_color
      INT 0
      APP
        VAR o_color_red
        VAR m
  LET Tu135 (UNIT)
    PUT
      VAR texture_color
      INT 1
      APP
        VAR o_color_green
        VAR m
  LET Tu134 (UNIT)
    PUT
      VAR texture_color
      INT 2
      APP
        VAR o_color_blue
        VAR m
  IF
    EQ
      VAR m_tex
      INT 1
    LET w1 (VAR of )
      FSUB
        GET
          VAR p
          INT 0
        APP
          VAR o_param_x
          VAR m
    LET flag1 (VAR of )
      LET d1 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w1
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w1
          VAR d1
        FLOAT 10.
    LET w3 (VAR of )
      FSUB
        GET
          VAR p
          INT 2
        APP
          VAR o_param_z
          VAR m
    LET flag2 (VAR of )
      LET d2 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w3
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w3
          VAR d2
        FLOAT 10.
    PUT
      VAR texture_color
      INT 1
      IF
        VAR flag1
        IF
          VAR flag2
          FLOAT 255.
          FLOAT 0.
        IF
          VAR flag2
          FLOAT 0.
          FLOAT 255.
    IF
      EQ
        VAR m_tex
        INT 2
      LET w2 (VAR of )
        APP
          VAR fsqr
          APP
            VAR sin
            FMUL
              GET
                VAR p
                INT 1
              FLOAT 0.25
      LET Tu132 (UNIT)
        PUT
          VAR texture_color
          INT 0
          FMUL
            FLOAT 255.
            VAR w2
      PUT
        VAR texture_color
        INT 1
        FMUL
          FLOAT 255.
          FSUB
            FLOAT 1.
            VAR w2
      IF
        EQ
          VAR m_tex
          INT 3
        LET w1 (VAR of )
          FSUB
            GET
              VAR p
              INT 0
            APP
              VAR o_param_x
              VAR m
        LET w3 (VAR of )
          FSUB
            GET
              VAR p
              INT 2
            APP
              VAR o_param_z
              VAR m
        LET w2 (VAR of )
          FDIV
            APP
              VAR sqrt
              FADD
                APP
                  VAR fsqr
                  VAR w1
                APP
                  VAR fsqr
                  VAR w3
            FLOAT 10.
        LET w4 (VAR of )
          FMUL
            FSUB
              VAR w2
              APP
                VAR floor
                VAR w2
            FLOAT 3.1415927
        LET cws (VAR of )
          APP
            VAR fsqr
            APP
              VAR cos
              VAR w4
        LET Tu133 (UNIT)
          PUT
            VAR texture_color
            INT 1
            FMUL
              VAR cws
              FLOAT 255.
        PUT
          VAR texture_color
          INT 2
          FMUL
            FSUB
              FLOAT 1.
              VAR cws
            FLOAT 255.
        IF
          EQ
            VAR m_tex
            INT 4
          LET w1 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 0
                APP
                  VAR o_param_x
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_a
                  VAR m
          LET w3 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 2
                APP
                  VAR o_param_z
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_c
                  VAR m
          LET w4 (VAR of )
            FADD
              APP
                VAR fsqr
                VAR w1
              APP
                VAR fsqr
                VAR w3
          LET w7 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w1
                FLOAT 0.0001
              FLOAT 15.
              LET w5 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w3
                    VAR w1
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w5
                  FLOAT 30.
                FLOAT 3.1415927
          LET w9 (VAR of )
            FSUB
              VAR w7
              APP
                VAR floor
                VAR w7
          LET w2 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 1
                APP
                  VAR o_param_y
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_b
                  VAR m
          LET w8 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w4
                FLOAT 0.0001
              FLOAT 15.
              LET w6 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w2
                    VAR w4
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w6
                  FLOAT 30.
                FLOAT 3.1415927
          LET w10 (VAR of )
            FSUB
              VAR w8
              APP
                VAR floor
                VAR w8
          LET w11 (VAR of )
            FSUB
              FSUB
                FLOAT 0.15
                APP
                  VAR fsqr
                  FSUB
                    FLOAT 0.5
                    VAR w9
              APP
                VAR fsqr
                FSUB
                  FLOAT 0.5
                  VAR w10
          LET w12 (VAR of )
            IF
              FLt
                VAR w11
                FLOAT 0.
              FLOAT 0.
              VAR w11
          PUT
            VAR texture_color
            INT 2
            FDIV
              FMUL
                FLOAT 255.
                VAR w12
              FLOAT 0.3
          UNIT
LETREC add_light (VAR of )
  (bright : VAR of ), (hilight : VAR of ), (hilight_scale : VAR of )
  LET Tu139 (UNIT)
    IF
      FLt
        FLOAT 0.
        VAR bright
      APP
        VAR vecaccum
        VAR rgb
        VAR bright
        VAR texture_color
      UNIT
  IF
    FLt
      FLOAT 0.
      VAR hilight
    LET ihl (VAR of )
      FMUL
        APP
          VAR fsqr
          APP
            VAR fsqr
            VAR hilight
        VAR hilight_scale
    LET Tu138 (UNIT)
      PUT
        VAR rgb
        INT 0
        FADD
          GET
            VAR rgb
            INT 0
          VAR ihl
    LET Tu137 (UNIT)
      PUT
        VAR rgb
        INT 1
        FADD
          GET
            VAR rgb
            INT 1
          VAR ihl
    PUT
      VAR rgb
      INT 2
      FADD
        GET
          VAR rgb
          INT 2
        VAR ihl
    UNIT
LETREC trace_reflections (VAR of )
  (index : VAR of ), (diffuse : VAR of ), (hilight_scale : VAR of ), (dirvec : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET rinfo (VAR of )
      GET
        VAR reflections
        VAR index
    LET dvec (VAR of )
      APP
        VAR r_dvec
        VAR rinfo
    LET Tu140 (UNIT)
      IF
        APP
          VAR judge_intersection_fast
          VAR dvec
        LET surface_id (VAR of )
          ADD
            MULTIPLE 4
              GET
                VAR intersected_object_id
                INT 0
            GET
              VAR intsec_rectside
              INT 0
        IF
          EQ
            VAR surface_id
            APP
              VAR r_surface_id
              VAR rinfo
          IF
            NOT
              APP
                VAR shadow_check_one_or_matrix
                INT 0
                GET
                  VAR or_net
                  INT 0
            LET p (VAR of )
              APP
                VAR veciprod
                VAR nvector
                APP
                  VAR d_vec
                  VAR dvec
            LET scale (VAR of )
              APP
                VAR r_bright
                VAR rinfo
            LET bright (VAR of )
              FMUL
                FMUL
                  VAR scale
                  VAR diffuse
                VAR p
            LET hilight (VAR of )
              FMUL
                VAR scale
                APP
                  VAR veciprod
                  VAR dirvec
                  APP
                    VAR d_vec
                    VAR dvec
            APP
              VAR add_light
              VAR bright
              VAR hilight
              VAR hilight_scale
            UNIT
          UNIT
        UNIT
    APP
      VAR trace_reflections
      SUB
        VAR index
        INT 1
      VAR diffuse
      VAR hilight_scale
      VAR dirvec
    UNIT
LETREC trace_ray (VAR of )
  (nref : VAR of ), (energy : VAR of ), (dirvec : VAR of ), (pixel : VAR of ), (dist : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      APP
        VAR judge_intersection
        VAR dirvec
      LET obj_id (VAR of )
        GET
          VAR intersected_object_id
          INT 0
      LET obj (VAR of )
        GET
          VAR objects
          VAR obj_id
      LET m_surface (VAR of )
        APP
          VAR o_reflectiontype
          VAR obj
      LET diffuse (VAR of )
        FMUL
          APP
            VAR o_diffuse
            VAR obj
          VAR energy
      LET Tu154 (UNIT)
        APP
          VAR get_nvector
          VAR obj
          VAR dirvec
      LET Tu153 (UNIT)
        APP
          VAR veccpy
          VAR startp
          VAR intersection_point
      LET Tu152 (UNIT)
        APP
          VAR utexture
          VAR obj
          VAR intersection_point
      LET Tu151 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          ADD
            MULTIPLE 4
              VAR obj_id
            GET
              VAR intsec_rectside
              INT 0
      LET intersection_points (VAR of )
        APP
          VAR p_intersection_points
          VAR pixel
      LET Tu150 (UNIT)
        APP
          VAR veccpy
          GET
            VAR intersection_points
            VAR nref
          VAR intersection_point
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu149 (UNIT)
        IF
          APP
            VAR fless
            APP
              VAR o_diffuse
              VAR obj
            FLOAT 0.5
          PUT
            VAR calc_diffuse
            VAR nref
            BOOL false
          LET Tu143 (UNIT)
            PUT
              VAR calc_diffuse
              VAR nref
              BOOL true
          LET energya (VAR of )
            APP
              VAR p_energy
              VAR pixel
          LET Tu142 (UNIT)
            APP
              VAR veccpy
              GET
                VAR energya
                VAR nref
              VAR texture_color
          LET Tu141 (UNIT)
            APP
              VAR vecscale
              GET
                VAR energya
                VAR nref
              FMUL
                FDIV
                  FLOAT 1.
                  FLOAT 256.
                VAR diffuse
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR nvectors
              VAR nref
            VAR nvector
      LET w (VAR of )
        FMUL
          FLOAT -2.
          APP
            VAR veciprod
            VAR dirvec
            VAR nvector
      LET Tu148 (UNIT)
        APP
          VAR vecaccum
          VAR dirvec
          VAR w
          VAR nvector
      LET hilight_scale (VAR of )
        FMUL
          VAR energy
          APP
            VAR o_hilight
            VAR obj
      LET Tu147 (UNIT)
        IF
          NOT
            APP
              VAR shadow_check_one_or_matrix
              INT 0
              GET
                VAR or_net
                INT 0
          LET bright (VAR of )
            FMUL
              NEG
                APP
                  VAR veciprod
                  VAR nvector
                  VAR light
              VAR diffuse
          LET hilight (VAR of )
            NEG
              APP
                VAR veciprod
                VAR dirvec
                VAR light
          APP
            VAR add_light
            VAR bright
            VAR hilight
            VAR hilight_scale
          UNIT
      LET Tu146 (UNIT)
        APP
          VAR setup_startp
          VAR intersection_point
      LET Tu145 (UNIT)
        APP
          VAR trace_reflections
          SUB
            GET
              VAR n_reflections
              INT 0
            INT 1
          VAR diffuse
          VAR hilight_scale
          VAR dirvec
      IF
        APP
          VAR fless
          FLOAT 0.1
          VAR energy
        LET Tu144 (UNIT)
          IF
            NOT
              LE
                INT 4
                VAR nref
            PUT
              VAR surface_ids
              ADD
                VAR nref
                INT 1
              NEG
                INT 1
            UNIT
        IF
          EQ
            VAR m_surface
            INT 2
          LET energy2 (VAR of )
            FMUL
              VAR energy
              FSUB
                FLOAT 1.
                APP
                  VAR o_diffuse
                  VAR obj
          APP
            VAR trace_ray
            ADD
              VAR nref
              INT 1
            VAR energy2
            VAR dirvec
            VAR pixel
            FADD
              VAR dist
              GET
                VAR tmin
                INT 0
          UNIT
        UNIT
      LET Tu157 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          NEG
            INT 1
      IF
        NOT
          EQ
            VAR nref
            INT 0
        LET hl (VAR of )
          NEG
            APP
              VAR veciprod
              VAR dirvec
              VAR light
        IF
          FLt
            FLOAT 0.
            VAR hl
          LET ihl (VAR of )
            FMUL
              FMUL
                FMUL
                  APP
                    VAR fsqr
                    VAR hl
                  VAR hl
                VAR energy
              GET
                VAR beam
                INT 0
          LET Tu156 (UNIT)
            PUT
              VAR rgb
              INT 0
              FADD
                GET
                  VAR rgb
                  INT 0
                VAR ihl
          LET Tu155 (UNIT)
            PUT
              VAR rgb
              INT 1
              FADD
                GET
                  VAR rgb
                  INT 1
                VAR ihl
          PUT
            VAR rgb
            INT 2
            FADD
              GET
                VAR rgb
                INT 2
              VAR ihl
          UNIT
        UNIT
    UNIT
LETREC trace_diffuse_ray (VAR of )
  (dirvec : VAR of ), (energy : VAR of )
  IF
    APP
      VAR judge_intersection_fast
      VAR dirvec
    LET obj (VAR of )
      GET
        VAR objects
        GET
          VAR intersected_object_id
          INT 0
    LET Tu159 (UNIT)
      APP
        VAR get_nvector
        VAR obj
        APP
          VAR d_vec
          VAR dirvec
    LET Tu158 (UNIT)
      APP
        VAR utexture
        VAR obj
        VAR intersection_point
    IF
      NOT
        APP
          VAR shadow_check_one_or_matrix
          INT 0
          GET
            VAR or_net
            INT 0
      LET br (VAR of )
        NEG
          APP
            VAR veciprod
            VAR nvector
            VAR light
      LET bright (VAR of )
        IF
          FLt
            FLOAT 0.
            VAR br
          VAR br
          FLOAT 0.
      APP
        VAR vecaccum
        VAR diffuse_ray
        FMUL
          FMUL
            VAR energy
            VAR bright
          APP
            VAR o_diffuse
            VAR obj
        VAR texture_color
      UNIT
    UNIT
LETREC iter_trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET p (VAR of )
      APP
        VAR veciprod
        APP
          VAR d_vec
          GET
            VAR dirvec_group
            VAR index
        VAR nvector
    LET Tu160 (UNIT)
      IF
        FLt
          VAR p
          FLOAT 0.
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            ADD
              VAR index
              INT 1
          FDIV
            VAR p
            FLOAT -150.
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            VAR index
          FDIV
            VAR p
            FLOAT 150.
    APP
      VAR iter_trace_diffuse_rays
      VAR dirvec_group
      VAR nvector
      VAR org
      SUB
        VAR index
        INT 2
    UNIT
LETREC trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu161 (UNIT)
    APP
      VAR setup_startp
      VAR org
  APP
    VAR iter_trace_diffuse_rays
    VAR dirvec_group
    VAR nvector
    VAR org
    INT 118
LETREC trace_diffuse_ray_80percent (VAR of )
  (group_id : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu165 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 0
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 0
        VAR nvector
        VAR org
      UNIT
  LET Tu164 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 1
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 1
        VAR nvector
        VAR org
      UNIT
  LET Tu163 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 2
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 2
        VAR nvector
        VAR org
      UNIT
  LET Tu162 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 3
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 3
        VAR nvector
        VAR org
      UNIT
  IF
    NOT
      EQ
        VAR group_id
        INT 4
    APP
      VAR trace_diffuse_rays
      GET
        VAR dirvecs
        INT 4
      VAR nvector
      VAR org
    UNIT
LETREC calc_diffuse_using_1point (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  LET ray20p (VAR of )
    APP
      VAR p_received_ray_20percent
      VAR pixel
  LET nvectors (VAR of )
    APP
      VAR p_nvectors
      VAR pixel
  LET intersection_points (VAR of )
    APP
      VAR p_intersection_points
      VAR pixel
  LET energya (VAR of )
    APP
      VAR p_energy
      VAR pixel
  LET Tu167 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR ray20p
        VAR nref
  LET Tu166 (UNIT)
    APP
      VAR trace_diffuse_ray_80percent
      APP
        VAR p_group_id
        VAR pixel
      GET
        VAR nvectors
        VAR nref
      GET
        VAR intersection_points
        VAR nref
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC calc_diffuse_using_5points (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET r_up (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR prev
        VAR x
  LET r_left (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        SUB
          VAR x
          INT 1
  LET r_center (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        VAR x
  LET r_right (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        ADD
          VAR x
          INT 1
  LET r_down (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR next
        VAR x
  LET Tu172 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR r_up
        VAR nref
  LET Tu171 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_left
        VAR nref
  LET Tu170 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_center
        VAR nref
  LET Tu169 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_right
        VAR nref
  LET Tu168 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_down
        VAR nref
  LET energya (VAR of )
    APP
      VAR p_energy
      GET
        VAR cur
        VAR x
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC do_without_neighbors (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      LE
        INT 0
        GET
          VAR surface_ids
          VAR nref
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu173 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          APP
            VAR calc_diffuse_using_1point
            VAR pixel
            VAR nref
          UNIT
      APP
        VAR do_without_neighbors
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC neighbors_exist (VAR of )
  (x : VAR of ), (y : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        ADD
          VAR y
          INT 1
    IF
      NOT
        LE
          VAR y
          INT 0
      IF
        NOT
          LE
            GET
              VAR image_size
              INT 0
            ADD
              VAR x
              INT 1
        IF
          NOT
            LE
              VAR x
              INT 0
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC get_surface_id (VAR of )
  (pixel : VAR of ), (index : VAR of )
  LET surface_ids (VAR of )
    APP
      VAR p_surface_ids
      VAR pixel
  GET
    VAR surface_ids
    VAR index
LETREC neighbors_are_available (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET sid_center (VAR of )
    APP
      VAR get_surface_id
      GET
        VAR cur
        VAR x
      VAR nref
  IF
    EQ
      APP
        VAR get_surface_id
        GET
          VAR prev
          VAR x
        VAR nref
      VAR sid_center
    IF
      EQ
        APP
          VAR get_surface_id
          GET
            VAR next
            VAR x
          VAR nref
        VAR sid_center
      IF
        EQ
          APP
            VAR get_surface_id
            GET
              VAR cur
              SUB
                VAR x
                INT 1
            VAR nref
          VAR sid_center
        IF
          EQ
            APP
              VAR get_surface_id
              GET
                VAR cur
                ADD
                  VAR x
                  INT 1
              VAR nref
            VAR sid_center
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC try_exploit_neighbors (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET pixel (VAR of )
    GET
      VAR cur
      VAR x
  IF
    LE
      VAR nref
      INT 4
    IF
      LE
        INT 0
        APP
          VAR get_surface_id
          VAR pixel
          VAR nref
      IF
        APP
          VAR neighbors_are_available
          VAR x
          VAR prev
          VAR cur
          VAR next
          VAR nref
        LET calc_diffuse (VAR of )
          APP
            VAR p_calc_diffuse
            VAR pixel
        LET Tu174 (UNIT)
          IF
            GET
              VAR calc_diffuse
              VAR nref
            APP
              VAR calc_diffuse_using_5points
              VAR x
              VAR prev
              VAR cur
              VAR next
              VAR nref
            UNIT
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          ADD
            VAR nref
            INT 1
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          VAR nref
      UNIT
    UNIT
LETREC write_ppm_header (VAR of )
  (Tu175 : VAR of )
  LET Tu183 (UNIT)
    APP
      VAR print_char
      INT 80
  LET Tu182 (UNIT)
    APP
      VAR print_char
      ADD
        INT 48
        INT 3
  LET Tu181 (UNIT)
    APP
      VAR print_char
      INT 10
  LET Tu180 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 0
  LET Tu179 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu178 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 1
  LET Tu177 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu176 (UNIT)
    APP
      VAR print_int
      INT 255
  APP
    VAR print_char
    INT 10
LETREC write_rgb_element (VAR of )
  (x : VAR of )
  LET ix (VAR of )
    float_to_int
      VAR x
  LET elem (VAR of )
    IF
      NOT
        LE
          VAR ix
          INT 255
      INT 255
      IF
        NOT
          LE
            INT 0
            VAR ix
        INT 0
        VAR ix
  APP
    VAR print_int
    VAR elem
LETREC write_rgb (VAR of )
  (Tu184 : VAR of )
  LET Tu189 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 0
  LET Tu188 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu187 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 1
  LET Tu186 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu185 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 2
  APP
    VAR print_char
    INT 10
LETREC pretrace_diffuse_rays (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET sid (VAR of )
      APP
        VAR get_surface_id
        VAR pixel
        VAR nref
    IF
      LE
        INT 0
        VAR sid
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu192 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          LET group_id (VAR of )
            APP
              VAR p_group_id
              VAR pixel
          LET Tu191 (UNIT)
            APP
              VAR vecbzero
              VAR diffuse_ray
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          LET intersection_points (VAR of )
            APP
              VAR p_intersection_points
              VAR pixel
          LET Tu190 (UNIT)
            APP
              VAR trace_diffuse_rays
              GET
                VAR dirvecs
                VAR group_id
              GET
                VAR nvectors
                VAR nref
              GET
                VAR intersection_points
                VAR nref
          LET ray20p (VAR of )
            APP
              VAR p_received_ray_20percent
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR ray20p
              VAR nref
            VAR diffuse_ray
          UNIT
      APP
        VAR pretrace_diffuse_rays
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC pretrace_pixels (VAR of )
  (line : VAR of ), (x : VAR of ), (group_id : VAR of ), (lc0 : VAR of ), (lc1 : VAR of ), (lc2 : VAR of )
  IF
    LE
      INT 0
      VAR x
    LET xdisp (VAR of )
      FMUL
        GET
          VAR scan_pitch
          INT 0
        int_to_float
          SUB
            VAR x
            GET
              VAR image_center
              INT 0
    LET Tu202 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 0
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 0
          VAR lc0
    LET Tu201 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 1
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 1
          VAR lc1
    LET Tu200 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 2
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 2
          VAR lc2
    LET Tu199 (UNIT)
      APP
        VAR vecunit_sgn
        VAR ptrace_dirvec
        BOOL false
    LET Tu198 (UNIT)
      APP
        VAR vecbzero
        VAR rgb
    LET Tu197 (UNIT)
      APP
        VAR veccpy
        VAR startp
        VAR viewpoint
    LET Tu196 (UNIT)
      APP
        VAR trace_ray
        INT 0
        FLOAT 1.
        VAR ptrace_dirvec
        GET
          VAR line
          VAR x
        FLOAT 0.
    LET Tu195 (UNIT)
      APP
        VAR veccpy
        APP
          VAR p_rgb
          GET
            VAR line
            VAR x
        VAR rgb
    LET Tu194 (UNIT)
      APP
        VAR p_set_group_id
        GET
          VAR line
          VAR x
        VAR group_id
    LET Tu193 (UNIT)
      APP
        VAR pretrace_diffuse_rays
        GET
          VAR line
          VAR x
        INT 0
    APP
      VAR pretrace_pixels
      VAR line
      SUB
        VAR x
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR lc0
      VAR lc1
      VAR lc2
    UNIT
LETREC pretrace_line (VAR of )
  (line : VAR of ), (y : VAR of ), (group_id : VAR of )
  LET ydisp (VAR of )
    FMUL
      GET
        VAR scan_pitch
        INT 0
      int_to_float
        SUB
          VAR y
          GET
            VAR image_center
            INT 1
  LET lc0 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 0
      GET
        VAR screenz_dir
        INT 0
  LET lc1 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 1
      GET
        VAR screenz_dir
        INT 1
  LET lc2 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 2
      GET
        VAR screenz_dir
        INT 2
  APP
    VAR pretrace_pixels
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 1
    VAR group_id
    VAR lc0
    VAR lc1
    VAR lc2
LETREC scan_pixel (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 0
        VAR x
    LET Tu205 (UNIT)
      APP
        VAR veccpy
        VAR rgb
        APP
          VAR p_rgb
          GET
            VAR cur
            VAR x
    LET Tu204 (UNIT)
      IF
        APP
          VAR neighbors_exist
          VAR x
          VAR y
          VAR next
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          INT 0
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          INT 0
    LET Tu203 (UNIT)
      APP
        VAR write_rgb
        UNIT
    APP
      VAR scan_pixel
      ADD
        VAR x
        INT 1
      VAR y
      VAR prev
      VAR cur
      VAR next
    UNIT
LETREC scan_line (VAR of )
  (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (group_id : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        VAR y
    LET Tu207 (UNIT)
      IF
        NOT
          LE
            SUB
              GET
                VAR image_size
                INT 1
              INT 1
            VAR y
        APP
          VAR pretrace_line
          VAR next
          ADD
            VAR y
            INT 1
          VAR group_id
        UNIT
    LET Tu206 (UNIT)
      APP
        VAR scan_pixel
        INT 0
        VAR y
        VAR prev
        VAR cur
        VAR next
    APP
      VAR scan_line
      ADD
        VAR y
        INT 1
      VAR cur
      VAR next
      VAR prev
      APP
        VAR add_mod5
        VAR group_id
        INT 2
    UNIT
LETREC create_float5x3array (VAR of )
  (Tu208 : VAR of )
  LET vec (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET array (VAR of )
    ARRAY
      INT 5
      VAR vec
  LET Tu212 (UNIT)
    PUT
      VAR array
      INT 1
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu211 (UNIT)
    PUT
      VAR array
      INT 2
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu210 (UNIT)
    PUT
      VAR array
      INT 3
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu209 (UNIT)
    PUT
      VAR array
      INT 4
      ARRAY
        INT 3
        FLOAT 0.
  VAR array
LETREC create_pixel (VAR of )
  (Tu213 : VAR of )
  LET m_rgb (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET m_isect_ps (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_sids (VAR of )
    ARRAY
      INT 5
      INT 0
  LET m_cdif (VAR of )
    ARRAY
      INT 5
      BOOL false
  LET m_engy (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_r20p (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_gid (VAR of )
    ARRAY
      INT 1
      INT 0
  LET m_nvectors (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  TUPLE
    VAR m_rgb
    VAR m_isect_ps
    VAR m_sids
    VAR m_cdif
    VAR m_engy
    VAR m_r20p
    VAR m_gid
    VAR m_nvectors
LETREC init_line_elements (VAR of )
  (line : VAR of ), (n : VAR of )
  IF
    LE
      INT 0
      VAR n
    LET Tu214 (UNIT)
      PUT
        VAR line
        VAR n
        APP
          VAR create_pixel
          UNIT
    APP
      VAR init_line_elements
      VAR line
      SUB
        VAR n
        INT 1
    VAR line
LETREC create_pixelline (VAR of )
  (Tu215 : VAR of )
  LET line (VAR of )
    ARRAY
      GET
        VAR image_size
        INT 0
      APP
        VAR create_pixel
        UNIT
  APP
    VAR init_line_elements
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 2
LETREC tan (VAR of )
  (x : VAR of )
  FDIV
    APP
      VAR sin
      VAR x
    APP
      VAR cos
      VAR x
LETREC adjust_position (VAR of )
  (h : VAR of ), (ratio : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FMUL
          VAR h
          VAR h
        FLOAT 0.1
  LET tan_h (VAR of )
    FDIV
      FLOAT 1.
      VAR l
  LET theta_h (VAR of )
    APP
      VAR atan
      VAR tan_h
  LET tan_m (VAR of )
    APP
      VAR tan
      FMUL
        VAR theta_h
        VAR ratio
  FMUL
    VAR tan_m
    VAR l
LETREC calc_dirvec (VAR of )
  (icount : VAR of ), (x : VAR of ), (y : VAR of ), (rx : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 5
      VAR icount
    LET l (VAR of )
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              VAR x
            APP
              VAR fsqr
              VAR y
          FLOAT 1.
    LET vx (VAR of )
      FDIV
        VAR x
        VAR l
    LET vy (VAR of )
      FDIV
        VAR y
        VAR l
    LET vz (VAR of )
      FDIV
        FLOAT 1.
        VAR l
    LET dgroup (VAR of )
      GET
        VAR dirvecs
        VAR group_id
    LET Tu220 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            VAR index
        VAR vx
        VAR vy
        VAR vz
    LET Tu219 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 40
        VAR vx
        VAR vz
        NEG
          VAR vy
    LET Tu218 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 80
        VAR vz
        NEG
          VAR vx
        NEG
          VAR vy
    LET Tu217 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 1
        NEG
          VAR vx
        NEG
          VAR vy
        NEG
          VAR vz
    LET Tu216 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 41
        NEG
          VAR vx
        NEG
          VAR vz
        VAR vy
    APP
      VAR vecset
      APP
        VAR d_vec
        GET
          VAR dgroup
          ADD
            VAR index
            INT 81
      NEG
        VAR vz
      VAR vx
      VAR vy
    LET x2 (VAR of )
      APP
        VAR adjust_position
        VAR y
        VAR rx
    APP
      VAR calc_dirvec
      ADD
        VAR icount
        INT 1
      VAR x2
      APP
        VAR adjust_position
        VAR x2
        VAR ry
      VAR rx
      VAR ry
      VAR group_id
      VAR index
LETREC calc_dirvecs (VAR of )
  (col : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR col
    LET rx (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.9
    LET Tu222 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx
        VAR ry
        VAR group_id
        VAR index
    LET rx2 (VAR of )
      FADD
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.1
    LET Tu221 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx2
        VAR ry
        VAR group_id
        ADD
          VAR index
          INT 2
    APP
      VAR calc_dirvecs
      SUB
        VAR col
        INT 1
      VAR ry
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR index
    UNIT
LETREC calc_dirvec_rows (VAR of )
  (row : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR row
    LET ry (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR row
          FLOAT 0.2
        FLOAT 0.9
    LET Tu223 (UNIT)
      APP
        VAR calc_dirvecs
        INT 4
        VAR ry
        VAR group_id
        VAR index
    APP
      VAR calc_dirvec_rows
      SUB
        VAR row
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 2
      ADD
        VAR index
        INT 4
    UNIT
LETREC create_dirvec (VAR of )
  (Tu224 : VAR of )
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      GET
        VAR n_objects
        INT 0
      VAR v3
  TUPLE
    VAR v3
    VAR consts
LETREC create_dirvec_elements (VAR of )
  (d : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu225 (UNIT)
      PUT
        VAR d
        VAR index
        APP
          VAR create_dirvec
          UNIT
    APP
      VAR create_dirvec_elements
      VAR d
      SUB
        VAR index
        INT 1
    UNIT
LETREC create_dirvecs (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu227 (UNIT)
      PUT
        VAR dirvecs
        VAR index
        ARRAY
          INT 120
          APP
            VAR create_dirvec
            UNIT
    LET Tu226 (UNIT)
      APP
        VAR create_dirvec_elements
        GET
          VAR dirvecs
          VAR index
        INT 118
    APP
      VAR create_dirvecs
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvec_constants (VAR of )
  (vecset : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu228 (UNIT)
      APP
        VAR setup_dirvec_constants
        GET
          VAR vecset
          VAR index
    APP
      VAR init_dirvec_constants
      VAR vecset
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_vecset_constants (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu229 (UNIT)
      APP
        VAR init_dirvec_constants
        GET
          VAR dirvecs
          VAR index
        INT 119
    APP
      VAR init_vecset_constants
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvecs (VAR of )
  (Tu230 : VAR of )
  LET Tu232 (UNIT)
    APP
      VAR create_dirvecs
      INT 4
  LET Tu231 (UNIT)
    APP
      VAR calc_dirvec_rows
      INT 9
      INT 0
      INT 0
  APP
    VAR init_vecset_constants
    INT 4
LETREC add_reflection (VAR of )
  (index : VAR of ), (surface_id : VAR of ), (bright : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET dvec (VAR of )
    APP
      VAR create_dirvec
      UNIT
  LET Tu234 (UNIT)
    APP
      VAR vecset
      APP
        VAR d_vec
        VAR dvec
      VAR v0
      VAR v1
      VAR v2
  LET Tu233 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR dvec
  PUT
    VAR reflections
    VAR index
    TUPLE
      VAR surface_id
      VAR dvec
      VAR bright
LETREC setup_rect_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    MULTIPLE 4
      VAR obj_id
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET n0 (VAR of )
    NEG
      GET
        VAR light
        INT 0
  LET n1 (VAR of )
    NEG
      GET
        VAR light
        INT 1
  LET n2 (VAR of )
    NEG
      GET
        VAR light
        INT 2
  LET Tu237 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      ADD
        VAR sid
        INT 1
      VAR br
      GET
        VAR light
        INT 0
      VAR n1
      VAR n2
  LET Tu236 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 1
      ADD
        VAR sid
        INT 2
      VAR br
      VAR n0
      GET
        VAR light
        INT 1
      VAR n2
  LET Tu235 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 2
      ADD
        VAR sid
        INT 3
      VAR br
      VAR n0
      VAR n1
      GET
        VAR light
        INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 3
LETREC setup_surface_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    ADD
      MULTIPLE 4
        VAR obj_id
      INT 1
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET p (VAR of )
    APP
      VAR veciprod
      VAR light
      APP
        VAR o_param_abc
        VAR obj
  LET Tu238 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      VAR sid
      VAR br
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_a
              VAR obj
          VAR p
        GET
          VAR light
          INT 0
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_b
              VAR obj
          VAR p
        GET
          VAR light
          INT 1
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_c
              VAR obj
          VAR p
        GET
          VAR light
          INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 1
LETREC setup_reflections (VAR of )
  (obj_id : VAR of )
  IF
    LE
      INT 0
      VAR obj_id
    LET obj (VAR of )
      GET
        VAR objects
        VAR obj_id
    IF
      EQ
        APP
          VAR o_reflectiontype
          VAR obj
        INT 2
      IF
        APP
          VAR fless
          APP
            VAR o_diffuse
            VAR obj
          FLOAT 1.
        LET m_shape (VAR of )
          APP
            VAR o_form
            VAR obj
        IF
          EQ
            VAR m_shape
            INT 1
          APP
            VAR setup_rect_reflection
            VAR obj_id
            VAR obj
          IF
            EQ
              VAR m_shape
              INT 2
            APP
              VAR setup_surface_reflection
              VAR obj_id
              VAR obj
            UNIT
        UNIT
      UNIT
    UNIT
LETREC rt (VAR of )
  (size_x : VAR of ), (size_y : VAR of )
  LET Tu250 (UNIT)
    PUT
      VAR image_size
      INT 0
      VAR size_x
  LET Tu249 (UNIT)
    PUT
      VAR image_size
      INT 1
      VAR size_y
  LET Tu248 (UNIT)
    PUT
      VAR image_center
      INT 0
      DIVIDE BY 2
        VAR size_x
  LET Tu247 (UNIT)
    PUT
      VAR image_center
      INT 1
      DIVIDE BY 2
        VAR size_y
  LET Tu246 (UNIT)
    PUT
      VAR scan_pitch
      INT 0
      FDIV
        FLOAT 128.
        int_to_float
          VAR size_x
  LET prev (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET cur (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET next (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET Tu245 (UNIT)
    APP
      VAR read_parameter
      UNIT
  LET Tu244 (UNIT)
    APP
      VAR write_ppm_header
      UNIT
  LET Tu243 (UNIT)
    APP
      VAR init_dirvecs
      UNIT
  LET Tu242 (UNIT)
    APP
      VAR veccpy
      APP
        VAR d_vec
        VAR light_dirvec
      VAR light
  LET Tu241 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR light_dirvec
  LET Tu240 (UNIT)
    APP
      VAR setup_reflections
      SUB
        GET
          VAR n_objects
          INT 0
        INT 1
  LET Tu239 (UNIT)
    APP
      VAR pretrace_line
      VAR cur
      INT 0
      INT 0
  APP
    VAR scan_line
    INT 0
    VAR prev
    VAR cur
    VAR next
    INT 2
LET a (VAR of )
  APP
    VAR rt
    INT 512
    INT 512
UNIT

----- kNormal.print -----
letrec print_int : (INT -> UNIT) =
variables : (n : INT)
  let n : INT =
    let Ti2502 : INT =
      int 0
    in
    if Ti2502 <= n
      n
      let Tu1 : UNIT =
        let Ti2503 : INT =
          int 45
        in
        out Ti2503 0
      in
      neg n
  in
  let Ti2504 : INT =
    int 10
  in
  if Ti2504 <= n
    let m : INT =
      div n 10
    in
    let Tu2 : UNIT =
      app
        print_int
        m
    in
    let Ti2506 : INT =
      let Ti2505 : INT =
        mul m 10
      in
      sub n Ti2505
    in
    out Ti2506 48
    out n 48
in
letrec print_char : (INT -> UNIT) =
variables : (c : INT)
  out c 0
in
letrec reduction_2pi_sub1 : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (a : FLOAT), (p : FLOAT)
  if a <. p
    p
    let Td2501 : FLOAT =
      fadd p p
    in
    app
      reduction_2pi_sub1
      a
      Td2501
in
letrec reduction_2pi_sub2 : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (a : FLOAT), (p : FLOAT)
  let Td2497 : FLOAT =
    float 6.28318530718
  in
  if Td2497 <. a
    let a : FLOAT =
      if p <. a
        fsub a p
        let Td2498 : FLOAT =
          float 0.
        in
        fadd a Td2498
    in
    let p : FLOAT =
      let Td2499 : FLOAT =
        float 2.
      in
      fdiv p Td2499
    in
    app
      reduction_2pi_sub2
      a
      p
    let Td2500 : FLOAT =
      float 0.
    in
    fadd a Td2500
in
letrec reduction_2pi : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let p : FLOAT =
    float 6.28318530718
  in
  let p : FLOAT =
    app
      reduction_2pi_sub1
      a
      p
  in
  app
    reduction_2pi_sub2
    a
    p
in
letrec kernel_sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a3 : FLOAT =
    fmul a2 a
  in
  let a5 : FLOAT =
    fmul a3 a2
  in
  let a7 : FLOAT =
    fmul a5 a2
  in
  let Td2496 : FLOAT =
    let Td2493 : FLOAT =
      let Td2490 : FLOAT =
        let Td2489 : FLOAT =
          let Td2488 : FLOAT =
            float 0.000198411698413
          in
          fmul Td2488 a7
        in
        fneg Td2489
      in
      let Td2492 : FLOAT =
        let Td2491 : FLOAT =
          float 0.0083333333333
        in
        fmul Td2491 a5
      in
      fadd Td2490 Td2492
    in
    let Td2495 : FLOAT =
      let Td2494 : FLOAT =
        float 0.166666666667
      in
      fmul Td2494 a3
    in
    fsub Td2493 Td2495
  in
  fadd Td2496 a
in
letrec kernel_cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a4 : FLOAT =
    fmul a2 a2
  in
  let a6 : FLOAT =
    fmul a4 a2
  in
  let Td2486 : FLOAT =
    let Td2483 : FLOAT =
      let Td2480 : FLOAT =
        let Td2479 : FLOAT =
          let Td2478 : FLOAT =
            float 0.00138888888889
          in
          fmul Td2478 a6
        in
        fneg Td2479
      in
      let Td2482 : FLOAT =
        let Td2481 : FLOAT =
          float 0.0416666666667
        in
        fmul Td2481 a4
      in
      fadd Td2480 Td2482
    in
    let Td2485 : FLOAT =
      let Td2484 : FLOAT =
        float 0.5
      in
      fmul Td2484 a2
    in
    fsub Td2483 Td2485
  in
  let Td2487 : FLOAT =
    float 1.
  in
  fadd Td2486 Td2487
in
letrec sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2459 : FLOAT =
      float 0.
    in
    if Td2459 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Td2460 : FLOAT =
      float 0.
    in
    if a <. Td2460
      fneg a
      let Td2461 : FLOAT =
        float 0.
      in
      fadd a Td2461
  in
  let a : FLOAT =
    app
      reduction_2pi
      a
  in
  let Tt2469 : (FLOAT * INT) =
    let Td2462 : FLOAT =
      float 3.14159265359
    in
    if Td2462 <. a
      let Td2464 : FLOAT =
        let Td2463 : FLOAT =
          float 3.14159265359
        in
        fsub a Td2463
      in
      let Ti2466 : INT =
        let Ti2465 : INT =
          int 0
        in
        if flag == Ti2465
          int 1
          int 0
      in
      Tuple
        Td2464
        Ti2466
      let Td2468 : FLOAT =
        let Td2467 : FLOAT =
          float 0.
        in
        fadd a Td2467
      in
      Tuple
        Td2468
        flag
  in
  let tuple (a : FLOAT), (flag : BOOL)
    Tt2469
  in
    let a : FLOAT =
      let Td2470 : FLOAT =
        float 1.57079632679
      in
      if Td2470 <. a
        let Td2471 : FLOAT =
          float 3.14159265359
        in
        fsub Td2471 a
        let Td2472 : FLOAT =
          float 0.
        in
        fadd a Td2472
    in
    let a : FLOAT =
      let Td2473 : FLOAT =
        float 0.785398163397
      in
      if a <. Td2473
        let Td2475 : FLOAT =
          let Td2474 : FLOAT =
            float 1.57079632679
          in
          fsub Td2474 a
        in
        app
          kernel_cos
          Td2475
        app
          kernel_sin
          a
    in
    let Ti2476 : INT =
      int 0
    in
    if flag == Ti2476
      fneg a
      let Td2477 : FLOAT =
        float 0.
      in
      fadd a Td2477
in
letrec cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a : FLOAT =
    let Td2438 : FLOAT =
      float 0.
    in
    if a <. Td2438
      fneg a
      let Td2439 : FLOAT =
        float 0.
      in
      fadd a Td2439
  in
  let a : FLOAT =
    app
      reduction_2pi
      a
  in
  let Tt2445 : (FLOAT * INT) =
    let Td2440 : FLOAT =
      float 3.14159265359
    in
    if Td2440 <. a
      let Td2442 : FLOAT =
        let Td2441 : FLOAT =
          float 3.14159265359
        in
        fsub a Td2441
      in
      let Ti2443 : INT =
        int 0
      in
      Tuple
        Td2442
        Ti2443
      let Ti2444 : INT =
        int 1
      in
      Tuple
        a
        Ti2444
  in
  let tuple (a : FLOAT), (flag : BOOL)
    Tt2445
  in
    let Tt2453 : (FLOAT * INT) =
      let Td2446 : FLOAT =
        float 1.57079632679
      in
      if Td2446 <. a
        let Td2448 : FLOAT =
          let Td2447 : FLOAT =
            float 3.14159265359
          in
          fsub Td2447 a
        in
        let Ti2450 : INT =
          let Ti2449 : INT =
            int 0
          in
          if flag == Ti2449
            int 1
            int 0
        in
        Tuple
          Td2448
          Ti2450
        let Td2452 : FLOAT =
          let Td2451 : FLOAT =
            float 0.
          in
          fadd a Td2451
        in
        Tuple
          Td2452
          flag
    in
    let tuple (a : FLOAT), (flag : BOOL)
      Tt2453
    in
      let a : FLOAT =
        let Td2454 : FLOAT =
          float 0.785398163397
        in
        if Td2454 <. a
          app
            kernel_cos
            a
          let Td2456 : FLOAT =
            let Td2455 : FLOAT =
              float 1.57079632679
            in
            fsub Td2455 a
          in
          app
            kernel_sin
            Td2456
      in
      let Ti2457 : INT =
        int 0
      in
      if flag == Ti2457
        fneg a
        let Td2458 : FLOAT =
          float 0.
        in
        fadd a Td2458
in
letrec sqrt : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  letrec inner : (FLOAT -> (INT -> FLOAT)) =
  variables : (t : FLOAT), (i : INT)
    let Ti2430 : INT =
      int 0
    in
    if i == Ti2430
      t
      let Td2435 : FLOAT =
        let Td2432 : FLOAT =
          let Td2431 : FLOAT =
            fmul t t
          in
          fadd Td2431 x
        in
        let Td2434 : FLOAT =
          let Td2433 : FLOAT =
            float 2.
          in
          fmul Td2433 t
        in
        fdiv Td2432 Td2434
      in
      let Ti2437 : INT =
        let Ti2436 : INT =
          int 1
        in
        sub i Ti2436
      in
      app
        inner
        Td2435
        Ti2437
  in
  let Td2428 : FLOAT =
    unknown sqrt_init x
  in
  let Ti2429 : INT =
    int 5
  in
  app
    inner
    Td2428
    Ti2429
in
letrec kernel_atan : (FLOAT -> FLOAT) =
variables : (a1 : FLOAT)
  let a2 : FLOAT =
    fmul a1 a1
  in
  let a3 : FLOAT =
    fmul a2 a1
  in
  let a5 : FLOAT =
    fmul a2 a3
  in
  let a7 : FLOAT =
    fmul a2 a5
  in
  let a9 : FLOAT =
    fmul a2 a7
  in
  let a11 : FLOAT =
    fmul a2 a9
  in
  let a13 : FLOAT =
    fmul a2 a11
  in
  let Td2425 : FLOAT =
    let Td2422 : FLOAT =
      let Td2419 : FLOAT =
        let Td2416 : FLOAT =
          let Td2413 : FLOAT =
            let Td2412 : FLOAT =
              let Td2411 : FLOAT =
                float 0.3333333
              in
              fmul Td2411 a3
            in
            fsub a1 Td2412
          in
          let Td2415 : FLOAT =
            let Td2414 : FLOAT =
              float 0.2
            in
            fmul Td2414 a5
          in
          fadd Td2413 Td2415
        in
        let Td2418 : FLOAT =
          let Td2417 : FLOAT =
            float 0.142857142
          in
          fmul Td2417 a7
        in
        fsub Td2416 Td2418
      in
      let Td2421 : FLOAT =
        let Td2420 : FLOAT =
          float 0.111111104
        in
        fmul Td2420 a9
      in
      fadd Td2419 Td2421
    in
    let Td2424 : FLOAT =
      let Td2423 : FLOAT =
        float 0.08976446
      in
      fmul Td2423 a11
    in
    fsub Td2422 Td2424
  in
  let Td2427 : FLOAT =
    let Td2426 : FLOAT =
      float 0.060035485
    in
    fmul Td2426 a13
  in
  fadd Td2425 Td2427
in
letrec atan : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2391 : FLOAT =
      float 0.
    in
    if Td2391 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Ti2392 : INT =
      int 0
    in
    if flag == Ti2392
      fneg a
      let Td2393 : FLOAT =
        float 0.
      in
      fadd a Td2393
  in
  let b : FLOAT =
    let Td2394 : FLOAT =
      float 0.4375
    in
    if a <. Td2394
      app
        kernel_atan
        a
      let Td2407 : FLOAT =
        let Td2395 : FLOAT =
          float 2.4375
        in
        if a <. Td2395
          let Td2396 : FLOAT =
            float 0.785398163397
          in
          let Td2402 : FLOAT =
            let Td2401 : FLOAT =
              let Td2398 : FLOAT =
                let Td2397 : FLOAT =
                  float 1.
                in
                fsub a Td2397
              in
              let Td2400 : FLOAT =
                let Td2399 : FLOAT =
                  float 1.
                in
                fadd a Td2399
              in
              fdiv Td2398 Td2400
            in
            app
              kernel_atan
              Td2401
          in
          fadd Td2396 Td2402
          let Td2403 : FLOAT =
            float 1.57079632679
          in
          let Td2406 : FLOAT =
            let Td2405 : FLOAT =
              let Td2404 : FLOAT =
                float 1.
              in
              fdiv Td2404 a
            in
            app
              kernel_atan
              Td2405
          in
          fsub Td2403 Td2406
      in
      let Td2408 : FLOAT =
        float 0.
      in
      fadd Td2407 Td2408
  in
  let Ti2409 : INT =
    int 0
  in
  if flag == Ti2409
    fneg b
    let Td2410 : FLOAT =
      float 0.
    in
    fadd Td2410 b
in
letrec floor : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let a : FLOAT =
    let Ti2389 : INT =
      ftoi x
    in
    itof Ti2389
  in
  if x <. a
    let Td2390 : FLOAT =
      float 1.
    in
    fsub a Td2390
    a
in
letrec fabs : (FLOAT -> FLOAT) =
variables : (f : FLOAT)
  let Td2388 : FLOAT =
    float 0.
  in
  if f <. Td2388
    fneg f
    f
in
letrec fhalf : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2387 : FLOAT =
    float 0.5
  in
  fmul x Td2387
in
letrec fsqr : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fmul x x
in
letrec fless : (FLOAT -> (FLOAT -> BOOL)) =
variables : (a : FLOAT), (b : FLOAT)
  if a <. b
    int 1
    int 0
in
letrec abs_float : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  app
    fabs
    x
in
let n_objects : Array of INT =
  let Ti251 : INT =
    int 1
  in
  let Ti252 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti251
    Ti252
in
let objects : Array of (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
  let dummy : Array of FLOAT =
    let Ti253 : INT =
      int 0
    in
    let Td254 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti253
      Td254
  in
  let Ti255 : INT =
    int 60
  in
  let Tt261 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * INT * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    let Ti256 : INT =
      int 0
    in
    let Ti257 : INT =
      int 0
    in
    let Ti258 : INT =
      int 0
    in
    let Ti259 : INT =
      int 0
    in
    let Ti260 : INT =
      int 0
    in
    Tuple
      Ti256
      Ti257
      Ti258
      Ti259
      dummy
      dummy
      Ti260
      dummy
      dummy
      dummy
      dummy
  in
  extfunapp
    create_array
    Ti255
    Tt261
in
let screen : Array of FLOAT =
  let Ti262 : INT =
    int 3
  in
  let Td263 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti262
    Td263
in
let viewpoint : Array of FLOAT =
  let Ti264 : INT =
    int 3
  in
  let Td265 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti264
    Td265
in
let light : Array of FLOAT =
  let Ti266 : INT =
    int 3
  in
  let Td267 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti266
    Td267
in
let beam : Array of FLOAT =
  let Ti268 : INT =
    int 1
  in
  let Td269 : FLOAT =
    float 255.
  in
  extfunapp
    create_float_array
    Ti268
    Td269
in
let and_net : Array of Array of INT =
  let Ti270 : INT =
    int 50
  in
  let Ta274 : Array of INT =
    let Ti271 : INT =
      int 1
    in
    let Ti273 : INT =
      let Ti272 : INT =
        int 1
      in
      neg Ti272
    in
    extfunapp
      create_array
      Ti271
      Ti273
  in
  extfunapp
    create_array
    Ti270
    Ta274
in
let or_net : Array of Array of Array of INT =
  let Ti275 : INT =
    int 1
  in
  let Ta279 : Array of Array of INT =
    let Ti276 : INT =
      int 1
    in
    let Ta278 : Array of INT =
      let Ti277 : INT =
        int 0
      in
      and_net.(Ti277)
    in
    extfunapp
      create_array
      Ti276
      Ta278
  in
  extfunapp
    create_array
    Ti275
    Ta279
in
let solver_dist : Array of FLOAT =
  let Ti280 : INT =
    int 1
  in
  let Td281 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti280
    Td281
in
let intsec_rectside : Array of INT =
  let Ti282 : INT =
    int 1
  in
  let Ti283 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti282
    Ti283
in
let tmin : Array of FLOAT =
  let Ti284 : INT =
    int 1
  in
  let Td285 : FLOAT =
    float 1000000000.
  in
  extfunapp
    create_float_array
    Ti284
    Td285
in
let intersection_point : Array of FLOAT =
  let Ti286 : INT =
    int 3
  in
  let Td287 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti286
    Td287
in
let intersected_object_id : Array of INT =
  let Ti288 : INT =
    int 1
  in
  let Ti289 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti288
    Ti289
in
let nvector : Array of FLOAT =
  let Ti290 : INT =
    int 3
  in
  let Td291 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti290
    Td291
in
let texture_color : Array of FLOAT =
  let Ti292 : INT =
    int 3
  in
  let Td293 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti292
    Td293
in
let diffuse_ray : Array of FLOAT =
  let Ti294 : INT =
    int 3
  in
  let Td295 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti294
    Td295
in
let rgb : Array of FLOAT =
  let Ti296 : INT =
    int 3
  in
  let Td297 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti296
    Td297
in
let image_size : Array of INT =
  let Ti298 : INT =
    int 2
  in
  let Ti299 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti298
    Ti299
in
let image_center : Array of INT =
  let Ti300 : INT =
    int 2
  in
  let Ti301 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti300
    Ti301
in
let scan_pitch : Array of FLOAT =
  let Ti302 : INT =
    int 1
  in
  let Td303 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti302
    Td303
in
let startp : Array of FLOAT =
  let Ti304 : INT =
    int 3
  in
  let Td305 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti304
    Td305
in
let startp_fast : Array of FLOAT =
  let Ti306 : INT =
    int 3
  in
  let Td307 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti306
    Td307
in
let screenx_dir : Array of FLOAT =
  let Ti308 : INT =
    int 3
  in
  let Td309 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti308
    Td309
in
let screeny_dir : Array of FLOAT =
  let Ti310 : INT =
    int 3
  in
  let Td311 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti310
    Td311
in
let screenz_dir : Array of FLOAT =
  let Ti312 : INT =
    int 3
  in
  let Td313 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti312
    Td313
in
let ptrace_dirvec : Array of FLOAT =
  let Ti314 : INT =
    int 3
  in
  let Td315 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti314
    Td315
in
let dirvecs : Array of Array of (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf : Array of FLOAT =
    let Ti316 : INT =
      int 0
    in
    let Td317 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti316
      Td317
  in
  let dummyff : Array of Array of FLOAT =
    let Ti318 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti318
      dummyf
  in
  let dummy_vs : Array of (Array of FLOAT * Array of Array of FLOAT) =
    let Ti319 : INT =
      int 0
    in
    let Tt320 : (Array of FLOAT * Array of Array of FLOAT) =
      Tuple
        dummyf
        dummyff
    in
    extfunapp
      create_array
      Ti319
      Tt320
  in
  let Ti321 : INT =
    int 5
  in
  extfunapp
    create_array
    Ti321
    dummy_vs
in
let light_dirvec : (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf2 : Array of FLOAT =
    let Ti322 : INT =
      int 0
    in
    let Td323 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti322
      Td323
  in
  let v3 : Array of FLOAT =
    let Ti324 : INT =
      int 3
    in
    let Td325 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti324
      Td325
  in
  let consts : Array of Array of FLOAT =
    let Ti326 : INT =
      int 60
    in
    extfunapp
      create_array
      Ti326
      dummyf2
  in
  Tuple
    v3
    consts
in
let reflections : Array of (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
  let dummyf3 : Array of FLOAT =
    let Ti327 : INT =
      int 0
    in
    let Td328 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti327
      Td328
  in
  let dummyff3 : Array of Array of FLOAT =
    let Ti329 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti329
      dummyf3
  in
  let dummydv : (Array of FLOAT * Array of Array of FLOAT) =
    Tuple
      dummyf3
      dummyff3
  in
  let Ti330 : INT =
    int 180
  in
  let Tt333 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    let Ti331 : INT =
      int 0
    in
    let Td332 : FLOAT =
      float 0.
    in
    Tuple
      Ti331
      dummydv
      Td332
  in
  extfunapp
    create_array
    Ti330
    Tt333
in
let n_reflections : Array of INT =
  let Ti334 : INT =
    int 1
  in
  let Ti335 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti334
    Ti335
in
letrec xor : (BOOL -> (BOOL -> BOOL)) =
variables : (x : BOOL), (y : BOOL)
  let Ti2385 : INT =
    int 0
  in
  if x == Ti2385
    y
    let Ti2386 : INT =
      int 0
    in
    if y == Ti2386
      int 1
      int 0
in
letrec sgn : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  if x == 0.0 
    float 0.
    let Td2384 : FLOAT =
      float 0.
    in
    if Td2384 <. x
      float 1.
      float -1.
in
letrec fneg_cond : (BOOL -> (FLOAT -> FLOAT)) =
variables : (cond : BOOL), (x : FLOAT)
  let Ti2383 : INT =
    int 0
  in
  if cond == Ti2383
    fneg x
    x
in
letrec add_mod5 : (INT -> (INT -> INT)) =
variables : (x : INT), (y : INT)
  let sum : INT =
    add x y
  in
  let Ti2381 : INT =
    int 5
  in
  if Ti2381 <= sum
    let Ti2382 : INT =
      int 5
    in
    sub sum Ti2382
    sum
in
letrec vecset : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))) =
variables : (v : Array of FLOAT), (x : FLOAT), (y : FLOAT), (z : FLOAT)
  let Tu4 : UNIT =
    let Ti2378 : INT =
      int 0
    in
    v.(Ti2378) <- x
  in
  let Tu3 : UNIT =
    let Ti2379 : INT =
      int 1
    in
    v.(Ti2379) <- y
  in
  let Ti2380 : INT =
    int 2
  in
  v.(Ti2380) <- z
in
letrec vecfill : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (v : Array of FLOAT), (elem : FLOAT)
  let Tu6 : UNIT =
    let Ti2375 : INT =
      int 0
    in
    v.(Ti2375) <- elem
  in
  let Tu5 : UNIT =
    let Ti2376 : INT =
      int 1
    in
    v.(Ti2376) <- elem
  in
  let Ti2377 : INT =
    int 2
  in
  v.(Ti2377) <- elem
in
letrec vecbzero : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2374 : FLOAT =
    float 0.
  in
  app
    vecfill
    v
    Td2374
in
letrec veccpy : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (src : Array of FLOAT)
  let Tu8 : UNIT =
    let Ti2365 : INT =
      int 0
    in
    let Td2367 : FLOAT =
      let Ti2366 : INT =
        int 0
      in
      src.(Ti2366)
    in
    dest.(Ti2365) <- Td2367
  in
  let Tu7 : UNIT =
    let Ti2368 : INT =
      int 1
    in
    let Td2370 : FLOAT =
      let Ti2369 : INT =
        int 1
      in
      src.(Ti2369)
    in
    dest.(Ti2368) <- Td2370
  in
  let Ti2371 : INT =
    int 2
  in
  let Td2373 : FLOAT =
    let Ti2372 : INT =
      int 2
    in
    src.(Ti2372)
  in
  dest.(Ti2371) <- Td2373
in
letrec vecdist2 : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (p : Array of FLOAT), (q : Array of FLOAT)
  let Td2358 : FLOAT =
    let Td2351 : FLOAT =
      let Td2350 : FLOAT =
        let Td2347 : FLOAT =
          let Ti2346 : INT =
            int 0
          in
          p.(Ti2346)
        in
        let Td2349 : FLOAT =
          let Ti2348 : INT =
            int 0
          in
          q.(Ti2348)
        in
        fsub Td2347 Td2349
      in
      app
        fsqr
        Td2350
    in
    let Td2357 : FLOAT =
      let Td2356 : FLOAT =
        let Td2353 : FLOAT =
          let Ti2352 : INT =
            int 1
          in
          p.(Ti2352)
        in
        let Td2355 : FLOAT =
          let Ti2354 : INT =
            int 1
          in
          q.(Ti2354)
        in
        fsub Td2353 Td2355
      in
      app
        fsqr
        Td2356
    in
    fadd Td2351 Td2357
  in
  let Td2364 : FLOAT =
    let Td2363 : FLOAT =
      let Td2360 : FLOAT =
        let Ti2359 : INT =
          int 2
        in
        p.(Ti2359)
      in
      let Td2362 : FLOAT =
        let Ti2361 : INT =
          int 2
        in
        q.(Ti2361)
      in
      fsub Td2360 Td2362
    in
    app
      fsqr
      Td2363
  in
  fadd Td2358 Td2364
in
letrec vecunit : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let il : FLOAT =
    let Td2321 : FLOAT =
      float 1.
    in
    let Td2333 : FLOAT =
      let Td2332 : FLOAT =
        let Td2328 : FLOAT =
          let Td2324 : FLOAT =
            let Td2323 : FLOAT =
              let Ti2322 : INT =
                int 0
              in
              v.(Ti2322)
            in
            app
              fsqr
              Td2323
          in
          let Td2327 : FLOAT =
            let Td2326 : FLOAT =
              let Ti2325 : INT =
                int 1
              in
              v.(Ti2325)
            in
            app
              fsqr
              Td2326
          in
          fadd Td2324 Td2327
        in
        let Td2331 : FLOAT =
          let Td2330 : FLOAT =
            let Ti2329 : INT =
              int 2
            in
            v.(Ti2329)
          in
          app
            fsqr
            Td2330
        in
        fadd Td2328 Td2331
      in
      app
        sqrt
        Td2332
    in
    fdiv Td2321 Td2333
  in
  let Tu10 : UNIT =
    let Ti2334 : INT =
      int 0
    in
    let Td2337 : FLOAT =
      let Td2336 : FLOAT =
        let Ti2335 : INT =
          int 0
        in
        v.(Ti2335)
      in
      fmul Td2336 il
    in
    v.(Ti2334) <- Td2337
  in
  let Tu9 : UNIT =
    let Ti2338 : INT =
      int 1
    in
    let Td2341 : FLOAT =
      let Td2340 : FLOAT =
        let Ti2339 : INT =
          int 1
        in
        v.(Ti2339)
      in
      fmul Td2340 il
    in
    v.(Ti2338) <- Td2341
  in
  let Ti2342 : INT =
    int 2
  in
  let Td2345 : FLOAT =
    let Td2344 : FLOAT =
      let Ti2343 : INT =
        int 2
      in
      v.(Ti2343)
    in
    fmul Td2344 il
  in
  v.(Ti2342) <- Td2345
in
letrec vecunit_sgn : (Array of FLOAT -> (BOOL -> UNIT)) =
variables : (v : Array of FLOAT), (inv : BOOL)
  let l : FLOAT =
    let Td2305 : FLOAT =
      let Td2301 : FLOAT =
        let Td2297 : FLOAT =
          let Td2296 : FLOAT =
            let Ti2295 : INT =
              int 0
            in
            v.(Ti2295)
          in
          app
            fsqr
            Td2296
        in
        let Td2300 : FLOAT =
          let Td2299 : FLOAT =
            let Ti2298 : INT =
              int 1
            in
            v.(Ti2298)
          in
          app
            fsqr
            Td2299
        in
        fadd Td2297 Td2300
      in
      let Td2304 : FLOAT =
        let Td2303 : FLOAT =
          let Ti2302 : INT =
            int 2
          in
          v.(Ti2302)
        in
        app
          fsqr
          Td2303
      in
      fadd Td2301 Td2304
    in
    app
      sqrt
      Td2305
  in
  let il : FLOAT =
    if l == 0.0 
      float 1.
      let Ti2306 : INT =
        int 0
      in
      if inv == Ti2306
        let Td2307 : FLOAT =
          float 1.
        in
        fdiv Td2307 l
        let Td2308 : FLOAT =
          float -1.
        in
        fdiv Td2308 l
  in
  let Tu12 : UNIT =
    let Ti2309 : INT =
      int 0
    in
    let Td2312 : FLOAT =
      let Td2311 : FLOAT =
        let Ti2310 : INT =
          int 0
        in
        v.(Ti2310)
      in
      fmul Td2311 il
    in
    v.(Ti2309) <- Td2312
  in
  let Tu11 : UNIT =
    let Ti2313 : INT =
      int 1
    in
    let Td2316 : FLOAT =
      let Td2315 : FLOAT =
        let Ti2314 : INT =
          int 1
        in
        v.(Ti2314)
      in
      fmul Td2315 il
    in
    v.(Ti2313) <- Td2316
  in
  let Ti2317 : INT =
    int 2
  in
  let Td2320 : FLOAT =
    let Td2319 : FLOAT =
      let Ti2318 : INT =
        int 2
      in
      v.(Ti2318)
    in
    fmul Td2319 il
  in
  v.(Ti2317) <- Td2320
in
letrec veciprod : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (v : Array of FLOAT), (w : Array of FLOAT)
  let Td2289 : FLOAT =
    let Td2283 : FLOAT =
      let Td2280 : FLOAT =
        let Ti2279 : INT =
          int 0
        in
        v.(Ti2279)
      in
      let Td2282 : FLOAT =
        let Ti2281 : INT =
          int 0
        in
        w.(Ti2281)
      in
      fmul Td2280 Td2282
    in
    let Td2288 : FLOAT =
      let Td2285 : FLOAT =
        let Ti2284 : INT =
          int 1
        in
        v.(Ti2284)
      in
      let Td2287 : FLOAT =
        let Ti2286 : INT =
          int 1
        in
        w.(Ti2286)
      in
      fmul Td2285 Td2287
    in
    fadd Td2283 Td2288
  in
  let Td2294 : FLOAT =
    let Td2291 : FLOAT =
      let Ti2290 : INT =
        int 2
      in
      v.(Ti2290)
    in
    let Td2293 : FLOAT =
      let Ti2292 : INT =
        int 2
      in
      w.(Ti2292)
    in
    fmul Td2291 Td2293
  in
  fadd Td2289 Td2294
in
letrec veciprod2 : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (v : Array of FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let Td2275 : FLOAT =
    let Td2271 : FLOAT =
      let Td2270 : FLOAT =
        let Ti2269 : INT =
          int 0
        in
        v.(Ti2269)
      in
      fmul Td2270 w0
    in
    let Td2274 : FLOAT =
      let Td2273 : FLOAT =
        let Ti2272 : INT =
          int 1
        in
        v.(Ti2272)
      in
      fmul Td2273 w1
    in
    fadd Td2271 Td2274
  in
  let Td2278 : FLOAT =
    let Td2277 : FLOAT =
      let Ti2276 : INT =
        int 2
      in
      v.(Ti2276)
    in
    fmul Td2277 w2
  in
  fadd Td2275 Td2278
in
letrec vecaccum : (Array of FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (scale : FLOAT), (v : Array of FLOAT)
  let Tu14 : UNIT =
    let Ti2248 : INT =
      int 0
    in
    let Td2254 : FLOAT =
      let Td2250 : FLOAT =
        let Ti2249 : INT =
          int 0
        in
        dest.(Ti2249)
      in
      let Td2253 : FLOAT =
        let Td2252 : FLOAT =
          let Ti2251 : INT =
            int 0
          in
          v.(Ti2251)
        in
        fmul scale Td2252
      in
      fadd Td2250 Td2253
    in
    dest.(Ti2248) <- Td2254
  in
  let Tu13 : UNIT =
    let Ti2255 : INT =
      int 1
    in
    let Td2261 : FLOAT =
      let Td2257 : FLOAT =
        let Ti2256 : INT =
          int 1
        in
        dest.(Ti2256)
      in
      let Td2260 : FLOAT =
        let Td2259 : FLOAT =
          let Ti2258 : INT =
            int 1
          in
          v.(Ti2258)
        in
        fmul scale Td2259
      in
      fadd Td2257 Td2260
    in
    dest.(Ti2255) <- Td2261
  in
  let Ti2262 : INT =
    int 2
  in
  let Td2268 : FLOAT =
    let Td2264 : FLOAT =
      let Ti2263 : INT =
        int 2
      in
      dest.(Ti2263)
    in
    let Td2267 : FLOAT =
      let Td2266 : FLOAT =
        let Ti2265 : INT =
          int 2
        in
        v.(Ti2265)
      in
      fmul scale Td2266
    in
    fadd Td2264 Td2267
  in
  dest.(Ti2262) <- Td2268
in
letrec vecadd : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu16 : UNIT =
    let Ti2230 : INT =
      int 0
    in
    let Td2235 : FLOAT =
      let Td2232 : FLOAT =
        let Ti2231 : INT =
          int 0
        in
        dest.(Ti2231)
      in
      let Td2234 : FLOAT =
        let Ti2233 : INT =
          int 0
        in
        v.(Ti2233)
      in
      fadd Td2232 Td2234
    in
    dest.(Ti2230) <- Td2235
  in
  let Tu15 : UNIT =
    let Ti2236 : INT =
      int 1
    in
    let Td2241 : FLOAT =
      let Td2238 : FLOAT =
        let Ti2237 : INT =
          int 1
        in
        dest.(Ti2237)
      in
      let Td2240 : FLOAT =
        let Ti2239 : INT =
          int 1
        in
        v.(Ti2239)
      in
      fadd Td2238 Td2240
    in
    dest.(Ti2236) <- Td2241
  in
  let Ti2242 : INT =
    int 2
  in
  let Td2247 : FLOAT =
    let Td2244 : FLOAT =
      let Ti2243 : INT =
        int 2
      in
      dest.(Ti2243)
    in
    let Td2246 : FLOAT =
      let Ti2245 : INT =
        int 2
      in
      v.(Ti2245)
    in
    fadd Td2244 Td2246
  in
  dest.(Ti2242) <- Td2247
in
letrec vecmul : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu18 : UNIT =
    let Ti2212 : INT =
      int 0
    in
    let Td2217 : FLOAT =
      let Td2214 : FLOAT =
        let Ti2213 : INT =
          int 0
        in
        dest.(Ti2213)
      in
      let Td2216 : FLOAT =
        let Ti2215 : INT =
          int 0
        in
        v.(Ti2215)
      in
      fmul Td2214 Td2216
    in
    dest.(Ti2212) <- Td2217
  in
  let Tu17 : UNIT =
    let Ti2218 : INT =
      int 1
    in
    let Td2223 : FLOAT =
      let Td2220 : FLOAT =
        let Ti2219 : INT =
          int 1
        in
        dest.(Ti2219)
      in
      let Td2222 : FLOAT =
        let Ti2221 : INT =
          int 1
        in
        v.(Ti2221)
      in
      fmul Td2220 Td2222
    in
    dest.(Ti2218) <- Td2223
  in
  let Ti2224 : INT =
    int 2
  in
  let Td2229 : FLOAT =
    let Td2226 : FLOAT =
      let Ti2225 : INT =
        int 2
      in
      dest.(Ti2225)
    in
    let Td2228 : FLOAT =
      let Ti2227 : INT =
        int 2
      in
      v.(Ti2227)
    in
    fmul Td2226 Td2228
  in
  dest.(Ti2224) <- Td2229
in
letrec vecscale : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (scale : FLOAT)
  let Tu20 : UNIT =
    let Ti2200 : INT =
      int 0
    in
    let Td2203 : FLOAT =
      let Td2202 : FLOAT =
        let Ti2201 : INT =
          int 0
        in
        dest.(Ti2201)
      in
      fmul Td2202 scale
    in
    dest.(Ti2200) <- Td2203
  in
  let Tu19 : UNIT =
    let Ti2204 : INT =
      int 1
    in
    let Td2207 : FLOAT =
      let Td2206 : FLOAT =
        let Ti2205 : INT =
          int 1
        in
        dest.(Ti2205)
      in
      fmul Td2206 scale
    in
    dest.(Ti2204) <- Td2207
  in
  let Ti2208 : INT =
    int 2
  in
  let Td2211 : FLOAT =
    let Td2210 : FLOAT =
      let Ti2209 : INT =
        int 2
      in
      dest.(Ti2209)
    in
    fmul Td2210 scale
  in
  dest.(Ti2208) <- Td2211
in
letrec vecaccumv : (Array of FLOAT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT), (w : Array of FLOAT)
  let Tu22 : UNIT =
    let Ti2173 : INT =
      int 0
    in
    let Td2181 : FLOAT =
      let Td2175 : FLOAT =
        let Ti2174 : INT =
          int 0
        in
        dest.(Ti2174)
      in
      let Td2180 : FLOAT =
        let Td2177 : FLOAT =
          let Ti2176 : INT =
            int 0
          in
          v.(Ti2176)
        in
        let Td2179 : FLOAT =
          let Ti2178 : INT =
            int 0
          in
          w.(Ti2178)
        in
        fmul Td2177 Td2179
      in
      fadd Td2175 Td2180
    in
    dest.(Ti2173) <- Td2181
  in
  let Tu21 : UNIT =
    let Ti2182 : INT =
      int 1
    in
    let Td2190 : FLOAT =
      let Td2184 : FLOAT =
        let Ti2183 : INT =
          int 1
        in
        dest.(Ti2183)
      in
      let Td2189 : FLOAT =
        let Td2186 : FLOAT =
          let Ti2185 : INT =
            int 1
          in
          v.(Ti2185)
        in
        let Td2188 : FLOAT =
          let Ti2187 : INT =
            int 1
          in
          w.(Ti2187)
        in
        fmul Td2186 Td2188
      in
      fadd Td2184 Td2189
    in
    dest.(Ti2182) <- Td2190
  in
  let Ti2191 : INT =
    int 2
  in
  let Td2199 : FLOAT =
    let Td2193 : FLOAT =
      let Ti2192 : INT =
        int 2
      in
      dest.(Ti2192)
    in
    let Td2198 : FLOAT =
      let Td2195 : FLOAT =
        let Ti2194 : INT =
          int 2
        in
        v.(Ti2194)
      in
      let Td2197 : FLOAT =
        let Ti2196 : INT =
          int 2
        in
        w.(Ti2196)
      in
      fmul Td2195 Td2197
    in
    fadd Td2193 Td2198
  in
  dest.(Ti2191) <- Td2199
in
letrec o_texturetype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (m_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_tex
in
letrec o_form : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (m_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_shape
in
letrec o_reflectiontype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_surface
in
letrec o_isinvert : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> BOOL) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (m_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_invert
in
letrec o_isrot : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (m_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_isrot
in
letrec o_param_a : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2172 : INT =
      int 0
    in
    m_abc.(Ti2172)
in
letrec o_param_b : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2171 : INT =
      int 1
    in
    m_abc.(Ti2171)
in
letrec o_param_c : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2170 : INT =
      int 2
    in
    m_abc.(Ti2170)
in
letrec o_param_abc : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_abc
in
letrec o_param_x : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2169 : INT =
      int 0
    in
    m_xyz.(Ti2169)
in
letrec o_param_y : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2168 : INT =
      int 1
    in
    m_xyz.(Ti2168)
in
letrec o_param_z : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2167 : INT =
      int 2
    in
    m_xyz.(Ti2167)
in
letrec o_diffuse : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2166 : INT =
      int 0
    in
    m_surfparams.(Ti2166)
in
letrec o_hilight : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2165 : INT =
      int 1
    in
    m_surfparams.(Ti2165)
in
letrec o_color_red : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2164 : INT =
      int 0
    in
    m_color.(Ti2164)
in
letrec o_color_green : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2163 : INT =
      int 1
    in
    m_color.(Ti2163)
in
letrec o_color_blue : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2162 : INT =
      int 2
    in
    m_color.(Ti2162)
in
letrec o_param_r1 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2161 : INT =
      int 0
    in
    m_rot123.(Ti2161)
in
letrec o_param_r2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2160 : INT =
      int 1
    in
    m_rot123.(Ti2160)
in
letrec o_param_r3 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2159 : INT =
      int 2
    in
    m_rot123.(Ti2159)
in
letrec o_param_ctbl : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (m_ctbl : Array of FLOAT)
    m
  in
    m_ctbl
in
letrec p_rgb : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (m_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_rgb
in
letrec p_intersection_points : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (m_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_isect_ps
in
letrec p_surface_ids : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (m_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_sids
in
letrec p_calc_diffuse : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of BOOL) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (m_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_cdif
in
letrec p_energy : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (m_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_engy
in
letrec p_received_ray_20percent : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (m_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_r20p
in
letrec p_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2158 : INT =
      int 0
    in
    m_gid.(Ti2158)
in
letrec p_set_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (id : INT)
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2157 : INT =
      int 0
    in
    m_gid.(Ti2157) <- id
in
letrec p_nvectors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (m_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_nvectors
in
letrec d_vec : ((Array of FLOAT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (m_vec : Array of FLOAT), (xm_const : Array of Array of FLOAT)
    d
  in
    m_vec
in
letrec d_const : ((Array of FLOAT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (dm_vec : Array of FLOAT), (m_const : Array of Array of FLOAT)
    d
  in
    m_const
in
letrec r_surface_id : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> INT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (m_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_sid
in
letrec r_dvec : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (m_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_dvec
in
letrec r_bright : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> FLOAT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (m_br : FLOAT)
    r
  in
    m_br
in
letrec rad : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2156 : FLOAT =
    float 0.017453293
  in
  fmul x Td2156
in
letrec read_screen_settings : (UNIT -> UNIT) =
variables : (Tu23 : UNIT)
  let Tu37 : UNIT =
    let Ti2101 : INT =
      int 0
    in
    let Td2103 : FLOAT =
      let Tu2102 : UNIT =
        unit ()
      in
      unknown inflt Tu2102
    in
    screen.(Ti2101) <- Td2103
  in
  let Tu36 : UNIT =
    let Ti2104 : INT =
      int 1
    in
    let Td2106 : FLOAT =
      let Tu2105 : UNIT =
        unit ()
      in
      unknown inflt Tu2105
    in
    screen.(Ti2104) <- Td2106
  in
  let Tu35 : UNIT =
    let Ti2107 : INT =
      int 2
    in
    let Td2109 : FLOAT =
      let Tu2108 : UNIT =
        unit ()
      in
      unknown inflt Tu2108
    in
    screen.(Ti2107) <- Td2109
  in
  let v1 : FLOAT =
    let Td2111 : FLOAT =
      let Tu2110 : UNIT =
        unit ()
      in
      unknown inflt Tu2110
    in
    app
      rad
      Td2111
  in
  let cos_v1 : FLOAT =
    app
      cos
      v1
  in
  let sin_v1 : FLOAT =
    app
      sin
      v1
  in
  let v2 : FLOAT =
    let Td2113 : FLOAT =
      let Tu2112 : UNIT =
        unit ()
      in
      unknown inflt Tu2112
    in
    app
      rad
      Td2113
  in
  let cos_v2 : FLOAT =
    app
      cos
      v2
  in
  let sin_v2 : FLOAT =
    app
      sin
      v2
  in
  let Tu34 : UNIT =
    let Ti2114 : INT =
      int 0
    in
    let Td2117 : FLOAT =
      let Td2115 : FLOAT =
        fmul cos_v1 sin_v2
      in
      let Td2116 : FLOAT =
        float 200.
      in
      fmul Td2115 Td2116
    in
    screenz_dir.(Ti2114) <- Td2117
  in
  let Tu33 : UNIT =
    let Ti2118 : INT =
      int 1
    in
    let Td2120 : FLOAT =
      let Td2119 : FLOAT =
        float -200.
      in
      fmul sin_v1 Td2119
    in
    screenz_dir.(Ti2118) <- Td2120
  in
  let Tu32 : UNIT =
    let Ti2121 : INT =
      int 2
    in
    let Td2124 : FLOAT =
      let Td2122 : FLOAT =
        fmul cos_v1 cos_v2
      in
      let Td2123 : FLOAT =
        float 200.
      in
      fmul Td2122 Td2123
    in
    screenz_dir.(Ti2121) <- Td2124
  in
  let Tu31 : UNIT =
    let Ti2125 : INT =
      int 0
    in
    screenx_dir.(Ti2125) <- cos_v2
  in
  let Tu30 : UNIT =
    let Ti2126 : INT =
      int 1
    in
    let Td2127 : FLOAT =
      float 0.
    in
    screenx_dir.(Ti2126) <- Td2127
  in
  let Tu29 : UNIT =
    let Ti2128 : INT =
      int 2
    in
    let Td2129 : FLOAT =
      fneg sin_v2
    in
    screenx_dir.(Ti2128) <- Td2129
  in
  let Tu28 : UNIT =
    let Ti2130 : INT =
      int 0
    in
    let Td2132 : FLOAT =
      let Td2131 : FLOAT =
        fneg sin_v1
      in
      fmul Td2131 sin_v2
    in
    screeny_dir.(Ti2130) <- Td2132
  in
  let Tu27 : UNIT =
    let Ti2133 : INT =
      int 1
    in
    let Td2134 : FLOAT =
      fneg cos_v1
    in
    screeny_dir.(Ti2133) <- Td2134
  in
  let Tu26 : UNIT =
    let Ti2135 : INT =
      int 2
    in
    let Td2137 : FLOAT =
      let Td2136 : FLOAT =
        fneg sin_v1
      in
      fmul Td2136 cos_v2
    in
    screeny_dir.(Ti2135) <- Td2137
  in
  let Tu25 : UNIT =
    let Ti2138 : INT =
      int 0
    in
    let Td2143 : FLOAT =
      let Td2140 : FLOAT =
        let Ti2139 : INT =
          int 0
        in
        screen.(Ti2139)
      in
      let Td2142 : FLOAT =
        let Ti2141 : INT =
          int 0
        in
        screenz_dir.(Ti2141)
      in
      fsub Td2140 Td2142
    in
    viewpoint.(Ti2138) <- Td2143
  in
  let Tu24 : UNIT =
    let Ti2144 : INT =
      int 1
    in
    let Td2149 : FLOAT =
      let Td2146 : FLOAT =
        let Ti2145 : INT =
          int 1
        in
        screen.(Ti2145)
      in
      let Td2148 : FLOAT =
        let Ti2147 : INT =
          int 1
        in
        screenz_dir.(Ti2147)
      in
      fsub Td2146 Td2148
    in
    viewpoint.(Ti2144) <- Td2149
  in
  let Ti2150 : INT =
    int 2
  in
  let Td2155 : FLOAT =
    let Td2152 : FLOAT =
      let Ti2151 : INT =
        int 2
      in
      screen.(Ti2151)
    in
    let Td2154 : FLOAT =
      let Ti2153 : INT =
        int 2
      in
      screenz_dir.(Ti2153)
    in
    fsub Td2152 Td2154
  in
  viewpoint.(Ti2150) <- Td2155
in
letrec read_light : (UNIT -> UNIT) =
variables : (Tu38 : UNIT)
  let nl : INT =
    let Tu2087 : UNIT =
      unit ()
    in
    unknown inint Tu2087
  in
  let l1 : FLOAT =
    let Td2089 : FLOAT =
      let Tu2088 : UNIT =
        unit ()
      in
      unknown inflt Tu2088
    in
    app
      rad
      Td2089
  in
  let sl1 : FLOAT =
    app
      sin
      l1
  in
  let Tu41 : UNIT =
    let Ti2090 : INT =
      int 1
    in
    let Td2091 : FLOAT =
      fneg sl1
    in
    light.(Ti2090) <- Td2091
  in
  let l2 : FLOAT =
    let Td2093 : FLOAT =
      let Tu2092 : UNIT =
        unit ()
      in
      unknown inflt Tu2092
    in
    app
      rad
      Td2093
  in
  let cl1 : FLOAT =
    app
      cos
      l1
  in
  let sl2 : FLOAT =
    app
      sin
      l2
  in
  let Tu40 : UNIT =
    let Ti2094 : INT =
      int 0
    in
    let Td2095 : FLOAT =
      fmul cl1 sl2
    in
    light.(Ti2094) <- Td2095
  in
  let cl2 : FLOAT =
    app
      cos
      l2
  in
  let Tu39 : UNIT =
    let Ti2096 : INT =
      int 2
    in
    let Td2097 : FLOAT =
      fmul cl1 cl2
    in
    light.(Ti2096) <- Td2097
  in
  let Ti2098 : INT =
    int 0
  in
  let Td2100 : FLOAT =
    let Tu2099 : UNIT =
      unit ()
    in
    unknown inflt Tu2099
  in
  beam.(Ti2098) <- Td2100
in
letrec rotate_quadratic_matrix : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (abc : Array of FLOAT), (rot : Array of FLOAT)
  let cos_x : FLOAT =
    let Td2001 : FLOAT =
      let Ti2000 : INT =
        int 0
      in
      rot.(Ti2000)
    in
    app
      cos
      Td2001
  in
  let sin_x : FLOAT =
    let Td2003 : FLOAT =
      let Ti2002 : INT =
        int 0
      in
      rot.(Ti2002)
    in
    app
      sin
      Td2003
  in
  let cos_y : FLOAT =
    let Td2005 : FLOAT =
      let Ti2004 : INT =
        int 1
      in
      rot.(Ti2004)
    in
    app
      cos
      Td2005
  in
  let sin_y : FLOAT =
    let Td2007 : FLOAT =
      let Ti2006 : INT =
        int 1
      in
      rot.(Ti2006)
    in
    app
      sin
      Td2007
  in
  let cos_z : FLOAT =
    let Td2009 : FLOAT =
      let Ti2008 : INT =
        int 2
      in
      rot.(Ti2008)
    in
    app
      cos
      Td2009
  in
  let sin_z : FLOAT =
    let Td2011 : FLOAT =
      let Ti2010 : INT =
        int 2
      in
      rot.(Ti2010)
    in
    app
      sin
      Td2011
  in
  let m00 : FLOAT =
    fmul cos_y cos_z
  in
  let m01 : FLOAT =
    let Td2013 : FLOAT =
      let Td2012 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2012 cos_z
    in
    let Td2014 : FLOAT =
      fmul cos_x sin_z
    in
    fsub Td2013 Td2014
  in
  let m02 : FLOAT =
    let Td2016 : FLOAT =
      let Td2015 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2015 cos_z
    in
    let Td2017 : FLOAT =
      fmul sin_x sin_z
    in
    fadd Td2016 Td2017
  in
  let m10 : FLOAT =
    fmul cos_y sin_z
  in
  let m11 : FLOAT =
    let Td2019 : FLOAT =
      let Td2018 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2018 sin_z
    in
    let Td2020 : FLOAT =
      fmul cos_x cos_z
    in
    fadd Td2019 Td2020
  in
  let m12 : FLOAT =
    let Td2022 : FLOAT =
      let Td2021 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2021 sin_z
    in
    let Td2023 : FLOAT =
      fmul sin_x cos_z
    in
    fsub Td2022 Td2023
  in
  let m20 : FLOAT =
    fneg sin_y
  in
  let m21 : FLOAT =
    fmul sin_x cos_y
  in
  let m22 : FLOAT =
    fmul cos_x cos_y
  in
  let ao : FLOAT =
    let Ti2024 : INT =
      int 0
    in
    abc.(Ti2024)
  in
  let bo : FLOAT =
    let Ti2025 : INT =
      int 1
    in
    abc.(Ti2025)
  in
  let co : FLOAT =
    let Ti2026 : INT =
      int 2
    in
    abc.(Ti2026)
  in
  let Tu46 : UNIT =
    let Ti2027 : INT =
      int 0
    in
    let Td2035 : FLOAT =
      let Td2032 : FLOAT =
        let Td2029 : FLOAT =
          let Td2028 : FLOAT =
            app
              fsqr
              m00
          in
          fmul ao Td2028
        in
        let Td2031 : FLOAT =
          let Td2030 : FLOAT =
            app
              fsqr
              m10
          in
          fmul bo Td2030
        in
        fadd Td2029 Td2031
      in
      let Td2034 : FLOAT =
        let Td2033 : FLOAT =
          app
            fsqr
            m20
        in
        fmul co Td2033
      in
      fadd Td2032 Td2034
    in
    abc.(Ti2027) <- Td2035
  in
  let Tu45 : UNIT =
    let Ti2036 : INT =
      int 1
    in
    let Td2044 : FLOAT =
      let Td2041 : FLOAT =
        let Td2038 : FLOAT =
          let Td2037 : FLOAT =
            app
              fsqr
              m01
          in
          fmul ao Td2037
        in
        let Td2040 : FLOAT =
          let Td2039 : FLOAT =
            app
              fsqr
              m11
          in
          fmul bo Td2039
        in
        fadd Td2038 Td2040
      in
      let Td2043 : FLOAT =
        let Td2042 : FLOAT =
          app
            fsqr
            m21
        in
        fmul co Td2042
      in
      fadd Td2041 Td2043
    in
    abc.(Ti2036) <- Td2044
  in
  let Tu44 : UNIT =
    let Ti2045 : INT =
      int 2
    in
    let Td2053 : FLOAT =
      let Td2050 : FLOAT =
        let Td2047 : FLOAT =
          let Td2046 : FLOAT =
            app
              fsqr
              m02
          in
          fmul ao Td2046
        in
        let Td2049 : FLOAT =
          let Td2048 : FLOAT =
            app
              fsqr
              m12
          in
          fmul bo Td2048
        in
        fadd Td2047 Td2049
      in
      let Td2052 : FLOAT =
        let Td2051 : FLOAT =
          app
            fsqr
            m22
        in
        fmul co Td2051
      in
      fadd Td2050 Td2052
    in
    abc.(Ti2045) <- Td2053
  in
  let Tu43 : UNIT =
    let Ti2054 : INT =
      int 0
    in
    let Td2064 : FLOAT =
      let Td2055 : FLOAT =
        float 2.
      in
      let Td2063 : FLOAT =
        let Td2060 : FLOAT =
          let Td2057 : FLOAT =
            let Td2056 : FLOAT =
              fmul ao m01
            in
            fmul Td2056 m02
          in
          let Td2059 : FLOAT =
            let Td2058 : FLOAT =
              fmul bo m11
            in
            fmul Td2058 m12
          in
          fadd Td2057 Td2059
        in
        let Td2062 : FLOAT =
          let Td2061 : FLOAT =
            fmul co m21
          in
          fmul Td2061 m22
        in
        fadd Td2060 Td2062
      in
      fmul Td2055 Td2063
    in
    rot.(Ti2054) <- Td2064
  in
  let Tu42 : UNIT =
    let Ti2065 : INT =
      int 1
    in
    let Td2075 : FLOAT =
      let Td2066 : FLOAT =
        float 2.
      in
      let Td2074 : FLOAT =
        let Td2071 : FLOAT =
          let Td2068 : FLOAT =
            let Td2067 : FLOAT =
              fmul ao m00
            in
            fmul Td2067 m02
          in
          let Td2070 : FLOAT =
            let Td2069 : FLOAT =
              fmul bo m10
            in
            fmul Td2069 m12
          in
          fadd Td2068 Td2070
        in
        let Td2073 : FLOAT =
          let Td2072 : FLOAT =
            fmul co m20
          in
          fmul Td2072 m22
        in
        fadd Td2071 Td2073
      in
      fmul Td2066 Td2074
    in
    rot.(Ti2065) <- Td2075
  in
  let Ti2076 : INT =
    int 2
  in
  let Td2086 : FLOAT =
    let Td2077 : FLOAT =
      float 2.
    in
    let Td2085 : FLOAT =
      let Td2082 : FLOAT =
        let Td2079 : FLOAT =
          let Td2078 : FLOAT =
            fmul ao m00
          in
          fmul Td2078 m01
        in
        let Td2081 : FLOAT =
          let Td2080 : FLOAT =
            fmul bo m10
          in
          fmul Td2080 m11
        in
        fadd Td2079 Td2081
      in
      let Td2084 : FLOAT =
        let Td2083 : FLOAT =
          fmul co m20
        in
        fmul Td2083 m21
      in
      fadd Td2082 Td2084
    in
    fmul Td2077 Td2085
  in
  rot.(Ti2076) <- Td2086
in
letrec read_nth_object : (INT -> BOOL) =
variables : (n : INT)
  let texture : INT =
    let Tu1912 : UNIT =
      unit ()
    in
    unknown inint Tu1912
  in
  let Ti1914 : INT =
    let Ti1913 : INT =
      int 1
    in
    neg Ti1913
  in
  if texture == Ti1914
    int 0
    let form : INT =
      let Tu1915 : UNIT =
        unit ()
      in
      unknown inint Tu1915
    in
    let refltype : INT =
      let Tu1916 : UNIT =
        unit ()
      in
      unknown inint Tu1916
    in
    let isrot_p : INT =
      let Tu1917 : UNIT =
        unit ()
      in
      unknown inint Tu1917
    in
    let abc : Array of FLOAT =
      let Ti1918 : INT =
        int 3
      in
      let Td1919 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1918
        Td1919
    in
    let Tu65 : UNIT =
      let Ti1920 : INT =
        int 0
      in
      let Td1922 : FLOAT =
        let Tu1921 : UNIT =
          unit ()
        in
        unknown inflt Tu1921
      in
      abc.(Ti1920) <- Td1922
    in
    let Tu64 : UNIT =
      let Ti1923 : INT =
        int 1
      in
      let Td1925 : FLOAT =
        let Tu1924 : UNIT =
          unit ()
        in
        unknown inflt Tu1924
      in
      abc.(Ti1923) <- Td1925
    in
    let Tu63 : UNIT =
      let Ti1926 : INT =
        int 2
      in
      let Td1928 : FLOAT =
        let Tu1927 : UNIT =
          unit ()
        in
        unknown inflt Tu1927
      in
      abc.(Ti1926) <- Td1928
    in
    let xyz : Array of FLOAT =
      let Ti1929 : INT =
        int 3
      in
      let Td1930 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1929
        Td1930
    in
    let Tu62 : UNIT =
      let Ti1931 : INT =
        int 0
      in
      let Td1933 : FLOAT =
        let Tu1932 : UNIT =
          unit ()
        in
        unknown inflt Tu1932
      in
      xyz.(Ti1931) <- Td1933
    in
    let Tu61 : UNIT =
      let Ti1934 : INT =
        int 1
      in
      let Td1936 : FLOAT =
        let Tu1935 : UNIT =
          unit ()
        in
        unknown inflt Tu1935
      in
      xyz.(Ti1934) <- Td1936
    in
    let Tu60 : UNIT =
      let Ti1937 : INT =
        int 2
      in
      let Td1939 : FLOAT =
        let Tu1938 : UNIT =
          unit ()
        in
        unknown inflt Tu1938
      in
      xyz.(Ti1937) <- Td1939
    in
    let m_invert : BOOL =
      let Td1941 : FLOAT =
        let Tu1940 : UNIT =
          unit ()
        in
        unknown inflt Tu1940
      in
      let Td1942 : FLOAT =
        float 0.
      in
      if Td1941 <. Td1942
        int 1
        int 0
    in
    let reflparam : Array of FLOAT =
      let Ti1943 : INT =
        int 2
      in
      let Td1944 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1943
        Td1944
    in
    let Tu59 : UNIT =
      let Ti1945 : INT =
        int 0
      in
      let Td1947 : FLOAT =
        let Tu1946 : UNIT =
          unit ()
        in
        unknown inflt Tu1946
      in
      reflparam.(Ti1945) <- Td1947
    in
    let Tu58 : UNIT =
      let Ti1948 : INT =
        int 1
      in
      let Td1950 : FLOAT =
        let Tu1949 : UNIT =
          unit ()
        in
        unknown inflt Tu1949
      in
      reflparam.(Ti1948) <- Td1950
    in
    let color : Array of FLOAT =
      let Ti1951 : INT =
        int 3
      in
      let Td1952 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1951
        Td1952
    in
    let Tu57 : UNIT =
      let Ti1953 : INT =
        int 0
      in
      let Td1955 : FLOAT =
        let Tu1954 : UNIT =
          unit ()
        in
        unknown inflt Tu1954
      in
      color.(Ti1953) <- Td1955
    in
    let Tu56 : UNIT =
      let Ti1956 : INT =
        int 1
      in
      let Td1958 : FLOAT =
        let Tu1957 : UNIT =
          unit ()
        in
        unknown inflt Tu1957
      in
      color.(Ti1956) <- Td1958
    in
    let Tu55 : UNIT =
      let Ti1959 : INT =
        int 2
      in
      let Td1961 : FLOAT =
        let Tu1960 : UNIT =
          unit ()
        in
        unknown inflt Tu1960
      in
      color.(Ti1959) <- Td1961
    in
    let rotation : Array of FLOAT =
      let Ti1962 : INT =
        int 3
      in
      let Td1963 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1962
        Td1963
    in
    let Tu54 : UNIT =
      let Ti1964 : INT =
        int 0
      in
      if isrot_p == Ti1964
        unit ()
        let Tu48 : UNIT =
          let Ti1965 : INT =
            int 0
          in
          let Td1968 : FLOAT =
            let Td1967 : FLOAT =
              let Tu1966 : UNIT =
                unit ()
              in
              unknown inflt Tu1966
            in
            app
              rad
              Td1967
          in
          rotation.(Ti1965) <- Td1968
        in
        let Tu47 : UNIT =
          let Ti1969 : INT =
            int 1
          in
          let Td1972 : FLOAT =
            let Td1971 : FLOAT =
              let Tu1970 : UNIT =
                unit ()
              in
              unknown inflt Tu1970
            in
            app
              rad
              Td1971
          in
          rotation.(Ti1969) <- Td1972
        in
        let Ti1973 : INT =
          int 2
        in
        let Td1976 : FLOAT =
          let Td1975 : FLOAT =
            let Tu1974 : UNIT =
              unit ()
            in
            unknown inflt Tu1974
          in
          app
            rad
            Td1975
        in
        rotation.(Ti1973) <- Td1976
    in
    let m_invert2 : BOOL =
      let Ti1977 : INT =
        int 2
      in
      if form == Ti1977
        int 1
        m_invert
    in
    let ctbl : Array of FLOAT =
      let Ti1978 : INT =
        int 4
      in
      let Td1979 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1978
        Td1979
    in
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      Tuple
        texture
        form
        refltype
        isrot_p
        abc
        xyz
        m_invert2
        reflparam
        color
        rotation
        ctbl
    in
    let Tu53 : UNIT =
      objects.(n) <- obj
    in
    let Tu52 : UNIT =
      let Ti1980 : INT =
        int 3
      in
      if form == Ti1980
        let a : FLOAT =
          let Ti1981 : INT =
            int 0
          in
          abc.(Ti1981)
        in
        let Tu50 : UNIT =
          let Ti1982 : INT =
            int 0
          in
          let Td1985 : FLOAT =
            if a == 0.0 
              float 0.
              let Td1983 : FLOAT =
                app
                  sgn
                  a
              in
              let Td1984 : FLOAT =
                app
                  fsqr
                  a
              in
              fdiv Td1983 Td1984
          in
          abc.(Ti1982) <- Td1985
        in
        let b : FLOAT =
          let Ti1986 : INT =
            int 1
          in
          abc.(Ti1986)
        in
        let Tu49 : UNIT =
          let Ti1987 : INT =
            int 1
          in
          let Td1990 : FLOAT =
            if b == 0.0 
              float 0.
              let Td1988 : FLOAT =
                app
                  sgn
                  b
              in
              let Td1989 : FLOAT =
                app
                  fsqr
                  b
              in
              fdiv Td1988 Td1989
          in
          abc.(Ti1987) <- Td1990
        in
        let c : FLOAT =
          let Ti1991 : INT =
            int 2
          in
          abc.(Ti1991)
        in
        let Ti1992 : INT =
          int 2
        in
        let Td1995 : FLOAT =
          if c == 0.0 
            float 0.
            let Td1993 : FLOAT =
              app
                sgn
                c
            in
            let Td1994 : FLOAT =
              app
                fsqr
                c
            in
            fdiv Td1993 Td1994
        in
        abc.(Ti1992) <- Td1995
        let Ti1996 : INT =
          int 2
        in
        if form == Ti1996
          let Ti1998 : INT =
            let Ti1997 : INT =
              int 0
            in
            if m_invert == Ti1997
              int 1
              int 0
          in
          app
            vecunit_sgn
            abc
            Ti1998
          unit ()
    in
    let Tu51 : UNIT =
      let Ti1999 : INT =
        int 0
      in
      if isrot_p == Ti1999
        unit ()
        app
          rotate_quadratic_matrix
          abc
          rotation
    in
    int 1
in
letrec read_object : (INT -> UNIT) =
variables : (n : INT)
  let Ti1906 : INT =
    int 60
  in
  if Ti1906 <= n
    unit ()
    let Tb1907 : BOOL =
      app
        read_nth_object
        n
    in
    let Ti1908 : INT =
      int 0
    in
    if Tb1907 == Ti1908
      let Ti1909 : INT =
        int 0
      in
      n_objects.(Ti1909) <- n
      let Ti1911 : INT =
        let Ti1910 : INT =
          int 1
        in
        add n Ti1910
      in
      app
        read_object
        Ti1911
in
letrec read_all_object : (UNIT -> UNIT) =
variables : (Tu66 : UNIT)
  let Ti1905 : INT =
    int 0
  in
  app
    read_object
    Ti1905
in
letrec read_net_item : (INT -> Array of INT) =
variables : (length : INT)
  let item : INT =
    let Tu1896 : UNIT =
      unit ()
    in
    unknown inint Tu1896
  in
  let Ti1898 : INT =
    let Ti1897 : INT =
      int 1
    in
    neg Ti1897
  in
  if item == Ti1898
    let Ti1900 : INT =
      let Ti1899 : INT =
        int 1
      in
      add length Ti1899
    in
    let Ti1902 : INT =
      let Ti1901 : INT =
        int 1
      in
      neg Ti1901
    in
    extfunapp
      create_array
      Ti1900
      Ti1902
    let v : Array of INT =
      let Ti1904 : INT =
        let Ti1903 : INT =
          int 1
        in
        add length Ti1903
      in
      app
        read_net_item
        Ti1904
    in
    let Tu67 : UNIT =
      v.(length) <- item
    in
    v
in
letrec read_or_network : (INT -> Array of Array of INT) =
variables : (length : INT)
  let net : Array of INT =
    let Ti1887 : INT =
      int 0
    in
    app
      read_net_item
      Ti1887
  in
  let Ti1889 : INT =
    let Ti1888 : INT =
      int 0
    in
    net.(Ti1888)
  in
  let Ti1891 : INT =
    let Ti1890 : INT =
      int 1
    in
    neg Ti1890
  in
  if Ti1889 == Ti1891
    let Ti1893 : INT =
      let Ti1892 : INT =
        int 1
      in
      add length Ti1892
    in
    extfunapp
      create_array
      Ti1893
      net
    let v : Array of Array of INT =
      let Ti1895 : INT =
        let Ti1894 : INT =
          int 1
        in
        add length Ti1894
      in
      app
        read_or_network
        Ti1895
    in
    let Tu68 : UNIT =
      v.(length) <- net
    in
    v
in
letrec read_and_network : (INT -> UNIT) =
variables : (n : INT)
  let net : Array of INT =
    let Ti1880 : INT =
      int 0
    in
    app
      read_net_item
      Ti1880
  in
  let Ti1882 : INT =
    let Ti1881 : INT =
      int 0
    in
    net.(Ti1881)
  in
  let Ti1884 : INT =
    let Ti1883 : INT =
      int 1
    in
    neg Ti1883
  in
  if Ti1882 == Ti1884
    unit ()
    let Tu69 : UNIT =
      and_net.(n) <- net
    in
    let Ti1886 : INT =
      let Ti1885 : INT =
        int 1
      in
      add n Ti1885
    in
    app
      read_and_network
      Ti1886
in
letrec read_parameter : (UNIT -> UNIT) =
variables : (Tu70 : UNIT)
  let Tu74 : UNIT =
    let Tu1873 : UNIT =
      unit ()
    in
    app
      read_screen_settings
      Tu1873
  in
  let Tu73 : UNIT =
    let Tu1874 : UNIT =
      unit ()
    in
    app
      read_light
      Tu1874
  in
  let Tu72 : UNIT =
    let Tu1875 : UNIT =
      unit ()
    in
    app
      read_all_object
      Tu1875
  in
  let Tu71 : UNIT =
    let Ti1876 : INT =
      int 0
    in
    app
      read_and_network
      Ti1876
  in
  let Ti1877 : INT =
    int 0
  in
  let Ta1879 : Array of Array of INT =
    let Ti1878 : INT =
      int 0
    in
    app
      read_or_network
      Ti1878
  in
  or_net.(Ti1877) <- Ta1879
in
letrec solver_rect_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> (INT -> BOOL)))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT), (i0 : INT), (i1 : INT), (i2 : INT)
  let Td1849 : FLOAT =
    dirvec.(i0)
  in
  if Td1849 == 0.0 
    int 0
    let abc : Array of FLOAT =
      app
        o_param_abc
        m
    in
    let d : FLOAT =
      let Tb1854 : BOOL =
        let Tb1850 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1853 : INT =
          let Td1851 : FLOAT =
            dirvec.(i0)
          in
          let Td1852 : FLOAT =
            float 0.
          in
          if Td1851 <. Td1852
            int 1
            int 0
        in
        app
          xor
          Tb1850
          Ti1853
      in
      let Td1855 : FLOAT =
        abc.(i0)
      in
      app
        fneg_cond
        Tb1854
        Td1855
    in
    let d2 : FLOAT =
      let Td1856 : FLOAT =
        fsub d b0
      in
      let Td1857 : FLOAT =
        dirvec.(i0)
      in
      fdiv Td1856 Td1857
    in
    let Tb1863 : BOOL =
      let Td1861 : FLOAT =
        let Td1860 : FLOAT =
          let Td1859 : FLOAT =
            let Td1858 : FLOAT =
              dirvec.(i1)
            in
            fmul d2 Td1858
          in
          fadd Td1859 b1
        in
        app
          fabs
          Td1860
      in
      let Td1862 : FLOAT =
        abc.(i1)
      in
      app
        fless
        Td1861
        Td1862
    in
    let Ti1864 : INT =
      int 0
    in
    if Tb1863 == Ti1864
      int 0
      let Tb1870 : BOOL =
        let Td1868 : FLOAT =
          let Td1867 : FLOAT =
            let Td1866 : FLOAT =
              let Td1865 : FLOAT =
                dirvec.(i2)
              in
              fmul d2 Td1865
            in
            fadd Td1866 b2
          in
          app
            fabs
            Td1867
        in
        let Td1869 : FLOAT =
          abc.(i2)
        in
        app
          fless
          Td1868
          Td1869
      in
      let Ti1871 : INT =
        int 0
      in
      if Tb1870 == Ti1871
        int 0
        let Tu75 : UNIT =
          let Ti1872 : INT =
            int 0
          in
          solver_dist.(Ti1872) <- d2
        in
        int 1
in
letrec solver_rect : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1837 : BOOL =
    let Ti1834 : INT =
      int 0
    in
    let Ti1835 : INT =
      int 1
    in
    let Ti1836 : INT =
      int 2
    in
    app
      solver_rect_surface
      m
      dirvec
      b0
      b1
      b2
      Ti1834
      Ti1835
      Ti1836
  in
  let Ti1838 : INT =
    int 0
  in
  if Tb1837 == Ti1838
    let Tb1842 : BOOL =
      let Ti1839 : INT =
        int 1
      in
      let Ti1840 : INT =
        int 2
      in
      let Ti1841 : INT =
        int 0
      in
      app
        solver_rect_surface
        m
        dirvec
        b1
        b2
        b0
        Ti1839
        Ti1840
        Ti1841
    in
    let Ti1843 : INT =
      int 0
    in
    if Tb1842 == Ti1843
      let Tb1847 : BOOL =
        let Ti1844 : INT =
          int 2
        in
        let Ti1845 : INT =
          int 0
        in
        let Ti1846 : INT =
          int 1
        in
        app
          solver_rect_surface
          m
          dirvec
          b2
          b0
          b1
          Ti1844
          Ti1845
          Ti1846
      in
      let Ti1848 : INT =
        int 0
      in
      if Tb1847 == Ti1848
        int 0
        int 3
      int 2
    int 1
in
letrec solver_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let abc : Array of FLOAT =
    app
      o_param_abc
      m
  in
  let d : FLOAT =
    app
      veciprod
      dirvec
      abc
  in
  let Td1829 : FLOAT =
    float 0.
  in
  if Td1829 <. d
    let Tu76 : UNIT =
      let Ti1830 : INT =
        int 0
      in
      let Td1833 : FLOAT =
        let Td1832 : FLOAT =
          let Td1831 : FLOAT =
            app
              veciprod2
              abc
              b0
              b1
              b2
          in
          fneg Td1831
        in
        fdiv Td1832 d
      in
      solver_dist.(Ti1830) <- Td1833
    in
    int 1
    int 0
in
letrec quadratic : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let diag_part : FLOAT =
    let Td1812 : FLOAT =
      let Td1808 : FLOAT =
        let Td1806 : FLOAT =
          app
            fsqr
            v0
        in
        let Td1807 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1806 Td1807
      in
      let Td1811 : FLOAT =
        let Td1809 : FLOAT =
          app
            fsqr
            v1
        in
        let Td1810 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1809 Td1810
      in
      fadd Td1808 Td1811
    in
    let Td1815 : FLOAT =
      let Td1813 : FLOAT =
        app
          fsqr
          v2
      in
      let Td1814 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1813 Td1814
    in
    fadd Td1812 Td1815
  in
  let Ti1816 : INT =
    app
      o_isrot
      m
  in
  let Ti1817 : INT =
    int 0
  in
  if Ti1816 == Ti1817
    diag_part
    let Td1825 : FLOAT =
      let Td1821 : FLOAT =
        let Td1820 : FLOAT =
          let Td1818 : FLOAT =
            fmul v1 v2
          in
          let Td1819 : FLOAT =
            app
              o_param_r1
              m
          in
          fmul Td1818 Td1819
        in
        fadd diag_part Td1820
      in
      let Td1824 : FLOAT =
        let Td1822 : FLOAT =
          fmul v2 v0
        in
        let Td1823 : FLOAT =
          app
            o_param_r2
            m
        in
        fmul Td1822 Td1823
      in
      fadd Td1821 Td1824
    in
    let Td1828 : FLOAT =
      let Td1826 : FLOAT =
        fmul v0 v1
      in
      let Td1827 : FLOAT =
        app
          o_param_r3
          m
      in
      fmul Td1826 Td1827
    in
    fadd Td1825 Td1828
in
letrec bilinear : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let diag_part : FLOAT =
    let Td1782 : FLOAT =
      let Td1778 : FLOAT =
        let Td1776 : FLOAT =
          fmul v0 w0
        in
        let Td1777 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1776 Td1777
      in
      let Td1781 : FLOAT =
        let Td1779 : FLOAT =
          fmul v1 w1
        in
        let Td1780 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1779 Td1780
      in
      fadd Td1778 Td1781
    in
    let Td1785 : FLOAT =
      let Td1783 : FLOAT =
        fmul v2 w2
      in
      let Td1784 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1783 Td1784
    in
    fadd Td1782 Td1785
  in
  let Ti1786 : INT =
    app
      o_isrot
      m
  in
  let Ti1787 : INT =
    int 0
  in
  if Ti1786 == Ti1787
    diag_part
    let Td1805 : FLOAT =
      let Td1804 : FLOAT =
        let Td1798 : FLOAT =
          let Td1792 : FLOAT =
            let Td1790 : FLOAT =
              let Td1788 : FLOAT =
                fmul v2 w1
              in
              let Td1789 : FLOAT =
                fmul v1 w2
              in
              fadd Td1788 Td1789
            in
            let Td1791 : FLOAT =
              app
                o_param_r1
                m
            in
            fmul Td1790 Td1791
          in
          let Td1797 : FLOAT =
            let Td1795 : FLOAT =
              let Td1793 : FLOAT =
                fmul v0 w2
              in
              let Td1794 : FLOAT =
                fmul v2 w0
              in
              fadd Td1793 Td1794
            in
            let Td1796 : FLOAT =
              app
                o_param_r2
                m
            in
            fmul Td1795 Td1796
          in
          fadd Td1792 Td1797
        in
        let Td1803 : FLOAT =
          let Td1801 : FLOAT =
            let Td1799 : FLOAT =
              fmul v0 w1
            in
            let Td1800 : FLOAT =
              fmul v1 w0
            in
            fadd Td1799 Td1800
          in
          let Td1802 : FLOAT =
            app
              o_param_r3
              m
          in
          fmul Td1801 Td1802
        in
        fadd Td1798 Td1803
      in
      app
        fhalf
        Td1804
    in
    fadd diag_part Td1805
in
letrec solver_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Td1754 : FLOAT =
      let Ti1753 : INT =
        int 0
      in
      dirvec.(Ti1753)
    in
    let Td1756 : FLOAT =
      let Ti1755 : INT =
        int 1
      in
      dirvec.(Ti1755)
    in
    let Td1758 : FLOAT =
      let Ti1757 : INT =
        int 2
      in
      dirvec.(Ti1757)
    in
    app
      quadratic
      m
      Td1754
      Td1756
      Td1758
  in
  if aa == 0.0 
    int 0
    let bb : FLOAT =
      let Td1760 : FLOAT =
        let Ti1759 : INT =
          int 0
        in
        dirvec.(Ti1759)
      in
      let Td1762 : FLOAT =
        let Ti1761 : INT =
          int 1
        in
        dirvec.(Ti1761)
      in
      let Td1764 : FLOAT =
        let Ti1763 : INT =
          int 2
        in
        dirvec.(Ti1763)
      in
      app
        bilinear
        m
        Td1760
        Td1762
        Td1764
        b0
        b1
        b2
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1765 : INT =
        app
          o_form
          m
      in
      let Ti1766 : INT =
        int 3
      in
      if Ti1765 == Ti1766
        let Td1767 : FLOAT =
          float 1.
        in
        fsub cc0 Td1767
        cc0
    in
    let d : FLOAT =
      let Td1768 : FLOAT =
        app
          fsqr
          bb
      in
      let Td1769 : FLOAT =
        fmul aa cc
      in
      fsub Td1768 Td1769
    in
    let Td1770 : FLOAT =
      float 0.
    in
    if Td1770 <. d
      let sd : FLOAT =
        app
          sqrt
          d
      in
      let t1 : FLOAT =
        let Tb1771 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1772 : INT =
          int 0
        in
        if Tb1771 == Ti1772
          fneg sd
          sd
      in
      let Tu77 : UNIT =
        let Ti1773 : INT =
          int 0
        in
        let Td1775 : FLOAT =
          let Td1774 : FLOAT =
            fsub t1 bb
          in
          fdiv Td1774 aa
        in
        solver_dist.(Ti1773) <- Td1775
      in
      int 1
      int 0
in
letrec solver : (INT -> (Array of FLOAT -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : Array of FLOAT), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1743 : FLOAT =
      let Ti1742 : INT =
        int 0
      in
      org.(Ti1742)
    in
    let Td1744 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1743 Td1744
  in
  let b1 : FLOAT =
    let Td1746 : FLOAT =
      let Ti1745 : INT =
        int 1
      in
      org.(Ti1745)
    in
    let Td1747 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1746 Td1747
  in
  let b2 : FLOAT =
    let Td1749 : FLOAT =
      let Ti1748 : INT =
        int 2
      in
      org.(Ti1748)
    in
    let Td1750 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1749 Td1750
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1751 : INT =
    int 1
  in
  if m_shape == Ti1751
    app
      solver_rect
      m
      dirvec
      b0
      b1
      b2
    let Ti1752 : INT =
      int 2
    in
    if m_shape == Ti1752
      app
        solver_surface
        m
        dirvec
        b0
        b1
        b2
      app
        solver_second
        m
        dirvec
        b0
        b1
        b2
in
letrec solver_rect_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v : Array of FLOAT), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let d0 : FLOAT =
    let Td1666 : FLOAT =
      let Td1665 : FLOAT =
        let Ti1664 : INT =
          int 0
        in
        dconst.(Ti1664)
      in
      fsub Td1665 b0
    in
    let Td1668 : FLOAT =
      let Ti1667 : INT =
        int 1
      in
      dconst.(Ti1667)
    in
    fmul Td1666 Td1668
  in
  let Ti1687 : INT =
    let Tb1675 : BOOL =
      let Td1673 : FLOAT =
        let Td1672 : FLOAT =
          let Td1671 : FLOAT =
            let Td1670 : FLOAT =
              let Ti1669 : INT =
                int 1
              in
              v.(Ti1669)
            in
            fmul d0 Td1670
          in
          fadd Td1671 b1
        in
        app
          fabs
          Td1672
      in
      let Td1674 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fless
        Td1673
        Td1674
    in
    let Ti1676 : INT =
      int 0
    in
    if Tb1675 == Ti1676
      int 0
      let Tb1683 : BOOL =
        let Td1681 : FLOAT =
          let Td1680 : FLOAT =
            let Td1679 : FLOAT =
              let Td1678 : FLOAT =
                let Ti1677 : INT =
                  int 2
                in
                v.(Ti1677)
              in
              fmul d0 Td1678
            in
            fadd Td1679 b2
          in
          app
            fabs
            Td1680
        in
        let Td1682 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1681
          Td1682
      in
      let Ti1684 : INT =
        int 0
      in
      if Tb1683 == Ti1684
        int 0
        let Td1686 : FLOAT =
          let Ti1685 : INT =
            int 1
          in
          dconst.(Ti1685)
        in
        if Td1686 == 0.0 
          int 0
          int 1
  in
  let Ti1688 : INT =
    int 0
  in
  if Ti1687 == Ti1688
    let d1 : FLOAT =
      let Td1691 : FLOAT =
        let Td1690 : FLOAT =
          let Ti1689 : INT =
            int 2
          in
          dconst.(Ti1689)
        in
        fsub Td1690 b1
      in
      let Td1693 : FLOAT =
        let Ti1692 : INT =
          int 3
        in
        dconst.(Ti1692)
      in
      fmul Td1691 Td1693
    in
    let Ti1712 : INT =
      let Tb1700 : BOOL =
        let Td1698 : FLOAT =
          let Td1697 : FLOAT =
            let Td1696 : FLOAT =
              let Td1695 : FLOAT =
                let Ti1694 : INT =
                  int 0
                in
                v.(Ti1694)
              in
              fmul d1 Td1695
            in
            fadd Td1696 b0
          in
          app
            fabs
            Td1697
        in
        let Td1699 : FLOAT =
          app
            o_param_a
            m
        in
        app
          fless
          Td1698
          Td1699
      in
      let Ti1701 : INT =
        int 0
      in
      if Tb1700 == Ti1701
        int 0
        let Tb1708 : BOOL =
          let Td1706 : FLOAT =
            let Td1705 : FLOAT =
              let Td1704 : FLOAT =
                let Td1703 : FLOAT =
                  let Ti1702 : INT =
                    int 2
                  in
                  v.(Ti1702)
                in
                fmul d1 Td1703
              in
              fadd Td1704 b2
            in
            app
              fabs
              Td1705
          in
          let Td1707 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fless
            Td1706
            Td1707
        in
        let Ti1709 : INT =
          int 0
        in
        if Tb1708 == Ti1709
          int 0
          let Td1711 : FLOAT =
            let Ti1710 : INT =
              int 3
            in
            dconst.(Ti1710)
          in
          if Td1711 == 0.0 
            int 0
            int 1
    in
    let Ti1713 : INT =
      int 0
    in
    if Ti1712 == Ti1713
      let d2 : FLOAT =
        let Td1716 : FLOAT =
          let Td1715 : FLOAT =
            let Ti1714 : INT =
              int 4
            in
            dconst.(Ti1714)
          in
          fsub Td1715 b2
        in
        let Td1718 : FLOAT =
          let Ti1717 : INT =
            int 5
          in
          dconst.(Ti1717)
        in
        fmul Td1716 Td1718
      in
      let Ti1737 : INT =
        let Tb1725 : BOOL =
          let Td1723 : FLOAT =
            let Td1722 : FLOAT =
              let Td1721 : FLOAT =
                let Td1720 : FLOAT =
                  let Ti1719 : INT =
                    int 0
                  in
                  v.(Ti1719)
                in
                fmul d2 Td1720
              in
              fadd Td1721 b0
            in
            app
              fabs
              Td1722
          in
          let Td1724 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fless
            Td1723
            Td1724
        in
        let Ti1726 : INT =
          int 0
        in
        if Tb1725 == Ti1726
          int 0
          let Tb1733 : BOOL =
            let Td1731 : FLOAT =
              let Td1730 : FLOAT =
                let Td1729 : FLOAT =
                  let Td1728 : FLOAT =
                    let Ti1727 : INT =
                      int 1
                    in
                    v.(Ti1727)
                  in
                  fmul d2 Td1728
                in
                fadd Td1729 b1
              in
              app
                fabs
                Td1730
            in
            let Td1732 : FLOAT =
              app
                o_param_b
                m
            in
            app
              fless
              Td1731
              Td1732
          in
          let Ti1734 : INT =
            int 0
          in
          if Tb1733 == Ti1734
            int 0
            let Td1736 : FLOAT =
              let Ti1735 : INT =
                int 5
              in
              dconst.(Ti1735)
            in
            if Td1736 == 0.0 
              int 0
              int 1
      in
      let Ti1738 : INT =
        int 0
      in
      if Ti1737 == Ti1738
        int 0
        let Tu80 : UNIT =
          let Ti1739 : INT =
            int 0
          in
          solver_dist.(Ti1739) <- d2
        in
        int 3
      let Tu79 : UNIT =
        let Ti1740 : INT =
          int 0
        in
        solver_dist.(Ti1740) <- d1
      in
      int 2
    let Tu78 : UNIT =
      let Ti1741 : INT =
        int 0
      in
      solver_dist.(Ti1741) <- d0
    in
    int 1
in
letrec solver_surface_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Td1650 : FLOAT =
    let Ti1649 : INT =
      int 0
    in
    dconst.(Ti1649)
  in
  let Td1651 : FLOAT =
    float 0.
  in
  if Td1650 <. Td1651
    let Tu81 : UNIT =
      let Ti1652 : INT =
        int 0
      in
      let Td1663 : FLOAT =
        let Td1659 : FLOAT =
          let Td1655 : FLOAT =
            let Td1654 : FLOAT =
              let Ti1653 : INT =
                int 1
              in
              dconst.(Ti1653)
            in
            fmul Td1654 b0
          in
          let Td1658 : FLOAT =
            let Td1657 : FLOAT =
              let Ti1656 : INT =
                int 2
              in
              dconst.(Ti1656)
            in
            fmul Td1657 b1
          in
          fadd Td1655 Td1658
        in
        let Td1662 : FLOAT =
          let Td1661 : FLOAT =
            let Ti1660 : INT =
              int 3
            in
            dconst.(Ti1660)
          in
          fmul Td1661 b2
        in
        fadd Td1659 Td1662
      in
      solver_dist.(Ti1652) <- Td1663
    in
    int 1
    int 0
in
letrec solver_second_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1618 : INT =
      int 0
    in
    dconst.(Ti1618)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1625 : FLOAT =
        let Td1621 : FLOAT =
          let Td1620 : FLOAT =
            let Ti1619 : INT =
              int 1
            in
            dconst.(Ti1619)
          in
          fmul Td1620 b0
        in
        let Td1624 : FLOAT =
          let Td1623 : FLOAT =
            let Ti1622 : INT =
              int 2
            in
            dconst.(Ti1622)
          in
          fmul Td1623 b1
        in
        fadd Td1621 Td1624
      in
      let Td1628 : FLOAT =
        let Td1627 : FLOAT =
          let Ti1626 : INT =
            int 3
          in
          dconst.(Ti1626)
        in
        fmul Td1627 b2
      in
      fadd Td1625 Td1628
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1629 : INT =
        app
          o_form
          m
      in
      let Ti1630 : INT =
        int 3
      in
      if Ti1629 == Ti1630
        let Td1631 : FLOAT =
          float 1.
        in
        fsub cc0 Td1631
        cc0
    in
    let d : FLOAT =
      let Td1632 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1633 : FLOAT =
        fmul aa cc
      in
      fsub Td1632 Td1633
    in
    let Td1634 : FLOAT =
      float 0.
    in
    if Td1634 <. d
      let Tu82 : UNIT =
        let Tb1635 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1636 : INT =
          int 0
        in
        if Tb1635 == Ti1636
          let Ti1637 : INT =
            int 0
          in
          let Td1642 : FLOAT =
            let Td1639 : FLOAT =
              let Td1638 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1638
            in
            let Td1641 : FLOAT =
              let Ti1640 : INT =
                int 4
              in
              dconst.(Ti1640)
            in
            fmul Td1639 Td1641
          in
          solver_dist.(Ti1637) <- Td1642
          let Ti1643 : INT =
            int 0
          in
          let Td1648 : FLOAT =
            let Td1645 : FLOAT =
              let Td1644 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1644
            in
            let Td1647 : FLOAT =
              let Ti1646 : INT =
                int 4
              in
              dconst.(Ti1646)
            in
            fmul Td1645 Td1647
          in
          solver_dist.(Ti1643) <- Td1648
      in
      int 1
      int 0
in
letrec solver_fast : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1607 : FLOAT =
      let Ti1606 : INT =
        int 0
      in
      org.(Ti1606)
    in
    let Td1608 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1607 Td1608
  in
  let b1 : FLOAT =
    let Td1610 : FLOAT =
      let Ti1609 : INT =
        int 1
      in
      org.(Ti1609)
    in
    let Td1611 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1610 Td1611
  in
  let b2 : FLOAT =
    let Td1613 : FLOAT =
      let Ti1612 : INT =
        int 2
      in
      org.(Ti1612)
    in
    let Td1614 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1613 Td1614
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1615 : INT =
    int 1
  in
  if m_shape == Ti1615
    let Ta1616 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1616
      dconst
      b0
      b1
      b2
    let Ti1617 : INT =
      int 2
    in
    if m_shape == Ti1617
      app
        solver_surface_fast
        m
        dconst
        b0
        b1
        b2
      app
        solver_second_fast
        m
        dconst
        b0
        b1
        b2
in
letrec solver_surface_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Td1598 : FLOAT =
    let Ti1597 : INT =
      int 0
    in
    dconst.(Ti1597)
  in
  let Td1599 : FLOAT =
    float 0.
  in
  if Td1598 <. Td1599
    let Tu83 : UNIT =
      let Ti1600 : INT =
        int 0
      in
      let Td1605 : FLOAT =
        let Td1602 : FLOAT =
          let Ti1601 : INT =
            int 0
          in
          dconst.(Ti1601)
        in
        let Td1604 : FLOAT =
          let Ti1603 : INT =
            int 3
          in
          sconst.(Ti1603)
        in
        fmul Td1602 Td1604
      in
      solver_dist.(Ti1600) <- Td1605
    in
    int 1
    int 0
in
letrec solver_second_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1568 : INT =
      int 0
    in
    dconst.(Ti1568)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1575 : FLOAT =
        let Td1571 : FLOAT =
          let Td1570 : FLOAT =
            let Ti1569 : INT =
              int 1
            in
            dconst.(Ti1569)
          in
          fmul Td1570 b0
        in
        let Td1574 : FLOAT =
          let Td1573 : FLOAT =
            let Ti1572 : INT =
              int 2
            in
            dconst.(Ti1572)
          in
          fmul Td1573 b1
        in
        fadd Td1571 Td1574
      in
      let Td1578 : FLOAT =
        let Td1577 : FLOAT =
          let Ti1576 : INT =
            int 3
          in
          dconst.(Ti1576)
        in
        fmul Td1577 b2
      in
      fadd Td1575 Td1578
    in
    let cc : FLOAT =
      let Ti1579 : INT =
        int 3
      in
      sconst.(Ti1579)
    in
    let d : FLOAT =
      let Td1580 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1581 : FLOAT =
        fmul aa cc
      in
      fsub Td1580 Td1581
    in
    let Td1582 : FLOAT =
      float 0.
    in
    if Td1582 <. d
      let Tu84 : UNIT =
        let Tb1583 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1584 : INT =
          int 0
        in
        if Tb1583 == Ti1584
          let Ti1585 : INT =
            int 0
          in
          let Td1590 : FLOAT =
            let Td1587 : FLOAT =
              let Td1586 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1586
            in
            let Td1589 : FLOAT =
              let Ti1588 : INT =
                int 4
              in
              dconst.(Ti1588)
            in
            fmul Td1587 Td1589
          in
          solver_dist.(Ti1585) <- Td1590
          let Ti1591 : INT =
            int 0
          in
          let Td1596 : FLOAT =
            let Td1593 : FLOAT =
              let Td1592 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1592
            in
            let Td1595 : FLOAT =
              let Ti1594 : INT =
                int 4
              in
              dconst.(Ti1594)
            in
            fmul Td1593 Td1595
          in
          solver_dist.(Ti1591) <- Td1596
      in
      int 1
      int 0
in
letrec solver_fast2 : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> INT)) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let sconst : Array of FLOAT =
    app
      o_param_ctbl
      m
  in
  let b0 : FLOAT =
    let Ti1562 : INT =
      int 0
    in
    sconst.(Ti1562)
  in
  let b1 : FLOAT =
    let Ti1563 : INT =
      int 1
    in
    sconst.(Ti1563)
  in
  let b2 : FLOAT =
    let Ti1564 : INT =
      int 2
    in
    sconst.(Ti1564)
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1565 : INT =
    int 1
  in
  if m_shape == Ti1565
    let Ta1566 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1566
      dconst
      b0
      b1
      b2
    let Ti1567 : INT =
      int 2
    in
    if m_shape == Ti1567
      app
        solver_surface_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
      app
        solver_second_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
in
letrec setup_rect_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1506 : INT =
      int 6
    in
    let Td1507 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1506
      Td1507
  in
  let Tu90 : UNIT =
    let Td1509 : FLOAT =
      let Ti1508 : INT =
        int 0
      in
      vec.(Ti1508)
    in
    if Td1509 == 0.0 
      let Ti1510 : INT =
        int 1
      in
      let Td1511 : FLOAT =
        float 0.
      in
      const.(Ti1510) <- Td1511
      let Tu85 : UNIT =
        let Ti1512 : INT =
          int 0
        in
        let Td1520 : FLOAT =
          let Tb1518 : BOOL =
            let Tb1513 : BOOL =
              app
                o_isinvert
                m
            in
            let Ti1517 : INT =
              let Td1515 : FLOAT =
                let Ti1514 : INT =
                  int 0
                in
                vec.(Ti1514)
              in
              let Td1516 : FLOAT =
                float 0.
              in
              if Td1515 <. Td1516
                int 1
                int 0
            in
            app
              xor
              Tb1513
              Ti1517
          in
          let Td1519 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fneg_cond
            Tb1518
            Td1519
        in
        const.(Ti1512) <- Td1520
      in
      let Ti1521 : INT =
        int 1
      in
      let Td1525 : FLOAT =
        let Td1522 : FLOAT =
          float 1.
        in
        let Td1524 : FLOAT =
          let Ti1523 : INT =
            int 0
          in
          vec.(Ti1523)
        in
        fdiv Td1522 Td1524
      in
      const.(Ti1521) <- Td1525
  in
  let Tu89 : UNIT =
    let Td1527 : FLOAT =
      let Ti1526 : INT =
        int 1
      in
      vec.(Ti1526)
    in
    if Td1527 == 0.0 
      let Ti1528 : INT =
        int 3
      in
      let Td1529 : FLOAT =
        float 0.
      in
      const.(Ti1528) <- Td1529
      let Tu86 : UNIT =
        let Ti1530 : INT =
          int 2
        in
        let Td1538 : FLOAT =
          let Tb1536 : BOOL =
            let Tb1531 : BOOL =
              app
                o_isinvert
                m
            in
            let Ti1535 : INT =
              let Td1533 : FLOAT =
                let Ti1532 : INT =
                  int 1
                in
                vec.(Ti1532)
              in
              let Td1534 : FLOAT =
                float 0.
              in
              if Td1533 <. Td1534
                int 1
                int 0
            in
            app
              xor
              Tb1531
              Ti1535
          in
          let Td1537 : FLOAT =
            app
              o_param_b
              m
          in
          app
            fneg_cond
            Tb1536
            Td1537
        in
        const.(Ti1530) <- Td1538
      in
      let Ti1539 : INT =
        int 3
      in
      let Td1543 : FLOAT =
        let Td1540 : FLOAT =
          float 1.
        in
        let Td1542 : FLOAT =
          let Ti1541 : INT =
            int 1
          in
          vec.(Ti1541)
        in
        fdiv Td1540 Td1542
      in
      const.(Ti1539) <- Td1543
  in
  let Tu88 : UNIT =
    let Td1545 : FLOAT =
      let Ti1544 : INT =
        int 2
      in
      vec.(Ti1544)
    in
    if Td1545 == 0.0 
      let Ti1546 : INT =
        int 5
      in
      let Td1547 : FLOAT =
        float 0.
      in
      const.(Ti1546) <- Td1547
      let Tu87 : UNIT =
        let Ti1548 : INT =
          int 4
        in
        let Td1556 : FLOAT =
          let Tb1554 : BOOL =
            let Tb1549 : BOOL =
              app
                o_isinvert
                m
            in
            let Ti1553 : INT =
              let Td1551 : FLOAT =
                let Ti1550 : INT =
                  int 2
                in
                vec.(Ti1550)
              in
              let Td1552 : FLOAT =
                float 0.
              in
              if Td1551 <. Td1552
                int 1
                int 0
            in
            app
              xor
              Tb1549
              Ti1553
          in
          let Td1555 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fneg_cond
            Tb1554
            Td1555
        in
        const.(Ti1548) <- Td1556
      in
      let Ti1557 : INT =
        int 5
      in
      let Td1561 : FLOAT =
        let Td1558 : FLOAT =
          float 1.
        in
        let Td1560 : FLOAT =
          let Ti1559 : INT =
            int 2
          in
          vec.(Ti1559)
        in
        fdiv Td1558 Td1560
      in
      const.(Ti1557) <- Td1561
  in
  const
in
letrec setup_surface_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1473 : INT =
      int 4
    in
    let Td1474 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1473
      Td1474
  in
  let d : FLOAT =
    let Td1483 : FLOAT =
      let Td1478 : FLOAT =
        let Td1476 : FLOAT =
          let Ti1475 : INT =
            int 0
          in
          vec.(Ti1475)
        in
        let Td1477 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1476 Td1477
      in
      let Td1482 : FLOAT =
        let Td1480 : FLOAT =
          let Ti1479 : INT =
            int 1
          in
          vec.(Ti1479)
        in
        let Td1481 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1480 Td1481
      in
      fadd Td1478 Td1482
    in
    let Td1487 : FLOAT =
      let Td1485 : FLOAT =
        let Ti1484 : INT =
          int 2
        in
        vec.(Ti1484)
      in
      let Td1486 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1485 Td1486
    in
    fadd Td1483 Td1487
  in
  let Tu94 : UNIT =
    let Td1488 : FLOAT =
      float 0.
    in
    if Td1488 <. d
      let Tu93 : UNIT =
        let Ti1489 : INT =
          int 0
        in
        let Td1491 : FLOAT =
          let Td1490 : FLOAT =
            float -1.
          in
          fdiv Td1490 d
        in
        const.(Ti1489) <- Td1491
      in
      let Tu92 : UNIT =
        let Ti1492 : INT =
          int 1
        in
        let Td1495 : FLOAT =
          let Td1494 : FLOAT =
            let Td1493 : FLOAT =
              app
                o_param_a
                m
            in
            fdiv Td1493 d
          in
          fneg Td1494
        in
        const.(Ti1492) <- Td1495
      in
      let Tu91 : UNIT =
        let Ti1496 : INT =
          int 2
        in
        let Td1499 : FLOAT =
          let Td1498 : FLOAT =
            let Td1497 : FLOAT =
              app
                o_param_b
                m
            in
            fdiv Td1497 d
          in
          fneg Td1498
        in
        const.(Ti1496) <- Td1499
      in
      let Ti1500 : INT =
        int 3
      in
      let Td1503 : FLOAT =
        let Td1502 : FLOAT =
          let Td1501 : FLOAT =
            app
              o_param_c
              m
          in
          fdiv Td1501 d
        in
        fneg Td1502
      in
      const.(Ti1500) <- Td1503
      let Ti1504 : INT =
        int 0
      in
      let Td1505 : FLOAT =
        float 0.
      in
      const.(Ti1504) <- Td1505
  in
  const
in
letrec setup_second_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (v : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1408 : INT =
      int 5
    in
    let Td1409 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1408
      Td1409
  in
  let aa : FLOAT =
    let Td1411 : FLOAT =
      let Ti1410 : INT =
        int 0
      in
      v.(Ti1410)
    in
    let Td1413 : FLOAT =
      let Ti1412 : INT =
        int 1
      in
      v.(Ti1412)
    in
    let Td1415 : FLOAT =
      let Ti1414 : INT =
        int 2
      in
      v.(Ti1414)
    in
    app
      quadratic
      m
      Td1411
      Td1413
      Td1415
  in
  let c1 : FLOAT =
    let Td1419 : FLOAT =
      let Td1417 : FLOAT =
        let Ti1416 : INT =
          int 0
        in
        v.(Ti1416)
      in
      let Td1418 : FLOAT =
        app
          o_param_a
          m
      in
      fmul Td1417 Td1418
    in
    fneg Td1419
  in
  let c2 : FLOAT =
    let Td1423 : FLOAT =
      let Td1421 : FLOAT =
        let Ti1420 : INT =
          int 1
        in
        v.(Ti1420)
      in
      let Td1422 : FLOAT =
        app
          o_param_b
          m
      in
      fmul Td1421 Td1422
    in
    fneg Td1423
  in
  let c3 : FLOAT =
    let Td1427 : FLOAT =
      let Td1425 : FLOAT =
        let Ti1424 : INT =
          int 2
        in
        v.(Ti1424)
      in
      let Td1426 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1425 Td1426
    in
    fneg Td1427
  in
  let Tu101 : UNIT =
    let Ti1428 : INT =
      int 0
    in
    const.(Ti1428) <- aa
  in
  let Tu100 : UNIT =
    let Ti1429 : INT =
      app
        o_isrot
        m
    in
    let Ti1430 : INT =
      int 0
    in
    if Ti1429 == Ti1430
      let Tu98 : UNIT =
        let Ti1431 : INT =
          int 1
        in
        const.(Ti1431) <- c1
      in
      let Tu97 : UNIT =
        let Ti1432 : INT =
          int 2
        in
        const.(Ti1432) <- c2
      in
      let Ti1433 : INT =
        int 3
      in
      const.(Ti1433) <- c3
      let Tu96 : UNIT =
        let Ti1434 : INT =
          int 1
        in
        let Td1445 : FLOAT =
          let Td1444 : FLOAT =
            let Td1443 : FLOAT =
              let Td1438 : FLOAT =
                let Td1436 : FLOAT =
                  let Ti1435 : INT =
                    int 2
                  in
                  v.(Ti1435)
                in
                let Td1437 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul Td1436 Td1437
              in
              let Td1442 : FLOAT =
                let Td1440 : FLOAT =
                  let Ti1439 : INT =
                    int 1
                  in
                  v.(Ti1439)
                in
                let Td1441 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1440 Td1441
              in
              fadd Td1438 Td1442
            in
            app
              fhalf
              Td1443
          in
          fsub c1 Td1444
        in
        const.(Ti1434) <- Td1445
      in
      let Tu95 : UNIT =
        let Ti1446 : INT =
          int 2
        in
        let Td1457 : FLOAT =
          let Td1456 : FLOAT =
            let Td1455 : FLOAT =
              let Td1450 : FLOAT =
                let Td1448 : FLOAT =
                  let Ti1447 : INT =
                    int 2
                  in
                  v.(Ti1447)
                in
                let Td1449 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul Td1448 Td1449
              in
              let Td1454 : FLOAT =
                let Td1452 : FLOAT =
                  let Ti1451 : INT =
                    int 0
                  in
                  v.(Ti1451)
                in
                let Td1453 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1452 Td1453
              in
              fadd Td1450 Td1454
            in
            app
              fhalf
              Td1455
          in
          fsub c2 Td1456
        in
        const.(Ti1446) <- Td1457
      in
      let Ti1458 : INT =
        int 3
      in
      let Td1469 : FLOAT =
        let Td1468 : FLOAT =
          let Td1467 : FLOAT =
            let Td1462 : FLOAT =
              let Td1460 : FLOAT =
                let Ti1459 : INT =
                  int 1
                in
                v.(Ti1459)
              in
              let Td1461 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul Td1460 Td1461
            in
            let Td1466 : FLOAT =
              let Td1464 : FLOAT =
                let Ti1463 : INT =
                  int 0
                in
                v.(Ti1463)
              in
              let Td1465 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul Td1464 Td1465
            in
            fadd Td1462 Td1466
          in
          app
            fhalf
            Td1467
        in
        fsub c3 Td1468
      in
      const.(Ti1458) <- Td1469
  in
  let Tu99 : UNIT =
    if aa == 0.0 
      unit ()
      let Ti1470 : INT =
        int 4
      in
      let Td1472 : FLOAT =
        let Td1471 : FLOAT =
          float 1.
        in
        fdiv Td1471 aa
      in
      const.(Ti1470) <- Td1472
  in
  const
in
letrec iter_setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti1400 : INT =
    int 0
  in
  if Ti1400 <= index
    let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let dconst : Array of Array of FLOAT =
      app
        d_const
        dirvec
    in
    let v : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    let m_shape : INT =
      app
        o_form
        m
    in
    let Tu102 : UNIT =
      let Ti1401 : INT =
        int 1
      in
      if m_shape == Ti1401
        let Ta1402 : Array of FLOAT =
          app
            setup_rect_table
            v
            m
        in
        dconst.(index) <- Ta1402
        let Ti1403 : INT =
          int 2
        in
        if m_shape == Ti1403
          let Ta1404 : Array of FLOAT =
            app
              setup_surface_table
              v
              m
          in
          dconst.(index) <- Ta1404
          let Ta1405 : Array of FLOAT =
            app
              setup_second_table
              v
              m
          in
          dconst.(index) <- Ta1405
    in
    let Ti1407 : INT =
      let Ti1406 : INT =
        int 1
      in
      sub index Ti1406
    in
    app
      iter_setup_dirvec_constants
      dirvec
      Ti1407
    unit ()
in
letrec setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> UNIT) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Ti1399 : INT =
    let Ti1397 : INT =
      let Ti1396 : INT =
        int 0
      in
      n_objects.(Ti1396)
    in
    let Ti1398 : INT =
      int 1
    in
    sub Ti1397 Ti1398
  in
  app
    iter_setup_dirvec_constants
    dirvec
    Ti1399
in
letrec setup_startp_constants : (Array of FLOAT -> (INT -> UNIT)) =
variables : (p : Array of FLOAT), (index : INT)
  let Ti1357 : INT =
    int 0
  in
  if Ti1357 <= index
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let sconst : Array of FLOAT =
      app
        o_param_ctbl
        obj
    in
    let m_shape : INT =
      app
        o_form
        obj
    in
    let Tu106 : UNIT =
      let Ti1358 : INT =
        int 0
      in
      let Td1362 : FLOAT =
        let Td1360 : FLOAT =
          let Ti1359 : INT =
            int 0
          in
          p.(Ti1359)
        in
        let Td1361 : FLOAT =
          app
            o_param_x
            obj
        in
        fsub Td1360 Td1361
      in
      sconst.(Ti1358) <- Td1362
    in
    let Tu105 : UNIT =
      let Ti1363 : INT =
        int 1
      in
      let Td1367 : FLOAT =
        let Td1365 : FLOAT =
          let Ti1364 : INT =
            int 1
          in
          p.(Ti1364)
        in
        let Td1366 : FLOAT =
          app
            o_param_y
            obj
        in
        fsub Td1365 Td1366
      in
      sconst.(Ti1363) <- Td1367
    in
    let Tu104 : UNIT =
      let Ti1368 : INT =
        int 2
      in
      let Td1372 : FLOAT =
        let Td1370 : FLOAT =
          let Ti1369 : INT =
            int 2
          in
          p.(Ti1369)
        in
        let Td1371 : FLOAT =
          app
            o_param_z
            obj
        in
        fsub Td1370 Td1371
      in
      sconst.(Ti1368) <- Td1372
    in
    let Tu103 : UNIT =
      let Ti1373 : INT =
        int 2
      in
      if m_shape == Ti1373
        let Ti1374 : INT =
          int 3
        in
        let Td1382 : FLOAT =
          let Ta1375 : Array of FLOAT =
            app
              o_param_abc
              obj
          in
          let Td1377 : FLOAT =
            let Ti1376 : INT =
              int 0
            in
            sconst.(Ti1376)
          in
          let Td1379 : FLOAT =
            let Ti1378 : INT =
              int 1
            in
            sconst.(Ti1378)
          in
          let Td1381 : FLOAT =
            let Ti1380 : INT =
              int 2
            in
            sconst.(Ti1380)
          in
          app
            veciprod2
            Ta1375
            Td1377
            Td1379
            Td1381
        in
        sconst.(Ti1374) <- Td1382
        let Ti1383 : INT =
          int 2
        in
        if m_shape <= Ti1383
          unit ()
          let cc0 : FLOAT =
            let Td1385 : FLOAT =
              let Ti1384 : INT =
                int 0
              in
              sconst.(Ti1384)
            in
            let Td1387 : FLOAT =
              let Ti1386 : INT =
                int 1
              in
              sconst.(Ti1386)
            in
            let Td1389 : FLOAT =
              let Ti1388 : INT =
                int 2
              in
              sconst.(Ti1388)
            in
            app
              quadratic
              obj
              Td1385
              Td1387
              Td1389
          in
          let Ti1390 : INT =
            int 3
          in
          let Td1393 : FLOAT =
            let Ti1391 : INT =
              int 3
            in
            if m_shape == Ti1391
              let Td1392 : FLOAT =
                float 1.
              in
              fsub cc0 Td1392
              cc0
          in
          sconst.(Ti1390) <- Td1393
    in
    let Ti1395 : INT =
      let Ti1394 : INT =
        int 1
      in
      sub index Ti1394
    in
    app
      setup_startp_constants
      p
      Ti1395
    unit ()
in
letrec setup_startp : (Array of FLOAT -> UNIT) =
variables : (p : Array of FLOAT)
  let Tu107 : UNIT =
    app
      veccpy
      startp_fast
      p
  in
  let Ti1356 : INT =
    let Ti1354 : INT =
      let Ti1353 : INT =
        int 0
      in
      n_objects.(Ti1353)
    in
    let Ti1355 : INT =
      int 1
    in
    sub Ti1354 Ti1355
  in
  app
    setup_startp_constants
    p
    Ti1356
in
letrec is_rect_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let Ti1349 : INT =
    let Tb1341 : BOOL =
      let Td1339 : FLOAT =
        app
          fabs
          p0
      in
      let Td1340 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fless
        Td1339
        Td1340
    in
    let Ti1342 : INT =
      int 0
    in
    if Tb1341 == Ti1342
      int 0
      let Tb1345 : BOOL =
        let Td1343 : FLOAT =
          app
            fabs
            p1
        in
        let Td1344 : FLOAT =
          app
            o_param_b
            m
        in
        app
          fless
          Td1343
          Td1344
      in
      let Ti1346 : INT =
        int 0
      in
      if Tb1345 == Ti1346
        int 0
        let Td1347 : FLOAT =
          app
            fabs
            p2
        in
        let Td1348 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1347
          Td1348
  in
  let Ti1350 : INT =
    int 0
  in
  if Ti1349 == Ti1350
    let Tb1351 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1352 : INT =
      int 0
    in
    if Tb1351 == Ti1352
      int 1
      int 0
    app
      o_isinvert
      m
in
letrec is_plane_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    let Ta1333 : Array of FLOAT =
      app
        o_param_abc
        m
    in
    app
      veciprod2
      Ta1333
      p0
      p1
      p2
  in
  let Tb1337 : BOOL =
    let Tb1334 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1336 : INT =
      let Td1335 : FLOAT =
        float 0.
      in
      if w <. Td1335
        int 1
        int 0
    in
    app
      xor
      Tb1334
      Ti1336
  in
  let Ti1338 : INT =
    int 0
  in
  if Tb1337 == Ti1338
    int 1
    int 0
in
letrec is_second_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    app
      quadratic
      m
      p0
      p1
      p2
  in
  let w2 : FLOAT =
    let Ti1325 : INT =
      app
        o_form
        m
    in
    let Ti1326 : INT =
      int 3
    in
    if Ti1325 == Ti1326
      let Td1327 : FLOAT =
        float 1.
      in
      fsub w Td1327
      w
  in
  let Tb1331 : BOOL =
    let Tb1328 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1330 : INT =
      let Td1329 : FLOAT =
        float 0.
      in
      if w2 <. Td1329
        int 1
        int 0
    in
    app
      xor
      Tb1328
      Ti1330
  in
  let Ti1332 : INT =
    int 0
  in
  if Tb1331 == Ti1332
    int 1
    int 0
in
letrec is_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let p0 : FLOAT =
    let Td1320 : FLOAT =
      app
        o_param_x
        m
    in
    fsub q0 Td1320
  in
  let p1 : FLOAT =
    let Td1321 : FLOAT =
      app
        o_param_y
        m
    in
    fsub q1 Td1321
  in
  let p2 : FLOAT =
    let Td1322 : FLOAT =
      app
        o_param_z
        m
    in
    fsub q2 Td1322
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1323 : INT =
    int 1
  in
  if m_shape == Ti1323
    app
      is_rect_outside
      m
      p0
      p1
      p2
    let Ti1324 : INT =
      int 2
    in
    if m_shape == Ti1324
      app
        is_plane_outside
        m
        p0
        p1
        p2
      app
        is_second_outside
        m
        p0
        p1
        p2
in
letrec check_all_inside : (INT -> (Array of INT -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL))))) =
variables : (ofs : INT), (iand : Array of INT), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let head : INT =
    iand.(ofs)
  in
  let Ti1314 : INT =
    let Ti1313 : INT =
      int 1
    in
    neg Ti1313
  in
  if head == Ti1314
    int 1
    let Tb1316 : BOOL =
      let Tt1315 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(head)
      in
      app
        is_outside
        Tt1315
        q0
        q1
        q2
    in
    let Ti1317 : INT =
      int 0
    in
    if Tb1316 == Ti1317
      let Ti1319 : INT =
        let Ti1318 : INT =
          int 1
        in
        add ofs Ti1318
      in
      app
        check_all_inside
        Ti1319
        iand
        q0
        q1
        q2
      int 0
in
letrec shadow_check_and_group : (INT -> (Array of INT -> BOOL)) =
variables : (iand_ofs : INT), (and_group : Array of INT)
  let Ti1279 : INT =
    and_group.(iand_ofs)
  in
  let Ti1281 : INT =
    let Ti1280 : INT =
      int 1
    in
    neg Ti1280
  in
  if Ti1279 == Ti1281
    int 0
    let obj : INT =
      and_group.(iand_ofs)
    in
    let t0 : INT =
      app
        solver_fast
        obj
        light_dirvec
        intersection_point
    in
    let t0p : FLOAT =
      let Ti1282 : INT =
        int 0
      in
      solver_dist.(Ti1282)
    in
    let Ti1285 : INT =
      let Ti1283 : INT =
        int 0
      in
      if t0 == Ti1283
        int 0
        let Td1284 : FLOAT =
          float -0.2
        in
        app
          fless
          t0p
          Td1284
    in
    let Ti1286 : INT =
      int 0
    in
    if Ti1285 == Ti1286
      let Tb1288 : BOOL =
        let Tt1287 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(obj)
        in
        app
          o_isinvert
          Tt1287
      in
      let Ti1289 : INT =
        int 0
      in
      if Tb1288 == Ti1289
        int 0
        let Ti1291 : INT =
          let Ti1290 : INT =
            int 1
          in
          add iand_ofs Ti1290
        in
        app
          shadow_check_and_group
          Ti1291
          and_group
      let t : FLOAT =
        let Td1292 : FLOAT =
          float 0.01
        in
        fadd t0p Td1292
      in
      let q0 : FLOAT =
        let Td1295 : FLOAT =
          let Td1294 : FLOAT =
            let Ti1293 : INT =
              int 0
            in
            light.(Ti1293)
          in
          fmul Td1294 t
        in
        let Td1297 : FLOAT =
          let Ti1296 : INT =
            int 0
          in
          intersection_point.(Ti1296)
        in
        fadd Td1295 Td1297
      in
      let q1 : FLOAT =
        let Td1300 : FLOAT =
          let Td1299 : FLOAT =
            let Ti1298 : INT =
              int 1
            in
            light.(Ti1298)
          in
          fmul Td1299 t
        in
        let Td1302 : FLOAT =
          let Ti1301 : INT =
            int 1
          in
          intersection_point.(Ti1301)
        in
        fadd Td1300 Td1302
      in
      let q2 : FLOAT =
        let Td1305 : FLOAT =
          let Td1304 : FLOAT =
            let Ti1303 : INT =
              int 2
            in
            light.(Ti1303)
          in
          fmul Td1304 t
        in
        let Td1307 : FLOAT =
          let Ti1306 : INT =
            int 2
          in
          intersection_point.(Ti1306)
        in
        fadd Td1305 Td1307
      in
      let Tb1309 : BOOL =
        let Ti1308 : INT =
          int 0
        in
        app
          check_all_inside
          Ti1308
          and_group
          q0
          q1
          q2
      in
      let Ti1310 : INT =
        int 0
      in
      if Tb1309 == Ti1310
        let Ti1312 : INT =
          let Ti1311 : INT =
            int 1
          in
          add iand_ofs Ti1311
        in
        app
          shadow_check_and_group
          Ti1312
          and_group
        int 1
in
letrec shadow_check_one_or_group : (INT -> (Array of INT -> BOOL)) =
variables : (ofs : INT), (or_group : Array of INT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1274 : INT =
    let Ti1273 : INT =
      int 1
    in
    neg Ti1273
  in
  if head == Ti1274
    int 0
    let and_group : Array of INT =
      and_net.(head)
    in
    let shadow_p : BOOL =
      let Ti1275 : INT =
        int 0
      in
      app
        shadow_check_and_group
        Ti1275
        and_group
    in
    let Ti1276 : INT =
      int 0
    in
    if shadow_p == Ti1276
      let Ti1278 : INT =
        let Ti1277 : INT =
          int 1
        in
        add ofs Ti1277
      in
      app
        shadow_check_one_or_group
        Ti1278
        or_group
      int 1
in
letrec shadow_check_one_or_matrix : (INT -> (Array of Array of INT -> BOOL)) =
variables : (ofs : INT), (or_matrix : Array of Array of INT)
  let head : Array of INT =
    or_matrix.(ofs)
  in
  let range_primitive : INT =
    let Ti1251 : INT =
      int 0
    in
    head.(Ti1251)
  in
  let Ti1253 : INT =
    let Ti1252 : INT =
      int 1
    in
    neg Ti1252
  in
  if range_primitive == Ti1253
    int 0
    let Ti1264 : INT =
      let Ti1254 : INT =
        int 99
      in
      if range_primitive == Ti1254
        int 1
        let t : INT =
          app
            solver_fast
            range_primitive
            light_dirvec
            intersection_point
        in
        let Ti1255 : INT =
          int 0
        in
        if t == Ti1255
          int 0
          let Tb1259 : BOOL =
            let Td1257 : FLOAT =
              let Ti1256 : INT =
                int 0
              in
              solver_dist.(Ti1256)
            in
            let Td1258 : FLOAT =
              float -0.1
            in
            app
              fless
              Td1257
              Td1258
          in
          let Ti1260 : INT =
            int 0
          in
          if Tb1259 == Ti1260
            int 0
            let Tb1262 : BOOL =
              let Ti1261 : INT =
                int 1
              in
              app
                shadow_check_one_or_group
                Ti1261
                head
            in
            let Ti1263 : INT =
              int 0
            in
            if Tb1262 == Ti1263
              int 0
              int 1
    in
    let Ti1265 : INT =
      int 0
    in
    if Ti1264 == Ti1265
      let Ti1267 : INT =
        let Ti1266 : INT =
          int 1
        in
        add ofs Ti1266
      in
      app
        shadow_check_one_or_matrix
        Ti1267
        or_matrix
      let Tb1269 : BOOL =
        let Ti1268 : INT =
          int 1
        in
        app
          shadow_check_one_or_group
          Ti1268
          head
      in
      let Ti1270 : INT =
        int 0
      in
      if Tb1269 == Ti1270
        let Ti1272 : INT =
          let Ti1271 : INT =
            int 1
          in
          add ofs Ti1271
        in
        app
          shadow_check_one_or_matrix
          Ti1272
          or_matrix
        int 1
in
letrec solve_each_element : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : Array of FLOAT)
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1212 : INT =
    let Ti1211 : INT =
      int 1
    in
    neg Ti1211
  in
  if iobj == Ti1212
    unit ()
    let t0 : INT =
      app
        solver
        iobj
        dirvec
        startp
    in
    let Ti1213 : INT =
      int 0
    in
    if t0 == Ti1213
      let Tb1215 : BOOL =
        let Tt1214 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1214
      in
      let Ti1216 : INT =
        int 0
      in
      if Tb1215 == Ti1216
        unit ()
        let Ti1218 : INT =
          let Ti1217 : INT =
            int 1
          in
          add iand_ofs Ti1217
        in
        app
          solve_each_element
          Ti1218
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1219 : INT =
          int 0
        in
        solver_dist.(Ti1219)
      in
      let Tu111 : UNIT =
        let Tb1221 : BOOL =
          let Td1220 : FLOAT =
            float 0.
          in
          app
            fless
            Td1220
            t0p
        in
        let Ti1222 : INT =
          int 0
        in
        if Tb1221 == Ti1222
          unit ()
          let Tb1225 : BOOL =
            let Td1224 : FLOAT =
              let Ti1223 : INT =
                int 0
              in
              tmin.(Ti1223)
            in
            app
              fless
              t0p
              Td1224
          in
          let Ti1226 : INT =
            int 0
          in
          if Tb1225 == Ti1226
            unit ()
            let t : FLOAT =
              let Td1227 : FLOAT =
                float 0.01
              in
              fadd t0p Td1227
            in
            let q0 : FLOAT =
              let Td1230 : FLOAT =
                let Td1229 : FLOAT =
                  let Ti1228 : INT =
                    int 0
                  in
                  dirvec.(Ti1228)
                in
                fmul Td1229 t
              in
              let Td1232 : FLOAT =
                let Ti1231 : INT =
                  int 0
                in
                startp.(Ti1231)
              in
              fadd Td1230 Td1232
            in
            let q1 : FLOAT =
              let Td1235 : FLOAT =
                let Td1234 : FLOAT =
                  let Ti1233 : INT =
                    int 1
                  in
                  dirvec.(Ti1233)
                in
                fmul Td1234 t
              in
              let Td1237 : FLOAT =
                let Ti1236 : INT =
                  int 1
                in
                startp.(Ti1236)
              in
              fadd Td1235 Td1237
            in
            let q2 : FLOAT =
              let Td1240 : FLOAT =
                let Td1239 : FLOAT =
                  let Ti1238 : INT =
                    int 2
                  in
                  dirvec.(Ti1238)
                in
                fmul Td1239 t
              in
              let Td1242 : FLOAT =
                let Ti1241 : INT =
                  int 2
                in
                startp.(Ti1241)
              in
              fadd Td1240 Td1242
            in
            let Tb1244 : BOOL =
              let Ti1243 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1243
                and_group
                q0
                q1
                q2
            in
            let Ti1245 : INT =
              int 0
            in
            if Tb1244 == Ti1245
              unit ()
              let Tu110 : UNIT =
                let Ti1246 : INT =
                  int 0
                in
                tmin.(Ti1246) <- t
              in
              let Tu109 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu108 : UNIT =
                let Ti1247 : INT =
                  int 0
                in
                intersected_object_id.(Ti1247) <- iobj
              in
              let Ti1248 : INT =
                int 0
              in
              intsec_rectside.(Ti1248) <- t0
      in
      let Ti1250 : INT =
        let Ti1249 : INT =
          int 1
        in
        add iand_ofs Ti1249
      in
      app
        solve_each_element
        Ti1250
        and_group
        dirvec
in
letrec solve_one_or_network : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : Array of FLOAT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1207 : INT =
    let Ti1206 : INT =
      int 1
    in
    neg Ti1206
  in
  if head == Ti1207
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu112 : UNIT =
      let Ti1208 : INT =
        int 0
      in
      app
        solve_each_element
        Ti1208
        and_group
        dirvec
    in
    let Ti1210 : INT =
      let Ti1209 : INT =
        int 1
      in
      add ofs Ti1209
    in
    app
      solve_one_or_network
      Ti1210
      or_group
      dirvec
in
letrec trace_or_matrix : (INT -> (Array of Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : Array of FLOAT)
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1192 : INT =
      int 0
    in
    head.(Ti1192)
  in
  let Ti1194 : INT =
    let Ti1193 : INT =
      int 1
    in
    neg Ti1193
  in
  if range_primitive == Ti1194
    unit ()
    let Tu113 : UNIT =
      let Ti1195 : INT =
        int 99
      in
      if range_primitive == Ti1195
        let Ti1196 : INT =
          int 1
        in
        app
          solve_one_or_network
          Ti1196
          head
          dirvec
        let t : INT =
          app
            solver
            range_primitive
            dirvec
            startp
        in
        let Ti1197 : INT =
          int 0
        in
        if t == Ti1197
          unit ()
          let tp : FLOAT =
            let Ti1198 : INT =
              int 0
            in
            solver_dist.(Ti1198)
          in
          let Tb1201 : BOOL =
            let Td1200 : FLOAT =
              let Ti1199 : INT =
                int 0
              in
              tmin.(Ti1199)
            in
            app
              fless
              tp
              Td1200
          in
          let Ti1202 : INT =
            int 0
          in
          if Tb1201 == Ti1202
            unit ()
            let Ti1203 : INT =
              int 1
            in
            app
              solve_one_or_network
              Ti1203
              head
              dirvec
    in
    let Ti1205 : INT =
      let Ti1204 : INT =
        int 1
      in
      add ofs Ti1204
    in
    app
      trace_or_matrix
      Ti1205
      or_network
      dirvec
in
letrec judge_intersection : (Array of FLOAT -> BOOL) =
variables : (dirvec : Array of FLOAT)
  let Tu115 : UNIT =
    let Ti1182 : INT =
      int 0
    in
    let Td1183 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1182) <- Td1183
  in
  let Tu114 : UNIT =
    let Ti1184 : INT =
      int 0
    in
    let Ta1186 : Array of Array of INT =
      let Ti1185 : INT =
        int 0
      in
      or_net.(Ti1185)
    in
    app
      trace_or_matrix
      Ti1184
      Ta1186
      dirvec
  in
  let t : FLOAT =
    let Ti1187 : INT =
      int 0
    in
    tmin.(Ti1187)
  in
  let Tb1189 : BOOL =
    let Td1188 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1188
      t
  in
  let Ti1190 : INT =
    int 0
  in
  if Tb1189 == Ti1190
    int 0
    let Td1191 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1191
in
letrec solve_each_element_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let vec : Array of FLOAT =
    app
      d_vec
      dirvec
  in
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1143 : INT =
    let Ti1142 : INT =
      int 1
    in
    neg Ti1142
  in
  if iobj == Ti1143
    unit ()
    let t0 : INT =
      app
        solver_fast2
        iobj
        dirvec
    in
    let Ti1144 : INT =
      int 0
    in
    if t0 == Ti1144
      let Tb1146 : BOOL =
        let Tt1145 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1145
      in
      let Ti1147 : INT =
        int 0
      in
      if Tb1146 == Ti1147
        unit ()
        let Ti1149 : INT =
          let Ti1148 : INT =
            int 1
          in
          add iand_ofs Ti1148
        in
        app
          solve_each_element_fast
          Ti1149
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1150 : INT =
          int 0
        in
        solver_dist.(Ti1150)
      in
      let Tu119 : UNIT =
        let Tb1152 : BOOL =
          let Td1151 : FLOAT =
            float 0.
          in
          app
            fless
            Td1151
            t0p
        in
        let Ti1153 : INT =
          int 0
        in
        if Tb1152 == Ti1153
          unit ()
          let Tb1156 : BOOL =
            let Td1155 : FLOAT =
              let Ti1154 : INT =
                int 0
              in
              tmin.(Ti1154)
            in
            app
              fless
              t0p
              Td1155
          in
          let Ti1157 : INT =
            int 0
          in
          if Tb1156 == Ti1157
            unit ()
            let t : FLOAT =
              let Td1158 : FLOAT =
                float 0.01
              in
              fadd t0p Td1158
            in
            let q0 : FLOAT =
              let Td1161 : FLOAT =
                let Td1160 : FLOAT =
                  let Ti1159 : INT =
                    int 0
                  in
                  vec.(Ti1159)
                in
                fmul Td1160 t
              in
              let Td1163 : FLOAT =
                let Ti1162 : INT =
                  int 0
                in
                startp_fast.(Ti1162)
              in
              fadd Td1161 Td1163
            in
            let q1 : FLOAT =
              let Td1166 : FLOAT =
                let Td1165 : FLOAT =
                  let Ti1164 : INT =
                    int 1
                  in
                  vec.(Ti1164)
                in
                fmul Td1165 t
              in
              let Td1168 : FLOAT =
                let Ti1167 : INT =
                  int 1
                in
                startp_fast.(Ti1167)
              in
              fadd Td1166 Td1168
            in
            let q2 : FLOAT =
              let Td1171 : FLOAT =
                let Td1170 : FLOAT =
                  let Ti1169 : INT =
                    int 2
                  in
                  vec.(Ti1169)
                in
                fmul Td1170 t
              in
              let Td1173 : FLOAT =
                let Ti1172 : INT =
                  int 2
                in
                startp_fast.(Ti1172)
              in
              fadd Td1171 Td1173
            in
            let Tb1175 : BOOL =
              let Ti1174 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1174
                and_group
                q0
                q1
                q2
            in
            let Ti1176 : INT =
              int 0
            in
            if Tb1175 == Ti1176
              unit ()
              let Tu118 : UNIT =
                let Ti1177 : INT =
                  int 0
                in
                tmin.(Ti1177) <- t
              in
              let Tu117 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu116 : UNIT =
                let Ti1178 : INT =
                  int 0
                in
                intersected_object_id.(Ti1178) <- iobj
              in
              let Ti1179 : INT =
                int 0
              in
              intsec_rectside.(Ti1179) <- t0
      in
      let Ti1181 : INT =
        let Ti1180 : INT =
          int 1
        in
        add iand_ofs Ti1180
      in
      app
        solve_each_element_fast
        Ti1181
        and_group
        dirvec
in
letrec solve_one_or_network_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : INT =
    or_group.(ofs)
  in
  let Ti1138 : INT =
    let Ti1137 : INT =
      int 1
    in
    neg Ti1137
  in
  if head == Ti1138
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu120 : UNIT =
      let Ti1139 : INT =
        int 0
      in
      app
        solve_each_element_fast
        Ti1139
        and_group
        dirvec
    in
    let Ti1141 : INT =
      let Ti1140 : INT =
        int 1
      in
      add ofs Ti1140
    in
    app
      solve_one_or_network_fast
      Ti1141
      or_group
      dirvec
in
letrec trace_or_matrix_fast : (INT -> (Array of Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1123 : INT =
      int 0
    in
    head.(Ti1123)
  in
  let Ti1125 : INT =
    let Ti1124 : INT =
      int 1
    in
    neg Ti1124
  in
  if range_primitive == Ti1125
    unit ()
    let Tu121 : UNIT =
      let Ti1126 : INT =
        int 99
      in
      if range_primitive == Ti1126
        let Ti1127 : INT =
          int 1
        in
        app
          solve_one_or_network_fast
          Ti1127
          head
          dirvec
        let t : INT =
          app
            solver_fast2
            range_primitive
            dirvec
        in
        let Ti1128 : INT =
          int 0
        in
        if t == Ti1128
          unit ()
          let tp : FLOAT =
            let Ti1129 : INT =
              int 0
            in
            solver_dist.(Ti1129)
          in
          let Tb1132 : BOOL =
            let Td1131 : FLOAT =
              let Ti1130 : INT =
                int 0
              in
              tmin.(Ti1130)
            in
            app
              fless
              tp
              Td1131
          in
          let Ti1133 : INT =
            int 0
          in
          if Tb1132 == Ti1133
            unit ()
            let Ti1134 : INT =
              int 1
            in
            app
              solve_one_or_network_fast
              Ti1134
              head
              dirvec
    in
    let Ti1136 : INT =
      let Ti1135 : INT =
        int 1
      in
      add ofs Ti1135
    in
    app
      trace_or_matrix_fast
      Ti1136
      or_network
      dirvec
in
letrec judge_intersection_fast : ((Array of FLOAT * Array of Array of FLOAT) -> BOOL) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Tu123 : UNIT =
    let Ti1113 : INT =
      int 0
    in
    let Td1114 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1113) <- Td1114
  in
  let Tu122 : UNIT =
    let Ti1115 : INT =
      int 0
    in
    let Ta1117 : Array of Array of INT =
      let Ti1116 : INT =
        int 0
      in
      or_net.(Ti1116)
    in
    app
      trace_or_matrix_fast
      Ti1115
      Ta1117
      dirvec
  in
  let t : FLOAT =
    let Ti1118 : INT =
      int 0
    in
    tmin.(Ti1118)
  in
  let Tb1120 : BOOL =
    let Td1119 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1119
      t
  in
  let Ti1121 : INT =
    int 0
  in
  if Tb1120 == Ti1121
    int 0
    let Td1122 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1122
in
letrec get_nvector_rect : (Array of FLOAT -> UNIT) =
variables : (dirvec : Array of FLOAT)
  let rectside : INT =
    let Ti1105 : INT =
      int 0
    in
    intsec_rectside.(Ti1105)
  in
  let Tu124 : UNIT =
    app
      vecbzero
      nvector
  in
  let Ti1107 : INT =
    let Ti1106 : INT =
      int 1
    in
    sub rectside Ti1106
  in
  let Td1112 : FLOAT =
    let Td1111 : FLOAT =
      let Td1110 : FLOAT =
        let Ti1109 : INT =
          let Ti1108 : INT =
            int 1
          in
          sub rectside Ti1108
        in
        dirvec.(Ti1109)
      in
      app
        sgn
        Td1110
    in
    fneg Td1111
  in
  nvector.(Ti1107) <- Td1112
in
letrec get_nvector_plane : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let Tu126 : UNIT =
    let Ti1096 : INT =
      int 0
    in
    let Td1098 : FLOAT =
      let Td1097 : FLOAT =
        app
          o_param_a
          m
      in
      fneg Td1097
    in
    nvector.(Ti1096) <- Td1098
  in
  let Tu125 : UNIT =
    let Ti1099 : INT =
      int 1
    in
    let Td1101 : FLOAT =
      let Td1100 : FLOAT =
        app
          o_param_b
          m
      in
      fneg Td1100
    in
    nvector.(Ti1099) <- Td1101
  in
  let Ti1102 : INT =
    int 2
  in
  let Td1104 : FLOAT =
    let Td1103 : FLOAT =
      app
        o_param_c
        m
    in
    fneg Td1103
  in
  nvector.(Ti1102) <- Td1104
in
letrec get_nvector_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let p0 : FLOAT =
    let Td1055 : FLOAT =
      let Ti1054 : INT =
        int 0
      in
      intersection_point.(Ti1054)
    in
    let Td1056 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1055 Td1056
  in
  let p1 : FLOAT =
    let Td1058 : FLOAT =
      let Ti1057 : INT =
        int 1
      in
      intersection_point.(Ti1057)
    in
    let Td1059 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1058 Td1059
  in
  let p2 : FLOAT =
    let Td1061 : FLOAT =
      let Ti1060 : INT =
        int 2
      in
      intersection_point.(Ti1060)
    in
    let Td1062 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1061 Td1062
  in
  let d0 : FLOAT =
    let Td1063 : FLOAT =
      app
        o_param_a
        m
    in
    fmul p0 Td1063
  in
  let d1 : FLOAT =
    let Td1064 : FLOAT =
      app
        o_param_b
        m
    in
    fmul p1 Td1064
  in
  let d2 : FLOAT =
    let Td1065 : FLOAT =
      app
        o_param_c
        m
    in
    fmul p2 Td1065
  in
  let Tu131 : UNIT =
    let Ti1066 : INT =
      app
        o_isrot
        m
    in
    let Ti1067 : INT =
      int 0
    in
    if Ti1066 == Ti1067
      let Tu128 : UNIT =
        let Ti1068 : INT =
          int 0
        in
        nvector.(Ti1068) <- d0
      in
      let Tu127 : UNIT =
        let Ti1069 : INT =
          int 1
        in
        nvector.(Ti1069) <- d1
      in
      let Ti1070 : INT =
        int 2
      in
      nvector.(Ti1070) <- d2
      let Tu130 : UNIT =
        let Ti1071 : INT =
          int 0
        in
        let Td1078 : FLOAT =
          let Td1077 : FLOAT =
            let Td1076 : FLOAT =
              let Td1073 : FLOAT =
                let Td1072 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p1 Td1072
              in
              let Td1075 : FLOAT =
                let Td1074 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul p2 Td1074
              in
              fadd Td1073 Td1075
            in
            app
              fhalf
              Td1076
          in
          fadd d0 Td1077
        in
        nvector.(Ti1071) <- Td1078
      in
      let Tu129 : UNIT =
        let Ti1079 : INT =
          int 1
        in
        let Td1086 : FLOAT =
          let Td1085 : FLOAT =
            let Td1084 : FLOAT =
              let Td1081 : FLOAT =
                let Td1080 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p0 Td1080
              in
              let Td1083 : FLOAT =
                let Td1082 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul p2 Td1082
              in
              fadd Td1081 Td1083
            in
            app
              fhalf
              Td1084
          in
          fadd d1 Td1085
        in
        nvector.(Ti1079) <- Td1086
      in
      let Ti1087 : INT =
        int 2
      in
      let Td1094 : FLOAT =
        let Td1093 : FLOAT =
          let Td1092 : FLOAT =
            let Td1089 : FLOAT =
              let Td1088 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul p0 Td1088
            in
            let Td1091 : FLOAT =
              let Td1090 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul p1 Td1090
            in
            fadd Td1089 Td1091
          in
          app
            fhalf
            Td1092
        in
        fadd d2 Td1093
      in
      nvector.(Ti1087) <- Td1094
  in
  let Tb1095 : BOOL =
    app
      o_isinvert
      m
  in
  app
    vecunit_sgn
    nvector
    Tb1095
in
letrec get_nvector : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT)
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1052 : INT =
    int 1
  in
  if m_shape == Ti1052
    app
      get_nvector_rect
      dirvec
    let Ti1053 : INT =
      int 2
    in
    if m_shape == Ti1053
      app
        get_nvector_plane
        m
      app
        get_nvector_second
        m
in
letrec utexture : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p : Array of FLOAT)
  let m_tex : INT =
    app
      o_texturetype
      m
  in
  let Tu136 : UNIT =
    let Ti929 : INT =
      int 0
    in
    let Td930 : FLOAT =
      app
        o_color_red
        m
    in
    texture_color.(Ti929) <- Td930
  in
  let Tu135 : UNIT =
    let Ti931 : INT =
      int 1
    in
    let Td932 : FLOAT =
      app
        o_color_green
        m
    in
    texture_color.(Ti931) <- Td932
  in
  let Tu134 : UNIT =
    let Ti933 : INT =
      int 2
    in
    let Td934 : FLOAT =
      app
        o_color_blue
        m
    in
    texture_color.(Ti933) <- Td934
  in
  let Ti935 : INT =
    int 1
  in
  if m_tex == Ti935
    let w1 : FLOAT =
      let Td937 : FLOAT =
        let Ti936 : INT =
          int 0
        in
        p.(Ti936)
      in
      let Td938 : FLOAT =
        app
          o_param_x
          m
      in
      fsub Td937 Td938
    in
    let flag1 : BOOL =
      let d1 : FLOAT =
        let Td941 : FLOAT =
          let Td940 : FLOAT =
            let Td939 : FLOAT =
              float 0.05
            in
            fmul w1 Td939
          in
          app
            floor
            Td940
        in
        let Td942 : FLOAT =
          float 20.
        in
        fmul Td941 Td942
      in
      let Td943 : FLOAT =
        fsub w1 d1
      in
      let Td944 : FLOAT =
        float 10.
      in
      app
        fless
        Td943
        Td944
    in
    let w3 : FLOAT =
      let Td946 : FLOAT =
        let Ti945 : INT =
          int 2
        in
        p.(Ti945)
      in
      let Td947 : FLOAT =
        app
          o_param_z
          m
      in
      fsub Td946 Td947
    in
    let flag2 : BOOL =
      let d2 : FLOAT =
        let Td950 : FLOAT =
          let Td949 : FLOAT =
            let Td948 : FLOAT =
              float 0.05
            in
            fmul w3 Td948
          in
          app
            floor
            Td949
        in
        let Td951 : FLOAT =
          float 20.
        in
        fmul Td950 Td951
      in
      let Td952 : FLOAT =
        fsub w3 d2
      in
      let Td953 : FLOAT =
        float 10.
      in
      app
        fless
        Td952
        Td953
    in
    let Ti954 : INT =
      int 1
    in
    let Td958 : FLOAT =
      let Ti955 : INT =
        int 0
      in
      if flag1 == Ti955
        let Ti956 : INT =
          int 0
        in
        if flag2 == Ti956
          float 255.
          float 0.
        let Ti957 : INT =
          int 0
        in
        if flag2 == Ti957
          float 0.
          float 255.
    in
    texture_color.(Ti954) <- Td958
    let Ti959 : INT =
      int 2
    in
    if m_tex == Ti959
      let w2 : FLOAT =
        let Td964 : FLOAT =
          let Td963 : FLOAT =
            let Td961 : FLOAT =
              let Ti960 : INT =
                int 1
              in
              p.(Ti960)
            in
            let Td962 : FLOAT =
              float 0.25
            in
            fmul Td961 Td962
          in
          app
            sin
            Td963
        in
        app
          fsqr
          Td964
      in
      let Tu132 : UNIT =
        let Ti965 : INT =
          int 0
        in
        let Td967 : FLOAT =
          let Td966 : FLOAT =
            float 255.
          in
          fmul Td966 w2
        in
        texture_color.(Ti965) <- Td967
      in
      let Ti968 : INT =
        int 1
      in
      let Td972 : FLOAT =
        let Td969 : FLOAT =
          float 255.
        in
        let Td971 : FLOAT =
          let Td970 : FLOAT =
            float 1.
          in
          fsub Td970 w2
        in
        fmul Td969 Td971
      in
      texture_color.(Ti968) <- Td972
      let Ti973 : INT =
        int 3
      in
      if m_tex == Ti973
        let w1 : FLOAT =
          let Td975 : FLOAT =
            let Ti974 : INT =
              int 0
            in
            p.(Ti974)
          in
          let Td976 : FLOAT =
            app
              o_param_x
              m
          in
          fsub Td975 Td976
        in
        let w3 : FLOAT =
          let Td978 : FLOAT =
            let Ti977 : INT =
              int 2
            in
            p.(Ti977)
          in
          let Td979 : FLOAT =
            app
              o_param_z
              m
          in
          fsub Td978 Td979
        in
        let w2 : FLOAT =
          let Td983 : FLOAT =
            let Td982 : FLOAT =
              let Td980 : FLOAT =
                app
                  fsqr
                  w1
              in
              let Td981 : FLOAT =
                app
                  fsqr
                  w3
              in
              fadd Td980 Td981
            in
            app
              sqrt
              Td982
          in
          let Td984 : FLOAT =
            float 10.
          in
          fdiv Td983 Td984
        in
        let w4 : FLOAT =
          let Td986 : FLOAT =
            let Td985 : FLOAT =
              app
                floor
                w2
            in
            fsub w2 Td985
          in
          let Td987 : FLOAT =
            float 3.1415927
          in
          fmul Td986 Td987
        in
        let cws : FLOAT =
          let Td988 : FLOAT =
            app
              cos
              w4
          in
          app
            fsqr
            Td988
        in
        let Tu133 : UNIT =
          let Ti989 : INT =
            int 1
          in
          let Td991 : FLOAT =
            let Td990 : FLOAT =
              float 255.
            in
            fmul cws Td990
          in
          texture_color.(Ti989) <- Td991
        in
        let Ti992 : INT =
          int 2
        in
        let Td996 : FLOAT =
          let Td994 : FLOAT =
            let Td993 : FLOAT =
              float 1.
            in
            fsub Td993 cws
          in
          let Td995 : FLOAT =
            float 255.
          in
          fmul Td994 Td995
        in
        texture_color.(Ti992) <- Td996
        let Ti997 : INT =
          int 4
        in
        if m_tex == Ti997
          let w1 : FLOAT =
            let Td1001 : FLOAT =
              let Td999 : FLOAT =
                let Ti998 : INT =
                  int 0
                in
                p.(Ti998)
              in
              let Td1000 : FLOAT =
                app
                  o_param_x
                  m
              in
              fsub Td999 Td1000
            in
            let Td1003 : FLOAT =
              let Td1002 : FLOAT =
                app
                  o_param_a
                  m
              in
              app
                sqrt
                Td1002
            in
            fmul Td1001 Td1003
          in
          let w3 : FLOAT =
            let Td1007 : FLOAT =
              let Td1005 : FLOAT =
                let Ti1004 : INT =
                  int 2
                in
                p.(Ti1004)
              in
              let Td1006 : FLOAT =
                app
                  o_param_z
                  m
              in
              fsub Td1005 Td1006
            in
            let Td1009 : FLOAT =
              let Td1008 : FLOAT =
                app
                  o_param_c
                  m
              in
              app
                sqrt
                Td1008
            in
            fmul Td1007 Td1009
          in
          let w4 : FLOAT =
            let Td1010 : FLOAT =
              app
                fsqr
                w1
            in
            let Td1011 : FLOAT =
              app
                fsqr
                w3
            in
            fadd Td1010 Td1011
          in
          let w7 : FLOAT =
            let Tb1014 : BOOL =
              let Td1012 : FLOAT =
                app
                  fabs
                  w1
              in
              let Td1013 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1012
                Td1013
            in
            let Ti1015 : INT =
              int 0
            in
            if Tb1014 == Ti1015
              let w5 : FLOAT =
                let Td1016 : FLOAT =
                  fdiv w3 w1
                in
                app
                  fabs
                  Td1016
              in
              let Td1019 : FLOAT =
                let Td1017 : FLOAT =
                  app
                    atan
                    w5
                in
                let Td1018 : FLOAT =
                  float 30.
                in
                fmul Td1017 Td1018
              in
              let Td1020 : FLOAT =
                float 3.1415927
              in
              fdiv Td1019 Td1020
              float 15.
          in
          let w9 : FLOAT =
            let Td1021 : FLOAT =
              app
                floor
                w7
            in
            fsub w7 Td1021
          in
          let w2 : FLOAT =
            let Td1025 : FLOAT =
              let Td1023 : FLOAT =
                let Ti1022 : INT =
                  int 1
                in
                p.(Ti1022)
              in
              let Td1024 : FLOAT =
                app
                  o_param_y
                  m
              in
              fsub Td1023 Td1024
            in
            let Td1027 : FLOAT =
              let Td1026 : FLOAT =
                app
                  o_param_b
                  m
              in
              app
                sqrt
                Td1026
            in
            fmul Td1025 Td1027
          in
          let w8 : FLOAT =
            let Tb1030 : BOOL =
              let Td1028 : FLOAT =
                app
                  fabs
                  w4
              in
              let Td1029 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1028
                Td1029
            in
            let Ti1031 : INT =
              int 0
            in
            if Tb1030 == Ti1031
              let w6 : FLOAT =
                let Td1032 : FLOAT =
                  fdiv w2 w4
                in
                app
                  fabs
                  Td1032
              in
              let Td1035 : FLOAT =
                let Td1033 : FLOAT =
                  app
                    atan
                    w6
                in
                let Td1034 : FLOAT =
                  float 30.
                in
                fmul Td1033 Td1034
              in
              let Td1036 : FLOAT =
                float 3.1415927
              in
              fdiv Td1035 Td1036
              float 15.
          in
          let w10 : FLOAT =
            let Td1037 : FLOAT =
              app
                floor
                w8
            in
            fsub w8 Td1037
          in
          let w11 : FLOAT =
            let Td1042 : FLOAT =
              let Td1038 : FLOAT =
                float 0.15
              in
              let Td1041 : FLOAT =
                let Td1040 : FLOAT =
                  let Td1039 : FLOAT =
                    float 0.5
                  in
                  fsub Td1039 w9
                in
                app
                  fsqr
                  Td1040
              in
              fsub Td1038 Td1041
            in
            let Td1045 : FLOAT =
              let Td1044 : FLOAT =
                let Td1043 : FLOAT =
                  float 0.5
                in
                fsub Td1043 w10
              in
              app
                fsqr
                Td1044
            in
            fsub Td1042 Td1045
          in
          let w12 : FLOAT =
            let Td1046 : FLOAT =
              float 0.
            in
            if w11 <. Td1046
              float 0.
              w11
          in
          let Ti1047 : INT =
            int 2
          in
          let Td1051 : FLOAT =
            let Td1049 : FLOAT =
              let Td1048 : FLOAT =
                float 255.
              in
              fmul Td1048 w12
            in
            let Td1050 : FLOAT =
              float 0.3
            in
            fdiv Td1049 Td1050
          in
          texture_color.(Ti1047) <- Td1051
          unit ()
in
letrec add_light : (FLOAT -> (FLOAT -> (FLOAT -> UNIT))) =
variables : (bright : FLOAT), (hilight : FLOAT), (hilight_scale : FLOAT)
  let Tu139 : UNIT =
    let Td913 : FLOAT =
      float 0.
    in
    if Td913 <. bright
      app
        vecaccum
        rgb
        bright
        texture_color
      unit ()
  in
  let Td914 : FLOAT =
    float 0.
  in
  if Td914 <. hilight
    let ihl : FLOAT =
      let Td916 : FLOAT =
        let Td915 : FLOAT =
          app
            fsqr
            hilight
        in
        app
          fsqr
          Td915
      in
      fmul Td916 hilight_scale
    in
    let Tu138 : UNIT =
      let Ti917 : INT =
        int 0
      in
      let Td920 : FLOAT =
        let Td919 : FLOAT =
          let Ti918 : INT =
            int 0
          in
          rgb.(Ti918)
        in
        fadd Td919 ihl
      in
      rgb.(Ti917) <- Td920
    in
    let Tu137 : UNIT =
      let Ti921 : INT =
        int 1
      in
      let Td924 : FLOAT =
        let Td923 : FLOAT =
          let Ti922 : INT =
            int 1
          in
          rgb.(Ti922)
        in
        fadd Td923 ihl
      in
      rgb.(Ti921) <- Td924
    in
    let Ti925 : INT =
      int 2
    in
    let Td928 : FLOAT =
      let Td927 : FLOAT =
        let Ti926 : INT =
          int 2
        in
        rgb.(Ti926)
      in
      fadd Td927 ihl
    in
    rgb.(Ti925) <- Td928
    unit ()
in
letrec trace_reflections : (INT -> (FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT)))) =
variables : (index : INT), (diffuse : FLOAT), (hilight_scale : FLOAT), (dirvec : Array of FLOAT)
  let Ti893 : INT =
    int 0
  in
  if Ti893 <= index
    let rinfo : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
      reflections.(index)
    in
    let dvec : (Array of FLOAT * Array of Array of FLOAT) =
      app
        r_dvec
        rinfo
    in
    let Tu140 : UNIT =
      let Tb894 : BOOL =
        app
          judge_intersection_fast
          dvec
      in
      let Ti895 : INT =
        int 0
      in
      if Tb894 == Ti895
        unit ()
        let surface_id : INT =
          let Ti898 : INT =
            let Ti897 : INT =
              let Ti896 : INT =
                int 0
              in
              intersected_object_id.(Ti896)
            in
            mul Ti897 4
          in
          let Ti900 : INT =
            let Ti899 : INT =
              int 0
            in
            intsec_rectside.(Ti899)
          in
          add Ti898 Ti900
        in
        let Ti901 : INT =
          app
            r_surface_id
            rinfo
        in
        if surface_id == Ti901
          let Tb905 : BOOL =
            let Ti902 : INT =
              int 0
            in
            let Ta904 : Array of Array of INT =
              let Ti903 : INT =
                int 0
              in
              or_net.(Ti903)
            in
            app
              shadow_check_one_or_matrix
              Ti902
              Ta904
          in
          let Ti906 : INT =
            int 0
          in
          if Tb905 == Ti906
            let p : FLOAT =
              let Ta907 : Array of FLOAT =
                app
                  d_vec
                  dvec
              in
              app
                veciprod
                nvector
                Ta907
            in
            let scale : FLOAT =
              app
                r_bright
                rinfo
            in
            let bright : FLOAT =
              let Td908 : FLOAT =
                fmul scale diffuse
              in
              fmul Td908 p
            in
            let hilight : FLOAT =
              let Td910 : FLOAT =
                let Ta909 : Array of FLOAT =
                  app
                    d_vec
                    dvec
                in
                app
                  veciprod
                  dirvec
                  Ta909
              in
              fmul scale Td910
            in
            app
              add_light
              bright
              hilight
              hilight_scale
            unit ()
          unit ()
    in
    let Ti912 : INT =
      let Ti911 : INT =
        int 1
      in
      sub index Ti911
    in
    app
      trace_reflections
      Ti912
      diffuse
      hilight_scale
      dirvec
    unit ()
in
letrec trace_ray : (INT -> (FLOAT -> (Array of FLOAT -> ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (FLOAT -> UNIT))))) =
variables : (nref : INT), (energy : FLOAT), (dirvec : Array of FLOAT), (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (dist : FLOAT)
  let Ti816 : INT =
    int 4
  in
  if nref <= Ti816
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Tb817 : BOOL =
      app
        judge_intersection
        dirvec
    in
    let Ti818 : INT =
      int 0
    in
    if Tb817 == Ti818
      let Tu157 : UNIT =
        let Ti820 : INT =
          let Ti819 : INT =
            int 1
          in
          neg Ti819
        in
        surface_ids.(nref) <- Ti820
      in
      let Ti821 : INT =
        int 0
      in
      if nref == Ti821
        unit ()
        let hl : FLOAT =
          let Td822 : FLOAT =
            app
              veciprod
              dirvec
              light
          in
          fneg Td822
        in
        let Td823 : FLOAT =
          float 0.
        in
        if Td823 <. hl
          let ihl : FLOAT =
            let Td826 : FLOAT =
              let Td825 : FLOAT =
                let Td824 : FLOAT =
                  app
                    fsqr
                    hl
                in
                fmul Td824 hl
              in
              fmul Td825 energy
            in
            let Td828 : FLOAT =
              let Ti827 : INT =
                int 0
              in
              beam.(Ti827)
            in
            fmul Td826 Td828
          in
          let Tu156 : UNIT =
            let Ti829 : INT =
              int 0
            in
            let Td832 : FLOAT =
              let Td831 : FLOAT =
                let Ti830 : INT =
                  int 0
                in
                rgb.(Ti830)
              in
              fadd Td831 ihl
            in
            rgb.(Ti829) <- Td832
          in
          let Tu155 : UNIT =
            let Ti833 : INT =
              int 1
            in
            let Td836 : FLOAT =
              let Td835 : FLOAT =
                let Ti834 : INT =
                  int 1
                in
                rgb.(Ti834)
              in
              fadd Td835 ihl
            in
            rgb.(Ti833) <- Td836
          in
          let Ti837 : INT =
            int 2
          in
          let Td840 : FLOAT =
            let Td839 : FLOAT =
              let Ti838 : INT =
                int 2
              in
              rgb.(Ti838)
            in
            fadd Td839 ihl
          in
          rgb.(Ti837) <- Td840
          unit ()
      let obj_id : INT =
        let Ti841 : INT =
          int 0
        in
        intersected_object_id.(Ti841)
      in
      let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(obj_id)
      in
      let m_surface : INT =
        app
          o_reflectiontype
          obj
      in
      let diffuse : FLOAT =
        let Td842 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td842 energy
      in
      let Tu154 : UNIT =
        app
          get_nvector
          obj
          dirvec
      in
      let Tu153 : UNIT =
        app
          veccpy
          startp
          intersection_point
      in
      let Tu152 : UNIT =
        app
          utexture
          obj
          intersection_point
      in
      let Tu151 : UNIT =
        let Ti846 : INT =
          let Ti843 : INT =
            mul obj_id 4
          in
          let Ti845 : INT =
            let Ti844 : INT =
              int 0
            in
            intsec_rectside.(Ti844)
          in
          add Ti843 Ti845
        in
        surface_ids.(nref) <- Ti846
      in
      let intersection_points : Array of Array of FLOAT =
        app
          p_intersection_points
          pixel
      in
      let Tu150 : UNIT =
        let Ta847 : Array of FLOAT =
          intersection_points.(nref)
        in
        app
          veccpy
          Ta847
          intersection_point
      in
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu149 : UNIT =
        let Tb850 : BOOL =
          let Td848 : FLOAT =
            app
              o_diffuse
              obj
          in
          let Td849 : FLOAT =
            float 0.5
          in
          app
            fless
            Td848
            Td849
        in
        let Ti851 : INT =
          int 0
        in
        if Tb850 == Ti851
          let Tu143 : UNIT =
            let Ti852 : INT =
              int 1
            in
            calc_diffuse.(nref) <- Ti852
          in
          let energya : Array of Array of FLOAT =
            app
              p_energy
              pixel
          in
          let Tu142 : UNIT =
            let Ta853 : Array of FLOAT =
              energya.(nref)
            in
            app
              veccpy
              Ta853
              texture_color
          in
          let Tu141 : UNIT =
            let Ta854 : Array of FLOAT =
              energya.(nref)
            in
            let Td858 : FLOAT =
              let Td857 : FLOAT =
                let Td855 : FLOAT =
                  float 1.
                in
                let Td856 : FLOAT =
                  float 256.
                in
                fdiv Td855 Td856
              in
              fmul Td857 diffuse
            in
            app
              vecscale
              Ta854
              Td858
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let Ta859 : Array of FLOAT =
            nvectors.(nref)
          in
          app
            veccpy
            Ta859
            nvector
          let Ti860 : INT =
            int 0
          in
          calc_diffuse.(nref) <- Ti860
      in
      let w : FLOAT =
        let Td861 : FLOAT =
          float -2.
        in
        let Td862 : FLOAT =
          app
            veciprod
            dirvec
            nvector
        in
        fmul Td861 Td862
      in
      let Tu148 : UNIT =
        app
          vecaccum
          dirvec
          w
          nvector
      in
      let hilight_scale : FLOAT =
        let Td863 : FLOAT =
          app
            o_hilight
            obj
        in
        fmul energy Td863
      in
      let Tu147 : UNIT =
        let Tb867 : BOOL =
          let Ti864 : INT =
            int 0
          in
          let Ta866 : Array of Array of INT =
            let Ti865 : INT =
              int 0
            in
            or_net.(Ti865)
          in
          app
            shadow_check_one_or_matrix
            Ti864
            Ta866
        in
        let Ti868 : INT =
          int 0
        in
        if Tb867 == Ti868
          let bright : FLOAT =
            let Td870 : FLOAT =
              let Td869 : FLOAT =
                app
                  veciprod
                  nvector
                  light
              in
              fneg Td869
            in
            fmul Td870 diffuse
          in
          let hilight : FLOAT =
            let Td871 : FLOAT =
              app
                veciprod
                dirvec
                light
            in
            fneg Td871
          in
          app
            add_light
            bright
            hilight
            hilight_scale
          unit ()
      in
      let Tu146 : UNIT =
        app
          setup_startp
          intersection_point
      in
      let Tu145 : UNIT =
        let Ti875 : INT =
          let Ti873 : INT =
            let Ti872 : INT =
              int 0
            in
            n_reflections.(Ti872)
          in
          let Ti874 : INT =
            int 1
          in
          sub Ti873 Ti874
        in
        app
          trace_reflections
          Ti875
          diffuse
          hilight_scale
          dirvec
      in
      let Tb877 : BOOL =
        let Td876 : FLOAT =
          float 0.1
        in
        app
          fless
          Td876
          energy
      in
      let Ti878 : INT =
        int 0
      in
      if Tb877 == Ti878
        unit ()
        let Tu144 : UNIT =
          let Ti879 : INT =
            int 4
          in
          if Ti879 <= nref
            unit ()
            let Ti881 : INT =
              let Ti880 : INT =
                int 1
              in
              add nref Ti880
            in
            let Ti883 : INT =
              let Ti882 : INT =
                int 1
              in
              neg Ti882
            in
            surface_ids.(Ti881) <- Ti883
        in
        let Ti884 : INT =
          int 2
        in
        if m_surface == Ti884
          let energy2 : FLOAT =
            let Td887 : FLOAT =
              let Td885 : FLOAT =
                float 1.
              in
              let Td886 : FLOAT =
                app
                  o_diffuse
                  obj
              in
              fsub Td885 Td886
            in
            fmul energy Td887
          in
          let Ti889 : INT =
            let Ti888 : INT =
              int 1
            in
            add nref Ti888
          in
          let Td892 : FLOAT =
            let Td891 : FLOAT =
              let Ti890 : INT =
                int 0
              in
              tmin.(Ti890)
            in
            fadd dist Td891
          in
          app
            trace_ray
            Ti889
            energy2
            dirvec
            pixel
            Td892
          unit ()
    unit ()
in
letrec trace_diffuse_ray : ((Array of FLOAT * Array of Array of FLOAT) -> (FLOAT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (energy : FLOAT)
  let Tb801 : BOOL =
    app
      judge_intersection_fast
      dirvec
  in
  let Ti802 : INT =
    int 0
  in
  if Tb801 == Ti802
    unit ()
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      let Ti804 : INT =
        let Ti803 : INT =
          int 0
        in
        intersected_object_id.(Ti803)
      in
      objects.(Ti804)
    in
    let Tu159 : UNIT =
      let Ta805 : Array of FLOAT =
        app
          d_vec
          dirvec
      in
      app
        get_nvector
        obj
        Ta805
    in
    let Tu158 : UNIT =
      app
        utexture
        obj
        intersection_point
    in
    let Tb809 : BOOL =
      let Ti806 : INT =
        int 0
      in
      let Ta808 : Array of Array of INT =
        let Ti807 : INT =
          int 0
        in
        or_net.(Ti807)
      in
      app
        shadow_check_one_or_matrix
        Ti806
        Ta808
    in
    let Ti810 : INT =
      int 0
    in
    if Tb809 == Ti810
      let br : FLOAT =
        let Td811 : FLOAT =
          app
            veciprod
            nvector
            light
        in
        fneg Td811
      in
      let bright : FLOAT =
        let Td812 : FLOAT =
          float 0.
        in
        if Td812 <. br
          br
          float 0.
      in
      let Td815 : FLOAT =
        let Td813 : FLOAT =
          fmul energy bright
        in
        let Td814 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td813 Td814
      in
      app
        vecaccum
        diffuse_ray
        Td815
        texture_color
      unit ()
in
letrec iter_trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (INT -> UNIT)))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT), (index : INT)
  let Ti787 : INT =
    int 0
  in
  if Ti787 <= index
    let p : FLOAT =
      let Ta789 : Array of FLOAT =
        let Tt788 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        app
          d_vec
          Tt788
      in
      app
        veciprod
        Ta789
        nvector
    in
    let Tu160 : UNIT =
      let Td790 : FLOAT =
        float 0.
      in
      if p <. Td790
        let Tt793 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti792 : INT =
            let Ti791 : INT =
              int 1
            in
            add index Ti791
          in
          dirvec_group.(Ti792)
        in
        let Td795 : FLOAT =
          let Td794 : FLOAT =
            float -150.
          in
          fdiv p Td794
        in
        app
          trace_diffuse_ray
          Tt793
          Td795
        let Tt796 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        let Td798 : FLOAT =
          let Td797 : FLOAT =
            float 150.
          in
          fdiv p Td797
        in
        app
          trace_diffuse_ray
          Tt796
          Td798
    in
    let Ti800 : INT =
      let Ti799 : INT =
        int 2
      in
      sub index Ti799
    in
    app
      iter_trace_diffuse_rays
      dirvec_group
      nvector
      org
      Ti800
    unit ()
in
letrec trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu161 : UNIT =
    app
      setup_startp
      org
  in
  let Ti786 : INT =
    int 118
  in
  app
    iter_trace_diffuse_rays
    dirvec_group
    nvector
    org
    Ti786
in
letrec trace_diffuse_ray_80percent : (INT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (group_id : INT), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu165 : UNIT =
    let Ti771 : INT =
      int 0
    in
    if group_id == Ti771
      unit ()
      let Ta773 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti772 : INT =
          int 0
        in
        dirvecs.(Ti772)
      in
      app
        trace_diffuse_rays
        Ta773
        nvector
        org
  in
  let Tu164 : UNIT =
    let Ti774 : INT =
      int 1
    in
    if group_id == Ti774
      unit ()
      let Ta776 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti775 : INT =
          int 1
        in
        dirvecs.(Ti775)
      in
      app
        trace_diffuse_rays
        Ta776
        nvector
        org
  in
  let Tu163 : UNIT =
    let Ti777 : INT =
      int 2
    in
    if group_id == Ti777
      unit ()
      let Ta779 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti778 : INT =
          int 2
        in
        dirvecs.(Ti778)
      in
      app
        trace_diffuse_rays
        Ta779
        nvector
        org
  in
  let Tu162 : UNIT =
    let Ti780 : INT =
      int 3
    in
    if group_id == Ti780
      unit ()
      let Ta782 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti781 : INT =
          int 3
        in
        dirvecs.(Ti781)
      in
      app
        trace_diffuse_rays
        Ta782
        nvector
        org
  in
  let Ti783 : INT =
    int 4
  in
  if group_id == Ti783
    unit ()
    let Ta785 : Array of (Array of FLOAT * Array of Array of FLOAT) =
      let Ti784 : INT =
        int 4
      in
      dirvecs.(Ti784)
    in
    app
      trace_diffuse_rays
      Ta785
      nvector
      org
in
letrec calc_diffuse_using_1point : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let ray20p : Array of Array of FLOAT =
    app
      p_received_ray_20percent
      pixel
  in
  let nvectors : Array of Array of FLOAT =
    app
      p_nvectors
      pixel
  in
  let intersection_points : Array of Array of FLOAT =
    app
      p_intersection_points
      pixel
  in
  let energya : Array of Array of FLOAT =
    app
      p_energy
      pixel
  in
  let Tu167 : UNIT =
    let Ta766 : Array of FLOAT =
      ray20p.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta766
  in
  let Tu166 : UNIT =
    let Ti767 : INT =
      app
        p_group_id
        pixel
    in
    let Ta768 : Array of FLOAT =
      nvectors.(nref)
    in
    let Ta769 : Array of FLOAT =
      intersection_points.(nref)
    in
    app
      trace_diffuse_ray_80percent
      Ti767
      Ta768
      Ta769
  in
  let Ta770 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta770
    diffuse_ray
in
letrec calc_diffuse_using_5points : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let r_up : Array of Array of FLOAT =
    let Tt750 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      p_received_ray_20percent
      Tt750
  in
  let r_left : Array of Array of FLOAT =
    let Tt753 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti752 : INT =
        let Ti751 : INT =
          int 1
        in
        sub x Ti751
      in
      cur.(Ti752)
    in
    app
      p_received_ray_20percent
      Tt753
  in
  let r_center : Array of Array of FLOAT =
    let Tt754 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_received_ray_20percent
      Tt754
  in
  let r_right : Array of Array of FLOAT =
    let Tt757 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti756 : INT =
        let Ti755 : INT =
          int 1
        in
        add x Ti755
      in
      cur.(Ti756)
    in
    app
      p_received_ray_20percent
      Tt757
  in
  let r_down : Array of Array of FLOAT =
    let Tt758 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      next.(x)
    in
    app
      p_received_ray_20percent
      Tt758
  in
  let Tu172 : UNIT =
    let Ta759 : Array of FLOAT =
      r_up.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta759
  in
  let Tu171 : UNIT =
    let Ta760 : Array of FLOAT =
      r_left.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta760
  in
  let Tu170 : UNIT =
    let Ta761 : Array of FLOAT =
      r_center.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta761
  in
  let Tu169 : UNIT =
    let Ta762 : Array of FLOAT =
      r_right.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta762
  in
  let Tu168 : UNIT =
    let Ta763 : Array of FLOAT =
      r_down.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta763
  in
  let energya : Array of Array of FLOAT =
    let Tt764 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_energy
      Tt764
  in
  let Ta765 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta765
    diffuse_ray
in
letrec do_without_neighbors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti743 : INT =
    int 4
  in
  if nref <= Ti743
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Ti744 : INT =
      int 0
    in
    let Ti745 : INT =
      surface_ids.(nref)
    in
    if Ti744 <= Ti745
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu173 : UNIT =
        let Tb746 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti747 : INT =
          int 0
        in
        if Tb746 == Ti747
          unit ()
          app
            calc_diffuse_using_1point
            pixel
            nref
      in
      let Ti749 : INT =
        let Ti748 : INT =
          int 1
        in
        add nref Ti748
      in
      app
        do_without_neighbors
        pixel
        Ti749
      unit ()
    unit ()
in
letrec neighbors_exist : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> BOOL))) =
variables : (x : INT), (y : INT), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti734 : INT =
    let Ti733 : INT =
      int 1
    in
    image_size.(Ti733)
  in
  let Ti736 : INT =
    let Ti735 : INT =
      int 1
    in
    add y Ti735
  in
  if Ti734 <= Ti736
    int 0
    let Ti737 : INT =
      int 0
    in
    if y <= Ti737
      int 0
      let Ti739 : INT =
        let Ti738 : INT =
          int 0
        in
        image_size.(Ti738)
      in
      let Ti741 : INT =
        let Ti740 : INT =
          int 1
        in
        add x Ti740
      in
      if Ti739 <= Ti741
        int 0
        let Ti742 : INT =
          int 0
        in
        if x <= Ti742
          int 0
          int 1
in
letrec get_surface_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> INT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (index : INT)
  let surface_ids : Array of INT =
    app
      p_surface_ids
      pixel
  in
  surface_ids.(index)
in
letrec neighbors_are_available : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> BOOL))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let sid_center : INT =
    let Tt720 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      get_surface_id
      Tt720
      nref
  in
  let Ti722 : INT =
    let Tt721 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      get_surface_id
      Tt721
      nref
  in
  if Ti722 == sid_center
    let Ti724 : INT =
      let Tt723 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        next.(x)
      in
      app
        get_surface_id
        Tt723
        nref
    in
    if Ti724 == sid_center
      let Ti728 : INT =
        let Tt727 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          let Ti726 : INT =
            let Ti725 : INT =
              int 1
            in
            sub x Ti725
          in
          cur.(Ti726)
        in
        app
          get_surface_id
          Tt727
          nref
      in
      if Ti728 == sid_center
        let Ti732 : INT =
          let Tt731 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
            let Ti730 : INT =
              let Ti729 : INT =
                int 1
              in
              add x Ti729
            in
            cur.(Ti730)
          in
          app
            get_surface_id
            Tt731
            nref
        in
        if Ti732 == sid_center
          int 1
          int 0
        int 0
      int 0
    int 0
in
letrec try_exploit_neighbors : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    cur.(x)
  in
  let Ti710 : INT =
    int 4
  in
  if nref <= Ti710
    let Ti711 : INT =
      int 0
    in
    let Ti712 : INT =
      app
        get_surface_id
        pixel
        nref
    in
    if Ti711 <= Ti712
      let Tb713 : BOOL =
        app
          neighbors_are_available
          x
          prev
          cur
          next
          nref
      in
      let Ti714 : INT =
        int 0
      in
      if Tb713 == Ti714
        let Tt715 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          do_without_neighbors
          Tt715
          nref
        let calc_diffuse : Array of BOOL =
          app
            p_calc_diffuse
            pixel
        in
        let Tu174 : UNIT =
          let Tb716 : BOOL =
            calc_diffuse.(nref)
          in
          let Ti717 : INT =
            int 0
          in
          if Tb716 == Ti717
            unit ()
            app
              calc_diffuse_using_5points
              x
              prev
              cur
              next
              nref
        in
        let Ti719 : INT =
          let Ti718 : INT =
            int 1
          in
          add nref Ti718
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti719
      unit ()
    unit ()
in
letrec write_ppm_header : (UNIT -> UNIT) =
variables : (Tu175 : UNIT)
  let Tu183 : UNIT =
    let Ti697 : INT =
      int 80
    in
    app
      print_char
      Ti697
  in
  let Tu182 : UNIT =
    let Ti700 : INT =
      let Ti698 : INT =
        int 48
      in
      let Ti699 : INT =
        int 3
      in
      add Ti698 Ti699
    in
    app
      print_char
      Ti700
  in
  let Tu181 : UNIT =
    let Ti701 : INT =
      int 10
    in
    app
      print_char
      Ti701
  in
  let Tu180 : UNIT =
    let Ti703 : INT =
      let Ti702 : INT =
        int 0
      in
      image_size.(Ti702)
    in
    app
      print_int
      Ti703
  in
  let Tu179 : UNIT =
    let Ti704 : INT =
      int 32
    in
    app
      print_char
      Ti704
  in
  let Tu178 : UNIT =
    let Ti706 : INT =
      let Ti705 : INT =
        int 1
      in
      image_size.(Ti705)
    in
    app
      print_int
      Ti706
  in
  let Tu177 : UNIT =
    let Ti707 : INT =
      int 32
    in
    app
      print_char
      Ti707
  in
  let Tu176 : UNIT =
    let Ti708 : INT =
      int 255
    in
    app
      print_int
      Ti708
  in
  let Ti709 : INT =
    int 10
  in
  app
    print_char
    Ti709
in
letrec write_rgb_element : (FLOAT -> UNIT) =
variables : (x : FLOAT)
  let ix : INT =
    ftoi x
  in
  let elem : INT =
    let Ti695 : INT =
      int 255
    in
    if ix <= Ti695
      let Ti696 : INT =
        int 0
      in
      if Ti696 <= ix
        ix
        int 0
      int 255
  in
  app
    print_int
    elem
in
letrec write_rgb : (UNIT -> UNIT) =
variables : (Tu184 : UNIT)
  let Tu189 : UNIT =
    let Td687 : FLOAT =
      let Ti686 : INT =
        int 0
      in
      rgb.(Ti686)
    in
    app
      write_rgb_element
      Td687
  in
  let Tu188 : UNIT =
    let Ti688 : INT =
      int 32
    in
    app
      print_char
      Ti688
  in
  let Tu187 : UNIT =
    let Td690 : FLOAT =
      let Ti689 : INT =
        int 1
      in
      rgb.(Ti689)
    in
    app
      write_rgb_element
      Td690
  in
  let Tu186 : UNIT =
    let Ti691 : INT =
      int 32
    in
    app
      print_char
      Ti691
  in
  let Tu185 : UNIT =
    let Td693 : FLOAT =
      let Ti692 : INT =
        int 2
      in
      rgb.(Ti692)
    in
    app
      write_rgb_element
      Td693
  in
  let Ti694 : INT =
    int 10
  in
  app
    print_char
    Ti694
in
letrec pretrace_diffuse_rays : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti676 : INT =
    int 4
  in
  if nref <= Ti676
    let sid : INT =
      app
        get_surface_id
        pixel
        nref
    in
    let Ti677 : INT =
      int 0
    in
    if Ti677 <= sid
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu192 : UNIT =
        let Tb678 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti679 : INT =
          int 0
        in
        if Tb678 == Ti679
          unit ()
          let group_id : INT =
            app
              p_group_id
              pixel
          in
          let Tu191 : UNIT =
            app
              vecbzero
              diffuse_ray
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let intersection_points : Array of Array of FLOAT =
            app
              p_intersection_points
              pixel
          in
          let Tu190 : UNIT =
            let Ta680 : Array of (Array of FLOAT * Array of Array of FLOAT) =
              dirvecs.(group_id)
            in
            let Ta681 : Array of FLOAT =
              nvectors.(nref)
            in
            let Ta682 : Array of FLOAT =
              intersection_points.(nref)
            in
            app
              trace_diffuse_rays
              Ta680
              Ta681
              Ta682
          in
          let ray20p : Array of Array of FLOAT =
            app
              p_received_ray_20percent
              pixel
          in
          let Ta683 : Array of FLOAT =
            ray20p.(nref)
          in
          app
            veccpy
            Ta683
            diffuse_ray
      in
      let Ti685 : INT =
        let Ti684 : INT =
          int 1
        in
        add nref Ti684
      in
      app
        pretrace_diffuse_rays
        pixel
        Ti685
      unit ()
    unit ()
in
letrec pretrace_pixels : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (x : INT), (group_id : INT), (lc0 : FLOAT), (lc1 : FLOAT), (lc2 : FLOAT)
  let Ti640 : INT =
    int 0
  in
  if Ti640 <= x
    let xdisp : FLOAT =
      let Td642 : FLOAT =
        let Ti641 : INT =
          int 0
        in
        scan_pitch.(Ti641)
      in
      let Td646 : FLOAT =
        let Ti645 : INT =
          let Ti644 : INT =
            let Ti643 : INT =
              int 0
            in
            image_center.(Ti643)
          in
          sub x Ti644
        in
        itof Ti645
      in
      fmul Td642 Td646
    in
    let Tu202 : UNIT =
      let Ti647 : INT =
        int 0
      in
      let Td651 : FLOAT =
        let Td650 : FLOAT =
          let Td649 : FLOAT =
            let Ti648 : INT =
              int 0
            in
            screenx_dir.(Ti648)
          in
          fmul xdisp Td649
        in
        fadd Td650 lc0
      in
      ptrace_dirvec.(Ti647) <- Td651
    in
    let Tu201 : UNIT =
      let Ti652 : INT =
        int 1
      in
      let Td656 : FLOAT =
        let Td655 : FLOAT =
          let Td654 : FLOAT =
            let Ti653 : INT =
              int 1
            in
            screenx_dir.(Ti653)
          in
          fmul xdisp Td654
        in
        fadd Td655 lc1
      in
      ptrace_dirvec.(Ti652) <- Td656
    in
    let Tu200 : UNIT =
      let Ti657 : INT =
        int 2
      in
      let Td661 : FLOAT =
        let Td660 : FLOAT =
          let Td659 : FLOAT =
            let Ti658 : INT =
              int 2
            in
            screenx_dir.(Ti658)
          in
          fmul xdisp Td659
        in
        fadd Td660 lc2
      in
      ptrace_dirvec.(Ti657) <- Td661
    in
    let Tu199 : UNIT =
      let Ti662 : INT =
        int 0
      in
      app
        vecunit_sgn
        ptrace_dirvec
        Ti662
    in
    let Tu198 : UNIT =
      app
        vecbzero
        rgb
    in
    let Tu197 : UNIT =
      app
        veccpy
        startp
        viewpoint
    in
    let Tu196 : UNIT =
      let Ti663 : INT =
        int 0
      in
      let Td664 : FLOAT =
        float 1.
      in
      let Tt665 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Td666 : FLOAT =
        float 0.
      in
      app
        trace_ray
        Ti663
        Td664
        ptrace_dirvec
        Tt665
        Td666
    in
    let Tu195 : UNIT =
      let Ta668 : Array of FLOAT =
        let Tt667 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          line.(x)
        in
        app
          p_rgb
          Tt667
      in
      app
        veccpy
        Ta668
        rgb
    in
    let Tu194 : UNIT =
      let Tt669 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      app
        p_set_group_id
        Tt669
        group_id
    in
    let Tu193 : UNIT =
      let Tt670 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Ti671 : INT =
        int 0
      in
      app
        pretrace_diffuse_rays
        Tt670
        Ti671
    in
    let Ti673 : INT =
      let Ti672 : INT =
        int 1
      in
      sub x Ti672
    in
    let Ti675 : INT =
      let Ti674 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti674
    in
    app
      pretrace_pixels
      line
      Ti673
      Ti675
      lc0
      lc1
      lc2
    unit ()
in
letrec pretrace_line : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> UNIT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (y : INT), (group_id : INT)
  let ydisp : FLOAT =
    let Td616 : FLOAT =
      let Ti615 : INT =
        int 0
      in
      scan_pitch.(Ti615)
    in
    let Td620 : FLOAT =
      let Ti619 : INT =
        let Ti618 : INT =
          let Ti617 : INT =
            int 1
          in
          image_center.(Ti617)
        in
        sub y Ti618
      in
      itof Ti619
    in
    fmul Td616 Td620
  in
  let lc0 : FLOAT =
    let Td623 : FLOAT =
      let Td622 : FLOAT =
        let Ti621 : INT =
          int 0
        in
        screeny_dir.(Ti621)
      in
      fmul ydisp Td622
    in
    let Td625 : FLOAT =
      let Ti624 : INT =
        int 0
      in
      screenz_dir.(Ti624)
    in
    fadd Td623 Td625
  in
  let lc1 : FLOAT =
    let Td628 : FLOAT =
      let Td627 : FLOAT =
        let Ti626 : INT =
          int 1
        in
        screeny_dir.(Ti626)
      in
      fmul ydisp Td627
    in
    let Td630 : FLOAT =
      let Ti629 : INT =
        int 1
      in
      screenz_dir.(Ti629)
    in
    fadd Td628 Td630
  in
  let lc2 : FLOAT =
    let Td633 : FLOAT =
      let Td632 : FLOAT =
        let Ti631 : INT =
          int 2
        in
        screeny_dir.(Ti631)
      in
      fmul ydisp Td632
    in
    let Td635 : FLOAT =
      let Ti634 : INT =
        int 2
      in
      screenz_dir.(Ti634)
    in
    fadd Td633 Td635
  in
  let Ti639 : INT =
    let Ti637 : INT =
      let Ti636 : INT =
        int 0
      in
      image_size.(Ti636)
    in
    let Ti638 : INT =
      int 1
    in
    sub Ti637 Ti638
  in
  app
    pretrace_pixels
    line
    Ti639
    group_id
    lc0
    lc1
    lc2
in
letrec scan_pixel : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> UNIT))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti604 : INT =
    let Ti603 : INT =
      int 0
    in
    image_size.(Ti603)
  in
  if Ti604 <= x
    unit ()
    let Tu205 : UNIT =
      let Ta606 : Array of FLOAT =
        let Tt605 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          p_rgb
          Tt605
      in
      app
        veccpy
        rgb
        Ta606
    in
    let Tu204 : UNIT =
      let Tb607 : BOOL =
        app
          neighbors_exist
          x
          y
          next
      in
      let Ti608 : INT =
        int 0
      in
      if Tb607 == Ti608
        let Tt609 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        let Ti610 : INT =
          int 0
        in
        app
          do_without_neighbors
          Tt609
          Ti610
        let Ti611 : INT =
          int 0
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti611
    in
    let Tu203 : UNIT =
      let Tu612 : UNIT =
        unit ()
      in
      app
        write_rgb
        Tu612
    in
    let Ti614 : INT =
      let Ti613 : INT =
        int 1
      in
      add x Ti613
    in
    app
      scan_pixel
      Ti614
      y
      prev
      cur
      next
in
letrec scan_line : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (group_id : INT)
  let Ti591 : INT =
    let Ti590 : INT =
      int 1
    in
    image_size.(Ti590)
  in
  if Ti591 <= y
    unit ()
    let Tu207 : UNIT =
      let Ti595 : INT =
        let Ti593 : INT =
          let Ti592 : INT =
            int 1
          in
          image_size.(Ti592)
        in
        let Ti594 : INT =
          int 1
        in
        sub Ti593 Ti594
      in
      if Ti595 <= y
        unit ()
        let Ti597 : INT =
          let Ti596 : INT =
            int 1
          in
          add y Ti596
        in
        app
          pretrace_line
          next
          Ti597
          group_id
    in
    let Tu206 : UNIT =
      let Ti598 : INT =
        int 0
      in
      app
        scan_pixel
        Ti598
        y
        prev
        cur
        next
    in
    let Ti600 : INT =
      let Ti599 : INT =
        int 1
      in
      add y Ti599
    in
    let Ti602 : INT =
      let Ti601 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti601
    in
    app
      scan_line
      Ti600
      cur
      next
      prev
      Ti602
in
letrec create_float5x3array : (UNIT -> Array of Array of FLOAT) =
variables : (Tu208 : UNIT)
  let vec : Array of FLOAT =
    let Ti571 : INT =
      int 3
    in
    let Td572 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti571
      Td572
  in
  let array : Array of Array of FLOAT =
    let Ti573 : INT =
      int 5
    in
    extfunapp
      create_array
      Ti573
      vec
  in
  let Tu212 : UNIT =
    let Ti574 : INT =
      int 1
    in
    let Ta577 : Array of FLOAT =
      let Ti575 : INT =
        int 3
      in
      let Td576 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti575
        Td576
    in
    array.(Ti574) <- Ta577
  in
  let Tu211 : UNIT =
    let Ti578 : INT =
      int 2
    in
    let Ta581 : Array of FLOAT =
      let Ti579 : INT =
        int 3
      in
      let Td580 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti579
        Td580
    in
    array.(Ti578) <- Ta581
  in
  let Tu210 : UNIT =
    let Ti582 : INT =
      int 3
    in
    let Ta585 : Array of FLOAT =
      let Ti583 : INT =
        int 3
      in
      let Td584 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti583
        Td584
    in
    array.(Ti582) <- Ta585
  in
  let Tu209 : UNIT =
    let Ti586 : INT =
      int 4
    in
    let Ta589 : Array of FLOAT =
      let Ti587 : INT =
        int 3
      in
      let Td588 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti587
        Td588
    in
    array.(Ti586) <- Ta589
  in
  array
in
letrec create_pixel : (UNIT -> (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu213 : UNIT)
  let m_rgb : Array of FLOAT =
    let Ti559 : INT =
      int 3
    in
    let Td560 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti559
      Td560
  in
  let m_isect_ps : Array of Array of FLOAT =
    let Tu561 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu561
  in
  let m_sids : Array of INT =
    let Ti562 : INT =
      int 5
    in
    let Ti563 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti562
      Ti563
  in
  let m_cdif : Array of BOOL =
    let Ti564 : INT =
      int 5
    in
    let Ti565 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti564
      Ti565
  in
  let m_engy : Array of Array of FLOAT =
    let Tu566 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu566
  in
  let m_r20p : Array of Array of FLOAT =
    let Tu567 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu567
  in
  let m_gid : Array of INT =
    let Ti568 : INT =
      int 1
    in
    let Ti569 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti568
      Ti569
  in
  let m_nvectors : Array of Array of FLOAT =
    let Tu570 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu570
  in
  Tuple
    m_rgb
    m_isect_ps
    m_sids
    m_cdif
    m_engy
    m_r20p
    m_gid
    m_nvectors
in
letrec init_line_elements : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (n : INT)
  let Ti554 : INT =
    int 0
  in
  if Ti554 <= n
    let Tu214 : UNIT =
      let Tt556 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        let Tu555 : UNIT =
          unit ()
        in
        app
          create_pixel
          Tu555
      in
      line.(n) <- Tt556
    in
    let Ti558 : INT =
      let Ti557 : INT =
        int 1
      in
      sub n Ti557
    in
    app
      init_line_elements
      line
      Ti558
    line
in
letrec create_pixelline : (UNIT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu215 : UNIT)
  let line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Ti547 : INT =
      let Ti546 : INT =
        int 0
      in
      image_size.(Ti546)
    in
    let Tt549 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Tu548 : UNIT =
        unit ()
      in
      app
        create_pixel
        Tu548
    in
    extfunapp
      create_array
      Ti547
      Tt549
  in
  let Ti553 : INT =
    let Ti551 : INT =
      let Ti550 : INT =
        int 0
      in
      image_size.(Ti550)
    in
    let Ti552 : INT =
      int 2
    in
    sub Ti551 Ti552
  in
  app
    init_line_elements
    line
    Ti553
in
letrec tan : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td544 : FLOAT =
    app
      sin
      x
  in
  let Td545 : FLOAT =
    app
      cos
      x
  in
  fdiv Td544 Td545
in
letrec adjust_position : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (h : FLOAT), (ratio : FLOAT)
  let l : FLOAT =
    let Td541 : FLOAT =
      let Td539 : FLOAT =
        fmul h h
      in
      let Td540 : FLOAT =
        float 0.1
      in
      fadd Td539 Td540
    in
    app
      sqrt
      Td541
  in
  let tan_h : FLOAT =
    let Td542 : FLOAT =
      float 1.
    in
    fdiv Td542 l
  in
  let theta_h : FLOAT =
    app
      atan
      tan_h
  in
  let tan_m : FLOAT =
    let Td543 : FLOAT =
      fmul theta_h ratio
    in
    app
      tan
      Td543
  in
  fmul tan_m l
in
letrec calc_dirvec : (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> UNIT))))))) =
variables : (icount : INT), (x : FLOAT), (y : FLOAT), (rx : FLOAT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti498 : INT =
    int 5
  in
  if Ti498 <= icount
    let l : FLOAT =
      let Td503 : FLOAT =
        let Td501 : FLOAT =
          let Td499 : FLOAT =
            app
              fsqr
              x
          in
          let Td500 : FLOAT =
            app
              fsqr
              y
          in
          fadd Td499 Td500
        in
        let Td502 : FLOAT =
          float 1.
        in
        fadd Td501 Td502
      in
      app
        sqrt
        Td503
    in
    let vx : FLOAT =
      fdiv x l
    in
    let vy : FLOAT =
      fdiv y l
    in
    let vz : FLOAT =
      let Td504 : FLOAT =
        float 1.
      in
      fdiv Td504 l
    in
    let dgroup : Array of (Array of FLOAT * Array of Array of FLOAT) =
      dirvecs.(group_id)
    in
    let Tu220 : UNIT =
      let Ta506 : Array of FLOAT =
        let Tt505 : (Array of FLOAT * Array of Array of FLOAT) =
          dgroup.(index)
        in
        app
          d_vec
          Tt505
      in
      app
        vecset
        Ta506
        vx
        vy
        vz
    in
    let Tu219 : UNIT =
      let Ta510 : Array of FLOAT =
        let Tt509 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti508 : INT =
            let Ti507 : INT =
              int 40
            in
            add index Ti507
          in
          dgroup.(Ti508)
        in
        app
          d_vec
          Tt509
      in
      let Td511 : FLOAT =
        fneg vy
      in
      app
        vecset
        Ta510
        vx
        vz
        Td511
    in
    let Tu218 : UNIT =
      let Ta515 : Array of FLOAT =
        let Tt514 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti513 : INT =
            let Ti512 : INT =
              int 80
            in
            add index Ti512
          in
          dgroup.(Ti513)
        in
        app
          d_vec
          Tt514
      in
      let Td516 : FLOAT =
        fneg vx
      in
      let Td517 : FLOAT =
        fneg vy
      in
      app
        vecset
        Ta515
        vz
        Td516
        Td517
    in
    let Tu217 : UNIT =
      let Ta521 : Array of FLOAT =
        let Tt520 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti519 : INT =
            let Ti518 : INT =
              int 1
            in
            add index Ti518
          in
          dgroup.(Ti519)
        in
        app
          d_vec
          Tt520
      in
      let Td522 : FLOAT =
        fneg vx
      in
      let Td523 : FLOAT =
        fneg vy
      in
      let Td524 : FLOAT =
        fneg vz
      in
      app
        vecset
        Ta521
        Td522
        Td523
        Td524
    in
    let Tu216 : UNIT =
      let Ta528 : Array of FLOAT =
        let Tt527 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti526 : INT =
            let Ti525 : INT =
              int 41
            in
            add index Ti525
          in
          dgroup.(Ti526)
        in
        app
          d_vec
          Tt527
      in
      let Td529 : FLOAT =
        fneg vx
      in
      let Td530 : FLOAT =
        fneg vz
      in
      app
        vecset
        Ta528
        Td529
        Td530
        vy
    in
    let Ta534 : Array of FLOAT =
      let Tt533 : (Array of FLOAT * Array of Array of FLOAT) =
        let Ti532 : INT =
          let Ti531 : INT =
            int 81
          in
          add index Ti531
        in
        dgroup.(Ti532)
      in
      app
        d_vec
        Tt533
    in
    let Td535 : FLOAT =
      fneg vz
    in
    app
      vecset
      Ta534
      Td535
      vx
      vy
    let x2 : FLOAT =
      app
        adjust_position
        y
        rx
    in
    let Ti537 : INT =
      let Ti536 : INT =
        int 1
      in
      add icount Ti536
    in
    let Td538 : FLOAT =
      app
        adjust_position
        x2
        ry
    in
    app
      calc_dirvec
      Ti537
      x2
      Td538
      rx
      ry
      group_id
      index
in
letrec calc_dirvecs : (INT -> (FLOAT -> (INT -> (INT -> UNIT)))) =
variables : (col : INT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti477 : INT =
    int 0
  in
  if Ti477 <= col
    let rx : FLOAT =
      let Td480 : FLOAT =
        let Td478 : FLOAT =
          itof col
        in
        let Td479 : FLOAT =
          float 0.2
        in
        fmul Td478 Td479
      in
      let Td481 : FLOAT =
        float 0.9
      in
      fsub Td480 Td481
    in
    let Tu222 : UNIT =
      let Ti482 : INT =
        int 0
      in
      let Td483 : FLOAT =
        float 0.
      in
      let Td484 : FLOAT =
        float 0.
      in
      app
        calc_dirvec
        Ti482
        Td483
        Td484
        rx
        ry
        group_id
        index
    in
    let rx2 : FLOAT =
      let Td487 : FLOAT =
        let Td485 : FLOAT =
          itof col
        in
        let Td486 : FLOAT =
          float 0.2
        in
        fmul Td485 Td486
      in
      let Td488 : FLOAT =
        float 0.1
      in
      fadd Td487 Td488
    in
    let Tu221 : UNIT =
      let Ti489 : INT =
        int 0
      in
      let Td490 : FLOAT =
        float 0.
      in
      let Td491 : FLOAT =
        float 0.
      in
      let Ti493 : INT =
        let Ti492 : INT =
          int 2
        in
        add index Ti492
      in
      app
        calc_dirvec
        Ti489
        Td490
        Td491
        rx2
        ry
        group_id
        Ti493
    in
    let Ti495 : INT =
      let Ti494 : INT =
        int 1
      in
      sub col Ti494
    in
    let Ti497 : INT =
      let Ti496 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti496
    in
    app
      calc_dirvecs
      Ti495
      ry
      Ti497
      index
    unit ()
in
letrec calc_dirvec_rows : (INT -> (INT -> (INT -> UNIT))) =
variables : (row : INT), (group_id : INT), (index : INT)
  let Ti465 : INT =
    int 0
  in
  if Ti465 <= row
    let ry : FLOAT =
      let Td468 : FLOAT =
        let Td466 : FLOAT =
          itof row
        in
        let Td467 : FLOAT =
          float 0.2
        in
        fmul Td466 Td467
      in
      let Td469 : FLOAT =
        float 0.9
      in
      fsub Td468 Td469
    in
    let Tu223 : UNIT =
      let Ti470 : INT =
        int 4
      in
      app
        calc_dirvecs
        Ti470
        ry
        group_id
        index
    in
    let Ti472 : INT =
      let Ti471 : INT =
        int 1
      in
      sub row Ti471
    in
    let Ti474 : INT =
      let Ti473 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti473
    in
    let Ti476 : INT =
      let Ti475 : INT =
        int 4
      in
      add index Ti475
    in
    app
      calc_dirvec_rows
      Ti472
      Ti474
      Ti476
    unit ()
in
letrec create_dirvec : (UNIT -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (Tu224 : UNIT)
  let v3 : Array of FLOAT =
    let Ti461 : INT =
      int 3
    in
    let Td462 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti461
      Td462
  in
  let consts : Array of Array of FLOAT =
    let Ti464 : INT =
      let Ti463 : INT =
        int 0
      in
      n_objects.(Ti463)
    in
    extfunapp
      create_array
      Ti464
      v3
  in
  Tuple
    v3
    consts
in
letrec create_dirvec_elements : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (d : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti456 : INT =
    int 0
  in
  if Ti456 <= index
    let Tu225 : UNIT =
      let Tt458 : (Array of FLOAT * Array of Array of FLOAT) =
        let Tu457 : UNIT =
          unit ()
        in
        app
          create_dirvec
          Tu457
      in
      d.(index) <- Tt458
    in
    let Ti460 : INT =
      let Ti459 : INT =
        int 1
      in
      sub index Ti459
    in
    app
      create_dirvec_elements
      d
      Ti460
    unit ()
in
letrec create_dirvecs : (INT -> UNIT) =
variables : (index : INT)
  let Ti447 : INT =
    int 0
  in
  if Ti447 <= index
    let Tu227 : UNIT =
      let Ta451 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti448 : INT =
          int 120
        in
        let Tt450 : (Array of FLOAT * Array of Array of FLOAT) =
          let Tu449 : UNIT =
            unit ()
          in
          app
            create_dirvec
            Tu449
        in
        extfunapp
          create_array
          Ti448
          Tt450
      in
      dirvecs.(index) <- Ta451
    in
    let Tu226 : UNIT =
      let Ta452 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti453 : INT =
        int 118
      in
      app
        create_dirvec_elements
        Ta452
        Ti453
    in
    let Ti455 : INT =
      let Ti454 : INT =
        int 1
      in
      sub index Ti454
    in
    app
      create_dirvecs
      Ti455
    unit ()
in
letrec init_dirvec_constants : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (vecset : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti443 : INT =
    int 0
  in
  if Ti443 <= index
    let Tu228 : UNIT =
      let Tt444 : (Array of FLOAT * Array of Array of FLOAT) =
        vecset.(index)
      in
      app
        setup_dirvec_constants
        Tt444
    in
    let Ti446 : INT =
      let Ti445 : INT =
        int 1
      in
      sub index Ti445
    in
    app
      init_dirvec_constants
      vecset
      Ti446
    unit ()
in
letrec init_vecset_constants : (INT -> UNIT) =
variables : (index : INT)
  let Ti438 : INT =
    int 0
  in
  if Ti438 <= index
    let Tu229 : UNIT =
      let Ta439 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti440 : INT =
        int 119
      in
      app
        init_dirvec_constants
        Ta439
        Ti440
    in
    let Ti442 : INT =
      let Ti441 : INT =
        int 1
      in
      sub index Ti441
    in
    app
      init_vecset_constants
      Ti442
    unit ()
in
letrec init_dirvecs : (UNIT -> UNIT) =
variables : (Tu230 : UNIT)
  let Tu232 : UNIT =
    let Ti433 : INT =
      int 4
    in
    app
      create_dirvecs
      Ti433
  in
  let Tu231 : UNIT =
    let Ti434 : INT =
      int 9
    in
    let Ti435 : INT =
      int 0
    in
    let Ti436 : INT =
      int 0
    in
    app
      calc_dirvec_rows
      Ti434
      Ti435
      Ti436
  in
  let Ti437 : INT =
    int 4
  in
  app
    init_vecset_constants
    Ti437
in
letrec add_reflection : (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (index : INT), (surface_id : INT), (bright : FLOAT), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let dvec : (Array of FLOAT * Array of Array of FLOAT) =
    let Tu430 : UNIT =
      unit ()
    in
    app
      create_dirvec
      Tu430
  in
  let Tu234 : UNIT =
    let Ta431 : Array of FLOAT =
      app
        d_vec
        dvec
    in
    app
      vecset
      Ta431
      v0
      v1
      v2
  in
  let Tu233 : UNIT =
    app
      setup_dirvec_constants
      dvec
  in
  let Tt432 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    Tuple
      surface_id
      dvec
      bright
  in
  reflections.(index) <- Tt432
in
letrec setup_rect_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    mul obj_id 4
  in
  let nr : INT =
    let Ti402 : INT =
      int 0
    in
    n_reflections.(Ti402)
  in
  let br : FLOAT =
    let Td403 : FLOAT =
      float 1.
    in
    let Td404 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td403 Td404
  in
  let n0 : FLOAT =
    let Td406 : FLOAT =
      let Ti405 : INT =
        int 0
      in
      light.(Ti405)
    in
    fneg Td406
  in
  let n1 : FLOAT =
    let Td408 : FLOAT =
      let Ti407 : INT =
        int 1
      in
      light.(Ti407)
    in
    fneg Td408
  in
  let n2 : FLOAT =
    let Td410 : FLOAT =
      let Ti409 : INT =
        int 2
      in
      light.(Ti409)
    in
    fneg Td410
  in
  let Tu237 : UNIT =
    let Ti412 : INT =
      let Ti411 : INT =
        int 1
      in
      add sid Ti411
    in
    let Td414 : FLOAT =
      let Ti413 : INT =
        int 0
      in
      light.(Ti413)
    in
    app
      add_reflection
      nr
      Ti412
      br
      Td414
      n1
      n2
  in
  let Tu236 : UNIT =
    let Ti416 : INT =
      let Ti415 : INT =
        int 1
      in
      add nr Ti415
    in
    let Ti418 : INT =
      let Ti417 : INT =
        int 2
      in
      add sid Ti417
    in
    let Td420 : FLOAT =
      let Ti419 : INT =
        int 1
      in
      light.(Ti419)
    in
    app
      add_reflection
      Ti416
      Ti418
      br
      n0
      Td420
      n2
  in
  let Tu235 : UNIT =
    let Ti422 : INT =
      let Ti421 : INT =
        int 2
      in
      add nr Ti421
    in
    let Ti424 : INT =
      let Ti423 : INT =
        int 3
      in
      add sid Ti423
    in
    let Td426 : FLOAT =
      let Ti425 : INT =
        int 2
      in
      light.(Ti425)
    in
    app
      add_reflection
      Ti422
      Ti424
      br
      n0
      n1
      Td426
  in
  let Ti427 : INT =
    int 0
  in
  let Ti429 : INT =
    let Ti428 : INT =
      int 3
    in
    add nr Ti428
  in
  n_reflections.(Ti427) <- Ti429
in
letrec setup_surface_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    let Ti372 : INT =
      mul obj_id 4
    in
    let Ti373 : INT =
      int 1
    in
    add Ti372 Ti373
  in
  let nr : INT =
    let Ti374 : INT =
      int 0
    in
    n_reflections.(Ti374)
  in
  let br : FLOAT =
    let Td375 : FLOAT =
      float 1.
    in
    let Td376 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td375 Td376
  in
  let p : FLOAT =
    let Ta377 : Array of FLOAT =
      app
        o_param_abc
        obj
    in
    app
      veciprod
      light
      Ta377
  in
  let Tu238 : UNIT =
    let Td384 : FLOAT =
      let Td381 : FLOAT =
        let Td380 : FLOAT =
          let Td378 : FLOAT =
            float 2.
          in
          let Td379 : FLOAT =
            app
              o_param_a
              obj
          in
          fmul Td378 Td379
        in
        fmul Td380 p
      in
      let Td383 : FLOAT =
        let Ti382 : INT =
          int 0
        in
        light.(Ti382)
      in
      fsub Td381 Td383
    in
    let Td391 : FLOAT =
      let Td388 : FLOAT =
        let Td387 : FLOAT =
          let Td385 : FLOAT =
            float 2.
          in
          let Td386 : FLOAT =
            app
              o_param_b
              obj
          in
          fmul Td385 Td386
        in
        fmul Td387 p
      in
      let Td390 : FLOAT =
        let Ti389 : INT =
          int 1
        in
        light.(Ti389)
      in
      fsub Td388 Td390
    in
    let Td398 : FLOAT =
      let Td395 : FLOAT =
        let Td394 : FLOAT =
          let Td392 : FLOAT =
            float 2.
          in
          let Td393 : FLOAT =
            app
              o_param_c
              obj
          in
          fmul Td392 Td393
        in
        fmul Td394 p
      in
      let Td397 : FLOAT =
        let Ti396 : INT =
          int 2
        in
        light.(Ti396)
      in
      fsub Td395 Td397
    in
    app
      add_reflection
      nr
      sid
      br
      Td384
      Td391
      Td398
  in
  let Ti399 : INT =
    int 0
  in
  let Ti401 : INT =
    let Ti400 : INT =
      int 1
    in
    add nr Ti400
  in
  n_reflections.(Ti399) <- Ti401
in
letrec setup_reflections : (INT -> UNIT) =
variables : (obj_id : INT)
  let Ti363 : INT =
    int 0
  in
  if Ti363 <= obj_id
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(obj_id)
    in
    let Ti364 : INT =
      app
        o_reflectiontype
        obj
    in
    let Ti365 : INT =
      int 2
    in
    if Ti364 == Ti365
      let Tb368 : BOOL =
        let Td366 : FLOAT =
          app
            o_diffuse
            obj
        in
        let Td367 : FLOAT =
          float 1.
        in
        app
          fless
          Td366
          Td367
      in
      let Ti369 : INT =
        int 0
      in
      if Tb368 == Ti369
        unit ()
        let m_shape : INT =
          app
            o_form
            obj
        in
        let Ti370 : INT =
          int 1
        in
        if m_shape == Ti370
          app
            setup_rect_reflection
            obj_id
            obj
          let Ti371 : INT =
            int 2
          in
          if m_shape == Ti371
            app
              setup_surface_reflection
              obj_id
              obj
            unit ()
      unit ()
    unit ()
in
letrec rt : (INT -> (INT -> UNIT)) =
variables : (size_x : INT), (size_y : INT)
  let Tu250 : UNIT =
    let Ti338 : INT =
      int 0
    in
    image_size.(Ti338) <- size_x
  in
  let Tu249 : UNIT =
    let Ti339 : INT =
      int 1
    in
    image_size.(Ti339) <- size_y
  in
  let Tu248 : UNIT =
    let Ti340 : INT =
      int 0
    in
    let Ti341 : INT =
      div size_x 2
    in
    image_center.(Ti340) <- Ti341
  in
  let Tu247 : UNIT =
    let Ti342 : INT =
      int 1
    in
    let Ti343 : INT =
      div size_y 2
    in
    image_center.(Ti342) <- Ti343
  in
  let Tu246 : UNIT =
    let Ti344 : INT =
      int 0
    in
    let Td347 : FLOAT =
      let Td345 : FLOAT =
        float 128.
      in
      let Td346 : FLOAT =
        itof size_x
      in
      fdiv Td345 Td346
    in
    scan_pitch.(Ti344) <- Td347
  in
  let prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu348 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu348
  in
  let cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu349 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu349
  in
  let next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu350 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu350
  in
  let Tu245 : UNIT =
    let Tu351 : UNIT =
      unit ()
    in
    app
      read_parameter
      Tu351
  in
  let Tu244 : UNIT =
    let Tu352 : UNIT =
      unit ()
    in
    app
      write_ppm_header
      Tu352
  in
  let Tu243 : UNIT =
    let Tu353 : UNIT =
      unit ()
    in
    app
      init_dirvecs
      Tu353
  in
  let Tu242 : UNIT =
    let Ta354 : Array of FLOAT =
      app
        d_vec
        light_dirvec
    in
    app
      veccpy
      Ta354
      light
  in
  let Tu241 : UNIT =
    app
      setup_dirvec_constants
      light_dirvec
  in
  let Tu240 : UNIT =
    let Ti358 : INT =
      let Ti356 : INT =
        let Ti355 : INT =
          int 0
        in
        n_objects.(Ti355)
      in
      let Ti357 : INT =
        int 1
      in
      sub Ti356 Ti357
    in
    app
      setup_reflections
      Ti358
  in
  let Tu239 : UNIT =
    let Ti359 : INT =
      int 0
    in
    let Ti360 : INT =
      int 0
    in
    app
      pretrace_line
      cur
      Ti359
      Ti360
  in
  let Ti361 : INT =
    int 0
  in
  let Ti362 : INT =
    int 2
  in
  app
    scan_line
    Ti361
    prev
    cur
    next
    Ti362
in
let a : UNIT =
  let Ti336 : INT =
    int 512
  in
  let Ti337 : INT =
    int 512
  in
  app
    rt
    Ti336
    Ti337
in
unit ()
