----- syntax.print -----
LETREC finv (VAR of )
  (x : VAR of )
  IF
    FZero?
      VAR x
    VAR x
    LET t (VAR of )
      UNKNOWN APP        finv_init
        VAR x
    LET two (VAR of )
      FLOAT 2.
    LET t (VAR of )
      FMUL
        VAR t
        FSUB
          VAR two
          FMUL
            VAR x
            VAR t
    LET t (VAR of )
      FMUL
        VAR t
        FSUB
          VAR two
          FMUL
            VAR x
            VAR t
    LET t (VAR of )
      FMUL
        VAR t
        FSUB
          VAR two
          FMUL
            VAR x
            VAR t
    LET t (VAR of )
      FMUL
        VAR t
        FSUB
          VAR two
          FMUL
            VAR x
            VAR t
    LET t (VAR of )
      FMUL
        VAR t
        FSUB
          VAR two
          FMUL
            VAR x
            VAR t
    VAR t
LETREC fdiv (VAR of )
  (x : VAR of ), (y : VAR of )
  FMUL
    VAR x
    APP
      VAR finv
      VAR y
LETREC print_int (VAR of )
  (n : VAR of )
  LET n (VAR of )
    IF
      NOT
        LE
          INT 0
          VAR n
      LET Tu1 (UNIT)
        OUT
          INT 45        0
      NEG
        VAR n
      VAR n
  IF
    NOT
      LE
        INT 10
        VAR n
    OUT
      VAR n    48
    LET m (VAR of )
      DIVIDE BY 10
        VAR n
    LET Tu2 (UNIT)
      APP
        VAR print_int
        VAR m
    OUT
      SUB
        VAR n
        MULTIPLE 10
          VAR m    48
LETREC print_newline (VAR of )
  (Tu3 : VAR of )
  OUT
    INT 0  10
LETREC reduction_2pi_sub1 (VAR of )
  (v : VAR of )
  IF
    FLt
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
    UNIT
    LET Tu4 (UNIT)
      PUT
        VAR v
        INT 1
        FMUL
          GET
            VAR v
            INT 1
          FLOAT 2.
    APP
      VAR reduction_2pi_sub1
      VAR v
LETREC reduction_2pi_sub2 (VAR of )
  (v : VAR of )
  IF
    FLt
      FLOAT 6.28318530718
      GET
        VAR v
        INT 0
    LET Tu6 (UNIT)
      IF
        FLt
          GET
            VAR v
            INT 1
          GET
            VAR v
            INT 0
        PUT
          VAR v
          INT 0
          FSUB
            GET
              VAR v
              INT 0
            GET
              VAR v
              INT 1
        UNIT
    LET Tu5 (UNIT)
      PUT
        VAR v
        INT 1
        APP
          VAR fdiv
          GET
            VAR v
            INT 1
          FLOAT 2.
    APP
      VAR reduction_2pi_sub2
      VAR v
    UNIT
LETREC reduction_2pi (VAR of )
  (v : VAR of )
  LET Tu8 (UNIT)
    PUT
      VAR v
      INT 1
      FLOAT 6.28318530718
  LET Tu7 (UNIT)
    APP
      VAR reduction_2pi_sub1
      VAR v
  APP
    VAR reduction_2pi_sub2
    VAR v
LETREC kernel_sin (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a
  LET a5 (VAR of )
    FMUL
      VAR a3
      VAR a2
  LET a7 (VAR of )
    FMUL
      VAR a5
      VAR a2
  FSUB
    FADD
      FSUB
        VAR a
        FMUL
          FLOAT 0.16666668
          VAR a3
      FMUL
        FLOAT 0.008332824
        VAR a5
    FMUL
      FLOAT 0.00019587841
      VAR a7
LETREC kernel_cos (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a4 (VAR of )
    FMUL
      VAR a2
      VAR a2
  LET a6 (VAR of )
    FMUL
      VAR a4
      VAR a2
  FSUB
    FADD
      FSUB
        FLOAT 1.
        FMUL
          FLOAT 0.5
          VAR a2
      FMUL
        FLOAT 0.04166368
        VAR a4
    FMUL
      FLOAT 0.0013695068
      VAR a6
LETREC sin (VAR of )
  (a : VAR of )
  LET v (VAR of )
    ARRAY
      INT 3
      VAR a
  LET Tu13 (UNIT)
    IF
      FLt
        VAR a
        FLOAT 0.
      PUT
        VAR v
        INT 0
        NEG
          VAR a
      UNIT
  LET Tu12 (UNIT)
    APP
      VAR reduction_2pi
      VAR v
  LET Tu11 (UNIT)
    IF
      FLt
        FLOAT 3.14159265359
        GET
          VAR v
          INT 0
      LET Tu9 (UNIT)
        PUT
          VAR v
          INT 0
          FSUB
            GET
              VAR v
              INT 0
            FLOAT 3.14159265359
      PUT
        VAR v
        INT 2
        NEG
          GET
            VAR v
            INT 2
      UNIT
  LET Tu10 (UNIT)
    IF
      FLt
        FLOAT 1.57079632679
        GET
          VAR v
          INT 0
      PUT
        VAR v
        INT 0
        FSUB
          FLOAT 3.14159265359
          GET
            VAR v
            INT 0
      UNIT
  LET x (VAR of )
    IF
      FLt
        FLOAT 0.785398163397
        GET
          VAR v
          INT 0
      APP
        VAR kernel_cos
        FSUB
          FLOAT 1.57079632679
          GET
            VAR v
            INT 0
      APP
        VAR kernel_sin
        GET
          VAR v
          INT 0
  IF
    FLt
      GET
        VAR v
        INT 2
      FLOAT 0.
    NEG
      VAR x
    VAR x
LETREC cos (VAR of )
  (a : VAR of )
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      VAR a
  LET v (VAR of )
    ARRAY
      INT 3
      VAR a
  LET Tu18 (UNIT)
    APP
      VAR reduction_2pi
      VAR v
  LET Tu17 (UNIT)
    IF
      FLt
        FLOAT 3.14159265359
        GET
          VAR v
          INT 0
      LET Tu14 (UNIT)
        PUT
          VAR v
          INT 0
          FSUB
            GET
              VAR v
              INT 0
            FLOAT 3.14159265359
      PUT
        VAR v
        INT 2
        FLOAT -1.
      UNIT
  LET Tu16 (UNIT)
    IF
      FLt
        FLOAT 1.57079632679
        GET
          VAR v
          INT 0
      LET Tu15 (UNIT)
        PUT
          VAR v
          INT 0
          FSUB
            FLOAT 3.14159265359
            GET
              VAR v
              INT 0
      PUT
        VAR v
        INT 2
        NEG
          GET
            VAR v
            INT 2
      UNIT
  LET x (VAR of )
    IF
      FLt
        GET
          VAR v
          INT 0
        FLOAT 0.785398163397
      APP
        VAR kernel_cos
        GET
          VAR v
          INT 0
      APP
        VAR kernel_sin
        FSUB
          FLOAT 1.57079632679
          GET
            VAR v
            INT 0
  IF
    FLt
      GET
        VAR v
        INT 2
      FLOAT 0.
    NEG
      VAR x
    VAR x
LETREC sqrt (VAR of )
  (x : VAR of )
  IF
    FLt
      FLOAT 0.
      VAR x
    LET t (VAR of )
      UNKNOWN APP        sqrt_init
        VAR x
    LET t (VAR of )
      APP
        VAR fdiv
        FADD
          FMUL
            VAR t
            VAR t
          VAR x
        FADD
          VAR t
          VAR t
    LET t (VAR of )
      APP
        VAR fdiv
        FADD
          FMUL
            VAR t
            VAR t
          VAR x
        FADD
          VAR t
          VAR t
    LET t (VAR of )
      APP
        VAR fdiv
        FADD
          FMUL
            VAR t
            VAR t
          VAR x
        FADD
          VAR t
          VAR t
    LET t (VAR of )
      APP
        VAR fdiv
        FADD
          FMUL
            VAR t
            VAR t
          VAR x
        FADD
          VAR t
          VAR t
    VAR t
    FLOAT 0.
LETREC kernel_atan (VAR of )
  (a1 : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a1
      VAR a1
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a1
  LET a5 (VAR of )
    FMUL
      VAR a2
      VAR a3
  LET a7 (VAR of )
    FMUL
      VAR a2
      VAR a5
  LET a9 (VAR of )
    FMUL
      VAR a2
      VAR a7
  LET a11 (VAR of )
    FMUL
      VAR a2
      VAR a9
  LET a13 (VAR of )
    FMUL
      VAR a2
      VAR a11
  FADD
    FSUB
      FADD
        FSUB
          FADD
            FSUB
              VAR a1
              FMUL
                FLOAT 0.3333333
                VAR a3
            FMUL
              FLOAT 0.2
              VAR a5
          FMUL
            FLOAT 0.142857142
            VAR a7
        FMUL
          FLOAT 0.111111104
          VAR a9
      FMUL
        FLOAT 0.08976446
        VAR a11
    FMUL
      FLOAT 0.060035485
      VAR a13
LETREC atan (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      VAR flag
      VAR a
      NEG
        VAR a
  LET b (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.4375
      APP
        VAR kernel_atan
        VAR a
      IF
        FLt
          VAR a
          FLOAT 2.4375
        FADD
          FLOAT 0.785398163397
          APP
            VAR kernel_atan
            APP
              VAR fdiv
              FSUB
                VAR a
                FLOAT 1.
              FADD
                VAR a
                FLOAT 1.
        FSUB
          FLOAT 1.57079632679
          APP
            VAR kernel_atan
            APP
              VAR fdiv
              FLOAT 1.
              VAR a
  IF
    VAR flag
    VAR b
    NEG
      VAR b
LETREC floor (VAR of )
  (x : VAR of )
  LET a (VAR of )
    int_to_float
      float_to_int
        VAR x
  IF
    FLt
      VAR x
      VAR a
    FSUB
      VAR a
      FLOAT 1.
    VAR a
LETREC fabs (VAR of )
  (f : VAR of )
  IF
    FLt
      VAR f
      FLOAT 0.
    NEG
      VAR f
    VAR f
LETREC fhalf (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.5
LETREC fneg (VAR of )
  (x : VAR of )
  NEG
    VAR x
LETREC abs_float (VAR of )
  (x : VAR of )
  APP
    VAR fabs
    VAR x
LETREC fispos (VAR of )
  (x : VAR of )
  FLt
    FLOAT 0.
    VAR x
LETREC fisneg (VAR of )
  (x : VAR of )
  FLt
    VAR x
    FLOAT 0.
LET n_objects (VAR of )
  ARRAY
    INT 1
    INT 0
LET objects (VAR of )
  LET dummy (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  ARRAY
    INT 60
    TUPLE
      INT 0
      INT 0
      INT 0
      INT 0
      VAR dummy
      VAR dummy
      BOOL false
      VAR dummy
      VAR dummy
      VAR dummy
      VAR dummy
LET screen (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET viewpoint (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET light (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET beam (VAR of )
  ARRAY
    INT 1
    FLOAT 255.
LET and_net (VAR of )
  ARRAY
    INT 50
    ARRAY
      INT 1
      NEG
        INT 1
LET or_net (VAR of )
  ARRAY
    INT 1
    ARRAY
      INT 1
      GET
        VAR and_net
        INT 0
LET solver_dist (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET intsec_rectside (VAR of )
  ARRAY
    INT 1
    INT 0
LET tmin (VAR of )
  ARRAY
    INT 1
    FLOAT 1000000000.
LET intersection_point (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET intersected_object_id (VAR of )
  ARRAY
    INT 1
    INT 0
LET nvector (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET texture_color (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET diffuse_ray (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET rgb (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET image_size (VAR of )
  ARRAY
    INT 2
    INT 0
LET image_center (VAR of )
  ARRAY
    INT 2
    INT 0
LET scan_pitch (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET startp (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET startp_fast (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenx_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screeny_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenz_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET ptrace_dirvec (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET dirvecs (VAR of )
  LET dummyf (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff (VAR of )
    ARRAY
      INT 0
      VAR dummyf
  LET dummy_vs (VAR of )
    ARRAY
      INT 0
      TUPLE
        VAR dummyf
        VAR dummyff
  ARRAY
    INT 5
    VAR dummy_vs
LET light_dirvec (VAR of )
  LET dummyf2 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      INT 60
      VAR dummyf2
  TUPLE
    VAR v3
    VAR consts
LET reflections (VAR of )
  LET dummyf3 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff3 (VAR of )
    ARRAY
      INT 0
      VAR dummyf3
  LET dummydv (VAR of )
    TUPLE
      VAR dummyf3
      VAR dummyff3
  ARRAY
    INT 180
    TUPLE
      INT 0
      VAR dummydv
      FLOAT 0.
LET n_reflections (VAR of )
  ARRAY
    INT 1
    INT 0
LETREC xor (VAR of )
  (x : VAR of ), (y : VAR of )
  IF
    VAR x
    NOT
      VAR y
    VAR y
LETREC sgn (VAR of )
  (x : VAR of )
  IF
    FZero?
      VAR x
    FLOAT 0.
    IF
      APP
        VAR fispos
        VAR x
      FLOAT 1.
      FLOAT -1.
LETREC fneg_cond (VAR of )
  (cond : VAR of ), (x : VAR of )
  IF
    VAR cond
    VAR x
    APP
      VAR fneg
      VAR x
LETREC add_mod5 (VAR of )
  (x : VAR of ), (y : VAR of )
  LET sum (VAR of )
    ADD
      VAR x
      VAR y
  IF
    LE
      INT 5
      VAR sum
    SUB
      VAR sum
      INT 5
    VAR sum
LETREC vecset (VAR of )
  (v : VAR of ), (x : VAR of ), (y : VAR of ), (z : VAR of )
  LET Tu20 (UNIT)
    PUT
      VAR v
      INT 0
      VAR x
  LET Tu19 (UNIT)
    PUT
      VAR v
      INT 1
      VAR y
  PUT
    VAR v
    INT 2
    VAR z
LETREC vecfill (VAR of )
  (v : VAR of ), (elem : VAR of )
  LET Tu22 (UNIT)
    PUT
      VAR v
      INT 0
      VAR elem
  LET Tu21 (UNIT)
    PUT
      VAR v
      INT 1
      VAR elem
  PUT
    VAR v
    INT 2
    VAR elem
LETREC vecbzero (VAR of )
  (v : VAR of )
  APP
    VAR vecfill
    VAR v
    FLOAT 0.
LETREC veccpy (VAR of )
  (dest : VAR of ), (src : VAR of )
  LET Tu24 (UNIT)
    PUT
      VAR dest
      INT 0
      GET
        VAR src
        INT 0
  LET Tu23 (UNIT)
    PUT
      VAR dest
      INT 1
      GET
        VAR src
        INT 1
  PUT
    VAR dest
    INT 2
    GET
      VAR src
      INT 2
LETREC vecdist2 (VAR of )
  (p : VAR of ), (q : VAR of )
  FADD
    FADD
      UNKNOWN APP        fsqr
        FSUB
          GET
            VAR p
            INT 0
          GET
            VAR q
            INT 0
      UNKNOWN APP        fsqr
        FSUB
          GET
            VAR p
            INT 1
          GET
            VAR q
            INT 1
    UNKNOWN APP      fsqr
      FSUB
        GET
          VAR p
          INT 2
        GET
          VAR q
          INT 2
LETREC vecunit (VAR of )
  (v : VAR of )
  LET il (VAR of )
    APP
      VAR fdiv
      FLOAT 1.
      APP
        VAR sqrt
        FADD
          FADD
            UNKNOWN APP              fsqr
              GET
                VAR v
                INT 0
            UNKNOWN APP              fsqr
              GET
                VAR v
                INT 1
          UNKNOWN APP            fsqr
            GET
              VAR v
              INT 2
  LET Tu26 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu25 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC vecunit_sgn (VAR of )
  (v : VAR of ), (inv : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FADD
          UNKNOWN APP            fsqr
            GET
              VAR v
              INT 0
          UNKNOWN APP            fsqr
            GET
              VAR v
              INT 1
        UNKNOWN APP          fsqr
          GET
            VAR v
            INT 2
  LET il (VAR of )
    IF
      FZero?
        VAR l
      FLOAT 1.
      IF
        VAR inv
        APP
          VAR fdiv
          FLOAT -1.
          VAR l
        APP
          VAR fdiv
          FLOAT 1.
          VAR l
  LET Tu28 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu27 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC veciprod (VAR of )
  (v : VAR of ), (w : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        GET
          VAR w
          INT 0
      FMUL
        GET
          VAR v
          INT 1
        GET
          VAR w
          INT 1
    FMUL
      GET
        VAR v
        INT 2
      GET
        VAR w
        INT 2
LETREC veciprod2 (VAR of )
  (v : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        VAR w0
      FMUL
        GET
          VAR v
          INT 1
        VAR w1
    FMUL
      GET
        VAR v
        INT 2
      VAR w2
LETREC vecaccum (VAR of )
  (dest : VAR of ), (scale : VAR of ), (v : VAR of )
  LET Tu30 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          VAR scale
          GET
            VAR v
            INT 0
  LET Tu29 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          VAR scale
          GET
            VAR v
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        VAR scale
        GET
          VAR v
          INT 2
LETREC vecadd (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu32 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu31 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecmul (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu34 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu33 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecscale (VAR of )
  (dest : VAR of ), (scale : VAR of )
  LET Tu36 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        VAR scale
  LET Tu35 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        VAR scale
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      VAR scale
LETREC vecaccumv (VAR of )
  (dest : VAR of ), (v : VAR of ), (w : VAR of )
  LET Tu38 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          GET
            VAR v
            INT 0
          GET
            VAR w
            INT 0
  LET Tu37 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          GET
            VAR v
            INT 1
          GET
            VAR w
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        GET
          VAR v
          INT 2
        GET
          VAR w
          INT 2
LETREC o_texturetype (VAR of )
  (m : VAR of )
  (m_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_tex
LETREC o_form (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (m_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_shape
LETREC o_reflectiontype (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_surface
LETREC o_isinvert (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (m_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_invert
LETREC o_isrot (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (m_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_isrot
LETREC o_param_a (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 0
LETREC o_param_b (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 1
LETREC o_param_c (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 2
LETREC o_param_abc (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_abc
LETREC o_param_x (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 0
LETREC o_param_y (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 1
LETREC o_param_z (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 2
LETREC o_diffuse (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 0
LETREC o_hilight (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 1
LETREC o_color_red (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 0
LETREC o_color_green (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 1
LETREC o_color_blue (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 2
LETREC o_param_r1 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 0
LETREC o_param_r2 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 1
LETREC o_param_r3 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 2
LETREC o_param_ctbl (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (m_ctbl : VAR of )
    VAR m
    VAR m_ctbl
LETREC p_rgb (VAR of )
  (pixel : VAR of )
  (m_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_rgb
LETREC p_intersection_points (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (m_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_isect_ps
LETREC p_surface_ids (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (m_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_sids
LETREC p_calc_diffuse (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (m_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_cdif
LETREC p_energy (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (m_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_engy
LETREC p_received_ray_20percent (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (m_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_r20p
LETREC p_group_id (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    GET
      VAR m_gid
      INT 0
LETREC p_set_group_id (VAR of )
  (pixel : VAR of ), (id : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    PUT
      VAR m_gid
      INT 0
      VAR id
LETREC p_nvectors (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (m_nvectors : VAR of )
    VAR pixel
    VAR m_nvectors
LETREC d_vec (VAR of )
  (d : VAR of )
  (m_vec : VAR of ), (xm_const : VAR of )
    VAR d
    VAR m_vec
LETREC d_const (VAR of )
  (d : VAR of )
  (dm_vec : VAR of ), (m_const : VAR of )
    VAR d
    VAR m_const
LETREC r_surface_id (VAR of )
  (r : VAR of )
  (m_sid : VAR of ), (xm_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_sid
LETREC r_dvec (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (m_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_dvec
LETREC r_bright (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (xm_dvec : VAR of ), (m_br : VAR of )
    VAR r
    VAR m_br
LETREC rad (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.017453293
LETREC read_screen_settings (VAR of )
  (Tu39 : VAR of )
  LET Tu53 (UNIT)
    PUT
      VAR screen
      INT 0
      UNKNOWN APP        inflt
        UNIT
  LET Tu52 (UNIT)
    PUT
      VAR screen
      INT 1
      UNKNOWN APP        inflt
        UNIT
  LET Tu51 (UNIT)
    PUT
      VAR screen
      INT 2
      UNKNOWN APP        inflt
        UNIT
  LET v1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v1 (VAR of )
    APP
      VAR cos
      VAR v1
  LET sin_v1 (VAR of )
    APP
      VAR sin
      VAR v1
  LET v2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v2 (VAR of )
    APP
      VAR cos
      VAR v2
  LET sin_v2 (VAR of )
    APP
      VAR sin
      VAR v2
  LET Tu50 (UNIT)
    PUT
      VAR screenz_dir
      INT 0
      FMUL
        FMUL
          VAR cos_v1
          VAR sin_v2
        FLOAT 200.
  LET Tu49 (UNIT)
    PUT
      VAR screenz_dir
      INT 1
      FMUL
        VAR sin_v1
        FLOAT -200.
  LET Tu48 (UNIT)
    PUT
      VAR screenz_dir
      INT 2
      FMUL
        FMUL
          VAR cos_v1
          VAR cos_v2
        FLOAT 200.
  LET Tu47 (UNIT)
    PUT
      VAR screenx_dir
      INT 0
      VAR cos_v2
  LET Tu46 (UNIT)
    PUT
      VAR screenx_dir
      INT 1
      FLOAT 0.
  LET Tu45 (UNIT)
    PUT
      VAR screenx_dir
      INT 2
      APP
        VAR fneg
        VAR sin_v2
  LET Tu44 (UNIT)
    PUT
      VAR screeny_dir
      INT 0
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR sin_v2
  LET Tu43 (UNIT)
    PUT
      VAR screeny_dir
      INT 1
      APP
        VAR fneg
        VAR cos_v1
  LET Tu42 (UNIT)
    PUT
      VAR screeny_dir
      INT 2
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR cos_v2
  LET Tu41 (UNIT)
    PUT
      VAR viewpoint
      INT 0
      FSUB
        GET
          VAR screen
          INT 0
        GET
          VAR screenz_dir
          INT 0
  LET Tu40 (UNIT)
    PUT
      VAR viewpoint
      INT 1
      FSUB
        GET
          VAR screen
          INT 1
        GET
          VAR screenz_dir
          INT 1
  PUT
    VAR viewpoint
    INT 2
    FSUB
      GET
        VAR screen
        INT 2
      GET
        VAR screenz_dir
        INT 2
LETREC read_light (VAR of )
  (Tu54 : VAR of )
  LET nl (VAR of )
    UNKNOWN APP      inint
      UNIT
  LET l1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET sl1 (VAR of )
    APP
      VAR sin
      VAR l1
  LET Tu57 (UNIT)
    PUT
      VAR light
      INT 1
      APP
        VAR fneg
        VAR sl1
  LET l2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cl1 (VAR of )
    APP
      VAR cos
      VAR l1
  LET sl2 (VAR of )
    APP
      VAR sin
      VAR l2
  LET Tu56 (UNIT)
    PUT
      VAR light
      INT 0
      FMUL
        VAR cl1
        VAR sl2
  LET cl2 (VAR of )
    APP
      VAR cos
      VAR l2
  LET Tu55 (UNIT)
    PUT
      VAR light
      INT 2
      FMUL
        VAR cl1
        VAR cl2
  PUT
    VAR beam
    INT 0
    UNKNOWN APP      inflt
      UNIT
LETREC rotate_quadratic_matrix (VAR of )
  (abc : VAR of ), (rot : VAR of )
  LET cos_x (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 0
  LET sin_x (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 0
  LET cos_y (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 1
  LET sin_y (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 1
  LET cos_z (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 2
  LET sin_z (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 2
  LET m00 (VAR of )
    FMUL
      VAR cos_y
      VAR cos_z
  LET m01 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR cos_x
        VAR sin_z
  LET m02 (VAR of )
    FADD
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR sin_x
        VAR sin_z
  LET m10 (VAR of )
    FMUL
      VAR cos_y
      VAR sin_z
  LET m11 (VAR of )
    FADD
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR cos_x
        VAR cos_z
  LET m12 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR sin_x
        VAR cos_z
  LET m20 (VAR of )
    APP
      VAR fneg
      VAR sin_y
  LET m21 (VAR of )
    FMUL
      VAR sin_x
      VAR cos_y
  LET m22 (VAR of )
    FMUL
      VAR cos_x
      VAR cos_y
  LET ao (VAR of )
    GET
      VAR abc
      INT 0
  LET bo (VAR of )
    GET
      VAR abc
      INT 1
  LET co (VAR of )
    GET
      VAR abc
      INT 2
  LET Tu62 (UNIT)
    PUT
      VAR abc
      INT 0
      FADD
        FADD
          FMUL
            VAR ao
            UNKNOWN APP              fsqr
              VAR m00
          FMUL
            VAR bo
            UNKNOWN APP              fsqr
              VAR m10
        FMUL
          VAR co
          UNKNOWN APP            fsqr
            VAR m20
  LET Tu61 (UNIT)
    PUT
      VAR abc
      INT 1
      FADD
        FADD
          FMUL
            VAR ao
            UNKNOWN APP              fsqr
              VAR m01
          FMUL
            VAR bo
            UNKNOWN APP              fsqr
              VAR m11
        FMUL
          VAR co
          UNKNOWN APP            fsqr
            VAR m21
  LET Tu60 (UNIT)
    PUT
      VAR abc
      INT 2
      FADD
        FADD
          FMUL
            VAR ao
            UNKNOWN APP              fsqr
              VAR m02
          FMUL
            VAR bo
            UNKNOWN APP              fsqr
              VAR m12
        FMUL
          VAR co
          UNKNOWN APP            fsqr
            VAR m22
  LET Tu59 (UNIT)
    PUT
      VAR rot
      INT 0
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m01
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m11
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m21
            VAR m22
  LET Tu58 (UNIT)
    PUT
      VAR rot
      INT 1
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m00
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m10
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m20
            VAR m22
  PUT
    VAR rot
    INT 2
    FMUL
      FLOAT 2.
      FADD
        FADD
          FMUL
            FMUL
              VAR ao
              VAR m00
            VAR m01
          FMUL
            FMUL
              VAR bo
              VAR m10
            VAR m11
        FMUL
          FMUL
            VAR co
            VAR m20
          VAR m21
LETREC read_nth_object (VAR of )
  (n : VAR of )
  LET texture (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    NOT
      EQ
        VAR texture
        NEG
          INT 1
    LET form (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET refltype (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET isrot_p (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET abc (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu81 (UNIT)
      PUT
        VAR abc
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu80 (UNIT)
      PUT
        VAR abc
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu79 (UNIT)
      PUT
        VAR abc
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET xyz (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu78 (UNIT)
      PUT
        VAR xyz
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu77 (UNIT)
      PUT
        VAR xyz
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu76 (UNIT)
      PUT
        VAR xyz
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET m_invert (VAR of )
      APP
        VAR fisneg
        UNKNOWN APP          inflt
          UNIT
    LET reflparam (VAR of )
      ARRAY
        INT 2
        FLOAT 0.
    LET Tu75 (UNIT)
      PUT
        VAR reflparam
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu74 (UNIT)
      PUT
        VAR reflparam
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET color (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu73 (UNIT)
      PUT
        VAR color
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu72 (UNIT)
      PUT
        VAR color
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu71 (UNIT)
      PUT
        VAR color
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET rotation (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu70 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        LET Tu64 (UNIT)
          PUT
            VAR rotation
            INT 0
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        LET Tu63 (UNIT)
          PUT
            VAR rotation
            INT 1
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        PUT
          VAR rotation
          INT 2
          APP
            VAR rad
            UNKNOWN APP              inflt
              UNIT
        UNIT
    LET m_invert2 (VAR of )
      IF
        EQ
          VAR form
          INT 2
        BOOL true
        VAR m_invert
    LET ctbl (VAR of )
      ARRAY
        INT 4
        FLOAT 0.
    LET obj (VAR of )
      TUPLE
        VAR texture
        VAR form
        VAR refltype
        VAR isrot_p
        VAR abc
        VAR xyz
        VAR m_invert2
        VAR reflparam
        VAR color
        VAR rotation
        VAR ctbl
    LET Tu69 (UNIT)
      PUT
        VAR objects
        VAR n
        VAR obj
    LET Tu68 (UNIT)
      IF
        EQ
          VAR form
          INT 3
        LET a (VAR of )
          GET
            VAR abc
            INT 0
        LET Tu66 (UNIT)
          PUT
            VAR abc
            INT 0
            IF
              FZero?
                VAR a
              FLOAT 0.
              APP
                VAR fdiv
                APP
                  VAR sgn
                  VAR a
                UNKNOWN APP                  fsqr
                  VAR a
        LET b (VAR of )
          GET
            VAR abc
            INT 1
        LET Tu65 (UNIT)
          PUT
            VAR abc
            INT 1
            IF
              FZero?
                VAR b
              FLOAT 0.
              APP
                VAR fdiv
                APP
                  VAR sgn
                  VAR b
                UNKNOWN APP                  fsqr
                  VAR b
        LET c (VAR of )
          GET
            VAR abc
            INT 2
        PUT
          VAR abc
          INT 2
          IF
            FZero?
              VAR c
            FLOAT 0.
            APP
              VAR fdiv
              APP
                VAR sgn
                VAR c
              UNKNOWN APP                fsqr
                VAR c
        IF
          EQ
            VAR form
            INT 2
          APP
            VAR vecunit_sgn
            VAR abc
            NOT
              VAR m_invert
          UNIT
    LET Tu67 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        APP
          VAR rotate_quadratic_matrix
          VAR abc
          VAR rotation
        UNIT
    BOOL true
    BOOL false
LETREC read_object (VAR of )
  (n : VAR of )
  IF
    NOT
      LE
        INT 60
        VAR n
    IF
      APP
        VAR read_nth_object
        VAR n
      APP
        VAR read_object
        ADD
          VAR n
          INT 1
      PUT
        VAR n_objects
        INT 0
        VAR n
    UNIT
LETREC read_all_object (VAR of )
  (Tu82 : VAR of )
  APP
    VAR read_object
    INT 0
LETREC read_net_item (VAR of )
  (length : VAR of )
  LET item (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    EQ
      VAR item
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      NEG
        INT 1
    LET v (VAR of )
      APP
        VAR read_net_item
        ADD
          VAR length
          INT 1
    LET Tu83 (UNIT)
      PUT
        VAR v
        VAR length
        VAR item
    VAR v
LETREC read_or_network (VAR of )
  (length : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      VAR net
    LET v (VAR of )
      APP
        VAR read_or_network
        ADD
          VAR length
          INT 1
    LET Tu84 (UNIT)
      PUT
        VAR v
        VAR length
        VAR net
    VAR v
LETREC read_and_network (VAR of )
  (n : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    UNIT
    LET Tu85 (UNIT)
      PUT
        VAR and_net
        VAR n
        VAR net
    APP
      VAR read_and_network
      ADD
        VAR n
        INT 1
LETREC read_parameter (VAR of )
  (Tu86 : VAR of )
  LET Tu90 (UNIT)
    APP
      VAR read_screen_settings
      UNIT
  LET Tu89 (UNIT)
    APP
      VAR read_light
      UNIT
  LET Tu88 (UNIT)
    APP
      VAR read_all_object
      UNIT
  LET Tu87 (UNIT)
    APP
      VAR read_and_network
      INT 0
  PUT
    VAR or_net
    INT 0
    APP
      VAR read_or_network
      INT 0
LETREC solver_rect_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of ), (i0 : VAR of ), (i1 : VAR of ), (i2 : VAR of )
  IF
    FZero?
      GET
        VAR dirvec
        VAR i0
    BOOL false
    LET abc (VAR of )
      APP
        VAR o_param_abc
        VAR m
    LET d (VAR of )
      APP
        VAR fneg_cond
        APP
          VAR xor
          APP
            VAR o_isinvert
            VAR m
          APP
            VAR fisneg
            GET
              VAR dirvec
              VAR i0
        GET
          VAR abc
          VAR i0
    LET d2 (VAR of )
      APP
        VAR fdiv
        FSUB
          VAR d
          VAR b0
        GET
          VAR dirvec
          VAR i0
    IF
      FLt
        APP
          VAR fabs
          FADD
            FMUL
              VAR d2
              GET
                VAR dirvec
                VAR i1
            VAR b1
        GET
          VAR abc
          VAR i1
      IF
        FLt
          APP
            VAR fabs
            FADD
              FMUL
                VAR d2
                GET
                  VAR dirvec
                  VAR i2
              VAR b2
          GET
            VAR abc
            VAR i2
        LET Tu91 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        BOOL true
        BOOL false
      BOOL false
LETREC solver_rect (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR solver_rect_surface
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
      INT 0
      INT 1
      INT 2
    INT 1
    IF
      APP
        VAR solver_rect_surface
        VAR m
        VAR dirvec
        VAR b1
        VAR b2
        VAR b0
        INT 1
        INT 2
        INT 0
      INT 2
      IF
        APP
          VAR solver_rect_surface
          VAR m
          VAR dirvec
          VAR b2
          VAR b0
          VAR b1
          INT 2
          INT 0
          INT 1
        INT 3
        INT 0
LETREC solver_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET abc (VAR of )
    APP
      VAR o_param_abc
      VAR m
  LET d (VAR of )
    APP
      VAR veciprod
      VAR dirvec
      VAR abc
  IF
    APP
      VAR fispos
      VAR d
    LET Tu92 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        APP
          VAR fdiv
          APP
            VAR fneg
            APP
              VAR veciprod2
              VAR abc
              VAR b0
              VAR b1
              VAR b2
          VAR d
    INT 1
    INT 0
LETREC quadratic (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          UNKNOWN APP            fsqr
            VAR v0
          APP
            VAR o_param_a
            VAR m
        FMUL
          UNKNOWN APP            fsqr
            VAR v1
          APP
            VAR o_param_b
            VAR m
      FMUL
        UNKNOWN APP          fsqr
          VAR v2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      FADD
        FADD
          VAR diag_part
          FMUL
            FMUL
              VAR v1
              VAR v2
            APP
              VAR o_param_r1
              VAR m
        FMUL
          FMUL
            VAR v2
            VAR v0
          APP
            VAR o_param_r2
            VAR m
      FMUL
        FMUL
          VAR v0
          VAR v1
        APP
          VAR o_param_r3
          VAR m
LETREC bilinear (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          FMUL
            VAR v0
            VAR w0
          APP
            VAR o_param_a
            VAR m
        FMUL
          FMUL
            VAR v1
            VAR w1
          APP
            VAR o_param_b
            VAR m
      FMUL
        FMUL
          VAR v2
          VAR w2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      VAR diag_part
      APP
        VAR fhalf
        FADD
          FADD
            FMUL
              FADD
                FMUL
                  VAR v2
                  VAR w1
                FMUL
                  VAR v1
                  VAR w2
              APP
                VAR o_param_r1
                VAR m
            FMUL
              FADD
                FMUL
                  VAR v0
                  VAR w2
                FMUL
                  VAR v2
                  VAR w0
              APP
                VAR o_param_r2
                VAR m
          FMUL
            FADD
              FMUL
                VAR v0
                VAR w1
              FMUL
                VAR v1
                VAR w0
            APP
              VAR o_param_r3
              VAR m
LETREC solver_second (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR dirvec
        INT 0
      GET
        VAR dirvec
        INT 1
      GET
        VAR dirvec
        INT 2
  IF
    FZero?
      VAR aa
    INT 0
    LET bb (VAR of )
      APP
        VAR bilinear
        VAR m
        GET
          VAR dirvec
          INT 0
        GET
          VAR dirvec
          INT 1
        GET
          VAR dirvec
          INT 2
        VAR b0
        VAR b1
        VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        UNKNOWN APP          fsqr
          VAR bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET sd (VAR of )
        APP
          VAR sqrt
          VAR d
      LET t1 (VAR of )
        IF
          APP
            VAR o_isinvert
            VAR m
          VAR sd
          APP
            VAR fneg
            VAR sd
      LET Tu93 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          APP
            VAR fdiv
            FSUB
              VAR t1
              VAR bb
            VAR aa
      INT 1
      INT 0
LETREC solver (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
LETREC solver_rect_fast (VAR of )
  (m : VAR of ), (v : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET d0 (VAR of )
    FMUL
      FSUB
        GET
          VAR dconst
          INT 0
        VAR b0
      GET
        VAR dconst
        INT 1
  IF
    IF
      FLt
        APP
          VAR fabs
          FADD
            FMUL
              VAR d0
              GET
                VAR v
                INT 1
            VAR b1
        APP
          VAR o_param_b
          VAR m
      IF
        FLt
          APP
            VAR fabs
            FADD
              FMUL
                VAR d0
                GET
                  VAR v
                  INT 2
              VAR b2
          APP
            VAR o_param_c
            VAR m
        NOT
          FZero?
            GET
              VAR dconst
              INT 1
        BOOL false
      BOOL false
    LET Tu94 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        VAR d0
    INT 1
    LET d1 (VAR of )
      FMUL
        FSUB
          GET
            VAR dconst
            INT 2
          VAR b1
        GET
          VAR dconst
          INT 3
    IF
      IF
        FLt
          APP
            VAR fabs
            FADD
              FMUL
                VAR d1
                GET
                  VAR v
                  INT 0
              VAR b0
          APP
            VAR o_param_a
            VAR m
        IF
          FLt
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d1
                  GET
                    VAR v
                    INT 2
                VAR b2
            APP
              VAR o_param_c
              VAR m
          NOT
            FZero?
              GET
                VAR dconst
                INT 3
          BOOL false
        BOOL false
      LET Tu95 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          VAR d1
      INT 2
      LET d2 (VAR of )
        FMUL
          FSUB
            GET
              VAR dconst
              INT 4
            VAR b2
          GET
            VAR dconst
            INT 5
      IF
        IF
          FLt
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d2
                  GET
                    VAR v
                    INT 0
                VAR b0
            APP
              VAR o_param_a
              VAR m
          IF
            FLt
              APP
                VAR fabs
                FADD
                  FMUL
                    VAR d2
                    GET
                      VAR v
                      INT 1
                  VAR b1
              APP
                VAR o_param_b
                VAR m
            NOT
              FZero?
                GET
                  VAR dconst
                  INT 5
            BOOL false
          BOOL false
        LET Tu96 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        INT 3
        INT 0
LETREC solver_surface_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu97 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FADD
          FADD
            FMUL
              GET
                VAR dconst
                INT 1
              VAR b0
            FMUL
              GET
                VAR dconst
                INT 2
              VAR b1
          FMUL
            GET
              VAR dconst
              INT 3
            VAR b2
    INT 1
    INT 0
LETREC solver_second_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        UNKNOWN APP          fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu98 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
LETREC solver_surface_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu99 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FMUL
          GET
            VAR dconst
            INT 0
          GET
            VAR sconst
            INT 3
    INT 1
    INT 0
LETREC solver_second_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc (VAR of )
      GET
        VAR sconst
        INT 3
    LET d (VAR of )
      FSUB
        UNKNOWN APP          fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu100 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast2 (VAR of )
  (index : VAR of ), (dirvec : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET sconst (VAR of )
    APP
      VAR o_param_ctbl
      VAR m
  LET b0 (VAR of )
    GET
      VAR sconst
      INT 0
  LET b1 (VAR of )
    GET
      VAR sconst
      INT 1
  LET b2 (VAR of )
    GET
      VAR sconst
      INT 2
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
LETREC setup_rect_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 6
      FLOAT 0.
  LET Tu106 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 0
      PUT
        VAR const
        INT 1
        FLOAT 0.
      LET Tu101 (UNIT)
        PUT
          VAR const
          INT 0
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 0
            APP
              VAR o_param_a
              VAR m
      PUT
        VAR const
        INT 1
        APP
          VAR fdiv
          FLOAT 1.
          GET
            VAR vec
            INT 0
  LET Tu105 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 1
      PUT
        VAR const
        INT 3
        FLOAT 0.
      LET Tu102 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 1
            APP
              VAR o_param_b
              VAR m
      PUT
        VAR const
        INT 3
        APP
          VAR fdiv
          FLOAT 1.
          GET
            VAR vec
            INT 1
  LET Tu104 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 2
      PUT
        VAR const
        INT 5
        FLOAT 0.
      LET Tu103 (UNIT)
        PUT
          VAR const
          INT 4
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 2
            APP
              VAR o_param_c
              VAR m
      PUT
        VAR const
        INT 5
        APP
          VAR fdiv
          FLOAT 1.
          GET
            VAR vec
            INT 2
  VAR const
LETREC setup_surface_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 4
      FLOAT 0.
  LET d (VAR of )
    FADD
      FADD
        FMUL
          GET
            VAR vec
            INT 0
          APP
            VAR o_param_a
            VAR m
        FMUL
          GET
            VAR vec
            INT 1
          APP
            VAR o_param_b
            VAR m
      FMUL
        GET
          VAR vec
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu110 (UNIT)
    IF
      APP
        VAR fispos
        VAR d
      LET Tu109 (UNIT)
        PUT
          VAR const
          INT 0
          APP
            VAR fdiv
            FLOAT -1.
            VAR d
      LET Tu108 (UNIT)
        PUT
          VAR const
          INT 1
          APP
            VAR fneg
            APP
              VAR fdiv
              APP
                VAR o_param_a
                VAR m
              VAR d
      LET Tu107 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg
            APP
              VAR fdiv
              APP
                VAR o_param_b
                VAR m
              VAR d
      PUT
        VAR const
        INT 3
        APP
          VAR fneg
          APP
            VAR fdiv
            APP
              VAR o_param_c
              VAR m
            VAR d
      PUT
        VAR const
        INT 0
        FLOAT 0.
  VAR const
LETREC setup_second_table (VAR of )
  (v : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 5
      FLOAT 0.
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
      GET
        VAR v
        INT 2
  LET c1 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 0
        APP
          VAR o_param_a
          VAR m
  LET c2 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 1
        APP
          VAR o_param_b
          VAR m
  LET c3 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu117 (UNIT)
    PUT
      VAR const
      INT 0
      VAR aa
  LET Tu116 (UNIT)
    IF
      NOT
        EQ
          APP
            VAR o_isrot
            VAR m
          INT 0
      LET Tu112 (UNIT)
        PUT
          VAR const
          INT 1
          FSUB
            VAR c1
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r2
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 1
                  APP
                    VAR o_param_r3
                    VAR m
      LET Tu111 (UNIT)
        PUT
          VAR const
          INT 2
          FSUB
            VAR c2
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r1
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 0
                  APP
                    VAR o_param_r3
                    VAR m
      PUT
        VAR const
        INT 3
        FSUB
          VAR c3
          APP
            VAR fhalf
            FADD
              FMUL
                GET
                  VAR v
                  INT 1
                APP
                  VAR o_param_r1
                  VAR m
              FMUL
                GET
                  VAR v
                  INT 0
                APP
                  VAR o_param_r2
                  VAR m
      LET Tu114 (UNIT)
        PUT
          VAR const
          INT 1
          VAR c1
      LET Tu113 (UNIT)
        PUT
          VAR const
          INT 2
          VAR c2
      PUT
        VAR const
        INT 3
        VAR c3
  LET Tu115 (UNIT)
    IF
      NOT
        FZero?
          VAR aa
      PUT
        VAR const
        INT 4
        APP
          VAR fdiv
          FLOAT 1.
          VAR aa
      UNIT
  VAR const
LETREC iter_setup_dirvec_constants (VAR of )
  (dirvec : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET m (VAR of )
      GET
        VAR objects
        VAR index
    LET dconst (VAR of )
      APP
        VAR d_const
        VAR dirvec
    LET v (VAR of )
      APP
        VAR d_vec
        VAR dirvec
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR m
    LET Tu118 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 1
        PUT
          VAR dconst
          VAR index
          APP
            VAR setup_rect_table
            VAR v
            VAR m
        IF
          EQ
            VAR m_shape
            INT 2
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_surface_table
              VAR v
              VAR m
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_second_table
              VAR v
              VAR m
    APP
      VAR iter_setup_dirvec_constants
      VAR dirvec
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_dirvec_constants (VAR of )
  (dirvec : VAR of )
  APP
    VAR iter_setup_dirvec_constants
    VAR dirvec
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC setup_startp_constants (VAR of )
  (p : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET obj (VAR of )
      GET
        VAR objects
        VAR index
    LET sconst (VAR of )
      APP
        VAR o_param_ctbl
        VAR obj
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR obj
    LET Tu122 (UNIT)
      PUT
        VAR sconst
        INT 0
        FSUB
          GET
            VAR p
            INT 0
          APP
            VAR o_param_x
            VAR obj
    LET Tu121 (UNIT)
      PUT
        VAR sconst
        INT 1
        FSUB
          GET
            VAR p
            INT 1
          APP
            VAR o_param_y
            VAR obj
    LET Tu120 (UNIT)
      PUT
        VAR sconst
        INT 2
        FSUB
          GET
            VAR p
            INT 2
          APP
            VAR o_param_z
            VAR obj
    LET Tu119 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 2
        PUT
          VAR sconst
          INT 3
          APP
            VAR veciprod2
            APP
              VAR o_param_abc
              VAR obj
            GET
              VAR sconst
              INT 0
            GET
              VAR sconst
              INT 1
            GET
              VAR sconst
              INT 2
        IF
          NOT
            LE
              VAR m_shape
              INT 2
          LET cc0 (VAR of )
            APP
              VAR quadratic
              VAR obj
              GET
                VAR sconst
                INT 0
              GET
                VAR sconst
                INT 1
              GET
                VAR sconst
                INT 2
          PUT
            VAR sconst
            INT 3
            IF
              EQ
                VAR m_shape
                INT 3
              FSUB
                VAR cc0
                FLOAT 1.
              VAR cc0
          UNIT
    APP
      VAR setup_startp_constants
      VAR p
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_startp (VAR of )
  (p : VAR of )
  LET Tu123 (UNIT)
    APP
      VAR veccpy
      VAR startp_fast
      VAR p
  APP
    VAR setup_startp_constants
    VAR p
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC is_rect_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  IF
    IF
      FLt
        APP
          VAR fabs
          VAR p0
        APP
          VAR o_param_a
          VAR m
      IF
        FLt
          APP
            VAR fabs
            VAR p1
          APP
            VAR o_param_b
            VAR m
        FLt
          APP
            VAR fabs
            VAR p2
          APP
            VAR o_param_c
            VAR m
        BOOL false
      BOOL false
    APP
      VAR o_isinvert
      VAR m
    NOT
      APP
        VAR o_isinvert
        VAR m
LETREC is_plane_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR veciprod2
      APP
        VAR o_param_abc
        VAR m
      VAR p0
      VAR p1
      VAR p2
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w
LETREC is_second_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR quadratic
      VAR m
      VAR p0
      VAR p1
      VAR p2
  LET w2 (VAR of )
    IF
      EQ
        APP
          VAR o_form
          VAR m
        INT 3
      FSUB
        VAR w
        FLOAT 1.
      VAR w
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w2
LETREC is_outside (VAR of )
  (m : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET p0 (VAR of )
    FSUB
      VAR q0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      VAR q1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      VAR q2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR is_rect_outside
      VAR m
      VAR p0
      VAR p1
      VAR p2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR is_plane_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
      APP
        VAR is_second_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
LETREC check_all_inside (VAR of )
  (ofs : VAR of ), (iand : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET head (VAR of )
    GET
      VAR iand
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL true
    IF
      APP
        VAR is_outside
        GET
          VAR objects
          VAR head
        VAR q0
        VAR q1
        VAR q2
      BOOL false
      APP
        VAR check_all_inside
        ADD
          VAR ofs
          INT 1
        VAR iand
        VAR q0
        VAR q1
        VAR q2
LETREC shadow_check_and_group (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of )
  IF
    EQ
      GET
        VAR and_group
        VAR iand_ofs
      NEG
        INT 1
    BOOL false
    LET obj (VAR of )
      GET
        VAR and_group
        VAR iand_ofs
    LET t0 (VAR of )
      APP
        VAR solver_fast
        VAR obj
        VAR light_dirvec
        VAR intersection_point
    LET t0p (VAR of )
      GET
        VAR solver_dist
        INT 0
    IF
      IF
        NOT
          EQ
            VAR t0
            INT 0
        FLt
          VAR t0p
          FLOAT -0.2
        BOOL false
      LET t (VAR of )
        FADD
          VAR t0p
          FLOAT 0.01
      LET q0 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 0
            VAR t
          GET
            VAR intersection_point
            INT 0
      LET q1 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 1
            VAR t
          GET
            VAR intersection_point
            INT 1
      LET q2 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 2
            VAR t
          GET
            VAR intersection_point
            INT 2
      IF
        APP
          VAR check_all_inside
          INT 0
          VAR and_group
          VAR q0
          VAR q1
          VAR q2
        BOOL true
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR obj
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
        BOOL false
LETREC shadow_check_one_or_group (VAR of )
  (ofs : VAR of ), (or_group : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL false
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET shadow_p (VAR of )
      APP
        VAR shadow_check_and_group
        INT 0
        VAR and_group
    IF
      VAR shadow_p
      BOOL true
      APP
        VAR shadow_check_one_or_group
        ADD
          VAR ofs
          INT 1
        VAR or_group
LETREC shadow_check_one_or_matrix (VAR of )
  (ofs : VAR of ), (or_matrix : VAR of )
  LET head (VAR of )
    GET
      VAR or_matrix
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    BOOL false
    IF
      IF
        EQ
          VAR range_primitive
          INT 99
        BOOL true
        LET t (VAR of )
          APP
            VAR solver_fast
            VAR range_primitive
            VAR light_dirvec
            VAR intersection_point
        IF
          NOT
            EQ
              VAR t
              INT 0
          IF
            FLt
              GET
                VAR solver_dist
                INT 0
              FLOAT -0.1
            IF
              APP
                VAR shadow_check_one_or_group
                INT 1
                VAR head
              BOOL true
              BOOL false
            BOOL false
          BOOL false
      IF
        APP
          VAR shadow_check_one_or_group
          INT 1
          VAR head
        BOOL true
        APP
          VAR shadow_check_one_or_matrix
          ADD
            VAR ofs
            INT 1
          VAR or_matrix
      APP
        VAR shadow_check_one_or_matrix
        ADD
          VAR ofs
          INT 1
        VAR or_matrix
LETREC solve_each_element (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver
        VAR iobj
        VAR dirvec
        VAR startp
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu127 (UNIT)
        IF
          FLt
            FLOAT 0.
            VAR t0p
          IF
            FLt
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 0
                  VAR t
                GET
                  VAR startp
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 1
                  VAR t
                GET
                  VAR startp
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 2
                  VAR t
                GET
                  VAR startp
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu126 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu125 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu124 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu128 (UNIT)
      APP
        VAR solve_each_element
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu129 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver
            VAR range_primitive
            VAR dirvec
            VAR startp
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            FLt
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection (VAR of )
  (dirvec : VAR of )
  LET Tu131 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu130 (UNIT)
    APP
      VAR trace_or_matrix
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    FLt
      FLOAT -0.1
      VAR t
    FLt
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC solve_each_element_fast (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET vec (VAR of )
    APP
      VAR d_vec
      VAR dirvec
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver_fast2
        VAR iobj
        VAR dirvec
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu135 (UNIT)
        IF
          FLt
            FLOAT 0.
            VAR t0p
          IF
            FLt
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 0
                  VAR t
                GET
                  VAR startp_fast
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 1
                  VAR t
                GET
                  VAR startp_fast
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 2
                  VAR t
                GET
                  VAR startp_fast
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu134 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu133 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu132 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element_fast
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element_fast
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network_fast (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu136 (UNIT)
      APP
        VAR solve_each_element_fast
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network_fast
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix_fast (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu137 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network_fast
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver_fast2
            VAR range_primitive
            VAR dirvec
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            FLt
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network_fast
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix_fast
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection_fast (VAR of )
  (dirvec : VAR of )
  LET Tu139 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu138 (UNIT)
    APP
      VAR trace_or_matrix_fast
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    FLt
      FLOAT -0.1
      VAR t
    FLt
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC get_nvector_rect (VAR of )
  (dirvec : VAR of )
  LET rectside (VAR of )
    GET
      VAR intsec_rectside
      INT 0
  LET Tu140 (UNIT)
    APP
      VAR vecbzero
      VAR nvector
  PUT
    VAR nvector
    SUB
      VAR rectside
      INT 1
    APP
      VAR fneg
      APP
        VAR sgn
        GET
          VAR dirvec
          SUB
            VAR rectside
            INT 1
LETREC get_nvector_plane (VAR of )
  (m : VAR of )
  LET Tu142 (UNIT)
    PUT
      VAR nvector
      INT 0
      APP
        VAR fneg
        APP
          VAR o_param_a
          VAR m
  LET Tu141 (UNIT)
    PUT
      VAR nvector
      INT 1
      APP
        VAR fneg
        APP
          VAR o_param_b
          VAR m
  PUT
    VAR nvector
    INT 2
    APP
      VAR fneg
      APP
        VAR o_param_c
        VAR m
LETREC get_nvector_second (VAR of )
  (m : VAR of )
  LET p0 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET d0 (VAR of )
    FMUL
      VAR p0
      APP
        VAR o_param_a
        VAR m
  LET d1 (VAR of )
    FMUL
      VAR p1
      APP
        VAR o_param_b
        VAR m
  LET d2 (VAR of )
    FMUL
      VAR p2
      APP
        VAR o_param_c
        VAR m
  LET Tu147 (UNIT)
    IF
      EQ
        APP
          VAR o_isrot
          VAR m
        INT 0
      LET Tu144 (UNIT)
        PUT
          VAR nvector
          INT 0
          VAR d0
      LET Tu143 (UNIT)
        PUT
          VAR nvector
          INT 1
          VAR d1
      PUT
        VAR nvector
        INT 2
        VAR d2
      LET Tu146 (UNIT)
        PUT
          VAR nvector
          INT 0
          FADD
            VAR d0
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p1
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r2
                    VAR m
      LET Tu145 (UNIT)
        PUT
          VAR nvector
          INT 1
          FADD
            VAR d1
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p0
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r1
                    VAR m
      PUT
        VAR nvector
        INT 2
        FADD
          VAR d2
          APP
            VAR fhalf
            FADD
              FMUL
                VAR p0
                APP
                  VAR o_param_r2
                  VAR m
              FMUL
                VAR p1
                APP
                  VAR o_param_r1
                  VAR m
  APP
    VAR vecunit_sgn
    VAR nvector
    APP
      VAR o_isinvert
      VAR m
LETREC get_nvector (VAR of )
  (m : VAR of ), (dirvec : VAR of )
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR get_nvector_rect
      VAR dirvec
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR get_nvector_plane
        VAR m
      APP
        VAR get_nvector_second
        VAR m
LETREC utexture (VAR of )
  (m : VAR of ), (p : VAR of )
  LET m_tex (VAR of )
    APP
      VAR o_texturetype
      VAR m
  LET Tu152 (UNIT)
    PUT
      VAR texture_color
      INT 0
      APP
        VAR o_color_red
        VAR m
  LET Tu151 (UNIT)
    PUT
      VAR texture_color
      INT 1
      APP
        VAR o_color_green
        VAR m
  LET Tu150 (UNIT)
    PUT
      VAR texture_color
      INT 2
      APP
        VAR o_color_blue
        VAR m
  IF
    EQ
      VAR m_tex
      INT 1
    LET w1 (VAR of )
      FSUB
        GET
          VAR p
          INT 0
        APP
          VAR o_param_x
          VAR m
    LET flag1 (VAR of )
      LET d1 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w1
              FLOAT 0.05
          FLOAT 20.
      FLt
        FSUB
          VAR w1
          VAR d1
        FLOAT 10.
    LET w3 (VAR of )
      FSUB
        GET
          VAR p
          INT 2
        APP
          VAR o_param_z
          VAR m
    LET flag2 (VAR of )
      LET d2 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w3
              FLOAT 0.05
          FLOAT 20.
      FLt
        FSUB
          VAR w3
          VAR d2
        FLOAT 10.
    PUT
      VAR texture_color
      INT 1
      IF
        VAR flag1
        IF
          VAR flag2
          FLOAT 255.
          FLOAT 0.
        IF
          VAR flag2
          FLOAT 0.
          FLOAT 255.
    IF
      EQ
        VAR m_tex
        INT 2
      LET w2 (VAR of )
        UNKNOWN APP          fsqr
          APP
            VAR sin
            FMUL
              GET
                VAR p
                INT 1
              FLOAT 0.25
      LET Tu148 (UNIT)
        PUT
          VAR texture_color
          INT 0
          FMUL
            FLOAT 255.
            VAR w2
      PUT
        VAR texture_color
        INT 1
        FMUL
          FLOAT 255.
          FSUB
            FLOAT 1.
            VAR w2
      IF
        EQ
          VAR m_tex
          INT 3
        LET w1 (VAR of )
          FSUB
            GET
              VAR p
              INT 0
            APP
              VAR o_param_x
              VAR m
        LET w3 (VAR of )
          FSUB
            GET
              VAR p
              INT 2
            APP
              VAR o_param_z
              VAR m
        LET w2 (VAR of )
          APP
            VAR fdiv
            APP
              VAR sqrt
              FADD
                UNKNOWN APP                  fsqr
                  VAR w1
                UNKNOWN APP                  fsqr
                  VAR w3
            FLOAT 10.
        LET w4 (VAR of )
          FMUL
            FSUB
              VAR w2
              APP
                VAR floor
                VAR w2
            FLOAT 3.1415927
        LET cws (VAR of )
          UNKNOWN APP            fsqr
            APP
              VAR cos
              VAR w4
        LET Tu149 (UNIT)
          PUT
            VAR texture_color
            INT 1
            FMUL
              VAR cws
              FLOAT 255.
        PUT
          VAR texture_color
          INT 2
          FMUL
            FSUB
              FLOAT 1.
              VAR cws
            FLOAT 255.
        IF
          EQ
            VAR m_tex
            INT 4
          LET w1 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 0
                APP
                  VAR o_param_x
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_a
                  VAR m
          LET w3 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 2
                APP
                  VAR o_param_z
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_c
                  VAR m
          LET w4 (VAR of )
            FADD
              UNKNOWN APP                fsqr
                VAR w1
              UNKNOWN APP                fsqr
                VAR w3
          LET w7 (VAR of )
            IF
              FLt
                APP
                  VAR fabs
                  VAR w1
                FLOAT 0.0001
              FLOAT 15.
              LET w5 (VAR of )
                APP
                  VAR fabs
                  APP
                    VAR fdiv
                    VAR w3
                    VAR w1
              APP
                VAR fdiv
                FMUL
                  APP
                    VAR atan
                    VAR w5
                  FLOAT 30.
                FLOAT 3.1415927
          LET w9 (VAR of )
            FSUB
              VAR w7
              APP
                VAR floor
                VAR w7
          LET w2 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 1
                APP
                  VAR o_param_y
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_b
                  VAR m
          LET w8 (VAR of )
            IF
              FLt
                APP
                  VAR fabs
                  VAR w4
                FLOAT 0.0001
              FLOAT 15.
              LET w6 (VAR of )
                APP
                  VAR fabs
                  APP
                    VAR fdiv
                    VAR w2
                    VAR w4
              APP
                VAR fdiv
                FMUL
                  APP
                    VAR atan
                    VAR w6
                  FLOAT 30.
                FLOAT 3.1415927
          LET w10 (VAR of )
            FSUB
              VAR w8
              APP
                VAR floor
                VAR w8
          LET w11 (VAR of )
            FSUB
              FSUB
                FLOAT 0.15
                UNKNOWN APP                  fsqr
                  FSUB
                    FLOAT 0.5
                    VAR w9
              UNKNOWN APP                fsqr
                FSUB
                  FLOAT 0.5
                  VAR w10
          LET w12 (VAR of )
            IF
              APP
                VAR fisneg
                VAR w11
              FLOAT 0.
              VAR w11
          PUT
            VAR texture_color
            INT 2
            APP
              VAR fdiv
              FMUL
                FLOAT 255.
                VAR w12
              FLOAT 0.3
          UNIT
LETREC add_light (VAR of )
  (bright : VAR of ), (hilight : VAR of ), (hilight_scale : VAR of )
  LET Tu155 (UNIT)
    IF
      APP
        VAR fispos
        VAR bright
      APP
        VAR vecaccum
        VAR rgb
        VAR bright
        VAR texture_color
      UNIT
  IF
    APP
      VAR fispos
      VAR hilight
    LET ihl (VAR of )
      FMUL
        UNKNOWN APP          fsqr
          UNKNOWN APP            fsqr
            VAR hilight
        VAR hilight_scale
    LET Tu154 (UNIT)
      PUT
        VAR rgb
        INT 0
        FADD
          GET
            VAR rgb
            INT 0
          VAR ihl
    LET Tu153 (UNIT)
      PUT
        VAR rgb
        INT 1
        FADD
          GET
            VAR rgb
            INT 1
          VAR ihl
    PUT
      VAR rgb
      INT 2
      FADD
        GET
          VAR rgb
          INT 2
        VAR ihl
    UNIT
LETREC trace_reflections (VAR of )
  (index : VAR of ), (diffuse : VAR of ), (hilight_scale : VAR of ), (dirvec : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET rinfo (VAR of )
      GET
        VAR reflections
        VAR index
    LET dvec (VAR of )
      APP
        VAR r_dvec
        VAR rinfo
    LET Tu156 (UNIT)
      IF
        APP
          VAR judge_intersection_fast
          VAR dvec
        LET surface_id (VAR of )
          ADD
            MULTIPLE 4
              GET
                VAR intersected_object_id
                INT 0
            GET
              VAR intsec_rectside
              INT 0
        IF
          EQ
            VAR surface_id
            APP
              VAR r_surface_id
              VAR rinfo
          IF
            NOT
              APP
                VAR shadow_check_one_or_matrix
                INT 0
                GET
                  VAR or_net
                  INT 0
            LET p (VAR of )
              APP
                VAR veciprod
                VAR nvector
                APP
                  VAR d_vec
                  VAR dvec
            LET scale (VAR of )
              APP
                VAR r_bright
                VAR rinfo
            LET bright (VAR of )
              FMUL
                FMUL
                  VAR scale
                  VAR diffuse
                VAR p
            LET hilight (VAR of )
              FMUL
                VAR scale
                APP
                  VAR veciprod
                  VAR dirvec
                  APP
                    VAR d_vec
                    VAR dvec
            APP
              VAR add_light
              VAR bright
              VAR hilight
              VAR hilight_scale
            UNIT
          UNIT
        UNIT
    APP
      VAR trace_reflections
      SUB
        VAR index
        INT 1
      VAR diffuse
      VAR hilight_scale
      VAR dirvec
    UNIT
LETREC trace_ray (VAR of )
  (nref : VAR of ), (energy : VAR of ), (dirvec : VAR of ), (pixel : VAR of ), (dist : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      APP
        VAR judge_intersection
        VAR dirvec
      LET obj_id (VAR of )
        GET
          VAR intersected_object_id
          INT 0
      LET obj (VAR of )
        GET
          VAR objects
          VAR obj_id
      LET m_surface (VAR of )
        APP
          VAR o_reflectiontype
          VAR obj
      LET diffuse (VAR of )
        FMUL
          APP
            VAR o_diffuse
            VAR obj
          VAR energy
      LET Tu170 (UNIT)
        APP
          VAR get_nvector
          VAR obj
          VAR dirvec
      LET Tu169 (UNIT)
        APP
          VAR veccpy
          VAR startp
          VAR intersection_point
      LET Tu168 (UNIT)
        APP
          VAR utexture
          VAR obj
          VAR intersection_point
      LET Tu167 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          ADD
            MULTIPLE 4
              VAR obj_id
            GET
              VAR intsec_rectside
              INT 0
      LET intersection_points (VAR of )
        APP
          VAR p_intersection_points
          VAR pixel
      LET Tu166 (UNIT)
        APP
          VAR veccpy
          GET
            VAR intersection_points
            VAR nref
          VAR intersection_point
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu165 (UNIT)
        IF
          FLt
            APP
              VAR o_diffuse
              VAR obj
            FLOAT 0.5
          PUT
            VAR calc_diffuse
            VAR nref
            BOOL false
          LET Tu159 (UNIT)
            PUT
              VAR calc_diffuse
              VAR nref
              BOOL true
          LET energya (VAR of )
            APP
              VAR p_energy
              VAR pixel
          LET Tu158 (UNIT)
            APP
              VAR veccpy
              GET
                VAR energya
                VAR nref
              VAR texture_color
          LET Tu157 (UNIT)
            APP
              VAR vecscale
              GET
                VAR energya
                VAR nref
              FMUL
                APP
                  VAR fdiv
                  FLOAT 1.
                  FLOAT 256.
                VAR diffuse
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR nvectors
              VAR nref
            VAR nvector
      LET w (VAR of )
        FMUL
          FLOAT -2.
          APP
            VAR veciprod
            VAR dirvec
            VAR nvector
      LET Tu164 (UNIT)
        APP
          VAR vecaccum
          VAR dirvec
          VAR w
          VAR nvector
      LET hilight_scale (VAR of )
        FMUL
          VAR energy
          APP
            VAR o_hilight
            VAR obj
      LET Tu163 (UNIT)
        IF
          NOT
            APP
              VAR shadow_check_one_or_matrix
              INT 0
              GET
                VAR or_net
                INT 0
          LET bright (VAR of )
            FMUL
              APP
                VAR fneg
                APP
                  VAR veciprod
                  VAR nvector
                  VAR light
              VAR diffuse
          LET hilight (VAR of )
            APP
              VAR fneg
              APP
                VAR veciprod
                VAR dirvec
                VAR light
          APP
            VAR add_light
            VAR bright
            VAR hilight
            VAR hilight_scale
          UNIT
      LET Tu162 (UNIT)
        APP
          VAR setup_startp
          VAR intersection_point
      LET Tu161 (UNIT)
        APP
          VAR trace_reflections
          SUB
            GET
              VAR n_reflections
              INT 0
            INT 1
          VAR diffuse
          VAR hilight_scale
          VAR dirvec
      IF
        FLt
          FLOAT 0.1
          VAR energy
        LET Tu160 (UNIT)
          IF
            NOT
              LE
                INT 4
                VAR nref
            PUT
              VAR surface_ids
              ADD
                VAR nref
                INT 1
              NEG
                INT 1
            UNIT
        IF
          EQ
            VAR m_surface
            INT 2
          LET energy2 (VAR of )
            FMUL
              VAR energy
              FSUB
                FLOAT 1.
                APP
                  VAR o_diffuse
                  VAR obj
          APP
            VAR trace_ray
            ADD
              VAR nref
              INT 1
            VAR energy2
            VAR dirvec
            VAR pixel
            FADD
              VAR dist
              GET
                VAR tmin
                INT 0
          UNIT
        UNIT
      LET Tu173 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          NEG
            INT 1
      IF
        NOT
          EQ
            VAR nref
            INT 0
        LET hl (VAR of )
          APP
            VAR fneg
            APP
              VAR veciprod
              VAR dirvec
              VAR light
        IF
          APP
            VAR fispos
            VAR hl
          LET ihl (VAR of )
            FMUL
              FMUL
                FMUL
                  UNKNOWN APP                    fsqr
                    VAR hl
                  VAR hl
                VAR energy
              GET
                VAR beam
                INT 0
          LET Tu172 (UNIT)
            PUT
              VAR rgb
              INT 0
              FADD
                GET
                  VAR rgb
                  INT 0
                VAR ihl
          LET Tu171 (UNIT)
            PUT
              VAR rgb
              INT 1
              FADD
                GET
                  VAR rgb
                  INT 1
                VAR ihl
          PUT
            VAR rgb
            INT 2
            FADD
              GET
                VAR rgb
                INT 2
              VAR ihl
          UNIT
        UNIT
    UNIT
LETREC trace_diffuse_ray (VAR of )
  (dirvec : VAR of ), (energy : VAR of )
  IF
    APP
      VAR judge_intersection_fast
      VAR dirvec
    LET obj (VAR of )
      GET
        VAR objects
        GET
          VAR intersected_object_id
          INT 0
    LET Tu175 (UNIT)
      APP
        VAR get_nvector
        VAR obj
        APP
          VAR d_vec
          VAR dirvec
    LET Tu174 (UNIT)
      APP
        VAR utexture
        VAR obj
        VAR intersection_point
    IF
      NOT
        APP
          VAR shadow_check_one_or_matrix
          INT 0
          GET
            VAR or_net
            INT 0
      LET br (VAR of )
        APP
          VAR fneg
          APP
            VAR veciprod
            VAR nvector
            VAR light
      LET bright (VAR of )
        IF
          APP
            VAR fispos
            VAR br
          VAR br
          FLOAT 0.
      APP
        VAR vecaccum
        VAR diffuse_ray
        FMUL
          FMUL
            VAR energy
            VAR bright
          APP
            VAR o_diffuse
            VAR obj
        VAR texture_color
      UNIT
    UNIT
LETREC iter_trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET p (VAR of )
      APP
        VAR veciprod
        APP
          VAR d_vec
          GET
            VAR dirvec_group
            VAR index
        VAR nvector
    LET Tu176 (UNIT)
      IF
        APP
          VAR fisneg
          VAR p
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            ADD
              VAR index
              INT 1
          APP
            VAR fdiv
            VAR p
            FLOAT -150.
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            VAR index
          APP
            VAR fdiv
            VAR p
            FLOAT 150.
    APP
      VAR iter_trace_diffuse_rays
      VAR dirvec_group
      VAR nvector
      VAR org
      SUB
        VAR index
        INT 2
    UNIT
LETREC trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu177 (UNIT)
    APP
      VAR setup_startp
      VAR org
  APP
    VAR iter_trace_diffuse_rays
    VAR dirvec_group
    VAR nvector
    VAR org
    INT 118
LETREC trace_diffuse_ray_80percent (VAR of )
  (group_id : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu181 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 0
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 0
        VAR nvector
        VAR org
      UNIT
  LET Tu180 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 1
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 1
        VAR nvector
        VAR org
      UNIT
  LET Tu179 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 2
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 2
        VAR nvector
        VAR org
      UNIT
  LET Tu178 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 3
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 3
        VAR nvector
        VAR org
      UNIT
  IF
    NOT
      EQ
        VAR group_id
        INT 4
    APP
      VAR trace_diffuse_rays
      GET
        VAR dirvecs
        INT 4
      VAR nvector
      VAR org
    UNIT
LETREC calc_diffuse_using_1point (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  LET ray20p (VAR of )
    APP
      VAR p_received_ray_20percent
      VAR pixel
  LET nvectors (VAR of )
    APP
      VAR p_nvectors
      VAR pixel
  LET intersection_points (VAR of )
    APP
      VAR p_intersection_points
      VAR pixel
  LET energya (VAR of )
    APP
      VAR p_energy
      VAR pixel
  LET Tu183 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR ray20p
        VAR nref
  LET Tu182 (UNIT)
    APP
      VAR trace_diffuse_ray_80percent
      APP
        VAR p_group_id
        VAR pixel
      GET
        VAR nvectors
        VAR nref
      GET
        VAR intersection_points
        VAR nref
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC calc_diffuse_using_5points (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET r_up (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR prev
        VAR x
  LET r_left (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        SUB
          VAR x
          INT 1
  LET r_center (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        VAR x
  LET r_right (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        ADD
          VAR x
          INT 1
  LET r_down (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR next
        VAR x
  LET Tu188 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR r_up
        VAR nref
  LET Tu187 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_left
        VAR nref
  LET Tu186 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_center
        VAR nref
  LET Tu185 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_right
        VAR nref
  LET Tu184 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_down
        VAR nref
  LET energya (VAR of )
    APP
      VAR p_energy
      GET
        VAR cur
        VAR x
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC do_without_neighbors (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      LE
        INT 0
        GET
          VAR surface_ids
          VAR nref
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu189 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          APP
            VAR calc_diffuse_using_1point
            VAR pixel
            VAR nref
          UNIT
      APP
        VAR do_without_neighbors
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC neighbors_exist (VAR of )
  (x : VAR of ), (y : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        ADD
          VAR y
          INT 1
    IF
      NOT
        LE
          VAR y
          INT 0
      IF
        NOT
          LE
            GET
              VAR image_size
              INT 0
            ADD
              VAR x
              INT 1
        IF
          NOT
            LE
              VAR x
              INT 0
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC get_surface_id (VAR of )
  (pixel : VAR of ), (index : VAR of )
  LET surface_ids (VAR of )
    APP
      VAR p_surface_ids
      VAR pixel
  GET
    VAR surface_ids
    VAR index
LETREC neighbors_are_available (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET sid_center (VAR of )
    APP
      VAR get_surface_id
      GET
        VAR cur
        VAR x
      VAR nref
  IF
    EQ
      APP
        VAR get_surface_id
        GET
          VAR prev
          VAR x
        VAR nref
      VAR sid_center
    IF
      EQ
        APP
          VAR get_surface_id
          GET
            VAR next
            VAR x
          VAR nref
        VAR sid_center
      IF
        EQ
          APP
            VAR get_surface_id
            GET
              VAR cur
              SUB
                VAR x
                INT 1
            VAR nref
          VAR sid_center
        IF
          EQ
            APP
              VAR get_surface_id
              GET
                VAR cur
                ADD
                  VAR x
                  INT 1
              VAR nref
            VAR sid_center
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC try_exploit_neighbors (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET pixel (VAR of )
    GET
      VAR cur
      VAR x
  IF
    LE
      VAR nref
      INT 4
    IF
      LE
        INT 0
        APP
          VAR get_surface_id
          VAR pixel
          VAR nref
      IF
        APP
          VAR neighbors_are_available
          VAR x
          VAR prev
          VAR cur
          VAR next
          VAR nref
        LET calc_diffuse (VAR of )
          APP
            VAR p_calc_diffuse
            VAR pixel
        LET Tu190 (UNIT)
          IF
            GET
              VAR calc_diffuse
              VAR nref
            APP
              VAR calc_diffuse_using_5points
              VAR x
              VAR prev
              VAR cur
              VAR next
              VAR nref
            UNIT
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          ADD
            VAR nref
            INT 1
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          VAR nref
      UNIT
    UNIT
LETREC write_ppm_header (VAR of )
  (Tu191 : VAR of )
  LET Tu199 (UNIT)
    OUT
      INT 80    0
  LET Tu198 (UNIT)
    OUT
      ADD
        INT 48
        INT 6    0
  LET Tu197 (UNIT)
    OUT
      INT 10    0
  LET Tu196 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 0
  LET Tu195 (UNIT)
    OUT
      INT 32    0
  LET Tu194 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 1
  LET Tu193 (UNIT)
    OUT
      INT 32    0
  LET Tu192 (UNIT)
    APP
      VAR print_int
      INT 255
  OUT
    INT 10  0
LETREC write_rgb_element (VAR of )
  (x : VAR of )
  LET ix (VAR of )
    float_to_int
      VAR x
  LET elem (VAR of )
    IF
      NOT
        LE
          VAR ix
          INT 255
      INT 255
      IF
        NOT
          LE
            INT 0
            VAR ix
        INT 0
        VAR ix
  OUT
    VAR elem  0
LETREC write_rgb (VAR of )
  (Tu200 : VAR of )
  LET Tu202 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 0
  LET Tu201 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 1
  APP
    VAR write_rgb_element
    GET
      VAR rgb
      INT 2
LETREC pretrace_diffuse_rays (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET sid (VAR of )
      APP
        VAR get_surface_id
        VAR pixel
        VAR nref
    IF
      LE
        INT 0
        VAR sid
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu205 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          LET group_id (VAR of )
            APP
              VAR p_group_id
              VAR pixel
          LET Tu204 (UNIT)
            APP
              VAR vecbzero
              VAR diffuse_ray
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          LET intersection_points (VAR of )
            APP
              VAR p_intersection_points
              VAR pixel
          LET Tu203 (UNIT)
            APP
              VAR trace_diffuse_rays
              GET
                VAR dirvecs
                VAR group_id
              GET
                VAR nvectors
                VAR nref
              GET
                VAR intersection_points
                VAR nref
          LET ray20p (VAR of )
            APP
              VAR p_received_ray_20percent
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR ray20p
              VAR nref
            VAR diffuse_ray
          UNIT
      APP
        VAR pretrace_diffuse_rays
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC pretrace_pixels (VAR of )
  (line : VAR of ), (x : VAR of ), (group_id : VAR of ), (lc0 : VAR of ), (lc1 : VAR of ), (lc2 : VAR of )
  IF
    LE
      INT 0
      VAR x
    LET xdisp (VAR of )
      FMUL
        GET
          VAR scan_pitch
          INT 0
        int_to_float
          SUB
            VAR x
            GET
              VAR image_center
              INT 0
    LET Tu215 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 0
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 0
          VAR lc0
    LET Tu214 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 1
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 1
          VAR lc1
    LET Tu213 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 2
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 2
          VAR lc2
    LET Tu212 (UNIT)
      APP
        VAR vecunit_sgn
        VAR ptrace_dirvec
        BOOL false
    LET Tu211 (UNIT)
      APP
        VAR vecbzero
        VAR rgb
    LET Tu210 (UNIT)
      APP
        VAR veccpy
        VAR startp
        VAR viewpoint
    LET Tu209 (UNIT)
      APP
        VAR trace_ray
        INT 0
        FLOAT 1.
        VAR ptrace_dirvec
        GET
          VAR line
          VAR x
        FLOAT 0.
    LET Tu208 (UNIT)
      APP
        VAR veccpy
        APP
          VAR p_rgb
          GET
            VAR line
            VAR x
        VAR rgb
    LET Tu207 (UNIT)
      APP
        VAR p_set_group_id
        GET
          VAR line
          VAR x
        VAR group_id
    LET Tu206 (UNIT)
      APP
        VAR pretrace_diffuse_rays
        GET
          VAR line
          VAR x
        INT 0
    APP
      VAR pretrace_pixels
      VAR line
      SUB
        VAR x
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR lc0
      VAR lc1
      VAR lc2
    UNIT
LETREC pretrace_line (VAR of )
  (line : VAR of ), (y : VAR of ), (group_id : VAR of )
  LET ydisp (VAR of )
    FMUL
      GET
        VAR scan_pitch
        INT 0
      int_to_float
        SUB
          VAR y
          GET
            VAR image_center
            INT 1
  LET lc0 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 0
      GET
        VAR screenz_dir
        INT 0
  LET lc1 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 1
      GET
        VAR screenz_dir
        INT 1
  LET lc2 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 2
      GET
        VAR screenz_dir
        INT 2
  APP
    VAR pretrace_pixels
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 1
    VAR group_id
    VAR lc0
    VAR lc1
    VAR lc2
LETREC scan_pixel (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 0
        VAR x
    LET Tu218 (UNIT)
      APP
        VAR veccpy
        VAR rgb
        APP
          VAR p_rgb
          GET
            VAR cur
            VAR x
    LET Tu217 (UNIT)
      IF
        APP
          VAR neighbors_exist
          VAR x
          VAR y
          VAR next
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          INT 0
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          INT 0
    LET Tu216 (UNIT)
      APP
        VAR write_rgb
        UNIT
    APP
      VAR scan_pixel
      ADD
        VAR x
        INT 1
      VAR y
      VAR prev
      VAR cur
      VAR next
    UNIT
LETREC scan_line (VAR of )
  (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (group_id : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        VAR y
    LET Tu220 (UNIT)
      IF
        NOT
          LE
            SUB
              GET
                VAR image_size
                INT 1
              INT 1
            VAR y
        APP
          VAR pretrace_line
          VAR next
          ADD
            VAR y
            INT 1
          VAR group_id
        UNIT
    LET Tu219 (UNIT)
      APP
        VAR scan_pixel
        INT 0
        VAR y
        VAR prev
        VAR cur
        VAR next
    APP
      VAR scan_line
      ADD
        VAR y
        INT 1
      VAR cur
      VAR next
      VAR prev
      APP
        VAR add_mod5
        VAR group_id
        INT 2
    UNIT
LETREC create_float5x3array (VAR of )
  (Tu221 : VAR of )
  LET vec (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET array (VAR of )
    ARRAY
      INT 5
      VAR vec
  LET Tu225 (UNIT)
    PUT
      VAR array
      INT 1
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu224 (UNIT)
    PUT
      VAR array
      INT 2
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu223 (UNIT)
    PUT
      VAR array
      INT 3
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu222 (UNIT)
    PUT
      VAR array
      INT 4
      ARRAY
        INT 3
        FLOAT 0.
  VAR array
LETREC create_pixel (VAR of )
  (Tu226 : VAR of )
  LET m_rgb (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET m_isect_ps (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_sids (VAR of )
    ARRAY
      INT 5
      INT 0
  LET m_cdif (VAR of )
    ARRAY
      INT 5
      BOOL false
  LET m_engy (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_r20p (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_gid (VAR of )
    ARRAY
      INT 1
      INT 0
  LET m_nvectors (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  TUPLE
    VAR m_rgb
    VAR m_isect_ps
    VAR m_sids
    VAR m_cdif
    VAR m_engy
    VAR m_r20p
    VAR m_gid
    VAR m_nvectors
LETREC init_line_elements (VAR of )
  (line : VAR of ), (n : VAR of )
  IF
    LE
      INT 0
      VAR n
    LET Tu227 (UNIT)
      PUT
        VAR line
        VAR n
        APP
          VAR create_pixel
          UNIT
    APP
      VAR init_line_elements
      VAR line
      SUB
        VAR n
        INT 1
    VAR line
LETREC create_pixelline (VAR of )
  (Tu228 : VAR of )
  LET line (VAR of )
    ARRAY
      GET
        VAR image_size
        INT 0
      APP
        VAR create_pixel
        UNIT
  APP
    VAR init_line_elements
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 2
LETREC tan (VAR of )
  (x : VAR of )
  APP
    VAR fdiv
    APP
      VAR sin
      VAR x
    APP
      VAR cos
      VAR x
LETREC adjust_position (VAR of )
  (h : VAR of ), (ratio : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FMUL
          VAR h
          VAR h
        FLOAT 0.1
  LET tan_h (VAR of )
    APP
      VAR fdiv
      FLOAT 1.
      VAR l
  LET theta_h (VAR of )
    APP
      VAR atan
      VAR tan_h
  LET tan_m (VAR of )
    APP
      VAR tan
      FMUL
        VAR theta_h
        VAR ratio
  FMUL
    VAR tan_m
    VAR l
LETREC calc_dirvec (VAR of )
  (icount : VAR of ), (x : VAR of ), (y : VAR of ), (rx : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 5
      VAR icount
    LET l (VAR of )
      APP
        VAR sqrt
        FADD
          FADD
            UNKNOWN APP              fsqr
              VAR x
            UNKNOWN APP              fsqr
              VAR y
          FLOAT 1.
    LET vx (VAR of )
      APP
        VAR fdiv
        VAR x
        VAR l
    LET vy (VAR of )
      APP
        VAR fdiv
        VAR y
        VAR l
    LET vz (VAR of )
      APP
        VAR fdiv
        FLOAT 1.
        VAR l
    LET dgroup (VAR of )
      GET
        VAR dirvecs
        VAR group_id
    LET Tu233 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            VAR index
        VAR vx
        VAR vy
        VAR vz
    LET Tu232 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 40
        VAR vx
        VAR vz
        APP
          VAR fneg
          VAR vy
    LET Tu231 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 80
        VAR vz
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
    LET Tu230 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 1
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
        APP
          VAR fneg
          VAR vz
    LET Tu229 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 41
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vz
        VAR vy
    APP
      VAR vecset
      APP
        VAR d_vec
        GET
          VAR dgroup
          ADD
            VAR index
            INT 81
      APP
        VAR fneg
        VAR vz
      VAR vx
      VAR vy
    LET x2 (VAR of )
      APP
        VAR adjust_position
        VAR y
        VAR rx
    APP
      VAR calc_dirvec
      ADD
        VAR icount
        INT 1
      VAR x2
      APP
        VAR adjust_position
        VAR x2
        VAR ry
      VAR rx
      VAR ry
      VAR group_id
      VAR index
LETREC calc_dirvecs (VAR of )
  (col : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR col
    LET rx (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.9
    LET Tu235 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx
        VAR ry
        VAR group_id
        VAR index
    LET rx2 (VAR of )
      FADD
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.1
    LET Tu234 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx2
        VAR ry
        VAR group_id
        ADD
          VAR index
          INT 2
    APP
      VAR calc_dirvecs
      SUB
        VAR col
        INT 1
      VAR ry
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR index
    UNIT
LETREC calc_dirvec_rows (VAR of )
  (row : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR row
    LET ry (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR row
          FLOAT 0.2
        FLOAT 0.9
    LET Tu236 (UNIT)
      APP
        VAR calc_dirvecs
        INT 4
        VAR ry
        VAR group_id
        VAR index
    APP
      VAR calc_dirvec_rows
      SUB
        VAR row
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 2
      ADD
        VAR index
        INT 4
    UNIT
LETREC create_dirvec (VAR of )
  (Tu237 : VAR of )
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      GET
        VAR n_objects
        INT 0
      VAR v3
  TUPLE
    VAR v3
    VAR consts
LETREC create_dirvec_elements (VAR of )
  (d : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu238 (UNIT)
      PUT
        VAR d
        VAR index
        APP
          VAR create_dirvec
          UNIT
    APP
      VAR create_dirvec_elements
      VAR d
      SUB
        VAR index
        INT 1
    UNIT
LETREC create_dirvecs (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu240 (UNIT)
      PUT
        VAR dirvecs
        VAR index
        ARRAY
          INT 120
          APP
            VAR create_dirvec
            UNIT
    LET Tu239 (UNIT)
      APP
        VAR create_dirvec_elements
        GET
          VAR dirvecs
          VAR index
        INT 118
    APP
      VAR create_dirvecs
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvec_constants (VAR of )
  (vecset : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu241 (UNIT)
      APP
        VAR setup_dirvec_constants
        GET
          VAR vecset
          VAR index
    APP
      VAR init_dirvec_constants
      VAR vecset
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_vecset_constants (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu242 (UNIT)
      APP
        VAR init_dirvec_constants
        GET
          VAR dirvecs
          VAR index
        INT 119
    APP
      VAR init_vecset_constants
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvecs (VAR of )
  (Tu243 : VAR of )
  LET Tu245 (UNIT)
    APP
      VAR create_dirvecs
      INT 4
  LET Tu244 (UNIT)
    APP
      VAR calc_dirvec_rows
      INT 9
      INT 0
      INT 0
  APP
    VAR init_vecset_constants
    INT 4
LETREC add_reflection (VAR of )
  (index : VAR of ), (surface_id : VAR of ), (bright : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET dvec (VAR of )
    APP
      VAR create_dirvec
      UNIT
  LET Tu247 (UNIT)
    APP
      VAR vecset
      APP
        VAR d_vec
        VAR dvec
      VAR v0
      VAR v1
      VAR v2
  LET Tu246 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR dvec
  PUT
    VAR reflections
    VAR index
    TUPLE
      VAR surface_id
      VAR dvec
      VAR bright
LETREC setup_rect_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    MULTIPLE 4
      VAR obj_id
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET n0 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 0
  LET n1 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 1
  LET n2 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 2
  LET Tu250 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      ADD
        VAR sid
        INT 1
      VAR br
      GET
        VAR light
        INT 0
      VAR n1
      VAR n2
  LET Tu249 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 1
      ADD
        VAR sid
        INT 2
      VAR br
      VAR n0
      GET
        VAR light
        INT 1
      VAR n2
  LET Tu248 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 2
      ADD
        VAR sid
        INT 3
      VAR br
      VAR n0
      VAR n1
      GET
        VAR light
        INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 3
LETREC setup_surface_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    ADD
      MULTIPLE 4
        VAR obj_id
      INT 1
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET p (VAR of )
    APP
      VAR veciprod
      VAR light
      APP
        VAR o_param_abc
        VAR obj
  LET Tu251 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      VAR sid
      VAR br
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_a
              VAR obj
          VAR p
        GET
          VAR light
          INT 0
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_b
              VAR obj
          VAR p
        GET
          VAR light
          INT 1
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_c
              VAR obj
          VAR p
        GET
          VAR light
          INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 1
LETREC setup_reflections (VAR of )
  (obj_id : VAR of )
  IF
    LE
      INT 0
      VAR obj_id
    LET obj (VAR of )
      GET
        VAR objects
        VAR obj_id
    IF
      EQ
        APP
          VAR o_reflectiontype
          VAR obj
        INT 2
      IF
        FLt
          APP
            VAR o_diffuse
            VAR obj
          FLOAT 1.
        LET m_shape (VAR of )
          APP
            VAR o_form
            VAR obj
        IF
          EQ
            VAR m_shape
            INT 1
          APP
            VAR setup_rect_reflection
            VAR obj_id
            VAR obj
          IF
            EQ
              VAR m_shape
              INT 2
            APP
              VAR setup_surface_reflection
              VAR obj_id
              VAR obj
            UNIT
        UNIT
      UNIT
    UNIT
LETREC rt (VAR of )
  (size_x : VAR of ), (size_y : VAR of )
  LET Tu263 (UNIT)
    PUT
      VAR image_size
      INT 0
      VAR size_x
  LET Tu262 (UNIT)
    PUT
      VAR image_size
      INT 1
      VAR size_y
  LET Tu261 (UNIT)
    PUT
      VAR image_center
      INT 0
      DIVIDE BY 2
        VAR size_x
  LET Tu260 (UNIT)
    PUT
      VAR image_center
      INT 1
      DIVIDE BY 2
        VAR size_y
  LET Tu259 (UNIT)
    PUT
      VAR scan_pitch
      INT 0
      APP
        VAR fdiv
        FLOAT 128.
        int_to_float
          VAR size_x
  LET prev (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET cur (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET next (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET Tu258 (UNIT)
    APP
      VAR read_parameter
      UNIT
  LET Tu257 (UNIT)
    APP
      VAR write_ppm_header
      UNIT
  LET Tu256 (UNIT)
    APP
      VAR init_dirvecs
      UNIT
  LET Tu255 (UNIT)
    APP
      VAR veccpy
      APP
        VAR d_vec
        VAR light_dirvec
      VAR light
  LET Tu254 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR light_dirvec
  LET Tu253 (UNIT)
    APP
      VAR setup_reflections
      SUB
        GET
          VAR n_objects
          INT 0
        INT 1
  LET Tu252 (UNIT)
    APP
      VAR pretrace_line
      VAR cur
      INT 0
      INT 0
  APP
    VAR scan_line
    INT 0
    VAR prev
    VAR cur
    VAR next
    INT 2
APP
  VAR rt
  INT 128
  INT 128

----- kNormal.print -----
letrec finv : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  if x == 0.0 
    x
    let t : FLOAT =
      unknown finv_init x
    in
    let two : FLOAT =
      float 2.
    in
    let t : FLOAT =
      let Td2534 : FLOAT =
        let Td2533 : FLOAT =
          fmul x t
        in
        fsub two Td2533
      in
      fmul t Td2534
    in
    let t : FLOAT =
      let Td2536 : FLOAT =
        let Td2535 : FLOAT =
          fmul x t
        in
        fsub two Td2535
      in
      fmul t Td2536
    in
    let t : FLOAT =
      let Td2538 : FLOAT =
        let Td2537 : FLOAT =
          fmul x t
        in
        fsub two Td2537
      in
      fmul t Td2538
    in
    let t : FLOAT =
      let Td2540 : FLOAT =
        let Td2539 : FLOAT =
          fmul x t
        in
        fsub two Td2539
      in
      fmul t Td2540
    in
    let t : FLOAT =
      let Td2542 : FLOAT =
        let Td2541 : FLOAT =
          fmul x t
        in
        fsub two Td2541
      in
      fmul t Td2542
    in
    t
in
letrec fdiv : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (x : FLOAT), (y : FLOAT)
  let Td2532 : FLOAT =
    app
      finv
      y
  in
  fmul x Td2532
in
letrec print_int : (INT -> UNIT) =
variables : (n : INT)
  let n : INT =
    let Ti2527 : INT =
      int 0
    in
    if Ti2527 <= n
      n
      let Tu1 : UNIT =
        let Ti2528 : INT =
          int 45
        in
        out Ti2528 0
      in
      neg n
  in
  let Ti2529 : INT =
    int 10
  in
  if Ti2529 <= n
    let m : INT =
      div n 10
    in
    let Tu2 : UNIT =
      app
        print_int
        m
    in
    let Ti2531 : INT =
      let Ti2530 : INT =
        mul m 10
      in
      sub n Ti2530
    in
    out Ti2531 48
    out n 48
in
letrec print_newline : (INT -> UNIT) =
variables : (Tu3 : INT)
  let Ti2526 : INT =
    int 0
  in
  out Ti2526 10
in
letrec reduction_2pi_sub1 : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2518 : FLOAT =
    let Ti2517 : INT =
      int 0
    in
    v.(Ti2517)
  in
  let Td2520 : FLOAT =
    let Ti2519 : INT =
      int 1
    in
    v.(Ti2519)
  in
  if Td2518 <. Td2520
    unit ()
    let Tu4 : UNIT =
      let Ti2521 : INT =
        int 1
      in
      let Td2525 : FLOAT =
        let Td2523 : FLOAT =
          let Ti2522 : INT =
            int 1
          in
          v.(Ti2522)
        in
        let Td2524 : FLOAT =
          float 2.
        in
        fmul Td2523 Td2524
      in
      v.(Ti2521) <- Td2525
    in
    app
      reduction_2pi_sub1
      v
in
letrec reduction_2pi_sub2 : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2499 : FLOAT =
    float 6.28318530718
  in
  let Td2501 : FLOAT =
    let Ti2500 : INT =
      int 0
    in
    v.(Ti2500)
  in
  if Td2499 <. Td2501
    let Tu6 : UNIT =
      let Td2503 : FLOAT =
        let Ti2502 : INT =
          int 1
        in
        v.(Ti2502)
      in
      let Td2505 : FLOAT =
        let Ti2504 : INT =
          int 0
        in
        v.(Ti2504)
      in
      if Td2503 <. Td2505
        let Ti2506 : INT =
          int 0
        in
        let Td2511 : FLOAT =
          let Td2508 : FLOAT =
            let Ti2507 : INT =
              int 0
            in
            v.(Ti2507)
          in
          let Td2510 : FLOAT =
            let Ti2509 : INT =
              int 1
            in
            v.(Ti2509)
          in
          fsub Td2508 Td2510
        in
        v.(Ti2506) <- Td2511
        unit ()
    in
    let Tu5 : UNIT =
      let Ti2512 : INT =
        int 1
      in
      let Td2516 : FLOAT =
        let Td2514 : FLOAT =
          let Ti2513 : INT =
            int 1
          in
          v.(Ti2513)
        in
        let Td2515 : FLOAT =
          float 2.
        in
        app
          fdiv
          Td2514
          Td2515
      in
      v.(Ti2512) <- Td2516
    in
    app
      reduction_2pi_sub2
      v
    unit ()
in
letrec reduction_2pi : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Tu8 : UNIT =
    let Ti2497 : INT =
      int 1
    in
    let Td2498 : FLOAT =
      float 6.28318530718
    in
    v.(Ti2497) <- Td2498
  in
  let Tu7 : UNIT =
    app
      reduction_2pi_sub1
      v
  in
  app
    reduction_2pi_sub2
    v
in
letrec kernel_sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a3 : FLOAT =
    fmul a2 a
  in
  let a5 : FLOAT =
    fmul a3 a2
  in
  let a7 : FLOAT =
    fmul a5 a2
  in
  let Td2494 : FLOAT =
    let Td2491 : FLOAT =
      let Td2490 : FLOAT =
        let Td2489 : FLOAT =
          float 0.16666668
        in
        fmul Td2489 a3
      in
      fsub a Td2490
    in
    let Td2493 : FLOAT =
      let Td2492 : FLOAT =
        float 0.008332824
      in
      fmul Td2492 a5
    in
    fadd Td2491 Td2493
  in
  let Td2496 : FLOAT =
    let Td2495 : FLOAT =
      float 0.00019587841
    in
    fmul Td2495 a7
  in
  fsub Td2494 Td2496
in
letrec kernel_cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a4 : FLOAT =
    fmul a2 a2
  in
  let a6 : FLOAT =
    fmul a4 a2
  in
  let Td2486 : FLOAT =
    let Td2483 : FLOAT =
      let Td2480 : FLOAT =
        float 1.
      in
      let Td2482 : FLOAT =
        let Td2481 : FLOAT =
          float 0.5
        in
        fmul Td2481 a2
      in
      fsub Td2480 Td2482
    in
    let Td2485 : FLOAT =
      let Td2484 : FLOAT =
        float 0.04166368
      in
      fmul Td2484 a4
    in
    fadd Td2483 Td2485
  in
  let Td2488 : FLOAT =
    let Td2487 : FLOAT =
      float 0.0013695068
    in
    fmul Td2487 a6
  in
  fsub Td2486 Td2488
in
letrec sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let v : Array of FLOAT =
    let Ti2444 : INT =
      int 3
    in
    extfunapp
      create_float_array
      Ti2444
      a
  in
  let Tu13 : UNIT =
    let Td2445 : FLOAT =
      float 0.
    in
    if a <. Td2445
      let Ti2446 : INT =
        int 0
      in
      let Td2447 : FLOAT =
        fneg a
      in
      v.(Ti2446) <- Td2447
      unit ()
  in
  let Tu12 : UNIT =
    app
      reduction_2pi
      v
  in
  let Tu11 : UNIT =
    let Td2448 : FLOAT =
      float 3.14159265359
    in
    let Td2450 : FLOAT =
      let Ti2449 : INT =
        int 0
      in
      v.(Ti2449)
    in
    if Td2448 <. Td2450
      let Tu9 : UNIT =
        let Ti2451 : INT =
          int 0
        in
        let Td2455 : FLOAT =
          let Td2453 : FLOAT =
            let Ti2452 : INT =
              int 0
            in
            v.(Ti2452)
          in
          let Td2454 : FLOAT =
            float 3.14159265359
          in
          fsub Td2453 Td2454
        in
        v.(Ti2451) <- Td2455
      in
      let Ti2456 : INT =
        int 2
      in
      let Td2459 : FLOAT =
        let Td2458 : FLOAT =
          let Ti2457 : INT =
            int 2
          in
          v.(Ti2457)
        in
        fneg Td2458
      in
      v.(Ti2456) <- Td2459
      unit ()
  in
  let Tu10 : UNIT =
    let Td2460 : FLOAT =
      float 1.57079632679
    in
    let Td2462 : FLOAT =
      let Ti2461 : INT =
        int 0
      in
      v.(Ti2461)
    in
    if Td2460 <. Td2462
      let Ti2463 : INT =
        int 0
      in
      let Td2467 : FLOAT =
        let Td2464 : FLOAT =
          float 3.14159265359
        in
        let Td2466 : FLOAT =
          let Ti2465 : INT =
            int 0
          in
          v.(Ti2465)
        in
        fsub Td2464 Td2466
      in
      v.(Ti2463) <- Td2467
      unit ()
  in
  let x : FLOAT =
    let Td2468 : FLOAT =
      float 0.785398163397
    in
    let Td2470 : FLOAT =
      let Ti2469 : INT =
        int 0
      in
      v.(Ti2469)
    in
    if Td2468 <. Td2470
      let Td2474 : FLOAT =
        let Td2471 : FLOAT =
          float 1.57079632679
        in
        let Td2473 : FLOAT =
          let Ti2472 : INT =
            int 0
          in
          v.(Ti2472)
        in
        fsub Td2471 Td2473
      in
      app
        kernel_cos
        Td2474
      let Td2476 : FLOAT =
        let Ti2475 : INT =
          int 0
        in
        v.(Ti2475)
      in
      app
        kernel_sin
        Td2476
  in
  let Td2478 : FLOAT =
    let Ti2477 : INT =
      int 2
    in
    v.(Ti2477)
  in
  let Td2479 : FLOAT =
    float 0.
  in
  if Td2478 <. Td2479
    fneg x
    x
in
letrec cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a : FLOAT =
    let Td2408 : FLOAT =
      float 0.
    in
    if a <. Td2408
      fneg a
      a
  in
  let v : Array of FLOAT =
    let Ti2409 : INT =
      int 3
    in
    extfunapp
      create_float_array
      Ti2409
      a
  in
  let Tu18 : UNIT =
    app
      reduction_2pi
      v
  in
  let Tu17 : UNIT =
    let Td2410 : FLOAT =
      float 3.14159265359
    in
    let Td2412 : FLOAT =
      let Ti2411 : INT =
        int 0
      in
      v.(Ti2411)
    in
    if Td2410 <. Td2412
      let Tu14 : UNIT =
        let Ti2413 : INT =
          int 0
        in
        let Td2417 : FLOAT =
          let Td2415 : FLOAT =
            let Ti2414 : INT =
              int 0
            in
            v.(Ti2414)
          in
          let Td2416 : FLOAT =
            float 3.14159265359
          in
          fsub Td2415 Td2416
        in
        v.(Ti2413) <- Td2417
      in
      let Ti2418 : INT =
        int 2
      in
      let Td2419 : FLOAT =
        float -1.
      in
      v.(Ti2418) <- Td2419
      unit ()
  in
  let Tu16 : UNIT =
    let Td2420 : FLOAT =
      float 1.57079632679
    in
    let Td2422 : FLOAT =
      let Ti2421 : INT =
        int 0
      in
      v.(Ti2421)
    in
    if Td2420 <. Td2422
      let Tu15 : UNIT =
        let Ti2423 : INT =
          int 0
        in
        let Td2427 : FLOAT =
          let Td2424 : FLOAT =
            float 3.14159265359
          in
          let Td2426 : FLOAT =
            let Ti2425 : INT =
              int 0
            in
            v.(Ti2425)
          in
          fsub Td2424 Td2426
        in
        v.(Ti2423) <- Td2427
      in
      let Ti2428 : INT =
        int 2
      in
      let Td2431 : FLOAT =
        let Td2430 : FLOAT =
          let Ti2429 : INT =
            int 2
          in
          v.(Ti2429)
        in
        fneg Td2430
      in
      v.(Ti2428) <- Td2431
      unit ()
  in
  let x : FLOAT =
    let Td2433 : FLOAT =
      let Ti2432 : INT =
        int 0
      in
      v.(Ti2432)
    in
    let Td2434 : FLOAT =
      float 0.785398163397
    in
    if Td2433 <. Td2434
      let Td2436 : FLOAT =
        let Ti2435 : INT =
          int 0
        in
        v.(Ti2435)
      in
      app
        kernel_cos
        Td2436
      let Td2440 : FLOAT =
        let Td2437 : FLOAT =
          float 1.57079632679
        in
        let Td2439 : FLOAT =
          let Ti2438 : INT =
            int 0
          in
          v.(Ti2438)
        in
        fsub Td2437 Td2439
      in
      app
        kernel_sin
        Td2440
  in
  let Td2442 : FLOAT =
    let Ti2441 : INT =
      int 2
    in
    v.(Ti2441)
  in
  let Td2443 : FLOAT =
    float 0.
  in
  if Td2442 <. Td2443
    fneg x
    x
in
letrec sqrt : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2395 : FLOAT =
    float 0.
  in
  if Td2395 <. x
    let t : FLOAT =
      unknown sqrt_init x
    in
    let t : FLOAT =
      let Td2397 : FLOAT =
        let Td2396 : FLOAT =
          fmul t t
        in
        fadd Td2396 x
      in
      let Td2398 : FLOAT =
        fadd t t
      in
      app
        fdiv
        Td2397
        Td2398
    in
    let t : FLOAT =
      let Td2400 : FLOAT =
        let Td2399 : FLOAT =
          fmul t t
        in
        fadd Td2399 x
      in
      let Td2401 : FLOAT =
        fadd t t
      in
      app
        fdiv
        Td2400
        Td2401
    in
    let t : FLOAT =
      let Td2403 : FLOAT =
        let Td2402 : FLOAT =
          fmul t t
        in
        fadd Td2402 x
      in
      let Td2404 : FLOAT =
        fadd t t
      in
      app
        fdiv
        Td2403
        Td2404
    in
    let t : FLOAT =
      let Td2406 : FLOAT =
        let Td2405 : FLOAT =
          fmul t t
        in
        fadd Td2405 x
      in
      let Td2407 : FLOAT =
        fadd t t
      in
      app
        fdiv
        Td2406
        Td2407
    in
    t
    float 0.
in
letrec kernel_atan : (FLOAT -> FLOAT) =
variables : (a1 : FLOAT)
  let a2 : FLOAT =
    fmul a1 a1
  in
  let a3 : FLOAT =
    fmul a2 a1
  in
  let a5 : FLOAT =
    fmul a2 a3
  in
  let a7 : FLOAT =
    fmul a2 a5
  in
  let a9 : FLOAT =
    fmul a2 a7
  in
  let a11 : FLOAT =
    fmul a2 a9
  in
  let a13 : FLOAT =
    fmul a2 a11
  in
  let Td2392 : FLOAT =
    let Td2389 : FLOAT =
      let Td2386 : FLOAT =
        let Td2383 : FLOAT =
          let Td2380 : FLOAT =
            let Td2379 : FLOAT =
              let Td2378 : FLOAT =
                float 0.3333333
              in
              fmul Td2378 a3
            in
            fsub a1 Td2379
          in
          let Td2382 : FLOAT =
            let Td2381 : FLOAT =
              float 0.2
            in
            fmul Td2381 a5
          in
          fadd Td2380 Td2382
        in
        let Td2385 : FLOAT =
          let Td2384 : FLOAT =
            float 0.142857142
          in
          fmul Td2384 a7
        in
        fsub Td2383 Td2385
      in
      let Td2388 : FLOAT =
        let Td2387 : FLOAT =
          float 0.111111104
        in
        fmul Td2387 a9
      in
      fadd Td2386 Td2388
    in
    let Td2391 : FLOAT =
      let Td2390 : FLOAT =
        float 0.08976446
      in
      fmul Td2390 a11
    in
    fsub Td2389 Td2391
  in
  let Td2394 : FLOAT =
    let Td2393 : FLOAT =
      float 0.060035485
    in
    fmul Td2393 a13
  in
  fadd Td2392 Td2394
in
letrec atan : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2362 : FLOAT =
      float 0.
    in
    if Td2362 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Ti2363 : INT =
      int 0
    in
    if flag == Ti2363
      fneg a
      a
  in
  let b : FLOAT =
    let Td2364 : FLOAT =
      float 0.4375
    in
    if a <. Td2364
      app
        kernel_atan
        a
      let Td2365 : FLOAT =
        float 2.4375
      in
      if a <. Td2365
        let Td2366 : FLOAT =
          float 0.785398163397
        in
        let Td2372 : FLOAT =
          let Td2371 : FLOAT =
            let Td2368 : FLOAT =
              let Td2367 : FLOAT =
                float 1.
              in
              fsub a Td2367
            in
            let Td2370 : FLOAT =
              let Td2369 : FLOAT =
                float 1.
              in
              fadd a Td2369
            in
            app
              fdiv
              Td2368
              Td2370
          in
          app
            kernel_atan
            Td2371
        in
        fadd Td2366 Td2372
        let Td2373 : FLOAT =
          float 1.57079632679
        in
        let Td2376 : FLOAT =
          let Td2375 : FLOAT =
            let Td2374 : FLOAT =
              float 1.
            in
            app
              fdiv
              Td2374
              a
          in
          app
            kernel_atan
            Td2375
        in
        fsub Td2373 Td2376
  in
  let Ti2377 : INT =
    int 0
  in
  if flag == Ti2377
    fneg b
    b
in
letrec floor : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let a : FLOAT =
    let Ti2360 : INT =
      ftoi x
    in
    itof Ti2360
  in
  if x <. a
    let Td2361 : FLOAT =
      float 1.
    in
    fsub a Td2361
    a
in
letrec fabs : (FLOAT -> FLOAT) =
variables : (f : FLOAT)
  let Td2359 : FLOAT =
    float 0.
  in
  if f <. Td2359
    fneg f
    f
in
letrec fhalf : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2358 : FLOAT =
    float 0.5
  in
  fmul x Td2358
in
letrec fneg : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fneg x
in
letrec abs_float : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  app
    fabs
    x
in
letrec fispos : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2357 : FLOAT =
    float 0.
  in
  if Td2357 <. x
    int 1
    int 0
in
letrec fisneg : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2356 : FLOAT =
    float 0.
  in
  if x <. Td2356
    int 1
    int 0
in
let n_objects : Array of INT =
  let Ti264 : INT =
    int 1
  in
  let Ti265 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti264
    Ti265
in
let objects : Array of (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
  let dummy : Array of FLOAT =
    let Ti266 : INT =
      int 0
    in
    let Td267 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti266
      Td267
  in
  let Ti268 : INT =
    int 60
  in
  let Tt274 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * INT * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    let Ti269 : INT =
      int 0
    in
    let Ti270 : INT =
      int 0
    in
    let Ti271 : INT =
      int 0
    in
    let Ti272 : INT =
      int 0
    in
    let Ti273 : INT =
      int 0
    in
    Tuple
      Ti269
      Ti270
      Ti271
      Ti272
      dummy
      dummy
      Ti273
      dummy
      dummy
      dummy
      dummy
  in
  extfunapp
    create_array
    Ti268
    Tt274
in
let screen : Array of FLOAT =
  let Ti275 : INT =
    int 3
  in
  let Td276 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti275
    Td276
in
let viewpoint : Array of FLOAT =
  let Ti277 : INT =
    int 3
  in
  let Td278 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti277
    Td278
in
let light : Array of FLOAT =
  let Ti279 : INT =
    int 3
  in
  let Td280 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti279
    Td280
in
let beam : Array of FLOAT =
  let Ti281 : INT =
    int 1
  in
  let Td282 : FLOAT =
    float 255.
  in
  extfunapp
    create_float_array
    Ti281
    Td282
in
let and_net : Array of Array of INT =
  let Ti283 : INT =
    int 50
  in
  let Ta287 : Array of INT =
    let Ti284 : INT =
      int 1
    in
    let Ti286 : INT =
      let Ti285 : INT =
        int 1
      in
      neg Ti285
    in
    extfunapp
      create_array
      Ti284
      Ti286
  in
  extfunapp
    create_array
    Ti283
    Ta287
in
let or_net : Array of Array of Array of INT =
  let Ti288 : INT =
    int 1
  in
  let Ta292 : Array of Array of INT =
    let Ti289 : INT =
      int 1
    in
    let Ta291 : Array of INT =
      let Ti290 : INT =
        int 0
      in
      and_net.(Ti290)
    in
    extfunapp
      create_array
      Ti289
      Ta291
  in
  extfunapp
    create_array
    Ti288
    Ta292
in
let solver_dist : Array of FLOAT =
  let Ti293 : INT =
    int 1
  in
  let Td294 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti293
    Td294
in
let intsec_rectside : Array of INT =
  let Ti295 : INT =
    int 1
  in
  let Ti296 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti295
    Ti296
in
let tmin : Array of FLOAT =
  let Ti297 : INT =
    int 1
  in
  let Td298 : FLOAT =
    float 1000000000.
  in
  extfunapp
    create_float_array
    Ti297
    Td298
in
let intersection_point : Array of FLOAT =
  let Ti299 : INT =
    int 3
  in
  let Td300 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti299
    Td300
in
let intersected_object_id : Array of INT =
  let Ti301 : INT =
    int 1
  in
  let Ti302 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti301
    Ti302
in
let nvector : Array of FLOAT =
  let Ti303 : INT =
    int 3
  in
  let Td304 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti303
    Td304
in
let texture_color : Array of FLOAT =
  let Ti305 : INT =
    int 3
  in
  let Td306 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti305
    Td306
in
let diffuse_ray : Array of FLOAT =
  let Ti307 : INT =
    int 3
  in
  let Td308 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti307
    Td308
in
let rgb : Array of FLOAT =
  let Ti309 : INT =
    int 3
  in
  let Td310 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti309
    Td310
in
let image_size : Array of INT =
  let Ti311 : INT =
    int 2
  in
  let Ti312 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti311
    Ti312
in
let image_center : Array of INT =
  let Ti313 : INT =
    int 2
  in
  let Ti314 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti313
    Ti314
in
let scan_pitch : Array of FLOAT =
  let Ti315 : INT =
    int 1
  in
  let Td316 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti315
    Td316
in
let startp : Array of FLOAT =
  let Ti317 : INT =
    int 3
  in
  let Td318 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti317
    Td318
in
let startp_fast : Array of FLOAT =
  let Ti319 : INT =
    int 3
  in
  let Td320 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti319
    Td320
in
let screenx_dir : Array of FLOAT =
  let Ti321 : INT =
    int 3
  in
  let Td322 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti321
    Td322
in
let screeny_dir : Array of FLOAT =
  let Ti323 : INT =
    int 3
  in
  let Td324 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti323
    Td324
in
let screenz_dir : Array of FLOAT =
  let Ti325 : INT =
    int 3
  in
  let Td326 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti325
    Td326
in
let ptrace_dirvec : Array of FLOAT =
  let Ti327 : INT =
    int 3
  in
  let Td328 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti327
    Td328
in
let dirvecs : Array of Array of (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf : Array of FLOAT =
    let Ti329 : INT =
      int 0
    in
    let Td330 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti329
      Td330
  in
  let dummyff : Array of Array of FLOAT =
    let Ti331 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti331
      dummyf
  in
  let dummy_vs : Array of (Array of FLOAT * Array of Array of FLOAT) =
    let Ti332 : INT =
      int 0
    in
    let Tt333 : (Array of FLOAT * Array of Array of FLOAT) =
      Tuple
        dummyf
        dummyff
    in
    extfunapp
      create_array
      Ti332
      Tt333
  in
  let Ti334 : INT =
    int 5
  in
  extfunapp
    create_array
    Ti334
    dummy_vs
in
let light_dirvec : (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf2 : Array of FLOAT =
    let Ti335 : INT =
      int 0
    in
    let Td336 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti335
      Td336
  in
  let v3 : Array of FLOAT =
    let Ti337 : INT =
      int 3
    in
    let Td338 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti337
      Td338
  in
  let consts : Array of Array of FLOAT =
    let Ti339 : INT =
      int 60
    in
    extfunapp
      create_array
      Ti339
      dummyf2
  in
  Tuple
    v3
    consts
in
let reflections : Array of (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
  let dummyf3 : Array of FLOAT =
    let Ti340 : INT =
      int 0
    in
    let Td341 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti340
      Td341
  in
  let dummyff3 : Array of Array of FLOAT =
    let Ti342 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti342
      dummyf3
  in
  let dummydv : (Array of FLOAT * Array of Array of FLOAT) =
    Tuple
      dummyf3
      dummyff3
  in
  let Ti343 : INT =
    int 180
  in
  let Tt346 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    let Ti344 : INT =
      int 0
    in
    let Td345 : FLOAT =
      float 0.
    in
    Tuple
      Ti344
      dummydv
      Td345
  in
  extfunapp
    create_array
    Ti343
    Tt346
in
let n_reflections : Array of INT =
  let Ti347 : INT =
    int 1
  in
  let Ti348 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti347
    Ti348
in
letrec xor : (BOOL -> (BOOL -> BOOL)) =
variables : (x : BOOL), (y : BOOL)
  let Ti2354 : INT =
    int 0
  in
  if x == Ti2354
    y
    let Ti2355 : INT =
      int 0
    in
    if y == Ti2355
      int 1
      int 0
in
letrec sgn : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  if x == 0.0 
    float 0.
    let Tb2352 : BOOL =
      app
        fispos
        x
    in
    let Ti2353 : INT =
      int 0
    in
    if Tb2352 == Ti2353
      float -1.
      float 1.
in
letrec fneg_cond : (BOOL -> (FLOAT -> FLOAT)) =
variables : (cond : BOOL), (x : FLOAT)
  let Ti2351 : INT =
    int 0
  in
  if cond == Ti2351
    app
      fneg
      x
    x
in
letrec add_mod5 : (INT -> (INT -> INT)) =
variables : (x : INT), (y : INT)
  let sum : INT =
    add x y
  in
  let Ti2349 : INT =
    int 5
  in
  if Ti2349 <= sum
    let Ti2350 : INT =
      int 5
    in
    sub sum Ti2350
    sum
in
letrec vecset : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))) =
variables : (v : Array of FLOAT), (x : FLOAT), (y : FLOAT), (z : FLOAT)
  let Tu20 : UNIT =
    let Ti2346 : INT =
      int 0
    in
    v.(Ti2346) <- x
  in
  let Tu19 : UNIT =
    let Ti2347 : INT =
      int 1
    in
    v.(Ti2347) <- y
  in
  let Ti2348 : INT =
    int 2
  in
  v.(Ti2348) <- z
in
letrec vecfill : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (v : Array of FLOAT), (elem : FLOAT)
  let Tu22 : UNIT =
    let Ti2343 : INT =
      int 0
    in
    v.(Ti2343) <- elem
  in
  let Tu21 : UNIT =
    let Ti2344 : INT =
      int 1
    in
    v.(Ti2344) <- elem
  in
  let Ti2345 : INT =
    int 2
  in
  v.(Ti2345) <- elem
in
letrec vecbzero : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2342 : FLOAT =
    float 0.
  in
  app
    vecfill
    v
    Td2342
in
letrec veccpy : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (src : Array of FLOAT)
  let Tu24 : UNIT =
    let Ti2333 : INT =
      int 0
    in
    let Td2335 : FLOAT =
      let Ti2334 : INT =
        int 0
      in
      src.(Ti2334)
    in
    dest.(Ti2333) <- Td2335
  in
  let Tu23 : UNIT =
    let Ti2336 : INT =
      int 1
    in
    let Td2338 : FLOAT =
      let Ti2337 : INT =
        int 1
      in
      src.(Ti2337)
    in
    dest.(Ti2336) <- Td2338
  in
  let Ti2339 : INT =
    int 2
  in
  let Td2341 : FLOAT =
    let Ti2340 : INT =
      int 2
    in
    src.(Ti2340)
  in
  dest.(Ti2339) <- Td2341
in
letrec vecdist2 : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (p : Array of FLOAT), (q : Array of FLOAT)
  let Td2326 : FLOAT =
    let Td2319 : FLOAT =
      let Td2318 : FLOAT =
        let Td2315 : FLOAT =
          let Ti2314 : INT =
            int 0
          in
          p.(Ti2314)
        in
        let Td2317 : FLOAT =
          let Ti2316 : INT =
            int 0
          in
          q.(Ti2316)
        in
        fsub Td2315 Td2317
      in
      unknown fsqr Td2318
    in
    let Td2325 : FLOAT =
      let Td2324 : FLOAT =
        let Td2321 : FLOAT =
          let Ti2320 : INT =
            int 1
          in
          p.(Ti2320)
        in
        let Td2323 : FLOAT =
          let Ti2322 : INT =
            int 1
          in
          q.(Ti2322)
        in
        fsub Td2321 Td2323
      in
      unknown fsqr Td2324
    in
    fadd Td2319 Td2325
  in
  let Td2332 : FLOAT =
    let Td2331 : FLOAT =
      let Td2328 : FLOAT =
        let Ti2327 : INT =
          int 2
        in
        p.(Ti2327)
      in
      let Td2330 : FLOAT =
        let Ti2329 : INT =
          int 2
        in
        q.(Ti2329)
      in
      fsub Td2328 Td2330
    in
    unknown fsqr Td2331
  in
  fadd Td2326 Td2332
in
letrec vecunit : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let il : FLOAT =
    let Td2289 : FLOAT =
      float 1.
    in
    let Td2301 : FLOAT =
      let Td2300 : FLOAT =
        let Td2296 : FLOAT =
          let Td2292 : FLOAT =
            let Td2291 : FLOAT =
              let Ti2290 : INT =
                int 0
              in
              v.(Ti2290)
            in
            unknown fsqr Td2291
          in
          let Td2295 : FLOAT =
            let Td2294 : FLOAT =
              let Ti2293 : INT =
                int 1
              in
              v.(Ti2293)
            in
            unknown fsqr Td2294
          in
          fadd Td2292 Td2295
        in
        let Td2299 : FLOAT =
          let Td2298 : FLOAT =
            let Ti2297 : INT =
              int 2
            in
            v.(Ti2297)
          in
          unknown fsqr Td2298
        in
        fadd Td2296 Td2299
      in
      app
        sqrt
        Td2300
    in
    app
      fdiv
      Td2289
      Td2301
  in
  let Tu26 : UNIT =
    let Ti2302 : INT =
      int 0
    in
    let Td2305 : FLOAT =
      let Td2304 : FLOAT =
        let Ti2303 : INT =
          int 0
        in
        v.(Ti2303)
      in
      fmul Td2304 il
    in
    v.(Ti2302) <- Td2305
  in
  let Tu25 : UNIT =
    let Ti2306 : INT =
      int 1
    in
    let Td2309 : FLOAT =
      let Td2308 : FLOAT =
        let Ti2307 : INT =
          int 1
        in
        v.(Ti2307)
      in
      fmul Td2308 il
    in
    v.(Ti2306) <- Td2309
  in
  let Ti2310 : INT =
    int 2
  in
  let Td2313 : FLOAT =
    let Td2312 : FLOAT =
      let Ti2311 : INT =
        int 2
      in
      v.(Ti2311)
    in
    fmul Td2312 il
  in
  v.(Ti2310) <- Td2313
in
letrec vecunit_sgn : (Array of FLOAT -> (BOOL -> UNIT)) =
variables : (v : Array of FLOAT), (inv : BOOL)
  let l : FLOAT =
    let Td2273 : FLOAT =
      let Td2269 : FLOAT =
        let Td2265 : FLOAT =
          let Td2264 : FLOAT =
            let Ti2263 : INT =
              int 0
            in
            v.(Ti2263)
          in
          unknown fsqr Td2264
        in
        let Td2268 : FLOAT =
          let Td2267 : FLOAT =
            let Ti2266 : INT =
              int 1
            in
            v.(Ti2266)
          in
          unknown fsqr Td2267
        in
        fadd Td2265 Td2268
      in
      let Td2272 : FLOAT =
        let Td2271 : FLOAT =
          let Ti2270 : INT =
            int 2
          in
          v.(Ti2270)
        in
        unknown fsqr Td2271
      in
      fadd Td2269 Td2272
    in
    app
      sqrt
      Td2273
  in
  let il : FLOAT =
    if l == 0.0 
      float 1.
      let Ti2274 : INT =
        int 0
      in
      if inv == Ti2274
        let Td2275 : FLOAT =
          float 1.
        in
        app
          fdiv
          Td2275
          l
        let Td2276 : FLOAT =
          float -1.
        in
        app
          fdiv
          Td2276
          l
  in
  let Tu28 : UNIT =
    let Ti2277 : INT =
      int 0
    in
    let Td2280 : FLOAT =
      let Td2279 : FLOAT =
        let Ti2278 : INT =
          int 0
        in
        v.(Ti2278)
      in
      fmul Td2279 il
    in
    v.(Ti2277) <- Td2280
  in
  let Tu27 : UNIT =
    let Ti2281 : INT =
      int 1
    in
    let Td2284 : FLOAT =
      let Td2283 : FLOAT =
        let Ti2282 : INT =
          int 1
        in
        v.(Ti2282)
      in
      fmul Td2283 il
    in
    v.(Ti2281) <- Td2284
  in
  let Ti2285 : INT =
    int 2
  in
  let Td2288 : FLOAT =
    let Td2287 : FLOAT =
      let Ti2286 : INT =
        int 2
      in
      v.(Ti2286)
    in
    fmul Td2287 il
  in
  v.(Ti2285) <- Td2288
in
letrec veciprod : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (v : Array of FLOAT), (w : Array of FLOAT)
  let Td2257 : FLOAT =
    let Td2251 : FLOAT =
      let Td2248 : FLOAT =
        let Ti2247 : INT =
          int 0
        in
        v.(Ti2247)
      in
      let Td2250 : FLOAT =
        let Ti2249 : INT =
          int 0
        in
        w.(Ti2249)
      in
      fmul Td2248 Td2250
    in
    let Td2256 : FLOAT =
      let Td2253 : FLOAT =
        let Ti2252 : INT =
          int 1
        in
        v.(Ti2252)
      in
      let Td2255 : FLOAT =
        let Ti2254 : INT =
          int 1
        in
        w.(Ti2254)
      in
      fmul Td2253 Td2255
    in
    fadd Td2251 Td2256
  in
  let Td2262 : FLOAT =
    let Td2259 : FLOAT =
      let Ti2258 : INT =
        int 2
      in
      v.(Ti2258)
    in
    let Td2261 : FLOAT =
      let Ti2260 : INT =
        int 2
      in
      w.(Ti2260)
    in
    fmul Td2259 Td2261
  in
  fadd Td2257 Td2262
in
letrec veciprod2 : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (v : Array of FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let Td2243 : FLOAT =
    let Td2239 : FLOAT =
      let Td2238 : FLOAT =
        let Ti2237 : INT =
          int 0
        in
        v.(Ti2237)
      in
      fmul Td2238 w0
    in
    let Td2242 : FLOAT =
      let Td2241 : FLOAT =
        let Ti2240 : INT =
          int 1
        in
        v.(Ti2240)
      in
      fmul Td2241 w1
    in
    fadd Td2239 Td2242
  in
  let Td2246 : FLOAT =
    let Td2245 : FLOAT =
      let Ti2244 : INT =
        int 2
      in
      v.(Ti2244)
    in
    fmul Td2245 w2
  in
  fadd Td2243 Td2246
in
letrec vecaccum : (Array of FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (scale : FLOAT), (v : Array of FLOAT)
  let Tu30 : UNIT =
    let Ti2216 : INT =
      int 0
    in
    let Td2222 : FLOAT =
      let Td2218 : FLOAT =
        let Ti2217 : INT =
          int 0
        in
        dest.(Ti2217)
      in
      let Td2221 : FLOAT =
        let Td2220 : FLOAT =
          let Ti2219 : INT =
            int 0
          in
          v.(Ti2219)
        in
        fmul scale Td2220
      in
      fadd Td2218 Td2221
    in
    dest.(Ti2216) <- Td2222
  in
  let Tu29 : UNIT =
    let Ti2223 : INT =
      int 1
    in
    let Td2229 : FLOAT =
      let Td2225 : FLOAT =
        let Ti2224 : INT =
          int 1
        in
        dest.(Ti2224)
      in
      let Td2228 : FLOAT =
        let Td2227 : FLOAT =
          let Ti2226 : INT =
            int 1
          in
          v.(Ti2226)
        in
        fmul scale Td2227
      in
      fadd Td2225 Td2228
    in
    dest.(Ti2223) <- Td2229
  in
  let Ti2230 : INT =
    int 2
  in
  let Td2236 : FLOAT =
    let Td2232 : FLOAT =
      let Ti2231 : INT =
        int 2
      in
      dest.(Ti2231)
    in
    let Td2235 : FLOAT =
      let Td2234 : FLOAT =
        let Ti2233 : INT =
          int 2
        in
        v.(Ti2233)
      in
      fmul scale Td2234
    in
    fadd Td2232 Td2235
  in
  dest.(Ti2230) <- Td2236
in
letrec vecadd : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu32 : UNIT =
    let Ti2198 : INT =
      int 0
    in
    let Td2203 : FLOAT =
      let Td2200 : FLOAT =
        let Ti2199 : INT =
          int 0
        in
        dest.(Ti2199)
      in
      let Td2202 : FLOAT =
        let Ti2201 : INT =
          int 0
        in
        v.(Ti2201)
      in
      fadd Td2200 Td2202
    in
    dest.(Ti2198) <- Td2203
  in
  let Tu31 : UNIT =
    let Ti2204 : INT =
      int 1
    in
    let Td2209 : FLOAT =
      let Td2206 : FLOAT =
        let Ti2205 : INT =
          int 1
        in
        dest.(Ti2205)
      in
      let Td2208 : FLOAT =
        let Ti2207 : INT =
          int 1
        in
        v.(Ti2207)
      in
      fadd Td2206 Td2208
    in
    dest.(Ti2204) <- Td2209
  in
  let Ti2210 : INT =
    int 2
  in
  let Td2215 : FLOAT =
    let Td2212 : FLOAT =
      let Ti2211 : INT =
        int 2
      in
      dest.(Ti2211)
    in
    let Td2214 : FLOAT =
      let Ti2213 : INT =
        int 2
      in
      v.(Ti2213)
    in
    fadd Td2212 Td2214
  in
  dest.(Ti2210) <- Td2215
in
letrec vecmul : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu34 : UNIT =
    let Ti2180 : INT =
      int 0
    in
    let Td2185 : FLOAT =
      let Td2182 : FLOAT =
        let Ti2181 : INT =
          int 0
        in
        dest.(Ti2181)
      in
      let Td2184 : FLOAT =
        let Ti2183 : INT =
          int 0
        in
        v.(Ti2183)
      in
      fmul Td2182 Td2184
    in
    dest.(Ti2180) <- Td2185
  in
  let Tu33 : UNIT =
    let Ti2186 : INT =
      int 1
    in
    let Td2191 : FLOAT =
      let Td2188 : FLOAT =
        let Ti2187 : INT =
          int 1
        in
        dest.(Ti2187)
      in
      let Td2190 : FLOAT =
        let Ti2189 : INT =
          int 1
        in
        v.(Ti2189)
      in
      fmul Td2188 Td2190
    in
    dest.(Ti2186) <- Td2191
  in
  let Ti2192 : INT =
    int 2
  in
  let Td2197 : FLOAT =
    let Td2194 : FLOAT =
      let Ti2193 : INT =
        int 2
      in
      dest.(Ti2193)
    in
    let Td2196 : FLOAT =
      let Ti2195 : INT =
        int 2
      in
      v.(Ti2195)
    in
    fmul Td2194 Td2196
  in
  dest.(Ti2192) <- Td2197
in
letrec vecscale : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (scale : FLOAT)
  let Tu36 : UNIT =
    let Ti2168 : INT =
      int 0
    in
    let Td2171 : FLOAT =
      let Td2170 : FLOAT =
        let Ti2169 : INT =
          int 0
        in
        dest.(Ti2169)
      in
      fmul Td2170 scale
    in
    dest.(Ti2168) <- Td2171
  in
  let Tu35 : UNIT =
    let Ti2172 : INT =
      int 1
    in
    let Td2175 : FLOAT =
      let Td2174 : FLOAT =
        let Ti2173 : INT =
          int 1
        in
        dest.(Ti2173)
      in
      fmul Td2174 scale
    in
    dest.(Ti2172) <- Td2175
  in
  let Ti2176 : INT =
    int 2
  in
  let Td2179 : FLOAT =
    let Td2178 : FLOAT =
      let Ti2177 : INT =
        int 2
      in
      dest.(Ti2177)
    in
    fmul Td2178 scale
  in
  dest.(Ti2176) <- Td2179
in
letrec vecaccumv : (Array of FLOAT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT), (w : Array of FLOAT)
  let Tu38 : UNIT =
    let Ti2141 : INT =
      int 0
    in
    let Td2149 : FLOAT =
      let Td2143 : FLOAT =
        let Ti2142 : INT =
          int 0
        in
        dest.(Ti2142)
      in
      let Td2148 : FLOAT =
        let Td2145 : FLOAT =
          let Ti2144 : INT =
            int 0
          in
          v.(Ti2144)
        in
        let Td2147 : FLOAT =
          let Ti2146 : INT =
            int 0
          in
          w.(Ti2146)
        in
        fmul Td2145 Td2147
      in
      fadd Td2143 Td2148
    in
    dest.(Ti2141) <- Td2149
  in
  let Tu37 : UNIT =
    let Ti2150 : INT =
      int 1
    in
    let Td2158 : FLOAT =
      let Td2152 : FLOAT =
        let Ti2151 : INT =
          int 1
        in
        dest.(Ti2151)
      in
      let Td2157 : FLOAT =
        let Td2154 : FLOAT =
          let Ti2153 : INT =
            int 1
          in
          v.(Ti2153)
        in
        let Td2156 : FLOAT =
          let Ti2155 : INT =
            int 1
          in
          w.(Ti2155)
        in
        fmul Td2154 Td2156
      in
      fadd Td2152 Td2157
    in
    dest.(Ti2150) <- Td2158
  in
  let Ti2159 : INT =
    int 2
  in
  let Td2167 : FLOAT =
    let Td2161 : FLOAT =
      let Ti2160 : INT =
        int 2
      in
      dest.(Ti2160)
    in
    let Td2166 : FLOAT =
      let Td2163 : FLOAT =
        let Ti2162 : INT =
          int 2
        in
        v.(Ti2162)
      in
      let Td2165 : FLOAT =
        let Ti2164 : INT =
          int 2
        in
        w.(Ti2164)
      in
      fmul Td2163 Td2165
    in
    fadd Td2161 Td2166
  in
  dest.(Ti2159) <- Td2167
in
letrec o_texturetype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (m_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_tex
in
letrec o_form : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (m_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_shape
in
letrec o_reflectiontype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_surface
in
letrec o_isinvert : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> BOOL) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (m_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_invert
in
letrec o_isrot : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (m_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_isrot
in
letrec o_param_a : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2140 : INT =
      int 0
    in
    m_abc.(Ti2140)
in
letrec o_param_b : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2139 : INT =
      int 1
    in
    m_abc.(Ti2139)
in
letrec o_param_c : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2138 : INT =
      int 2
    in
    m_abc.(Ti2138)
in
letrec o_param_abc : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_abc
in
letrec o_param_x : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2137 : INT =
      int 0
    in
    m_xyz.(Ti2137)
in
letrec o_param_y : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2136 : INT =
      int 1
    in
    m_xyz.(Ti2136)
in
letrec o_param_z : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2135 : INT =
      int 2
    in
    m_xyz.(Ti2135)
in
letrec o_diffuse : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2134 : INT =
      int 0
    in
    m_surfparams.(Ti2134)
in
letrec o_hilight : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2133 : INT =
      int 1
    in
    m_surfparams.(Ti2133)
in
letrec o_color_red : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2132 : INT =
      int 0
    in
    m_color.(Ti2132)
in
letrec o_color_green : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2131 : INT =
      int 1
    in
    m_color.(Ti2131)
in
letrec o_color_blue : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2130 : INT =
      int 2
    in
    m_color.(Ti2130)
in
letrec o_param_r1 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2129 : INT =
      int 0
    in
    m_rot123.(Ti2129)
in
letrec o_param_r2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2128 : INT =
      int 1
    in
    m_rot123.(Ti2128)
in
letrec o_param_r3 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2127 : INT =
      int 2
    in
    m_rot123.(Ti2127)
in
letrec o_param_ctbl : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (m_ctbl : Array of FLOAT)
    m
  in
    m_ctbl
in
letrec p_rgb : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (m_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_rgb
in
letrec p_intersection_points : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (m_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_isect_ps
in
letrec p_surface_ids : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (m_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_sids
in
letrec p_calc_diffuse : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of BOOL) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (m_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_cdif
in
letrec p_energy : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (m_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_engy
in
letrec p_received_ray_20percent : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (m_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_r20p
in
letrec p_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2126 : INT =
      int 0
    in
    m_gid.(Ti2126)
in
letrec p_set_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (id : INT)
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2125 : INT =
      int 0
    in
    m_gid.(Ti2125) <- id
in
letrec p_nvectors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (m_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_nvectors
in
letrec d_vec : ((Array of FLOAT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (m_vec : Array of FLOAT), (xm_const : Array of Array of FLOAT)
    d
  in
    m_vec
in
letrec d_const : ((Array of FLOAT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (dm_vec : Array of FLOAT), (m_const : Array of Array of FLOAT)
    d
  in
    m_const
in
letrec r_surface_id : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> INT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (m_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_sid
in
letrec r_dvec : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (m_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_dvec
in
letrec r_bright : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> FLOAT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (m_br : FLOAT)
    r
  in
    m_br
in
letrec rad : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2124 : FLOAT =
    float 0.017453293
  in
  fmul x Td2124
in
letrec read_screen_settings : (UNIT -> UNIT) =
variables : (Tu39 : UNIT)
  let Tu53 : UNIT =
    let Ti2069 : INT =
      int 0
    in
    let Td2071 : FLOAT =
      let Tu2070 : UNIT =
        unit ()
      in
      unknown inflt Tu2070
    in
    screen.(Ti2069) <- Td2071
  in
  let Tu52 : UNIT =
    let Ti2072 : INT =
      int 1
    in
    let Td2074 : FLOAT =
      let Tu2073 : UNIT =
        unit ()
      in
      unknown inflt Tu2073
    in
    screen.(Ti2072) <- Td2074
  in
  let Tu51 : UNIT =
    let Ti2075 : INT =
      int 2
    in
    let Td2077 : FLOAT =
      let Tu2076 : UNIT =
        unit ()
      in
      unknown inflt Tu2076
    in
    screen.(Ti2075) <- Td2077
  in
  let v1 : FLOAT =
    let Td2079 : FLOAT =
      let Tu2078 : UNIT =
        unit ()
      in
      unknown inflt Tu2078
    in
    app
      rad
      Td2079
  in
  let cos_v1 : FLOAT =
    app
      cos
      v1
  in
  let sin_v1 : FLOAT =
    app
      sin
      v1
  in
  let v2 : FLOAT =
    let Td2081 : FLOAT =
      let Tu2080 : UNIT =
        unit ()
      in
      unknown inflt Tu2080
    in
    app
      rad
      Td2081
  in
  let cos_v2 : FLOAT =
    app
      cos
      v2
  in
  let sin_v2 : FLOAT =
    app
      sin
      v2
  in
  let Tu50 : UNIT =
    let Ti2082 : INT =
      int 0
    in
    let Td2085 : FLOAT =
      let Td2083 : FLOAT =
        fmul cos_v1 sin_v2
      in
      let Td2084 : FLOAT =
        float 200.
      in
      fmul Td2083 Td2084
    in
    screenz_dir.(Ti2082) <- Td2085
  in
  let Tu49 : UNIT =
    let Ti2086 : INT =
      int 1
    in
    let Td2088 : FLOAT =
      let Td2087 : FLOAT =
        float -200.
      in
      fmul sin_v1 Td2087
    in
    screenz_dir.(Ti2086) <- Td2088
  in
  let Tu48 : UNIT =
    let Ti2089 : INT =
      int 2
    in
    let Td2092 : FLOAT =
      let Td2090 : FLOAT =
        fmul cos_v1 cos_v2
      in
      let Td2091 : FLOAT =
        float 200.
      in
      fmul Td2090 Td2091
    in
    screenz_dir.(Ti2089) <- Td2092
  in
  let Tu47 : UNIT =
    let Ti2093 : INT =
      int 0
    in
    screenx_dir.(Ti2093) <- cos_v2
  in
  let Tu46 : UNIT =
    let Ti2094 : INT =
      int 1
    in
    let Td2095 : FLOAT =
      float 0.
    in
    screenx_dir.(Ti2094) <- Td2095
  in
  let Tu45 : UNIT =
    let Ti2096 : INT =
      int 2
    in
    let Td2097 : FLOAT =
      app
        fneg
        sin_v2
    in
    screenx_dir.(Ti2096) <- Td2097
  in
  let Tu44 : UNIT =
    let Ti2098 : INT =
      int 0
    in
    let Td2100 : FLOAT =
      let Td2099 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2099 sin_v2
    in
    screeny_dir.(Ti2098) <- Td2100
  in
  let Tu43 : UNIT =
    let Ti2101 : INT =
      int 1
    in
    let Td2102 : FLOAT =
      app
        fneg
        cos_v1
    in
    screeny_dir.(Ti2101) <- Td2102
  in
  let Tu42 : UNIT =
    let Ti2103 : INT =
      int 2
    in
    let Td2105 : FLOAT =
      let Td2104 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2104 cos_v2
    in
    screeny_dir.(Ti2103) <- Td2105
  in
  let Tu41 : UNIT =
    let Ti2106 : INT =
      int 0
    in
    let Td2111 : FLOAT =
      let Td2108 : FLOAT =
        let Ti2107 : INT =
          int 0
        in
        screen.(Ti2107)
      in
      let Td2110 : FLOAT =
        let Ti2109 : INT =
          int 0
        in
        screenz_dir.(Ti2109)
      in
      fsub Td2108 Td2110
    in
    viewpoint.(Ti2106) <- Td2111
  in
  let Tu40 : UNIT =
    let Ti2112 : INT =
      int 1
    in
    let Td2117 : FLOAT =
      let Td2114 : FLOAT =
        let Ti2113 : INT =
          int 1
        in
        screen.(Ti2113)
      in
      let Td2116 : FLOAT =
        let Ti2115 : INT =
          int 1
        in
        screenz_dir.(Ti2115)
      in
      fsub Td2114 Td2116
    in
    viewpoint.(Ti2112) <- Td2117
  in
  let Ti2118 : INT =
    int 2
  in
  let Td2123 : FLOAT =
    let Td2120 : FLOAT =
      let Ti2119 : INT =
        int 2
      in
      screen.(Ti2119)
    in
    let Td2122 : FLOAT =
      let Ti2121 : INT =
        int 2
      in
      screenz_dir.(Ti2121)
    in
    fsub Td2120 Td2122
  in
  viewpoint.(Ti2118) <- Td2123
in
letrec read_light : (UNIT -> UNIT) =
variables : (Tu54 : UNIT)
  let nl : INT =
    let Tu2055 : UNIT =
      unit ()
    in
    unknown inint Tu2055
  in
  let l1 : FLOAT =
    let Td2057 : FLOAT =
      let Tu2056 : UNIT =
        unit ()
      in
      unknown inflt Tu2056
    in
    app
      rad
      Td2057
  in
  let sl1 : FLOAT =
    app
      sin
      l1
  in
  let Tu57 : UNIT =
    let Ti2058 : INT =
      int 1
    in
    let Td2059 : FLOAT =
      app
        fneg
        sl1
    in
    light.(Ti2058) <- Td2059
  in
  let l2 : FLOAT =
    let Td2061 : FLOAT =
      let Tu2060 : UNIT =
        unit ()
      in
      unknown inflt Tu2060
    in
    app
      rad
      Td2061
  in
  let cl1 : FLOAT =
    app
      cos
      l1
  in
  let sl2 : FLOAT =
    app
      sin
      l2
  in
  let Tu56 : UNIT =
    let Ti2062 : INT =
      int 0
    in
    let Td2063 : FLOAT =
      fmul cl1 sl2
    in
    light.(Ti2062) <- Td2063
  in
  let cl2 : FLOAT =
    app
      cos
      l2
  in
  let Tu55 : UNIT =
    let Ti2064 : INT =
      int 2
    in
    let Td2065 : FLOAT =
      fmul cl1 cl2
    in
    light.(Ti2064) <- Td2065
  in
  let Ti2066 : INT =
    int 0
  in
  let Td2068 : FLOAT =
    let Tu2067 : UNIT =
      unit ()
    in
    unknown inflt Tu2067
  in
  beam.(Ti2066) <- Td2068
in
letrec rotate_quadratic_matrix : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (abc : Array of FLOAT), (rot : Array of FLOAT)
  let cos_x : FLOAT =
    let Td1969 : FLOAT =
      let Ti1968 : INT =
        int 0
      in
      rot.(Ti1968)
    in
    app
      cos
      Td1969
  in
  let sin_x : FLOAT =
    let Td1971 : FLOAT =
      let Ti1970 : INT =
        int 0
      in
      rot.(Ti1970)
    in
    app
      sin
      Td1971
  in
  let cos_y : FLOAT =
    let Td1973 : FLOAT =
      let Ti1972 : INT =
        int 1
      in
      rot.(Ti1972)
    in
    app
      cos
      Td1973
  in
  let sin_y : FLOAT =
    let Td1975 : FLOAT =
      let Ti1974 : INT =
        int 1
      in
      rot.(Ti1974)
    in
    app
      sin
      Td1975
  in
  let cos_z : FLOAT =
    let Td1977 : FLOAT =
      let Ti1976 : INT =
        int 2
      in
      rot.(Ti1976)
    in
    app
      cos
      Td1977
  in
  let sin_z : FLOAT =
    let Td1979 : FLOAT =
      let Ti1978 : INT =
        int 2
      in
      rot.(Ti1978)
    in
    app
      sin
      Td1979
  in
  let m00 : FLOAT =
    fmul cos_y cos_z
  in
  let m01 : FLOAT =
    let Td1981 : FLOAT =
      let Td1980 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td1980 cos_z
    in
    let Td1982 : FLOAT =
      fmul cos_x sin_z
    in
    fsub Td1981 Td1982
  in
  let m02 : FLOAT =
    let Td1984 : FLOAT =
      let Td1983 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td1983 cos_z
    in
    let Td1985 : FLOAT =
      fmul sin_x sin_z
    in
    fadd Td1984 Td1985
  in
  let m10 : FLOAT =
    fmul cos_y sin_z
  in
  let m11 : FLOAT =
    let Td1987 : FLOAT =
      let Td1986 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td1986 sin_z
    in
    let Td1988 : FLOAT =
      fmul cos_x cos_z
    in
    fadd Td1987 Td1988
  in
  let m12 : FLOAT =
    let Td1990 : FLOAT =
      let Td1989 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td1989 sin_z
    in
    let Td1991 : FLOAT =
      fmul sin_x cos_z
    in
    fsub Td1990 Td1991
  in
  let m20 : FLOAT =
    app
      fneg
      sin_y
  in
  let m21 : FLOAT =
    fmul sin_x cos_y
  in
  let m22 : FLOAT =
    fmul cos_x cos_y
  in
  let ao : FLOAT =
    let Ti1992 : INT =
      int 0
    in
    abc.(Ti1992)
  in
  let bo : FLOAT =
    let Ti1993 : INT =
      int 1
    in
    abc.(Ti1993)
  in
  let co : FLOAT =
    let Ti1994 : INT =
      int 2
    in
    abc.(Ti1994)
  in
  let Tu62 : UNIT =
    let Ti1995 : INT =
      int 0
    in
    let Td2003 : FLOAT =
      let Td2000 : FLOAT =
        let Td1997 : FLOAT =
          let Td1996 : FLOAT =
            unknown fsqr m00
          in
          fmul ao Td1996
        in
        let Td1999 : FLOAT =
          let Td1998 : FLOAT =
            unknown fsqr m10
          in
          fmul bo Td1998
        in
        fadd Td1997 Td1999
      in
      let Td2002 : FLOAT =
        let Td2001 : FLOAT =
          unknown fsqr m20
        in
        fmul co Td2001
      in
      fadd Td2000 Td2002
    in
    abc.(Ti1995) <- Td2003
  in
  let Tu61 : UNIT =
    let Ti2004 : INT =
      int 1
    in
    let Td2012 : FLOAT =
      let Td2009 : FLOAT =
        let Td2006 : FLOAT =
          let Td2005 : FLOAT =
            unknown fsqr m01
          in
          fmul ao Td2005
        in
        let Td2008 : FLOAT =
          let Td2007 : FLOAT =
            unknown fsqr m11
          in
          fmul bo Td2007
        in
        fadd Td2006 Td2008
      in
      let Td2011 : FLOAT =
        let Td2010 : FLOAT =
          unknown fsqr m21
        in
        fmul co Td2010
      in
      fadd Td2009 Td2011
    in
    abc.(Ti2004) <- Td2012
  in
  let Tu60 : UNIT =
    let Ti2013 : INT =
      int 2
    in
    let Td2021 : FLOAT =
      let Td2018 : FLOAT =
        let Td2015 : FLOAT =
          let Td2014 : FLOAT =
            unknown fsqr m02
          in
          fmul ao Td2014
        in
        let Td2017 : FLOAT =
          let Td2016 : FLOAT =
            unknown fsqr m12
          in
          fmul bo Td2016
        in
        fadd Td2015 Td2017
      in
      let Td2020 : FLOAT =
        let Td2019 : FLOAT =
          unknown fsqr m22
        in
        fmul co Td2019
      in
      fadd Td2018 Td2020
    in
    abc.(Ti2013) <- Td2021
  in
  let Tu59 : UNIT =
    let Ti2022 : INT =
      int 0
    in
    let Td2032 : FLOAT =
      let Td2023 : FLOAT =
        float 2.
      in
      let Td2031 : FLOAT =
        let Td2028 : FLOAT =
          let Td2025 : FLOAT =
            let Td2024 : FLOAT =
              fmul ao m01
            in
            fmul Td2024 m02
          in
          let Td2027 : FLOAT =
            let Td2026 : FLOAT =
              fmul bo m11
            in
            fmul Td2026 m12
          in
          fadd Td2025 Td2027
        in
        let Td2030 : FLOAT =
          let Td2029 : FLOAT =
            fmul co m21
          in
          fmul Td2029 m22
        in
        fadd Td2028 Td2030
      in
      fmul Td2023 Td2031
    in
    rot.(Ti2022) <- Td2032
  in
  let Tu58 : UNIT =
    let Ti2033 : INT =
      int 1
    in
    let Td2043 : FLOAT =
      let Td2034 : FLOAT =
        float 2.
      in
      let Td2042 : FLOAT =
        let Td2039 : FLOAT =
          let Td2036 : FLOAT =
            let Td2035 : FLOAT =
              fmul ao m00
            in
            fmul Td2035 m02
          in
          let Td2038 : FLOAT =
            let Td2037 : FLOAT =
              fmul bo m10
            in
            fmul Td2037 m12
          in
          fadd Td2036 Td2038
        in
        let Td2041 : FLOAT =
          let Td2040 : FLOAT =
            fmul co m20
          in
          fmul Td2040 m22
        in
        fadd Td2039 Td2041
      in
      fmul Td2034 Td2042
    in
    rot.(Ti2033) <- Td2043
  in
  let Ti2044 : INT =
    int 2
  in
  let Td2054 : FLOAT =
    let Td2045 : FLOAT =
      float 2.
    in
    let Td2053 : FLOAT =
      let Td2050 : FLOAT =
        let Td2047 : FLOAT =
          let Td2046 : FLOAT =
            fmul ao m00
          in
          fmul Td2046 m01
        in
        let Td2049 : FLOAT =
          let Td2048 : FLOAT =
            fmul bo m10
          in
          fmul Td2048 m11
        in
        fadd Td2047 Td2049
      in
      let Td2052 : FLOAT =
        let Td2051 : FLOAT =
          fmul co m20
        in
        fmul Td2051 m21
      in
      fadd Td2050 Td2052
    in
    fmul Td2045 Td2053
  in
  rot.(Ti2044) <- Td2054
in
letrec read_nth_object : (INT -> BOOL) =
variables : (n : INT)
  let texture : INT =
    let Tu1881 : UNIT =
      unit ()
    in
    unknown inint Tu1881
  in
  let Ti1883 : INT =
    let Ti1882 : INT =
      int 1
    in
    neg Ti1882
  in
  if texture == Ti1883
    int 0
    let form : INT =
      let Tu1884 : UNIT =
        unit ()
      in
      unknown inint Tu1884
    in
    let refltype : INT =
      let Tu1885 : UNIT =
        unit ()
      in
      unknown inint Tu1885
    in
    let isrot_p : INT =
      let Tu1886 : UNIT =
        unit ()
      in
      unknown inint Tu1886
    in
    let abc : Array of FLOAT =
      let Ti1887 : INT =
        int 3
      in
      let Td1888 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1887
        Td1888
    in
    let Tu81 : UNIT =
      let Ti1889 : INT =
        int 0
      in
      let Td1891 : FLOAT =
        let Tu1890 : UNIT =
          unit ()
        in
        unknown inflt Tu1890
      in
      abc.(Ti1889) <- Td1891
    in
    let Tu80 : UNIT =
      let Ti1892 : INT =
        int 1
      in
      let Td1894 : FLOAT =
        let Tu1893 : UNIT =
          unit ()
        in
        unknown inflt Tu1893
      in
      abc.(Ti1892) <- Td1894
    in
    let Tu79 : UNIT =
      let Ti1895 : INT =
        int 2
      in
      let Td1897 : FLOAT =
        let Tu1896 : UNIT =
          unit ()
        in
        unknown inflt Tu1896
      in
      abc.(Ti1895) <- Td1897
    in
    let xyz : Array of FLOAT =
      let Ti1898 : INT =
        int 3
      in
      let Td1899 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1898
        Td1899
    in
    let Tu78 : UNIT =
      let Ti1900 : INT =
        int 0
      in
      let Td1902 : FLOAT =
        let Tu1901 : UNIT =
          unit ()
        in
        unknown inflt Tu1901
      in
      xyz.(Ti1900) <- Td1902
    in
    let Tu77 : UNIT =
      let Ti1903 : INT =
        int 1
      in
      let Td1905 : FLOAT =
        let Tu1904 : UNIT =
          unit ()
        in
        unknown inflt Tu1904
      in
      xyz.(Ti1903) <- Td1905
    in
    let Tu76 : UNIT =
      let Ti1906 : INT =
        int 2
      in
      let Td1908 : FLOAT =
        let Tu1907 : UNIT =
          unit ()
        in
        unknown inflt Tu1907
      in
      xyz.(Ti1906) <- Td1908
    in
    let m_invert : BOOL =
      let Td1910 : FLOAT =
        let Tu1909 : UNIT =
          unit ()
        in
        unknown inflt Tu1909
      in
      app
        fisneg
        Td1910
    in
    let reflparam : Array of FLOAT =
      let Ti1911 : INT =
        int 2
      in
      let Td1912 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1911
        Td1912
    in
    let Tu75 : UNIT =
      let Ti1913 : INT =
        int 0
      in
      let Td1915 : FLOAT =
        let Tu1914 : UNIT =
          unit ()
        in
        unknown inflt Tu1914
      in
      reflparam.(Ti1913) <- Td1915
    in
    let Tu74 : UNIT =
      let Ti1916 : INT =
        int 1
      in
      let Td1918 : FLOAT =
        let Tu1917 : UNIT =
          unit ()
        in
        unknown inflt Tu1917
      in
      reflparam.(Ti1916) <- Td1918
    in
    let color : Array of FLOAT =
      let Ti1919 : INT =
        int 3
      in
      let Td1920 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1919
        Td1920
    in
    let Tu73 : UNIT =
      let Ti1921 : INT =
        int 0
      in
      let Td1923 : FLOAT =
        let Tu1922 : UNIT =
          unit ()
        in
        unknown inflt Tu1922
      in
      color.(Ti1921) <- Td1923
    in
    let Tu72 : UNIT =
      let Ti1924 : INT =
        int 1
      in
      let Td1926 : FLOAT =
        let Tu1925 : UNIT =
          unit ()
        in
        unknown inflt Tu1925
      in
      color.(Ti1924) <- Td1926
    in
    let Tu71 : UNIT =
      let Ti1927 : INT =
        int 2
      in
      let Td1929 : FLOAT =
        let Tu1928 : UNIT =
          unit ()
        in
        unknown inflt Tu1928
      in
      color.(Ti1927) <- Td1929
    in
    let rotation : Array of FLOAT =
      let Ti1930 : INT =
        int 3
      in
      let Td1931 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1930
        Td1931
    in
    let Tu70 : UNIT =
      let Ti1932 : INT =
        int 0
      in
      if isrot_p == Ti1932
        unit ()
        let Tu64 : UNIT =
          let Ti1933 : INT =
            int 0
          in
          let Td1936 : FLOAT =
            let Td1935 : FLOAT =
              let Tu1934 : UNIT =
                unit ()
              in
              unknown inflt Tu1934
            in
            app
              rad
              Td1935
          in
          rotation.(Ti1933) <- Td1936
        in
        let Tu63 : UNIT =
          let Ti1937 : INT =
            int 1
          in
          let Td1940 : FLOAT =
            let Td1939 : FLOAT =
              let Tu1938 : UNIT =
                unit ()
              in
              unknown inflt Tu1938
            in
            app
              rad
              Td1939
          in
          rotation.(Ti1937) <- Td1940
        in
        let Ti1941 : INT =
          int 2
        in
        let Td1944 : FLOAT =
          let Td1943 : FLOAT =
            let Tu1942 : UNIT =
              unit ()
            in
            unknown inflt Tu1942
          in
          app
            rad
            Td1943
        in
        rotation.(Ti1941) <- Td1944
    in
    let m_invert2 : BOOL =
      let Ti1945 : INT =
        int 2
      in
      if form == Ti1945
        int 1
        m_invert
    in
    let ctbl : Array of FLOAT =
      let Ti1946 : INT =
        int 4
      in
      let Td1947 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1946
        Td1947
    in
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      Tuple
        texture
        form
        refltype
        isrot_p
        abc
        xyz
        m_invert2
        reflparam
        color
        rotation
        ctbl
    in
    let Tu69 : UNIT =
      objects.(n) <- obj
    in
    let Tu68 : UNIT =
      let Ti1948 : INT =
        int 3
      in
      if form == Ti1948
        let a : FLOAT =
          let Ti1949 : INT =
            int 0
          in
          abc.(Ti1949)
        in
        let Tu66 : UNIT =
          let Ti1950 : INT =
            int 0
          in
          let Td1953 : FLOAT =
            if a == 0.0 
              float 0.
              let Td1951 : FLOAT =
                app
                  sgn
                  a
              in
              let Td1952 : FLOAT =
                unknown fsqr a
              in
              app
                fdiv
                Td1951
                Td1952
          in
          abc.(Ti1950) <- Td1953
        in
        let b : FLOAT =
          let Ti1954 : INT =
            int 1
          in
          abc.(Ti1954)
        in
        let Tu65 : UNIT =
          let Ti1955 : INT =
            int 1
          in
          let Td1958 : FLOAT =
            if b == 0.0 
              float 0.
              let Td1956 : FLOAT =
                app
                  sgn
                  b
              in
              let Td1957 : FLOAT =
                unknown fsqr b
              in
              app
                fdiv
                Td1956
                Td1957
          in
          abc.(Ti1955) <- Td1958
        in
        let c : FLOAT =
          let Ti1959 : INT =
            int 2
          in
          abc.(Ti1959)
        in
        let Ti1960 : INT =
          int 2
        in
        let Td1963 : FLOAT =
          if c == 0.0 
            float 0.
            let Td1961 : FLOAT =
              app
                sgn
                c
            in
            let Td1962 : FLOAT =
              unknown fsqr c
            in
            app
              fdiv
              Td1961
              Td1962
        in
        abc.(Ti1960) <- Td1963
        let Ti1964 : INT =
          int 2
        in
        if form == Ti1964
          let Ti1966 : INT =
            let Ti1965 : INT =
              int 0
            in
            if m_invert == Ti1965
              int 1
              int 0
          in
          app
            vecunit_sgn
            abc
            Ti1966
          unit ()
    in
    let Tu67 : UNIT =
      let Ti1967 : INT =
        int 0
      in
      if isrot_p == Ti1967
        unit ()
        app
          rotate_quadratic_matrix
          abc
          rotation
    in
    int 1
in
letrec read_object : (INT -> UNIT) =
variables : (n : INT)
  let Ti1875 : INT =
    int 60
  in
  if Ti1875 <= n
    unit ()
    let Tb1876 : BOOL =
      app
        read_nth_object
        n
    in
    let Ti1877 : INT =
      int 0
    in
    if Tb1876 == Ti1877
      let Ti1878 : INT =
        int 0
      in
      n_objects.(Ti1878) <- n
      let Ti1880 : INT =
        let Ti1879 : INT =
          int 1
        in
        add n Ti1879
      in
      app
        read_object
        Ti1880
in
letrec read_all_object : (UNIT -> UNIT) =
variables : (Tu82 : UNIT)
  let Ti1874 : INT =
    int 0
  in
  app
    read_object
    Ti1874
in
letrec read_net_item : (INT -> Array of INT) =
variables : (length : INT)
  let item : INT =
    let Tu1865 : UNIT =
      unit ()
    in
    unknown inint Tu1865
  in
  let Ti1867 : INT =
    let Ti1866 : INT =
      int 1
    in
    neg Ti1866
  in
  if item == Ti1867
    let Ti1869 : INT =
      let Ti1868 : INT =
        int 1
      in
      add length Ti1868
    in
    let Ti1871 : INT =
      let Ti1870 : INT =
        int 1
      in
      neg Ti1870
    in
    extfunapp
      create_array
      Ti1869
      Ti1871
    let v : Array of INT =
      let Ti1873 : INT =
        let Ti1872 : INT =
          int 1
        in
        add length Ti1872
      in
      app
        read_net_item
        Ti1873
    in
    let Tu83 : UNIT =
      v.(length) <- item
    in
    v
in
letrec read_or_network : (INT -> Array of Array of INT) =
variables : (length : INT)
  let net : Array of INT =
    let Ti1856 : INT =
      int 0
    in
    app
      read_net_item
      Ti1856
  in
  let Ti1858 : INT =
    let Ti1857 : INT =
      int 0
    in
    net.(Ti1857)
  in
  let Ti1860 : INT =
    let Ti1859 : INT =
      int 1
    in
    neg Ti1859
  in
  if Ti1858 == Ti1860
    let Ti1862 : INT =
      let Ti1861 : INT =
        int 1
      in
      add length Ti1861
    in
    extfunapp
      create_array
      Ti1862
      net
    let v : Array of Array of INT =
      let Ti1864 : INT =
        let Ti1863 : INT =
          int 1
        in
        add length Ti1863
      in
      app
        read_or_network
        Ti1864
    in
    let Tu84 : UNIT =
      v.(length) <- net
    in
    v
in
letrec read_and_network : (INT -> UNIT) =
variables : (n : INT)
  let net : Array of INT =
    let Ti1849 : INT =
      int 0
    in
    app
      read_net_item
      Ti1849
  in
  let Ti1851 : INT =
    let Ti1850 : INT =
      int 0
    in
    net.(Ti1850)
  in
  let Ti1853 : INT =
    let Ti1852 : INT =
      int 1
    in
    neg Ti1852
  in
  if Ti1851 == Ti1853
    unit ()
    let Tu85 : UNIT =
      and_net.(n) <- net
    in
    let Ti1855 : INT =
      let Ti1854 : INT =
        int 1
      in
      add n Ti1854
    in
    app
      read_and_network
      Ti1855
in
letrec read_parameter : (UNIT -> UNIT) =
variables : (Tu86 : UNIT)
  let Tu90 : UNIT =
    let Tu1842 : UNIT =
      unit ()
    in
    app
      read_screen_settings
      Tu1842
  in
  let Tu89 : UNIT =
    let Tu1843 : UNIT =
      unit ()
    in
    app
      read_light
      Tu1843
  in
  let Tu88 : UNIT =
    let Tu1844 : UNIT =
      unit ()
    in
    app
      read_all_object
      Tu1844
  in
  let Tu87 : UNIT =
    let Ti1845 : INT =
      int 0
    in
    app
      read_and_network
      Ti1845
  in
  let Ti1846 : INT =
    int 0
  in
  let Ta1848 : Array of Array of INT =
    let Ti1847 : INT =
      int 0
    in
    app
      read_or_network
      Ti1847
  in
  or_net.(Ti1846) <- Ta1848
in
letrec solver_rect_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> (INT -> BOOL)))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT), (i0 : INT), (i1 : INT), (i2 : INT)
  let Td1823 : FLOAT =
    dirvec.(i0)
  in
  if Td1823 == 0.0 
    int 0
    let abc : Array of FLOAT =
      app
        o_param_abc
        m
    in
    let d : FLOAT =
      let Tb1827 : BOOL =
        let Tb1824 : BOOL =
          app
            o_isinvert
            m
        in
        let Tb1826 : BOOL =
          let Td1825 : FLOAT =
            dirvec.(i0)
          in
          app
            fisneg
            Td1825
        in
        app
          xor
          Tb1824
          Tb1826
      in
      let Td1828 : FLOAT =
        abc.(i0)
      in
      app
        fneg_cond
        Tb1827
        Td1828
    in
    let d2 : FLOAT =
      let Td1829 : FLOAT =
        fsub d b0
      in
      let Td1830 : FLOAT =
        dirvec.(i0)
      in
      app
        fdiv
        Td1829
        Td1830
    in
    let Td1834 : FLOAT =
      let Td1833 : FLOAT =
        let Td1832 : FLOAT =
          let Td1831 : FLOAT =
            dirvec.(i1)
          in
          fmul d2 Td1831
        in
        fadd Td1832 b1
      in
      app
        fabs
        Td1833
    in
    let Td1835 : FLOAT =
      abc.(i1)
    in
    if Td1834 <. Td1835
      let Td1839 : FLOAT =
        let Td1838 : FLOAT =
          let Td1837 : FLOAT =
            let Td1836 : FLOAT =
              dirvec.(i2)
            in
            fmul d2 Td1836
          in
          fadd Td1837 b2
        in
        app
          fabs
          Td1838
      in
      let Td1840 : FLOAT =
        abc.(i2)
      in
      if Td1839 <. Td1840
        let Tu91 : UNIT =
          let Ti1841 : INT =
            int 0
          in
          solver_dist.(Ti1841) <- d2
        in
        int 1
        int 0
      int 0
in
letrec solver_rect : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1811 : BOOL =
    let Ti1808 : INT =
      int 0
    in
    let Ti1809 : INT =
      int 1
    in
    let Ti1810 : INT =
      int 2
    in
    app
      solver_rect_surface
      m
      dirvec
      b0
      b1
      b2
      Ti1808
      Ti1809
      Ti1810
  in
  let Ti1812 : INT =
    int 0
  in
  if Tb1811 == Ti1812
    let Tb1816 : BOOL =
      let Ti1813 : INT =
        int 1
      in
      let Ti1814 : INT =
        int 2
      in
      let Ti1815 : INT =
        int 0
      in
      app
        solver_rect_surface
        m
        dirvec
        b1
        b2
        b0
        Ti1813
        Ti1814
        Ti1815
    in
    let Ti1817 : INT =
      int 0
    in
    if Tb1816 == Ti1817
      let Tb1821 : BOOL =
        let Ti1818 : INT =
          int 2
        in
        let Ti1819 : INT =
          int 0
        in
        let Ti1820 : INT =
          int 1
        in
        app
          solver_rect_surface
          m
          dirvec
          b2
          b0
          b1
          Ti1818
          Ti1819
          Ti1820
      in
      let Ti1822 : INT =
        int 0
      in
      if Tb1821 == Ti1822
        int 0
        int 3
      int 2
    int 1
in
letrec solver_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let abc : Array of FLOAT =
    app
      o_param_abc
      m
  in
  let d : FLOAT =
    app
      veciprod
      dirvec
      abc
  in
  let Tb1802 : BOOL =
    app
      fispos
      d
  in
  let Ti1803 : INT =
    int 0
  in
  if Tb1802 == Ti1803
    int 0
    let Tu92 : UNIT =
      let Ti1804 : INT =
        int 0
      in
      let Td1807 : FLOAT =
        let Td1806 : FLOAT =
          let Td1805 : FLOAT =
            app
              veciprod2
              abc
              b0
              b1
              b2
          in
          app
            fneg
            Td1805
        in
        app
          fdiv
          Td1806
          d
      in
      solver_dist.(Ti1804) <- Td1807
    in
    int 1
in
letrec quadratic : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let diag_part : FLOAT =
    let Td1785 : FLOAT =
      let Td1781 : FLOAT =
        let Td1779 : FLOAT =
          unknown fsqr v0
        in
        let Td1780 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1779 Td1780
      in
      let Td1784 : FLOAT =
        let Td1782 : FLOAT =
          unknown fsqr v1
        in
        let Td1783 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1782 Td1783
      in
      fadd Td1781 Td1784
    in
    let Td1788 : FLOAT =
      let Td1786 : FLOAT =
        unknown fsqr v2
      in
      let Td1787 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1786 Td1787
    in
    fadd Td1785 Td1788
  in
  let Ti1789 : INT =
    app
      o_isrot
      m
  in
  let Ti1790 : INT =
    int 0
  in
  if Ti1789 == Ti1790
    diag_part
    let Td1798 : FLOAT =
      let Td1794 : FLOAT =
        let Td1793 : FLOAT =
          let Td1791 : FLOAT =
            fmul v1 v2
          in
          let Td1792 : FLOAT =
            app
              o_param_r1
              m
          in
          fmul Td1791 Td1792
        in
        fadd diag_part Td1793
      in
      let Td1797 : FLOAT =
        let Td1795 : FLOAT =
          fmul v2 v0
        in
        let Td1796 : FLOAT =
          app
            o_param_r2
            m
        in
        fmul Td1795 Td1796
      in
      fadd Td1794 Td1797
    in
    let Td1801 : FLOAT =
      let Td1799 : FLOAT =
        fmul v0 v1
      in
      let Td1800 : FLOAT =
        app
          o_param_r3
          m
      in
      fmul Td1799 Td1800
    in
    fadd Td1798 Td1801
in
letrec bilinear : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let diag_part : FLOAT =
    let Td1755 : FLOAT =
      let Td1751 : FLOAT =
        let Td1749 : FLOAT =
          fmul v0 w0
        in
        let Td1750 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1749 Td1750
      in
      let Td1754 : FLOAT =
        let Td1752 : FLOAT =
          fmul v1 w1
        in
        let Td1753 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1752 Td1753
      in
      fadd Td1751 Td1754
    in
    let Td1758 : FLOAT =
      let Td1756 : FLOAT =
        fmul v2 w2
      in
      let Td1757 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1756 Td1757
    in
    fadd Td1755 Td1758
  in
  let Ti1759 : INT =
    app
      o_isrot
      m
  in
  let Ti1760 : INT =
    int 0
  in
  if Ti1759 == Ti1760
    diag_part
    let Td1778 : FLOAT =
      let Td1777 : FLOAT =
        let Td1771 : FLOAT =
          let Td1765 : FLOAT =
            let Td1763 : FLOAT =
              let Td1761 : FLOAT =
                fmul v2 w1
              in
              let Td1762 : FLOAT =
                fmul v1 w2
              in
              fadd Td1761 Td1762
            in
            let Td1764 : FLOAT =
              app
                o_param_r1
                m
            in
            fmul Td1763 Td1764
          in
          let Td1770 : FLOAT =
            let Td1768 : FLOAT =
              let Td1766 : FLOAT =
                fmul v0 w2
              in
              let Td1767 : FLOAT =
                fmul v2 w0
              in
              fadd Td1766 Td1767
            in
            let Td1769 : FLOAT =
              app
                o_param_r2
                m
            in
            fmul Td1768 Td1769
          in
          fadd Td1765 Td1770
        in
        let Td1776 : FLOAT =
          let Td1774 : FLOAT =
            let Td1772 : FLOAT =
              fmul v0 w1
            in
            let Td1773 : FLOAT =
              fmul v1 w0
            in
            fadd Td1772 Td1773
          in
          let Td1775 : FLOAT =
            app
              o_param_r3
              m
          in
          fmul Td1774 Td1775
        in
        fadd Td1771 Td1776
      in
      app
        fhalf
        Td1777
    in
    fadd diag_part Td1778
in
letrec solver_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Td1726 : FLOAT =
      let Ti1725 : INT =
        int 0
      in
      dirvec.(Ti1725)
    in
    let Td1728 : FLOAT =
      let Ti1727 : INT =
        int 1
      in
      dirvec.(Ti1727)
    in
    let Td1730 : FLOAT =
      let Ti1729 : INT =
        int 2
      in
      dirvec.(Ti1729)
    in
    app
      quadratic
      m
      Td1726
      Td1728
      Td1730
  in
  if aa == 0.0 
    int 0
    let bb : FLOAT =
      let Td1732 : FLOAT =
        let Ti1731 : INT =
          int 0
        in
        dirvec.(Ti1731)
      in
      let Td1734 : FLOAT =
        let Ti1733 : INT =
          int 1
        in
        dirvec.(Ti1733)
      in
      let Td1736 : FLOAT =
        let Ti1735 : INT =
          int 2
        in
        dirvec.(Ti1735)
      in
      app
        bilinear
        m
        Td1732
        Td1734
        Td1736
        b0
        b1
        b2
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1737 : INT =
        app
          o_form
          m
      in
      let Ti1738 : INT =
        int 3
      in
      if Ti1737 == Ti1738
        let Td1739 : FLOAT =
          float 1.
        in
        fsub cc0 Td1739
        cc0
    in
    let d : FLOAT =
      let Td1740 : FLOAT =
        unknown fsqr bb
      in
      let Td1741 : FLOAT =
        fmul aa cc
      in
      fsub Td1740 Td1741
    in
    let Tb1742 : BOOL =
      app
        fispos
        d
    in
    let Ti1743 : INT =
      int 0
    in
    if Tb1742 == Ti1743
      int 0
      let sd : FLOAT =
        app
          sqrt
          d
      in
      let t1 : FLOAT =
        let Tb1744 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1745 : INT =
          int 0
        in
        if Tb1744 == Ti1745
          app
            fneg
            sd
          sd
      in
      let Tu93 : UNIT =
        let Ti1746 : INT =
          int 0
        in
        let Td1748 : FLOAT =
          let Td1747 : FLOAT =
            fsub t1 bb
          in
          app
            fdiv
            Td1747
            aa
        in
        solver_dist.(Ti1746) <- Td1748
      in
      int 1
in
letrec solver : (INT -> (Array of FLOAT -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : Array of FLOAT), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1715 : FLOAT =
      let Ti1714 : INT =
        int 0
      in
      org.(Ti1714)
    in
    let Td1716 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1715 Td1716
  in
  let b1 : FLOAT =
    let Td1718 : FLOAT =
      let Ti1717 : INT =
        int 1
      in
      org.(Ti1717)
    in
    let Td1719 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1718 Td1719
  in
  let b2 : FLOAT =
    let Td1721 : FLOAT =
      let Ti1720 : INT =
        int 2
      in
      org.(Ti1720)
    in
    let Td1722 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1721 Td1722
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1723 : INT =
    int 1
  in
  if m_shape == Ti1723
    app
      solver_rect
      m
      dirvec
      b0
      b1
      b2
    let Ti1724 : INT =
      int 2
    in
    if m_shape == Ti1724
      app
        solver_surface
        m
        dirvec
        b0
        b1
        b2
      app
        solver_second
        m
        dirvec
        b0
        b1
        b2
in
letrec solver_rect_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v : Array of FLOAT), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let d0 : FLOAT =
    let Td1650 : FLOAT =
      let Td1649 : FLOAT =
        let Ti1648 : INT =
          int 0
        in
        dconst.(Ti1648)
      in
      fsub Td1649 b0
    in
    let Td1652 : FLOAT =
      let Ti1651 : INT =
        int 1
      in
      dconst.(Ti1651)
    in
    fmul Td1650 Td1652
  in
  let Ti1667 : INT =
    let Td1657 : FLOAT =
      let Td1656 : FLOAT =
        let Td1655 : FLOAT =
          let Td1654 : FLOAT =
            let Ti1653 : INT =
              int 1
            in
            v.(Ti1653)
          in
          fmul d0 Td1654
        in
        fadd Td1655 b1
      in
      app
        fabs
        Td1656
    in
    let Td1658 : FLOAT =
      app
        o_param_b
        m
    in
    if Td1657 <. Td1658
      let Td1663 : FLOAT =
        let Td1662 : FLOAT =
          let Td1661 : FLOAT =
            let Td1660 : FLOAT =
              let Ti1659 : INT =
                int 2
              in
              v.(Ti1659)
            in
            fmul d0 Td1660
          in
          fadd Td1661 b2
        in
        app
          fabs
          Td1662
      in
      let Td1664 : FLOAT =
        app
          o_param_c
          m
      in
      if Td1663 <. Td1664
        let Td1666 : FLOAT =
          let Ti1665 : INT =
            int 1
          in
          dconst.(Ti1665)
        in
        if Td1666 == 0.0 
          int 0
          int 1
        int 0
      int 0
  in
  let Ti1668 : INT =
    int 0
  in
  if Ti1667 == Ti1668
    let d1 : FLOAT =
      let Td1671 : FLOAT =
        let Td1670 : FLOAT =
          let Ti1669 : INT =
            int 2
          in
          dconst.(Ti1669)
        in
        fsub Td1670 b1
      in
      let Td1673 : FLOAT =
        let Ti1672 : INT =
          int 3
        in
        dconst.(Ti1672)
      in
      fmul Td1671 Td1673
    in
    let Ti1688 : INT =
      let Td1678 : FLOAT =
        let Td1677 : FLOAT =
          let Td1676 : FLOAT =
            let Td1675 : FLOAT =
              let Ti1674 : INT =
                int 0
              in
              v.(Ti1674)
            in
            fmul d1 Td1675
          in
          fadd Td1676 b0
        in
        app
          fabs
          Td1677
      in
      let Td1679 : FLOAT =
        app
          o_param_a
          m
      in
      if Td1678 <. Td1679
        let Td1684 : FLOAT =
          let Td1683 : FLOAT =
            let Td1682 : FLOAT =
              let Td1681 : FLOAT =
                let Ti1680 : INT =
                  int 2
                in
                v.(Ti1680)
              in
              fmul d1 Td1681
            in
            fadd Td1682 b2
          in
          app
            fabs
            Td1683
        in
        let Td1685 : FLOAT =
          app
            o_param_c
            m
        in
        if Td1684 <. Td1685
          let Td1687 : FLOAT =
            let Ti1686 : INT =
              int 3
            in
            dconst.(Ti1686)
          in
          if Td1687 == 0.0 
            int 0
            int 1
          int 0
        int 0
    in
    let Ti1689 : INT =
      int 0
    in
    if Ti1688 == Ti1689
      let d2 : FLOAT =
        let Td1692 : FLOAT =
          let Td1691 : FLOAT =
            let Ti1690 : INT =
              int 4
            in
            dconst.(Ti1690)
          in
          fsub Td1691 b2
        in
        let Td1694 : FLOAT =
          let Ti1693 : INT =
            int 5
          in
          dconst.(Ti1693)
        in
        fmul Td1692 Td1694
      in
      let Ti1709 : INT =
        let Td1699 : FLOAT =
          let Td1698 : FLOAT =
            let Td1697 : FLOAT =
              let Td1696 : FLOAT =
                let Ti1695 : INT =
                  int 0
                in
                v.(Ti1695)
              in
              fmul d2 Td1696
            in
            fadd Td1697 b0
          in
          app
            fabs
            Td1698
        in
        let Td1700 : FLOAT =
          app
            o_param_a
            m
        in
        if Td1699 <. Td1700
          let Td1705 : FLOAT =
            let Td1704 : FLOAT =
              let Td1703 : FLOAT =
                let Td1702 : FLOAT =
                  let Ti1701 : INT =
                    int 1
                  in
                  v.(Ti1701)
                in
                fmul d2 Td1702
              in
              fadd Td1703 b1
            in
            app
              fabs
              Td1704
          in
          let Td1706 : FLOAT =
            app
              o_param_b
              m
          in
          if Td1705 <. Td1706
            let Td1708 : FLOAT =
              let Ti1707 : INT =
                int 5
              in
              dconst.(Ti1707)
            in
            if Td1708 == 0.0 
              int 0
              int 1
            int 0
          int 0
      in
      let Ti1710 : INT =
        int 0
      in
      if Ti1709 == Ti1710
        int 0
        let Tu96 : UNIT =
          let Ti1711 : INT =
            int 0
          in
          solver_dist.(Ti1711) <- d2
        in
        int 3
      let Tu95 : UNIT =
        let Ti1712 : INT =
          int 0
        in
        solver_dist.(Ti1712) <- d1
      in
      int 2
    let Tu94 : UNIT =
      let Ti1713 : INT =
        int 0
      in
      solver_dist.(Ti1713) <- d0
    in
    int 1
in
letrec solver_surface_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1634 : BOOL =
    let Td1633 : FLOAT =
      let Ti1632 : INT =
        int 0
      in
      dconst.(Ti1632)
    in
    app
      fisneg
      Td1633
  in
  let Ti1635 : INT =
    int 0
  in
  if Tb1634 == Ti1635
    int 0
    let Tu97 : UNIT =
      let Ti1636 : INT =
        int 0
      in
      let Td1647 : FLOAT =
        let Td1643 : FLOAT =
          let Td1639 : FLOAT =
            let Td1638 : FLOAT =
              let Ti1637 : INT =
                int 1
              in
              dconst.(Ti1637)
            in
            fmul Td1638 b0
          in
          let Td1642 : FLOAT =
            let Td1641 : FLOAT =
              let Ti1640 : INT =
                int 2
              in
              dconst.(Ti1640)
            in
            fmul Td1641 b1
          in
          fadd Td1639 Td1642
        in
        let Td1646 : FLOAT =
          let Td1645 : FLOAT =
            let Ti1644 : INT =
              int 3
            in
            dconst.(Ti1644)
          in
          fmul Td1645 b2
        in
        fadd Td1643 Td1646
      in
      solver_dist.(Ti1636) <- Td1647
    in
    int 1
in
letrec solver_second_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1600 : INT =
      int 0
    in
    dconst.(Ti1600)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1607 : FLOAT =
        let Td1603 : FLOAT =
          let Td1602 : FLOAT =
            let Ti1601 : INT =
              int 1
            in
            dconst.(Ti1601)
          in
          fmul Td1602 b0
        in
        let Td1606 : FLOAT =
          let Td1605 : FLOAT =
            let Ti1604 : INT =
              int 2
            in
            dconst.(Ti1604)
          in
          fmul Td1605 b1
        in
        fadd Td1603 Td1606
      in
      let Td1610 : FLOAT =
        let Td1609 : FLOAT =
          let Ti1608 : INT =
            int 3
          in
          dconst.(Ti1608)
        in
        fmul Td1609 b2
      in
      fadd Td1607 Td1610
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1611 : INT =
        app
          o_form
          m
      in
      let Ti1612 : INT =
        int 3
      in
      if Ti1611 == Ti1612
        let Td1613 : FLOAT =
          float 1.
        in
        fsub cc0 Td1613
        cc0
    in
    let d : FLOAT =
      let Td1614 : FLOAT =
        unknown fsqr neg_bb
      in
      let Td1615 : FLOAT =
        fmul aa cc
      in
      fsub Td1614 Td1615
    in
    let Tb1616 : BOOL =
      app
        fispos
        d
    in
    let Ti1617 : INT =
      int 0
    in
    if Tb1616 == Ti1617
      int 0
      let Tu98 : UNIT =
        let Tb1618 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1619 : INT =
          int 0
        in
        if Tb1618 == Ti1619
          let Ti1620 : INT =
            int 0
          in
          let Td1625 : FLOAT =
            let Td1622 : FLOAT =
              let Td1621 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1621
            in
            let Td1624 : FLOAT =
              let Ti1623 : INT =
                int 4
              in
              dconst.(Ti1623)
            in
            fmul Td1622 Td1624
          in
          solver_dist.(Ti1620) <- Td1625
          let Ti1626 : INT =
            int 0
          in
          let Td1631 : FLOAT =
            let Td1628 : FLOAT =
              let Td1627 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1627
            in
            let Td1630 : FLOAT =
              let Ti1629 : INT =
                int 4
              in
              dconst.(Ti1629)
            in
            fmul Td1628 Td1630
          in
          solver_dist.(Ti1626) <- Td1631
      in
      int 1
in
letrec solver_fast : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1589 : FLOAT =
      let Ti1588 : INT =
        int 0
      in
      org.(Ti1588)
    in
    let Td1590 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1589 Td1590
  in
  let b1 : FLOAT =
    let Td1592 : FLOAT =
      let Ti1591 : INT =
        int 1
      in
      org.(Ti1591)
    in
    let Td1593 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1592 Td1593
  in
  let b2 : FLOAT =
    let Td1595 : FLOAT =
      let Ti1594 : INT =
        int 2
      in
      org.(Ti1594)
    in
    let Td1596 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1595 Td1596
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1597 : INT =
    int 1
  in
  if m_shape == Ti1597
    let Ta1598 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1598
      dconst
      b0
      b1
      b2
    let Ti1599 : INT =
      int 2
    in
    if m_shape == Ti1599
      app
        solver_surface_fast
        m
        dconst
        b0
        b1
        b2
      app
        solver_second_fast
        m
        dconst
        b0
        b1
        b2
in
letrec solver_surface_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1580 : BOOL =
    let Td1579 : FLOAT =
      let Ti1578 : INT =
        int 0
      in
      dconst.(Ti1578)
    in
    app
      fisneg
      Td1579
  in
  let Ti1581 : INT =
    int 0
  in
  if Tb1580 == Ti1581
    int 0
    let Tu99 : UNIT =
      let Ti1582 : INT =
        int 0
      in
      let Td1587 : FLOAT =
        let Td1584 : FLOAT =
          let Ti1583 : INT =
            int 0
          in
          dconst.(Ti1583)
        in
        let Td1586 : FLOAT =
          let Ti1585 : INT =
            int 3
          in
          sconst.(Ti1585)
        in
        fmul Td1584 Td1586
      in
      solver_dist.(Ti1582) <- Td1587
    in
    int 1
in
letrec solver_second_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1548 : INT =
      int 0
    in
    dconst.(Ti1548)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1555 : FLOAT =
        let Td1551 : FLOAT =
          let Td1550 : FLOAT =
            let Ti1549 : INT =
              int 1
            in
            dconst.(Ti1549)
          in
          fmul Td1550 b0
        in
        let Td1554 : FLOAT =
          let Td1553 : FLOAT =
            let Ti1552 : INT =
              int 2
            in
            dconst.(Ti1552)
          in
          fmul Td1553 b1
        in
        fadd Td1551 Td1554
      in
      let Td1558 : FLOAT =
        let Td1557 : FLOAT =
          let Ti1556 : INT =
            int 3
          in
          dconst.(Ti1556)
        in
        fmul Td1557 b2
      in
      fadd Td1555 Td1558
    in
    let cc : FLOAT =
      let Ti1559 : INT =
        int 3
      in
      sconst.(Ti1559)
    in
    let d : FLOAT =
      let Td1560 : FLOAT =
        unknown fsqr neg_bb
      in
      let Td1561 : FLOAT =
        fmul aa cc
      in
      fsub Td1560 Td1561
    in
    let Tb1562 : BOOL =
      app
        fispos
        d
    in
    let Ti1563 : INT =
      int 0
    in
    if Tb1562 == Ti1563
      int 0
      let Tu100 : UNIT =
        let Tb1564 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1565 : INT =
          int 0
        in
        if Tb1564 == Ti1565
          let Ti1566 : INT =
            int 0
          in
          let Td1571 : FLOAT =
            let Td1568 : FLOAT =
              let Td1567 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1567
            in
            let Td1570 : FLOAT =
              let Ti1569 : INT =
                int 4
              in
              dconst.(Ti1569)
            in
            fmul Td1568 Td1570
          in
          solver_dist.(Ti1566) <- Td1571
          let Ti1572 : INT =
            int 0
          in
          let Td1577 : FLOAT =
            let Td1574 : FLOAT =
              let Td1573 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1573
            in
            let Td1576 : FLOAT =
              let Ti1575 : INT =
                int 4
              in
              dconst.(Ti1575)
            in
            fmul Td1574 Td1576
          in
          solver_dist.(Ti1572) <- Td1577
      in
      int 1
in
letrec solver_fast2 : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> INT)) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let sconst : Array of FLOAT =
    app
      o_param_ctbl
      m
  in
  let b0 : FLOAT =
    let Ti1542 : INT =
      int 0
    in
    sconst.(Ti1542)
  in
  let b1 : FLOAT =
    let Ti1543 : INT =
      int 1
    in
    sconst.(Ti1543)
  in
  let b2 : FLOAT =
    let Ti1544 : INT =
      int 2
    in
    sconst.(Ti1544)
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1545 : INT =
    int 1
  in
  if m_shape == Ti1545
    let Ta1546 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1546
      dconst
      b0
      b1
      b2
    let Ti1547 : INT =
      int 2
    in
    if m_shape == Ti1547
      app
        solver_surface_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
      app
        solver_second_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
in
letrec setup_rect_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1489 : INT =
      int 6
    in
    let Td1490 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1489
      Td1490
  in
  let Tu106 : UNIT =
    let Td1492 : FLOAT =
      let Ti1491 : INT =
        int 0
      in
      vec.(Ti1491)
    in
    if Td1492 == 0.0 
      let Ti1493 : INT =
        int 1
      in
      let Td1494 : FLOAT =
        float 0.
      in
      const.(Ti1493) <- Td1494
      let Tu101 : UNIT =
        let Ti1495 : INT =
          int 0
        in
        let Td1502 : FLOAT =
          let Tb1500 : BOOL =
            let Tb1496 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1499 : BOOL =
              let Td1498 : FLOAT =
                let Ti1497 : INT =
                  int 0
                in
                vec.(Ti1497)
              in
              app
                fisneg
                Td1498
            in
            app
              xor
              Tb1496
              Tb1499
          in
          let Td1501 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fneg_cond
            Tb1500
            Td1501
        in
        const.(Ti1495) <- Td1502
      in
      let Ti1503 : INT =
        int 1
      in
      let Td1507 : FLOAT =
        let Td1504 : FLOAT =
          float 1.
        in
        let Td1506 : FLOAT =
          let Ti1505 : INT =
            int 0
          in
          vec.(Ti1505)
        in
        app
          fdiv
          Td1504
          Td1506
      in
      const.(Ti1503) <- Td1507
  in
  let Tu105 : UNIT =
    let Td1509 : FLOAT =
      let Ti1508 : INT =
        int 1
      in
      vec.(Ti1508)
    in
    if Td1509 == 0.0 
      let Ti1510 : INT =
        int 3
      in
      let Td1511 : FLOAT =
        float 0.
      in
      const.(Ti1510) <- Td1511
      let Tu102 : UNIT =
        let Ti1512 : INT =
          int 2
        in
        let Td1519 : FLOAT =
          let Tb1517 : BOOL =
            let Tb1513 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1516 : BOOL =
              let Td1515 : FLOAT =
                let Ti1514 : INT =
                  int 1
                in
                vec.(Ti1514)
              in
              app
                fisneg
                Td1515
            in
            app
              xor
              Tb1513
              Tb1516
          in
          let Td1518 : FLOAT =
            app
              o_param_b
              m
          in
          app
            fneg_cond
            Tb1517
            Td1518
        in
        const.(Ti1512) <- Td1519
      in
      let Ti1520 : INT =
        int 3
      in
      let Td1524 : FLOAT =
        let Td1521 : FLOAT =
          float 1.
        in
        let Td1523 : FLOAT =
          let Ti1522 : INT =
            int 1
          in
          vec.(Ti1522)
        in
        app
          fdiv
          Td1521
          Td1523
      in
      const.(Ti1520) <- Td1524
  in
  let Tu104 : UNIT =
    let Td1526 : FLOAT =
      let Ti1525 : INT =
        int 2
      in
      vec.(Ti1525)
    in
    if Td1526 == 0.0 
      let Ti1527 : INT =
        int 5
      in
      let Td1528 : FLOAT =
        float 0.
      in
      const.(Ti1527) <- Td1528
      let Tu103 : UNIT =
        let Ti1529 : INT =
          int 4
        in
        let Td1536 : FLOAT =
          let Tb1534 : BOOL =
            let Tb1530 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1533 : BOOL =
              let Td1532 : FLOAT =
                let Ti1531 : INT =
                  int 2
                in
                vec.(Ti1531)
              in
              app
                fisneg
                Td1532
            in
            app
              xor
              Tb1530
              Tb1533
          in
          let Td1535 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fneg_cond
            Tb1534
            Td1535
        in
        const.(Ti1529) <- Td1536
      in
      let Ti1537 : INT =
        int 5
      in
      let Td1541 : FLOAT =
        let Td1538 : FLOAT =
          float 1.
        in
        let Td1540 : FLOAT =
          let Ti1539 : INT =
            int 2
          in
          vec.(Ti1539)
        in
        app
          fdiv
          Td1538
          Td1540
      in
      const.(Ti1537) <- Td1541
  in
  const
in
letrec setup_surface_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1455 : INT =
      int 4
    in
    let Td1456 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1455
      Td1456
  in
  let d : FLOAT =
    let Td1465 : FLOAT =
      let Td1460 : FLOAT =
        let Td1458 : FLOAT =
          let Ti1457 : INT =
            int 0
          in
          vec.(Ti1457)
        in
        let Td1459 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1458 Td1459
      in
      let Td1464 : FLOAT =
        let Td1462 : FLOAT =
          let Ti1461 : INT =
            int 1
          in
          vec.(Ti1461)
        in
        let Td1463 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1462 Td1463
      in
      fadd Td1460 Td1464
    in
    let Td1469 : FLOAT =
      let Td1467 : FLOAT =
        let Ti1466 : INT =
          int 2
        in
        vec.(Ti1466)
      in
      let Td1468 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1467 Td1468
    in
    fadd Td1465 Td1469
  in
  let Tu110 : UNIT =
    let Tb1470 : BOOL =
      app
        fispos
        d
    in
    let Ti1471 : INT =
      int 0
    in
    if Tb1470 == Ti1471
      let Ti1472 : INT =
        int 0
      in
      let Td1473 : FLOAT =
        float 0.
      in
      const.(Ti1472) <- Td1473
      let Tu109 : UNIT =
        let Ti1474 : INT =
          int 0
        in
        let Td1476 : FLOAT =
          let Td1475 : FLOAT =
            float -1.
          in
          app
            fdiv
            Td1475
            d
        in
        const.(Ti1474) <- Td1476
      in
      let Tu108 : UNIT =
        let Ti1477 : INT =
          int 1
        in
        let Td1480 : FLOAT =
          let Td1479 : FLOAT =
            let Td1478 : FLOAT =
              app
                o_param_a
                m
            in
            app
              fdiv
              Td1478
              d
          in
          app
            fneg
            Td1479
        in
        const.(Ti1477) <- Td1480
      in
      let Tu107 : UNIT =
        let Ti1481 : INT =
          int 2
        in
        let Td1484 : FLOAT =
          let Td1483 : FLOAT =
            let Td1482 : FLOAT =
              app
                o_param_b
                m
            in
            app
              fdiv
              Td1482
              d
          in
          app
            fneg
            Td1483
        in
        const.(Ti1481) <- Td1484
      in
      let Ti1485 : INT =
        int 3
      in
      let Td1488 : FLOAT =
        let Td1487 : FLOAT =
          let Td1486 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fdiv
            Td1486
            d
        in
        app
          fneg
          Td1487
      in
      const.(Ti1485) <- Td1488
  in
  const
in
letrec setup_second_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (v : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1390 : INT =
      int 5
    in
    let Td1391 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1390
      Td1391
  in
  let aa : FLOAT =
    let Td1393 : FLOAT =
      let Ti1392 : INT =
        int 0
      in
      v.(Ti1392)
    in
    let Td1395 : FLOAT =
      let Ti1394 : INT =
        int 1
      in
      v.(Ti1394)
    in
    let Td1397 : FLOAT =
      let Ti1396 : INT =
        int 2
      in
      v.(Ti1396)
    in
    app
      quadratic
      m
      Td1393
      Td1395
      Td1397
  in
  let c1 : FLOAT =
    let Td1401 : FLOAT =
      let Td1399 : FLOAT =
        let Ti1398 : INT =
          int 0
        in
        v.(Ti1398)
      in
      let Td1400 : FLOAT =
        app
          o_param_a
          m
      in
      fmul Td1399 Td1400
    in
    app
      fneg
      Td1401
  in
  let c2 : FLOAT =
    let Td1405 : FLOAT =
      let Td1403 : FLOAT =
        let Ti1402 : INT =
          int 1
        in
        v.(Ti1402)
      in
      let Td1404 : FLOAT =
        app
          o_param_b
          m
      in
      fmul Td1403 Td1404
    in
    app
      fneg
      Td1405
  in
  let c3 : FLOAT =
    let Td1409 : FLOAT =
      let Td1407 : FLOAT =
        let Ti1406 : INT =
          int 2
        in
        v.(Ti1406)
      in
      let Td1408 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1407 Td1408
    in
    app
      fneg
      Td1409
  in
  let Tu117 : UNIT =
    let Ti1410 : INT =
      int 0
    in
    const.(Ti1410) <- aa
  in
  let Tu116 : UNIT =
    let Ti1411 : INT =
      app
        o_isrot
        m
    in
    let Ti1412 : INT =
      int 0
    in
    if Ti1411 == Ti1412
      let Tu114 : UNIT =
        let Ti1413 : INT =
          int 1
        in
        const.(Ti1413) <- c1
      in
      let Tu113 : UNIT =
        let Ti1414 : INT =
          int 2
        in
        const.(Ti1414) <- c2
      in
      let Ti1415 : INT =
        int 3
      in
      const.(Ti1415) <- c3
      let Tu112 : UNIT =
        let Ti1416 : INT =
          int 1
        in
        let Td1427 : FLOAT =
          let Td1426 : FLOAT =
            let Td1425 : FLOAT =
              let Td1420 : FLOAT =
                let Td1418 : FLOAT =
                  let Ti1417 : INT =
                    int 2
                  in
                  v.(Ti1417)
                in
                let Td1419 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul Td1418 Td1419
              in
              let Td1424 : FLOAT =
                let Td1422 : FLOAT =
                  let Ti1421 : INT =
                    int 1
                  in
                  v.(Ti1421)
                in
                let Td1423 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1422 Td1423
              in
              fadd Td1420 Td1424
            in
            app
              fhalf
              Td1425
          in
          fsub c1 Td1426
        in
        const.(Ti1416) <- Td1427
      in
      let Tu111 : UNIT =
        let Ti1428 : INT =
          int 2
        in
        let Td1439 : FLOAT =
          let Td1438 : FLOAT =
            let Td1437 : FLOAT =
              let Td1432 : FLOAT =
                let Td1430 : FLOAT =
                  let Ti1429 : INT =
                    int 2
                  in
                  v.(Ti1429)
                in
                let Td1431 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul Td1430 Td1431
              in
              let Td1436 : FLOAT =
                let Td1434 : FLOAT =
                  let Ti1433 : INT =
                    int 0
                  in
                  v.(Ti1433)
                in
                let Td1435 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1434 Td1435
              in
              fadd Td1432 Td1436
            in
            app
              fhalf
              Td1437
          in
          fsub c2 Td1438
        in
        const.(Ti1428) <- Td1439
      in
      let Ti1440 : INT =
        int 3
      in
      let Td1451 : FLOAT =
        let Td1450 : FLOAT =
          let Td1449 : FLOAT =
            let Td1444 : FLOAT =
              let Td1442 : FLOAT =
                let Ti1441 : INT =
                  int 1
                in
                v.(Ti1441)
              in
              let Td1443 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul Td1442 Td1443
            in
            let Td1448 : FLOAT =
              let Td1446 : FLOAT =
                let Ti1445 : INT =
                  int 0
                in
                v.(Ti1445)
              in
              let Td1447 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul Td1446 Td1447
            in
            fadd Td1444 Td1448
          in
          app
            fhalf
            Td1449
        in
        fsub c3 Td1450
      in
      const.(Ti1440) <- Td1451
  in
  let Tu115 : UNIT =
    if aa == 0.0 
      unit ()
      let Ti1452 : INT =
        int 4
      in
      let Td1454 : FLOAT =
        let Td1453 : FLOAT =
          float 1.
        in
        app
          fdiv
          Td1453
          aa
      in
      const.(Ti1452) <- Td1454
  in
  const
in
letrec iter_setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti1382 : INT =
    int 0
  in
  if Ti1382 <= index
    let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let dconst : Array of Array of FLOAT =
      app
        d_const
        dirvec
    in
    let v : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    let m_shape : INT =
      app
        o_form
        m
    in
    let Tu118 : UNIT =
      let Ti1383 : INT =
        int 1
      in
      if m_shape == Ti1383
        let Ta1384 : Array of FLOAT =
          app
            setup_rect_table
            v
            m
        in
        dconst.(index) <- Ta1384
        let Ti1385 : INT =
          int 2
        in
        if m_shape == Ti1385
          let Ta1386 : Array of FLOAT =
            app
              setup_surface_table
              v
              m
          in
          dconst.(index) <- Ta1386
          let Ta1387 : Array of FLOAT =
            app
              setup_second_table
              v
              m
          in
          dconst.(index) <- Ta1387
    in
    let Ti1389 : INT =
      let Ti1388 : INT =
        int 1
      in
      sub index Ti1388
    in
    app
      iter_setup_dirvec_constants
      dirvec
      Ti1389
    unit ()
in
letrec setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> UNIT) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Ti1381 : INT =
    let Ti1379 : INT =
      let Ti1378 : INT =
        int 0
      in
      n_objects.(Ti1378)
    in
    let Ti1380 : INT =
      int 1
    in
    sub Ti1379 Ti1380
  in
  app
    iter_setup_dirvec_constants
    dirvec
    Ti1381
in
letrec setup_startp_constants : (Array of FLOAT -> (INT -> UNIT)) =
variables : (p : Array of FLOAT), (index : INT)
  let Ti1339 : INT =
    int 0
  in
  if Ti1339 <= index
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let sconst : Array of FLOAT =
      app
        o_param_ctbl
        obj
    in
    let m_shape : INT =
      app
        o_form
        obj
    in
    let Tu122 : UNIT =
      let Ti1340 : INT =
        int 0
      in
      let Td1344 : FLOAT =
        let Td1342 : FLOAT =
          let Ti1341 : INT =
            int 0
          in
          p.(Ti1341)
        in
        let Td1343 : FLOAT =
          app
            o_param_x
            obj
        in
        fsub Td1342 Td1343
      in
      sconst.(Ti1340) <- Td1344
    in
    let Tu121 : UNIT =
      let Ti1345 : INT =
        int 1
      in
      let Td1349 : FLOAT =
        let Td1347 : FLOAT =
          let Ti1346 : INT =
            int 1
          in
          p.(Ti1346)
        in
        let Td1348 : FLOAT =
          app
            o_param_y
            obj
        in
        fsub Td1347 Td1348
      in
      sconst.(Ti1345) <- Td1349
    in
    let Tu120 : UNIT =
      let Ti1350 : INT =
        int 2
      in
      let Td1354 : FLOAT =
        let Td1352 : FLOAT =
          let Ti1351 : INT =
            int 2
          in
          p.(Ti1351)
        in
        let Td1353 : FLOAT =
          app
            o_param_z
            obj
        in
        fsub Td1352 Td1353
      in
      sconst.(Ti1350) <- Td1354
    in
    let Tu119 : UNIT =
      let Ti1355 : INT =
        int 2
      in
      if m_shape == Ti1355
        let Ti1356 : INT =
          int 3
        in
        let Td1364 : FLOAT =
          let Ta1357 : Array of FLOAT =
            app
              o_param_abc
              obj
          in
          let Td1359 : FLOAT =
            let Ti1358 : INT =
              int 0
            in
            sconst.(Ti1358)
          in
          let Td1361 : FLOAT =
            let Ti1360 : INT =
              int 1
            in
            sconst.(Ti1360)
          in
          let Td1363 : FLOAT =
            let Ti1362 : INT =
              int 2
            in
            sconst.(Ti1362)
          in
          app
            veciprod2
            Ta1357
            Td1359
            Td1361
            Td1363
        in
        sconst.(Ti1356) <- Td1364
        let Ti1365 : INT =
          int 2
        in
        if m_shape <= Ti1365
          unit ()
          let cc0 : FLOAT =
            let Td1367 : FLOAT =
              let Ti1366 : INT =
                int 0
              in
              sconst.(Ti1366)
            in
            let Td1369 : FLOAT =
              let Ti1368 : INT =
                int 1
              in
              sconst.(Ti1368)
            in
            let Td1371 : FLOAT =
              let Ti1370 : INT =
                int 2
              in
              sconst.(Ti1370)
            in
            app
              quadratic
              obj
              Td1367
              Td1369
              Td1371
          in
          let Ti1372 : INT =
            int 3
          in
          let Td1375 : FLOAT =
            let Ti1373 : INT =
              int 3
            in
            if m_shape == Ti1373
              let Td1374 : FLOAT =
                float 1.
              in
              fsub cc0 Td1374
              cc0
          in
          sconst.(Ti1372) <- Td1375
    in
    let Ti1377 : INT =
      let Ti1376 : INT =
        int 1
      in
      sub index Ti1376
    in
    app
      setup_startp_constants
      p
      Ti1377
    unit ()
in
letrec setup_startp : (Array of FLOAT -> UNIT) =
variables : (p : Array of FLOAT)
  let Tu123 : UNIT =
    app
      veccpy
      startp_fast
      p
  in
  let Ti1338 : INT =
    let Ti1336 : INT =
      let Ti1335 : INT =
        int 0
      in
      n_objects.(Ti1335)
    in
    let Ti1337 : INT =
      int 1
    in
    sub Ti1336 Ti1337
  in
  app
    setup_startp_constants
    p
    Ti1338
in
letrec is_rect_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let Ti1331 : INT =
    let Td1325 : FLOAT =
      app
        fabs
        p0
    in
    let Td1326 : FLOAT =
      app
        o_param_a
        m
    in
    if Td1325 <. Td1326
      let Td1327 : FLOAT =
        app
          fabs
          p1
      in
      let Td1328 : FLOAT =
        app
          o_param_b
          m
      in
      if Td1327 <. Td1328
        let Td1329 : FLOAT =
          app
            fabs
            p2
        in
        let Td1330 : FLOAT =
          app
            o_param_c
            m
        in
        if Td1329 <. Td1330
          int 1
          int 0
        int 0
      int 0
  in
  let Ti1332 : INT =
    int 0
  in
  if Ti1331 == Ti1332
    let Tb1333 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1334 : INT =
      int 0
    in
    if Tb1333 == Ti1334
      int 1
      int 0
    app
      o_isinvert
      m
in
letrec is_plane_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    let Ta1320 : Array of FLOAT =
      app
        o_param_abc
        m
    in
    app
      veciprod2
      Ta1320
      p0
      p1
      p2
  in
  let Tb1323 : BOOL =
    let Tb1321 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1322 : BOOL =
      app
        fisneg
        w
    in
    app
      xor
      Tb1321
      Tb1322
  in
  let Ti1324 : INT =
    int 0
  in
  if Tb1323 == Ti1324
    int 1
    int 0
in
letrec is_second_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    app
      quadratic
      m
      p0
      p1
      p2
  in
  let w2 : FLOAT =
    let Ti1313 : INT =
      app
        o_form
        m
    in
    let Ti1314 : INT =
      int 3
    in
    if Ti1313 == Ti1314
      let Td1315 : FLOAT =
        float 1.
      in
      fsub w Td1315
      w
  in
  let Tb1318 : BOOL =
    let Tb1316 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1317 : BOOL =
      app
        fisneg
        w2
    in
    app
      xor
      Tb1316
      Tb1317
  in
  let Ti1319 : INT =
    int 0
  in
  if Tb1318 == Ti1319
    int 1
    int 0
in
letrec is_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let p0 : FLOAT =
    let Td1308 : FLOAT =
      app
        o_param_x
        m
    in
    fsub q0 Td1308
  in
  let p1 : FLOAT =
    let Td1309 : FLOAT =
      app
        o_param_y
        m
    in
    fsub q1 Td1309
  in
  let p2 : FLOAT =
    let Td1310 : FLOAT =
      app
        o_param_z
        m
    in
    fsub q2 Td1310
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1311 : INT =
    int 1
  in
  if m_shape == Ti1311
    app
      is_rect_outside
      m
      p0
      p1
      p2
    let Ti1312 : INT =
      int 2
    in
    if m_shape == Ti1312
      app
        is_plane_outside
        m
        p0
        p1
        p2
      app
        is_second_outside
        m
        p0
        p1
        p2
in
letrec check_all_inside : (INT -> (Array of INT -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL))))) =
variables : (ofs : INT), (iand : Array of INT), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let head : INT =
    iand.(ofs)
  in
  let Ti1302 : INT =
    let Ti1301 : INT =
      int 1
    in
    neg Ti1301
  in
  if head == Ti1302
    int 1
    let Tb1304 : BOOL =
      let Tt1303 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(head)
      in
      app
        is_outside
        Tt1303
        q0
        q1
        q2
    in
    let Ti1305 : INT =
      int 0
    in
    if Tb1304 == Ti1305
      let Ti1307 : INT =
        let Ti1306 : INT =
          int 1
        in
        add ofs Ti1306
      in
      app
        check_all_inside
        Ti1307
        iand
        q0
        q1
        q2
      int 0
in
letrec shadow_check_and_group : (INT -> (Array of INT -> BOOL)) =
variables : (iand_ofs : INT), (and_group : Array of INT)
  let Ti1267 : INT =
    and_group.(iand_ofs)
  in
  let Ti1269 : INT =
    let Ti1268 : INT =
      int 1
    in
    neg Ti1268
  in
  if Ti1267 == Ti1269
    int 0
    let obj : INT =
      and_group.(iand_ofs)
    in
    let t0 : INT =
      app
        solver_fast
        obj
        light_dirvec
        intersection_point
    in
    let t0p : FLOAT =
      let Ti1270 : INT =
        int 0
      in
      solver_dist.(Ti1270)
    in
    let Ti1273 : INT =
      let Ti1271 : INT =
        int 0
      in
      if t0 == Ti1271
        int 0
        let Td1272 : FLOAT =
          float -0.2
        in
        if t0p <. Td1272
          int 1
          int 0
    in
    let Ti1274 : INT =
      int 0
    in
    if Ti1273 == Ti1274
      let Tb1276 : BOOL =
        let Tt1275 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(obj)
        in
        app
          o_isinvert
          Tt1275
      in
      let Ti1277 : INT =
        int 0
      in
      if Tb1276 == Ti1277
        int 0
        let Ti1279 : INT =
          let Ti1278 : INT =
            int 1
          in
          add iand_ofs Ti1278
        in
        app
          shadow_check_and_group
          Ti1279
          and_group
      let t : FLOAT =
        let Td1280 : FLOAT =
          float 0.01
        in
        fadd t0p Td1280
      in
      let q0 : FLOAT =
        let Td1283 : FLOAT =
          let Td1282 : FLOAT =
            let Ti1281 : INT =
              int 0
            in
            light.(Ti1281)
          in
          fmul Td1282 t
        in
        let Td1285 : FLOAT =
          let Ti1284 : INT =
            int 0
          in
          intersection_point.(Ti1284)
        in
        fadd Td1283 Td1285
      in
      let q1 : FLOAT =
        let Td1288 : FLOAT =
          let Td1287 : FLOAT =
            let Ti1286 : INT =
              int 1
            in
            light.(Ti1286)
          in
          fmul Td1287 t
        in
        let Td1290 : FLOAT =
          let Ti1289 : INT =
            int 1
          in
          intersection_point.(Ti1289)
        in
        fadd Td1288 Td1290
      in
      let q2 : FLOAT =
        let Td1293 : FLOAT =
          let Td1292 : FLOAT =
            let Ti1291 : INT =
              int 2
            in
            light.(Ti1291)
          in
          fmul Td1292 t
        in
        let Td1295 : FLOAT =
          let Ti1294 : INT =
            int 2
          in
          intersection_point.(Ti1294)
        in
        fadd Td1293 Td1295
      in
      let Tb1297 : BOOL =
        let Ti1296 : INT =
          int 0
        in
        app
          check_all_inside
          Ti1296
          and_group
          q0
          q1
          q2
      in
      let Ti1298 : INT =
        int 0
      in
      if Tb1297 == Ti1298
        let Ti1300 : INT =
          let Ti1299 : INT =
            int 1
          in
          add iand_ofs Ti1299
        in
        app
          shadow_check_and_group
          Ti1300
          and_group
        int 1
in
letrec shadow_check_one_or_group : (INT -> (Array of INT -> BOOL)) =
variables : (ofs : INT), (or_group : Array of INT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1262 : INT =
    let Ti1261 : INT =
      int 1
    in
    neg Ti1261
  in
  if head == Ti1262
    int 0
    let and_group : Array of INT =
      and_net.(head)
    in
    let shadow_p : BOOL =
      let Ti1263 : INT =
        int 0
      in
      app
        shadow_check_and_group
        Ti1263
        and_group
    in
    let Ti1264 : INT =
      int 0
    in
    if shadow_p == Ti1264
      let Ti1266 : INT =
        let Ti1265 : INT =
          int 1
        in
        add ofs Ti1265
      in
      app
        shadow_check_one_or_group
        Ti1266
        or_group
      int 1
in
letrec shadow_check_one_or_matrix : (INT -> (Array of Array of INT -> BOOL)) =
variables : (ofs : INT), (or_matrix : Array of Array of INT)
  let head : Array of INT =
    or_matrix.(ofs)
  in
  let range_primitive : INT =
    let Ti1241 : INT =
      int 0
    in
    head.(Ti1241)
  in
  let Ti1243 : INT =
    let Ti1242 : INT =
      int 1
    in
    neg Ti1242
  in
  if range_primitive == Ti1243
    int 0
    let Ti1252 : INT =
      let Ti1244 : INT =
        int 99
      in
      if range_primitive == Ti1244
        int 1
        let t : INT =
          app
            solver_fast
            range_primitive
            light_dirvec
            intersection_point
        in
        let Ti1245 : INT =
          int 0
        in
        if t == Ti1245
          int 0
          let Td1247 : FLOAT =
            let Ti1246 : INT =
              int 0
            in
            solver_dist.(Ti1246)
          in
          let Td1248 : FLOAT =
            float -0.1
          in
          if Td1247 <. Td1248
            let Tb1250 : BOOL =
              let Ti1249 : INT =
                int 1
              in
              app
                shadow_check_one_or_group
                Ti1249
                head
            in
            let Ti1251 : INT =
              int 0
            in
            if Tb1250 == Ti1251
              int 0
              int 1
            int 0
    in
    let Ti1253 : INT =
      int 0
    in
    if Ti1252 == Ti1253
      let Ti1255 : INT =
        let Ti1254 : INT =
          int 1
        in
        add ofs Ti1254
      in
      app
        shadow_check_one_or_matrix
        Ti1255
        or_matrix
      let Tb1257 : BOOL =
        let Ti1256 : INT =
          int 1
        in
        app
          shadow_check_one_or_group
          Ti1256
          head
      in
      let Ti1258 : INT =
        int 0
      in
      if Tb1257 == Ti1258
        let Ti1260 : INT =
          let Ti1259 : INT =
            int 1
          in
          add ofs Ti1259
        in
        app
          shadow_check_one_or_matrix
          Ti1260
          or_matrix
        int 1
in
letrec solve_each_element : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : Array of FLOAT)
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1206 : INT =
    let Ti1205 : INT =
      int 1
    in
    neg Ti1205
  in
  if iobj == Ti1206
    unit ()
    let t0 : INT =
      app
        solver
        iobj
        dirvec
        startp
    in
    let Ti1207 : INT =
      int 0
    in
    if t0 == Ti1207
      let Tb1209 : BOOL =
        let Tt1208 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1208
      in
      let Ti1210 : INT =
        int 0
      in
      if Tb1209 == Ti1210
        unit ()
        let Ti1212 : INT =
          let Ti1211 : INT =
            int 1
          in
          add iand_ofs Ti1211
        in
        app
          solve_each_element
          Ti1212
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1213 : INT =
          int 0
        in
        solver_dist.(Ti1213)
      in
      let Tu127 : UNIT =
        let Td1214 : FLOAT =
          float 0.
        in
        if Td1214 <. t0p
          let Td1216 : FLOAT =
            let Ti1215 : INT =
              int 0
            in
            tmin.(Ti1215)
          in
          if t0p <. Td1216
            let t : FLOAT =
              let Td1217 : FLOAT =
                float 0.01
              in
              fadd t0p Td1217
            in
            let q0 : FLOAT =
              let Td1220 : FLOAT =
                let Td1219 : FLOAT =
                  let Ti1218 : INT =
                    int 0
                  in
                  dirvec.(Ti1218)
                in
                fmul Td1219 t
              in
              let Td1222 : FLOAT =
                let Ti1221 : INT =
                  int 0
                in
                startp.(Ti1221)
              in
              fadd Td1220 Td1222
            in
            let q1 : FLOAT =
              let Td1225 : FLOAT =
                let Td1224 : FLOAT =
                  let Ti1223 : INT =
                    int 1
                  in
                  dirvec.(Ti1223)
                in
                fmul Td1224 t
              in
              let Td1227 : FLOAT =
                let Ti1226 : INT =
                  int 1
                in
                startp.(Ti1226)
              in
              fadd Td1225 Td1227
            in
            let q2 : FLOAT =
              let Td1230 : FLOAT =
                let Td1229 : FLOAT =
                  let Ti1228 : INT =
                    int 2
                  in
                  dirvec.(Ti1228)
                in
                fmul Td1229 t
              in
              let Td1232 : FLOAT =
                let Ti1231 : INT =
                  int 2
                in
                startp.(Ti1231)
              in
              fadd Td1230 Td1232
            in
            let Tb1234 : BOOL =
              let Ti1233 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1233
                and_group
                q0
                q1
                q2
            in
            let Ti1235 : INT =
              int 0
            in
            if Tb1234 == Ti1235
              unit ()
              let Tu126 : UNIT =
                let Ti1236 : INT =
                  int 0
                in
                tmin.(Ti1236) <- t
              in
              let Tu125 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu124 : UNIT =
                let Ti1237 : INT =
                  int 0
                in
                intersected_object_id.(Ti1237) <- iobj
              in
              let Ti1238 : INT =
                int 0
              in
              intsec_rectside.(Ti1238) <- t0
            unit ()
          unit ()
      in
      let Ti1240 : INT =
        let Ti1239 : INT =
          int 1
        in
        add iand_ofs Ti1239
      in
      app
        solve_each_element
        Ti1240
        and_group
        dirvec
in
letrec solve_one_or_network : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : Array of FLOAT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1201 : INT =
    let Ti1200 : INT =
      int 1
    in
    neg Ti1200
  in
  if head == Ti1201
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu128 : UNIT =
      let Ti1202 : INT =
        int 0
      in
      app
        solve_each_element
        Ti1202
        and_group
        dirvec
    in
    let Ti1204 : INT =
      let Ti1203 : INT =
        int 1
      in
      add ofs Ti1203
    in
    app
      solve_one_or_network
      Ti1204
      or_group
      dirvec
in
letrec trace_or_matrix : (INT -> (Array of Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : Array of FLOAT)
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1188 : INT =
      int 0
    in
    head.(Ti1188)
  in
  let Ti1190 : INT =
    let Ti1189 : INT =
      int 1
    in
    neg Ti1189
  in
  if range_primitive == Ti1190
    unit ()
    let Tu129 : UNIT =
      let Ti1191 : INT =
        int 99
      in
      if range_primitive == Ti1191
        let Ti1192 : INT =
          int 1
        in
        app
          solve_one_or_network
          Ti1192
          head
          dirvec
        let t : INT =
          app
            solver
            range_primitive
            dirvec
            startp
        in
        let Ti1193 : INT =
          int 0
        in
        if t == Ti1193
          unit ()
          let tp : FLOAT =
            let Ti1194 : INT =
              int 0
            in
            solver_dist.(Ti1194)
          in
          let Td1196 : FLOAT =
            let Ti1195 : INT =
              int 0
            in
            tmin.(Ti1195)
          in
          if tp <. Td1196
            let Ti1197 : INT =
              int 1
            in
            app
              solve_one_or_network
              Ti1197
              head
              dirvec
            unit ()
    in
    let Ti1199 : INT =
      let Ti1198 : INT =
        int 1
      in
      add ofs Ti1198
    in
    app
      trace_or_matrix
      Ti1199
      or_network
      dirvec
in
letrec judge_intersection : (Array of FLOAT -> BOOL) =
variables : (dirvec : Array of FLOAT)
  let Tu131 : UNIT =
    let Ti1180 : INT =
      int 0
    in
    let Td1181 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1180) <- Td1181
  in
  let Tu130 : UNIT =
    let Ti1182 : INT =
      int 0
    in
    let Ta1184 : Array of Array of INT =
      let Ti1183 : INT =
        int 0
      in
      or_net.(Ti1183)
    in
    app
      trace_or_matrix
      Ti1182
      Ta1184
      dirvec
  in
  let t : FLOAT =
    let Ti1185 : INT =
      int 0
    in
    tmin.(Ti1185)
  in
  let Td1186 : FLOAT =
    float -0.1
  in
  if Td1186 <. t
    let Td1187 : FLOAT =
      float 100000000.
    in
    if t <. Td1187
      int 1
      int 0
    int 0
in
letrec solve_each_element_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let vec : Array of FLOAT =
    app
      d_vec
      dirvec
  in
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1145 : INT =
    let Ti1144 : INT =
      int 1
    in
    neg Ti1144
  in
  if iobj == Ti1145
    unit ()
    let t0 : INT =
      app
        solver_fast2
        iobj
        dirvec
    in
    let Ti1146 : INT =
      int 0
    in
    if t0 == Ti1146
      let Tb1148 : BOOL =
        let Tt1147 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1147
      in
      let Ti1149 : INT =
        int 0
      in
      if Tb1148 == Ti1149
        unit ()
        let Ti1151 : INT =
          let Ti1150 : INT =
            int 1
          in
          add iand_ofs Ti1150
        in
        app
          solve_each_element_fast
          Ti1151
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1152 : INT =
          int 0
        in
        solver_dist.(Ti1152)
      in
      let Tu135 : UNIT =
        let Td1153 : FLOAT =
          float 0.
        in
        if Td1153 <. t0p
          let Td1155 : FLOAT =
            let Ti1154 : INT =
              int 0
            in
            tmin.(Ti1154)
          in
          if t0p <. Td1155
            let t : FLOAT =
              let Td1156 : FLOAT =
                float 0.01
              in
              fadd t0p Td1156
            in
            let q0 : FLOAT =
              let Td1159 : FLOAT =
                let Td1158 : FLOAT =
                  let Ti1157 : INT =
                    int 0
                  in
                  vec.(Ti1157)
                in
                fmul Td1158 t
              in
              let Td1161 : FLOAT =
                let Ti1160 : INT =
                  int 0
                in
                startp_fast.(Ti1160)
              in
              fadd Td1159 Td1161
            in
            let q1 : FLOAT =
              let Td1164 : FLOAT =
                let Td1163 : FLOAT =
                  let Ti1162 : INT =
                    int 1
                  in
                  vec.(Ti1162)
                in
                fmul Td1163 t
              in
              let Td1166 : FLOAT =
                let Ti1165 : INT =
                  int 1
                in
                startp_fast.(Ti1165)
              in
              fadd Td1164 Td1166
            in
            let q2 : FLOAT =
              let Td1169 : FLOAT =
                let Td1168 : FLOAT =
                  let Ti1167 : INT =
                    int 2
                  in
                  vec.(Ti1167)
                in
                fmul Td1168 t
              in
              let Td1171 : FLOAT =
                let Ti1170 : INT =
                  int 2
                in
                startp_fast.(Ti1170)
              in
              fadd Td1169 Td1171
            in
            let Tb1173 : BOOL =
              let Ti1172 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1172
                and_group
                q0
                q1
                q2
            in
            let Ti1174 : INT =
              int 0
            in
            if Tb1173 == Ti1174
              unit ()
              let Tu134 : UNIT =
                let Ti1175 : INT =
                  int 0
                in
                tmin.(Ti1175) <- t
              in
              let Tu133 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu132 : UNIT =
                let Ti1176 : INT =
                  int 0
                in
                intersected_object_id.(Ti1176) <- iobj
              in
              let Ti1177 : INT =
                int 0
              in
              intsec_rectside.(Ti1177) <- t0
            unit ()
          unit ()
      in
      let Ti1179 : INT =
        let Ti1178 : INT =
          int 1
        in
        add iand_ofs Ti1178
      in
      app
        solve_each_element_fast
        Ti1179
        and_group
        dirvec
in
letrec solve_one_or_network_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : INT =
    or_group.(ofs)
  in
  let Ti1140 : INT =
    let Ti1139 : INT =
      int 1
    in
    neg Ti1139
  in
  if head == Ti1140
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu136 : UNIT =
      let Ti1141 : INT =
        int 0
      in
      app
        solve_each_element_fast
        Ti1141
        and_group
        dirvec
    in
    let Ti1143 : INT =
      let Ti1142 : INT =
        int 1
      in
      add ofs Ti1142
    in
    app
      solve_one_or_network_fast
      Ti1143
      or_group
      dirvec
in
letrec trace_or_matrix_fast : (INT -> (Array of Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1127 : INT =
      int 0
    in
    head.(Ti1127)
  in
  let Ti1129 : INT =
    let Ti1128 : INT =
      int 1
    in
    neg Ti1128
  in
  if range_primitive == Ti1129
    unit ()
    let Tu137 : UNIT =
      let Ti1130 : INT =
        int 99
      in
      if range_primitive == Ti1130
        let Ti1131 : INT =
          int 1
        in
        app
          solve_one_or_network_fast
          Ti1131
          head
          dirvec
        let t : INT =
          app
            solver_fast2
            range_primitive
            dirvec
        in
        let Ti1132 : INT =
          int 0
        in
        if t == Ti1132
          unit ()
          let tp : FLOAT =
            let Ti1133 : INT =
              int 0
            in
            solver_dist.(Ti1133)
          in
          let Td1135 : FLOAT =
            let Ti1134 : INT =
              int 0
            in
            tmin.(Ti1134)
          in
          if tp <. Td1135
            let Ti1136 : INT =
              int 1
            in
            app
              solve_one_or_network_fast
              Ti1136
              head
              dirvec
            unit ()
    in
    let Ti1138 : INT =
      let Ti1137 : INT =
        int 1
      in
      add ofs Ti1137
    in
    app
      trace_or_matrix_fast
      Ti1138
      or_network
      dirvec
in
letrec judge_intersection_fast : ((Array of FLOAT * Array of Array of FLOAT) -> BOOL) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Tu139 : UNIT =
    let Ti1119 : INT =
      int 0
    in
    let Td1120 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1119) <- Td1120
  in
  let Tu138 : UNIT =
    let Ti1121 : INT =
      int 0
    in
    let Ta1123 : Array of Array of INT =
      let Ti1122 : INT =
        int 0
      in
      or_net.(Ti1122)
    in
    app
      trace_or_matrix_fast
      Ti1121
      Ta1123
      dirvec
  in
  let t : FLOAT =
    let Ti1124 : INT =
      int 0
    in
    tmin.(Ti1124)
  in
  let Td1125 : FLOAT =
    float -0.1
  in
  if Td1125 <. t
    let Td1126 : FLOAT =
      float 100000000.
    in
    if t <. Td1126
      int 1
      int 0
    int 0
in
letrec get_nvector_rect : (Array of FLOAT -> UNIT) =
variables : (dirvec : Array of FLOAT)
  let rectside : INT =
    let Ti1111 : INT =
      int 0
    in
    intsec_rectside.(Ti1111)
  in
  let Tu140 : UNIT =
    app
      vecbzero
      nvector
  in
  let Ti1113 : INT =
    let Ti1112 : INT =
      int 1
    in
    sub rectside Ti1112
  in
  let Td1118 : FLOAT =
    let Td1117 : FLOAT =
      let Td1116 : FLOAT =
        let Ti1115 : INT =
          let Ti1114 : INT =
            int 1
          in
          sub rectside Ti1114
        in
        dirvec.(Ti1115)
      in
      app
        sgn
        Td1116
    in
    app
      fneg
      Td1117
  in
  nvector.(Ti1113) <- Td1118
in
letrec get_nvector_plane : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let Tu142 : UNIT =
    let Ti1102 : INT =
      int 0
    in
    let Td1104 : FLOAT =
      let Td1103 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fneg
        Td1103
    in
    nvector.(Ti1102) <- Td1104
  in
  let Tu141 : UNIT =
    let Ti1105 : INT =
      int 1
    in
    let Td1107 : FLOAT =
      let Td1106 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fneg
        Td1106
    in
    nvector.(Ti1105) <- Td1107
  in
  let Ti1108 : INT =
    int 2
  in
  let Td1110 : FLOAT =
    let Td1109 : FLOAT =
      app
        o_param_c
        m
    in
    app
      fneg
      Td1109
  in
  nvector.(Ti1108) <- Td1110
in
letrec get_nvector_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let p0 : FLOAT =
    let Td1061 : FLOAT =
      let Ti1060 : INT =
        int 0
      in
      intersection_point.(Ti1060)
    in
    let Td1062 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1061 Td1062
  in
  let p1 : FLOAT =
    let Td1064 : FLOAT =
      let Ti1063 : INT =
        int 1
      in
      intersection_point.(Ti1063)
    in
    let Td1065 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1064 Td1065
  in
  let p2 : FLOAT =
    let Td1067 : FLOAT =
      let Ti1066 : INT =
        int 2
      in
      intersection_point.(Ti1066)
    in
    let Td1068 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1067 Td1068
  in
  let d0 : FLOAT =
    let Td1069 : FLOAT =
      app
        o_param_a
        m
    in
    fmul p0 Td1069
  in
  let d1 : FLOAT =
    let Td1070 : FLOAT =
      app
        o_param_b
        m
    in
    fmul p1 Td1070
  in
  let d2 : FLOAT =
    let Td1071 : FLOAT =
      app
        o_param_c
        m
    in
    fmul p2 Td1071
  in
  let Tu147 : UNIT =
    let Ti1072 : INT =
      app
        o_isrot
        m
    in
    let Ti1073 : INT =
      int 0
    in
    if Ti1072 == Ti1073
      let Tu144 : UNIT =
        let Ti1074 : INT =
          int 0
        in
        nvector.(Ti1074) <- d0
      in
      let Tu143 : UNIT =
        let Ti1075 : INT =
          int 1
        in
        nvector.(Ti1075) <- d1
      in
      let Ti1076 : INT =
        int 2
      in
      nvector.(Ti1076) <- d2
      let Tu146 : UNIT =
        let Ti1077 : INT =
          int 0
        in
        let Td1084 : FLOAT =
          let Td1083 : FLOAT =
            let Td1082 : FLOAT =
              let Td1079 : FLOAT =
                let Td1078 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p1 Td1078
              in
              let Td1081 : FLOAT =
                let Td1080 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul p2 Td1080
              in
              fadd Td1079 Td1081
            in
            app
              fhalf
              Td1082
          in
          fadd d0 Td1083
        in
        nvector.(Ti1077) <- Td1084
      in
      let Tu145 : UNIT =
        let Ti1085 : INT =
          int 1
        in
        let Td1092 : FLOAT =
          let Td1091 : FLOAT =
            let Td1090 : FLOAT =
              let Td1087 : FLOAT =
                let Td1086 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p0 Td1086
              in
              let Td1089 : FLOAT =
                let Td1088 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul p2 Td1088
              in
              fadd Td1087 Td1089
            in
            app
              fhalf
              Td1090
          in
          fadd d1 Td1091
        in
        nvector.(Ti1085) <- Td1092
      in
      let Ti1093 : INT =
        int 2
      in
      let Td1100 : FLOAT =
        let Td1099 : FLOAT =
          let Td1098 : FLOAT =
            let Td1095 : FLOAT =
              let Td1094 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul p0 Td1094
            in
            let Td1097 : FLOAT =
              let Td1096 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul p1 Td1096
            in
            fadd Td1095 Td1097
          in
          app
            fhalf
            Td1098
        in
        fadd d2 Td1099
      in
      nvector.(Ti1093) <- Td1100
  in
  let Tb1101 : BOOL =
    app
      o_isinvert
      m
  in
  app
    vecunit_sgn
    nvector
    Tb1101
in
letrec get_nvector : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT)
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1058 : INT =
    int 1
  in
  if m_shape == Ti1058
    app
      get_nvector_rect
      dirvec
    let Ti1059 : INT =
      int 2
    in
    if m_shape == Ti1059
      app
        get_nvector_plane
        m
      app
        get_nvector_second
        m
in
letrec utexture : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p : Array of FLOAT)
  let m_tex : INT =
    app
      o_texturetype
      m
  in
  let Tu152 : UNIT =
    let Ti938 : INT =
      int 0
    in
    let Td939 : FLOAT =
      app
        o_color_red
        m
    in
    texture_color.(Ti938) <- Td939
  in
  let Tu151 : UNIT =
    let Ti940 : INT =
      int 1
    in
    let Td941 : FLOAT =
      app
        o_color_green
        m
    in
    texture_color.(Ti940) <- Td941
  in
  let Tu150 : UNIT =
    let Ti942 : INT =
      int 2
    in
    let Td943 : FLOAT =
      app
        o_color_blue
        m
    in
    texture_color.(Ti942) <- Td943
  in
  let Ti944 : INT =
    int 1
  in
  if m_tex == Ti944
    let w1 : FLOAT =
      let Td946 : FLOAT =
        let Ti945 : INT =
          int 0
        in
        p.(Ti945)
      in
      let Td947 : FLOAT =
        app
          o_param_x
          m
      in
      fsub Td946 Td947
    in
    let flag1 : BOOL =
      let d1 : FLOAT =
        let Td950 : FLOAT =
          let Td949 : FLOAT =
            let Td948 : FLOAT =
              float 0.05
            in
            fmul w1 Td948
          in
          app
            floor
            Td949
        in
        let Td951 : FLOAT =
          float 20.
        in
        fmul Td950 Td951
      in
      let Td952 : FLOAT =
        fsub w1 d1
      in
      let Td953 : FLOAT =
        float 10.
      in
      if Td952 <. Td953
        int 1
        int 0
    in
    let w3 : FLOAT =
      let Td955 : FLOAT =
        let Ti954 : INT =
          int 2
        in
        p.(Ti954)
      in
      let Td956 : FLOAT =
        app
          o_param_z
          m
      in
      fsub Td955 Td956
    in
    let flag2 : BOOL =
      let d2 : FLOAT =
        let Td959 : FLOAT =
          let Td958 : FLOAT =
            let Td957 : FLOAT =
              float 0.05
            in
            fmul w3 Td957
          in
          app
            floor
            Td958
        in
        let Td960 : FLOAT =
          float 20.
        in
        fmul Td959 Td960
      in
      let Td961 : FLOAT =
        fsub w3 d2
      in
      let Td962 : FLOAT =
        float 10.
      in
      if Td961 <. Td962
        int 1
        int 0
    in
    let Ti963 : INT =
      int 1
    in
    let Td967 : FLOAT =
      let Ti964 : INT =
        int 0
      in
      if flag1 == Ti964
        let Ti965 : INT =
          int 0
        in
        if flag2 == Ti965
          float 255.
          float 0.
        let Ti966 : INT =
          int 0
        in
        if flag2 == Ti966
          float 0.
          float 255.
    in
    texture_color.(Ti963) <- Td967
    let Ti968 : INT =
      int 2
    in
    if m_tex == Ti968
      let w2 : FLOAT =
        let Td973 : FLOAT =
          let Td972 : FLOAT =
            let Td970 : FLOAT =
              let Ti969 : INT =
                int 1
              in
              p.(Ti969)
            in
            let Td971 : FLOAT =
              float 0.25
            in
            fmul Td970 Td971
          in
          app
            sin
            Td972
        in
        unknown fsqr Td973
      in
      let Tu148 : UNIT =
        let Ti974 : INT =
          int 0
        in
        let Td976 : FLOAT =
          let Td975 : FLOAT =
            float 255.
          in
          fmul Td975 w2
        in
        texture_color.(Ti974) <- Td976
      in
      let Ti977 : INT =
        int 1
      in
      let Td981 : FLOAT =
        let Td978 : FLOAT =
          float 255.
        in
        let Td980 : FLOAT =
          let Td979 : FLOAT =
            float 1.
          in
          fsub Td979 w2
        in
        fmul Td978 Td980
      in
      texture_color.(Ti977) <- Td981
      let Ti982 : INT =
        int 3
      in
      if m_tex == Ti982
        let w1 : FLOAT =
          let Td984 : FLOAT =
            let Ti983 : INT =
              int 0
            in
            p.(Ti983)
          in
          let Td985 : FLOAT =
            app
              o_param_x
              m
          in
          fsub Td984 Td985
        in
        let w3 : FLOAT =
          let Td987 : FLOAT =
            let Ti986 : INT =
              int 2
            in
            p.(Ti986)
          in
          let Td988 : FLOAT =
            app
              o_param_z
              m
          in
          fsub Td987 Td988
        in
        let w2 : FLOAT =
          let Td992 : FLOAT =
            let Td991 : FLOAT =
              let Td989 : FLOAT =
                unknown fsqr w1
              in
              let Td990 : FLOAT =
                unknown fsqr w3
              in
              fadd Td989 Td990
            in
            app
              sqrt
              Td991
          in
          let Td993 : FLOAT =
            float 10.
          in
          app
            fdiv
            Td992
            Td993
        in
        let w4 : FLOAT =
          let Td995 : FLOAT =
            let Td994 : FLOAT =
              app
                floor
                w2
            in
            fsub w2 Td994
          in
          let Td996 : FLOAT =
            float 3.1415927
          in
          fmul Td995 Td996
        in
        let cws : FLOAT =
          let Td997 : FLOAT =
            app
              cos
              w4
          in
          unknown fsqr Td997
        in
        let Tu149 : UNIT =
          let Ti998 : INT =
            int 1
          in
          let Td1000 : FLOAT =
            let Td999 : FLOAT =
              float 255.
            in
            fmul cws Td999
          in
          texture_color.(Ti998) <- Td1000
        in
        let Ti1001 : INT =
          int 2
        in
        let Td1005 : FLOAT =
          let Td1003 : FLOAT =
            let Td1002 : FLOAT =
              float 1.
            in
            fsub Td1002 cws
          in
          let Td1004 : FLOAT =
            float 255.
          in
          fmul Td1003 Td1004
        in
        texture_color.(Ti1001) <- Td1005
        let Ti1006 : INT =
          int 4
        in
        if m_tex == Ti1006
          let w1 : FLOAT =
            let Td1010 : FLOAT =
              let Td1008 : FLOAT =
                let Ti1007 : INT =
                  int 0
                in
                p.(Ti1007)
              in
              let Td1009 : FLOAT =
                app
                  o_param_x
                  m
              in
              fsub Td1008 Td1009
            in
            let Td1012 : FLOAT =
              let Td1011 : FLOAT =
                app
                  o_param_a
                  m
              in
              app
                sqrt
                Td1011
            in
            fmul Td1010 Td1012
          in
          let w3 : FLOAT =
            let Td1016 : FLOAT =
              let Td1014 : FLOAT =
                let Ti1013 : INT =
                  int 2
                in
                p.(Ti1013)
              in
              let Td1015 : FLOAT =
                app
                  o_param_z
                  m
              in
              fsub Td1014 Td1015
            in
            let Td1018 : FLOAT =
              let Td1017 : FLOAT =
                app
                  o_param_c
                  m
              in
              app
                sqrt
                Td1017
            in
            fmul Td1016 Td1018
          in
          let w4 : FLOAT =
            let Td1019 : FLOAT =
              unknown fsqr w1
            in
            let Td1020 : FLOAT =
              unknown fsqr w3
            in
            fadd Td1019 Td1020
          in
          let w7 : FLOAT =
            let Td1021 : FLOAT =
              app
                fabs
                w1
            in
            let Td1022 : FLOAT =
              float 0.0001
            in
            if Td1021 <. Td1022
              float 15.
              let w5 : FLOAT =
                let Td1023 : FLOAT =
                  app
                    fdiv
                    w3
                    w1
                in
                app
                  fabs
                  Td1023
              in
              let Td1026 : FLOAT =
                let Td1024 : FLOAT =
                  app
                    atan
                    w5
                in
                let Td1025 : FLOAT =
                  float 30.
                in
                fmul Td1024 Td1025
              in
              let Td1027 : FLOAT =
                float 3.1415927
              in
              app
                fdiv
                Td1026
                Td1027
          in
          let w9 : FLOAT =
            let Td1028 : FLOAT =
              app
                floor
                w7
            in
            fsub w7 Td1028
          in
          let w2 : FLOAT =
            let Td1032 : FLOAT =
              let Td1030 : FLOAT =
                let Ti1029 : INT =
                  int 1
                in
                p.(Ti1029)
              in
              let Td1031 : FLOAT =
                app
                  o_param_y
                  m
              in
              fsub Td1030 Td1031
            in
            let Td1034 : FLOAT =
              let Td1033 : FLOAT =
                app
                  o_param_b
                  m
              in
              app
                sqrt
                Td1033
            in
            fmul Td1032 Td1034
          in
          let w8 : FLOAT =
            let Td1035 : FLOAT =
              app
                fabs
                w4
            in
            let Td1036 : FLOAT =
              float 0.0001
            in
            if Td1035 <. Td1036
              float 15.
              let w6 : FLOAT =
                let Td1037 : FLOAT =
                  app
                    fdiv
                    w2
                    w4
                in
                app
                  fabs
                  Td1037
              in
              let Td1040 : FLOAT =
                let Td1038 : FLOAT =
                  app
                    atan
                    w6
                in
                let Td1039 : FLOAT =
                  float 30.
                in
                fmul Td1038 Td1039
              in
              let Td1041 : FLOAT =
                float 3.1415927
              in
              app
                fdiv
                Td1040
                Td1041
          in
          let w10 : FLOAT =
            let Td1042 : FLOAT =
              app
                floor
                w8
            in
            fsub w8 Td1042
          in
          let w11 : FLOAT =
            let Td1047 : FLOAT =
              let Td1043 : FLOAT =
                float 0.15
              in
              let Td1046 : FLOAT =
                let Td1045 : FLOAT =
                  let Td1044 : FLOAT =
                    float 0.5
                  in
                  fsub Td1044 w9
                in
                unknown fsqr Td1045
              in
              fsub Td1043 Td1046
            in
            let Td1050 : FLOAT =
              let Td1049 : FLOAT =
                let Td1048 : FLOAT =
                  float 0.5
                in
                fsub Td1048 w10
              in
              unknown fsqr Td1049
            in
            fsub Td1047 Td1050
          in
          let w12 : FLOAT =
            let Tb1051 : BOOL =
              app
                fisneg
                w11
            in
            let Ti1052 : INT =
              int 0
            in
            if Tb1051 == Ti1052
              w11
              float 0.
          in
          let Ti1053 : INT =
            int 2
          in
          let Td1057 : FLOAT =
            let Td1055 : FLOAT =
              let Td1054 : FLOAT =
                float 255.
              in
              fmul Td1054 w12
            in
            let Td1056 : FLOAT =
              float 0.3
            in
            app
              fdiv
              Td1055
              Td1056
          in
          texture_color.(Ti1053) <- Td1057
          unit ()
in
letrec add_light : (FLOAT -> (FLOAT -> (FLOAT -> UNIT))) =
variables : (bright : FLOAT), (hilight : FLOAT), (hilight_scale : FLOAT)
  let Tu155 : UNIT =
    let Tb920 : BOOL =
      app
        fispos
        bright
    in
    let Ti921 : INT =
      int 0
    in
    if Tb920 == Ti921
      unit ()
      app
        vecaccum
        rgb
        bright
        texture_color
  in
  let Tb922 : BOOL =
    app
      fispos
      hilight
  in
  let Ti923 : INT =
    int 0
  in
  if Tb922 == Ti923
    unit ()
    let ihl : FLOAT =
      let Td925 : FLOAT =
        let Td924 : FLOAT =
          unknown fsqr hilight
        in
        unknown fsqr Td924
      in
      fmul Td925 hilight_scale
    in
    let Tu154 : UNIT =
      let Ti926 : INT =
        int 0
      in
      let Td929 : FLOAT =
        let Td928 : FLOAT =
          let Ti927 : INT =
            int 0
          in
          rgb.(Ti927)
        in
        fadd Td928 ihl
      in
      rgb.(Ti926) <- Td929
    in
    let Tu153 : UNIT =
      let Ti930 : INT =
        int 1
      in
      let Td933 : FLOAT =
        let Td932 : FLOAT =
          let Ti931 : INT =
            int 1
          in
          rgb.(Ti931)
        in
        fadd Td932 ihl
      in
      rgb.(Ti930) <- Td933
    in
    let Ti934 : INT =
      int 2
    in
    let Td937 : FLOAT =
      let Td936 : FLOAT =
        let Ti935 : INT =
          int 2
        in
        rgb.(Ti935)
      in
      fadd Td936 ihl
    in
    rgb.(Ti934) <- Td937
in
letrec trace_reflections : (INT -> (FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT)))) =
variables : (index : INT), (diffuse : FLOAT), (hilight_scale : FLOAT), (dirvec : Array of FLOAT)
  let Ti900 : INT =
    int 0
  in
  if Ti900 <= index
    let rinfo : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
      reflections.(index)
    in
    let dvec : (Array of FLOAT * Array of Array of FLOAT) =
      app
        r_dvec
        rinfo
    in
    let Tu156 : UNIT =
      let Tb901 : BOOL =
        app
          judge_intersection_fast
          dvec
      in
      let Ti902 : INT =
        int 0
      in
      if Tb901 == Ti902
        unit ()
        let surface_id : INT =
          let Ti905 : INT =
            let Ti904 : INT =
              let Ti903 : INT =
                int 0
              in
              intersected_object_id.(Ti903)
            in
            mul Ti904 4
          in
          let Ti907 : INT =
            let Ti906 : INT =
              int 0
            in
            intsec_rectside.(Ti906)
          in
          add Ti905 Ti907
        in
        let Ti908 : INT =
          app
            r_surface_id
            rinfo
        in
        if surface_id == Ti908
          let Tb912 : BOOL =
            let Ti909 : INT =
              int 0
            in
            let Ta911 : Array of Array of INT =
              let Ti910 : INT =
                int 0
              in
              or_net.(Ti910)
            in
            app
              shadow_check_one_or_matrix
              Ti909
              Ta911
          in
          let Ti913 : INT =
            int 0
          in
          if Tb912 == Ti913
            let p : FLOAT =
              let Ta914 : Array of FLOAT =
                app
                  d_vec
                  dvec
              in
              app
                veciprod
                nvector
                Ta914
            in
            let scale : FLOAT =
              app
                r_bright
                rinfo
            in
            let bright : FLOAT =
              let Td915 : FLOAT =
                fmul scale diffuse
              in
              fmul Td915 p
            in
            let hilight : FLOAT =
              let Td917 : FLOAT =
                let Ta916 : Array of FLOAT =
                  app
                    d_vec
                    dvec
                in
                app
                  veciprod
                  dirvec
                  Ta916
              in
              fmul scale Td917
            in
            app
              add_light
              bright
              hilight
              hilight_scale
            unit ()
          unit ()
    in
    let Ti919 : INT =
      let Ti918 : INT =
        int 1
      in
      sub index Ti918
    in
    app
      trace_reflections
      Ti919
      diffuse
      hilight_scale
      dirvec
    unit ()
in
letrec trace_ray : (INT -> (FLOAT -> (Array of FLOAT -> ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (FLOAT -> UNIT))))) =
variables : (nref : INT), (energy : FLOAT), (dirvec : Array of FLOAT), (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (dist : FLOAT)
  let Ti826 : INT =
    int 4
  in
  if nref <= Ti826
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Tb827 : BOOL =
      app
        judge_intersection
        dirvec
    in
    let Ti828 : INT =
      int 0
    in
    if Tb827 == Ti828
      let Tu173 : UNIT =
        let Ti830 : INT =
          let Ti829 : INT =
            int 1
          in
          neg Ti829
        in
        surface_ids.(nref) <- Ti830
      in
      let Ti831 : INT =
        int 0
      in
      if nref == Ti831
        unit ()
        let hl : FLOAT =
          let Td832 : FLOAT =
            app
              veciprod
              dirvec
              light
          in
          app
            fneg
            Td832
        in
        let Tb833 : BOOL =
          app
            fispos
            hl
        in
        let Ti834 : INT =
          int 0
        in
        if Tb833 == Ti834
          unit ()
          let ihl : FLOAT =
            let Td837 : FLOAT =
              let Td836 : FLOAT =
                let Td835 : FLOAT =
                  unknown fsqr hl
                in
                fmul Td835 hl
              in
              fmul Td836 energy
            in
            let Td839 : FLOAT =
              let Ti838 : INT =
                int 0
              in
              beam.(Ti838)
            in
            fmul Td837 Td839
          in
          let Tu172 : UNIT =
            let Ti840 : INT =
              int 0
            in
            let Td843 : FLOAT =
              let Td842 : FLOAT =
                let Ti841 : INT =
                  int 0
                in
                rgb.(Ti841)
              in
              fadd Td842 ihl
            in
            rgb.(Ti840) <- Td843
          in
          let Tu171 : UNIT =
            let Ti844 : INT =
              int 1
            in
            let Td847 : FLOAT =
              let Td846 : FLOAT =
                let Ti845 : INT =
                  int 1
                in
                rgb.(Ti845)
              in
              fadd Td846 ihl
            in
            rgb.(Ti844) <- Td847
          in
          let Ti848 : INT =
            int 2
          in
          let Td851 : FLOAT =
            let Td850 : FLOAT =
              let Ti849 : INT =
                int 2
              in
              rgb.(Ti849)
            in
            fadd Td850 ihl
          in
          rgb.(Ti848) <- Td851
      let obj_id : INT =
        let Ti852 : INT =
          int 0
        in
        intersected_object_id.(Ti852)
      in
      let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(obj_id)
      in
      let m_surface : INT =
        app
          o_reflectiontype
          obj
      in
      let diffuse : FLOAT =
        let Td853 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td853 energy
      in
      let Tu170 : UNIT =
        app
          get_nvector
          obj
          dirvec
      in
      let Tu169 : UNIT =
        app
          veccpy
          startp
          intersection_point
      in
      let Tu168 : UNIT =
        app
          utexture
          obj
          intersection_point
      in
      let Tu167 : UNIT =
        let Ti857 : INT =
          let Ti854 : INT =
            mul obj_id 4
          in
          let Ti856 : INT =
            let Ti855 : INT =
              int 0
            in
            intsec_rectside.(Ti855)
          in
          add Ti854 Ti856
        in
        surface_ids.(nref) <- Ti857
      in
      let intersection_points : Array of Array of FLOAT =
        app
          p_intersection_points
          pixel
      in
      let Tu166 : UNIT =
        let Ta858 : Array of FLOAT =
          intersection_points.(nref)
        in
        app
          veccpy
          Ta858
          intersection_point
      in
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu165 : UNIT =
        let Td859 : FLOAT =
          app
            o_diffuse
            obj
        in
        let Td860 : FLOAT =
          float 0.5
        in
        if Td859 <. Td860
          let Ti861 : INT =
            int 0
          in
          calc_diffuse.(nref) <- Ti861
          let Tu159 : UNIT =
            let Ti862 : INT =
              int 1
            in
            calc_diffuse.(nref) <- Ti862
          in
          let energya : Array of Array of FLOAT =
            app
              p_energy
              pixel
          in
          let Tu158 : UNIT =
            let Ta863 : Array of FLOAT =
              energya.(nref)
            in
            app
              veccpy
              Ta863
              texture_color
          in
          let Tu157 : UNIT =
            let Ta864 : Array of FLOAT =
              energya.(nref)
            in
            let Td868 : FLOAT =
              let Td867 : FLOAT =
                let Td865 : FLOAT =
                  float 1.
                in
                let Td866 : FLOAT =
                  float 256.
                in
                app
                  fdiv
                  Td865
                  Td866
              in
              fmul Td867 diffuse
            in
            app
              vecscale
              Ta864
              Td868
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let Ta869 : Array of FLOAT =
            nvectors.(nref)
          in
          app
            veccpy
            Ta869
            nvector
      in
      let w : FLOAT =
        let Td870 : FLOAT =
          float -2.
        in
        let Td871 : FLOAT =
          app
            veciprod
            dirvec
            nvector
        in
        fmul Td870 Td871
      in
      let Tu164 : UNIT =
        app
          vecaccum
          dirvec
          w
          nvector
      in
      let hilight_scale : FLOAT =
        let Td872 : FLOAT =
          app
            o_hilight
            obj
        in
        fmul energy Td872
      in
      let Tu163 : UNIT =
        let Tb876 : BOOL =
          let Ti873 : INT =
            int 0
          in
          let Ta875 : Array of Array of INT =
            let Ti874 : INT =
              int 0
            in
            or_net.(Ti874)
          in
          app
            shadow_check_one_or_matrix
            Ti873
            Ta875
        in
        let Ti877 : INT =
          int 0
        in
        if Tb876 == Ti877
          let bright : FLOAT =
            let Td879 : FLOAT =
              let Td878 : FLOAT =
                app
                  veciprod
                  nvector
                  light
              in
              app
                fneg
                Td878
            in
            fmul Td879 diffuse
          in
          let hilight : FLOAT =
            let Td880 : FLOAT =
              app
                veciprod
                dirvec
                light
            in
            app
              fneg
              Td880
          in
          app
            add_light
            bright
            hilight
            hilight_scale
          unit ()
      in
      let Tu162 : UNIT =
        app
          setup_startp
          intersection_point
      in
      let Tu161 : UNIT =
        let Ti884 : INT =
          let Ti882 : INT =
            let Ti881 : INT =
              int 0
            in
            n_reflections.(Ti881)
          in
          let Ti883 : INT =
            int 1
          in
          sub Ti882 Ti883
        in
        app
          trace_reflections
          Ti884
          diffuse
          hilight_scale
          dirvec
      in
      let Td885 : FLOAT =
        float 0.1
      in
      if Td885 <. energy
        let Tu160 : UNIT =
          let Ti886 : INT =
            int 4
          in
          if Ti886 <= nref
            unit ()
            let Ti888 : INT =
              let Ti887 : INT =
                int 1
              in
              add nref Ti887
            in
            let Ti890 : INT =
              let Ti889 : INT =
                int 1
              in
              neg Ti889
            in
            surface_ids.(Ti888) <- Ti890
        in
        let Ti891 : INT =
          int 2
        in
        if m_surface == Ti891
          let energy2 : FLOAT =
            let Td894 : FLOAT =
              let Td892 : FLOAT =
                float 1.
              in
              let Td893 : FLOAT =
                app
                  o_diffuse
                  obj
              in
              fsub Td892 Td893
            in
            fmul energy Td894
          in
          let Ti896 : INT =
            let Ti895 : INT =
              int 1
            in
            add nref Ti895
          in
          let Td899 : FLOAT =
            let Td898 : FLOAT =
              let Ti897 : INT =
                int 0
              in
              tmin.(Ti897)
            in
            fadd dist Td898
          in
          app
            trace_ray
            Ti896
            energy2
            dirvec
            pixel
            Td899
          unit ()
        unit ()
    unit ()
in
letrec trace_diffuse_ray : ((Array of FLOAT * Array of Array of FLOAT) -> (FLOAT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (energy : FLOAT)
  let Tb810 : BOOL =
    app
      judge_intersection_fast
      dirvec
  in
  let Ti811 : INT =
    int 0
  in
  if Tb810 == Ti811
    unit ()
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      let Ti813 : INT =
        let Ti812 : INT =
          int 0
        in
        intersected_object_id.(Ti812)
      in
      objects.(Ti813)
    in
    let Tu175 : UNIT =
      let Ta814 : Array of FLOAT =
        app
          d_vec
          dirvec
      in
      app
        get_nvector
        obj
        Ta814
    in
    let Tu174 : UNIT =
      app
        utexture
        obj
        intersection_point
    in
    let Tb818 : BOOL =
      let Ti815 : INT =
        int 0
      in
      let Ta817 : Array of Array of INT =
        let Ti816 : INT =
          int 0
        in
        or_net.(Ti816)
      in
      app
        shadow_check_one_or_matrix
        Ti815
        Ta817
    in
    let Ti819 : INT =
      int 0
    in
    if Tb818 == Ti819
      let br : FLOAT =
        let Td820 : FLOAT =
          app
            veciprod
            nvector
            light
        in
        app
          fneg
          Td820
      in
      let bright : FLOAT =
        let Tb821 : BOOL =
          app
            fispos
            br
        in
        let Ti822 : INT =
          int 0
        in
        if Tb821 == Ti822
          float 0.
          br
      in
      let Td825 : FLOAT =
        let Td823 : FLOAT =
          fmul energy bright
        in
        let Td824 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td823 Td824
      in
      app
        vecaccum
        diffuse_ray
        Td825
        texture_color
      unit ()
in
letrec iter_trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (INT -> UNIT)))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT), (index : INT)
  let Ti795 : INT =
    int 0
  in
  if Ti795 <= index
    let p : FLOAT =
      let Ta797 : Array of FLOAT =
        let Tt796 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        app
          d_vec
          Tt796
      in
      app
        veciprod
        Ta797
        nvector
    in
    let Tu176 : UNIT =
      let Tb798 : BOOL =
        app
          fisneg
          p
      in
      let Ti799 : INT =
        int 0
      in
      if Tb798 == Ti799
        let Tt800 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        let Td802 : FLOAT =
          let Td801 : FLOAT =
            float 150.
          in
          app
            fdiv
            p
            Td801
        in
        app
          trace_diffuse_ray
          Tt800
          Td802
        let Tt805 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti804 : INT =
            let Ti803 : INT =
              int 1
            in
            add index Ti803
          in
          dirvec_group.(Ti804)
        in
        let Td807 : FLOAT =
          let Td806 : FLOAT =
            float -150.
          in
          app
            fdiv
            p
            Td806
        in
        app
          trace_diffuse_ray
          Tt805
          Td807
    in
    let Ti809 : INT =
      let Ti808 : INT =
        int 2
      in
      sub index Ti808
    in
    app
      iter_trace_diffuse_rays
      dirvec_group
      nvector
      org
      Ti809
    unit ()
in
letrec trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu177 : UNIT =
    app
      setup_startp
      org
  in
  let Ti794 : INT =
    int 118
  in
  app
    iter_trace_diffuse_rays
    dirvec_group
    nvector
    org
    Ti794
in
letrec trace_diffuse_ray_80percent : (INT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (group_id : INT), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu181 : UNIT =
    let Ti779 : INT =
      int 0
    in
    if group_id == Ti779
      unit ()
      let Ta781 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti780 : INT =
          int 0
        in
        dirvecs.(Ti780)
      in
      app
        trace_diffuse_rays
        Ta781
        nvector
        org
  in
  let Tu180 : UNIT =
    let Ti782 : INT =
      int 1
    in
    if group_id == Ti782
      unit ()
      let Ta784 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti783 : INT =
          int 1
        in
        dirvecs.(Ti783)
      in
      app
        trace_diffuse_rays
        Ta784
        nvector
        org
  in
  let Tu179 : UNIT =
    let Ti785 : INT =
      int 2
    in
    if group_id == Ti785
      unit ()
      let Ta787 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti786 : INT =
          int 2
        in
        dirvecs.(Ti786)
      in
      app
        trace_diffuse_rays
        Ta787
        nvector
        org
  in
  let Tu178 : UNIT =
    let Ti788 : INT =
      int 3
    in
    if group_id == Ti788
      unit ()
      let Ta790 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti789 : INT =
          int 3
        in
        dirvecs.(Ti789)
      in
      app
        trace_diffuse_rays
        Ta790
        nvector
        org
  in
  let Ti791 : INT =
    int 4
  in
  if group_id == Ti791
    unit ()
    let Ta793 : Array of (Array of FLOAT * Array of Array of FLOAT) =
      let Ti792 : INT =
        int 4
      in
      dirvecs.(Ti792)
    in
    app
      trace_diffuse_rays
      Ta793
      nvector
      org
in
letrec calc_diffuse_using_1point : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let ray20p : Array of Array of FLOAT =
    app
      p_received_ray_20percent
      pixel
  in
  let nvectors : Array of Array of FLOAT =
    app
      p_nvectors
      pixel
  in
  let intersection_points : Array of Array of FLOAT =
    app
      p_intersection_points
      pixel
  in
  let energya : Array of Array of FLOAT =
    app
      p_energy
      pixel
  in
  let Tu183 : UNIT =
    let Ta774 : Array of FLOAT =
      ray20p.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta774
  in
  let Tu182 : UNIT =
    let Ti775 : INT =
      app
        p_group_id
        pixel
    in
    let Ta776 : Array of FLOAT =
      nvectors.(nref)
    in
    let Ta777 : Array of FLOAT =
      intersection_points.(nref)
    in
    app
      trace_diffuse_ray_80percent
      Ti775
      Ta776
      Ta777
  in
  let Ta778 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta778
    diffuse_ray
in
letrec calc_diffuse_using_5points : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let r_up : Array of Array of FLOAT =
    let Tt758 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      p_received_ray_20percent
      Tt758
  in
  let r_left : Array of Array of FLOAT =
    let Tt761 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti760 : INT =
        let Ti759 : INT =
          int 1
        in
        sub x Ti759
      in
      cur.(Ti760)
    in
    app
      p_received_ray_20percent
      Tt761
  in
  let r_center : Array of Array of FLOAT =
    let Tt762 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_received_ray_20percent
      Tt762
  in
  let r_right : Array of Array of FLOAT =
    let Tt765 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti764 : INT =
        let Ti763 : INT =
          int 1
        in
        add x Ti763
      in
      cur.(Ti764)
    in
    app
      p_received_ray_20percent
      Tt765
  in
  let r_down : Array of Array of FLOAT =
    let Tt766 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      next.(x)
    in
    app
      p_received_ray_20percent
      Tt766
  in
  let Tu188 : UNIT =
    let Ta767 : Array of FLOAT =
      r_up.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta767
  in
  let Tu187 : UNIT =
    let Ta768 : Array of FLOAT =
      r_left.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta768
  in
  let Tu186 : UNIT =
    let Ta769 : Array of FLOAT =
      r_center.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta769
  in
  let Tu185 : UNIT =
    let Ta770 : Array of FLOAT =
      r_right.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta770
  in
  let Tu184 : UNIT =
    let Ta771 : Array of FLOAT =
      r_down.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta771
  in
  let energya : Array of Array of FLOAT =
    let Tt772 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_energy
      Tt772
  in
  let Ta773 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta773
    diffuse_ray
in
letrec do_without_neighbors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti751 : INT =
    int 4
  in
  if nref <= Ti751
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Ti752 : INT =
      int 0
    in
    let Ti753 : INT =
      surface_ids.(nref)
    in
    if Ti752 <= Ti753
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu189 : UNIT =
        let Tb754 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti755 : INT =
          int 0
        in
        if Tb754 == Ti755
          unit ()
          app
            calc_diffuse_using_1point
            pixel
            nref
      in
      let Ti757 : INT =
        let Ti756 : INT =
          int 1
        in
        add nref Ti756
      in
      app
        do_without_neighbors
        pixel
        Ti757
      unit ()
    unit ()
in
letrec neighbors_exist : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> BOOL))) =
variables : (x : INT), (y : INT), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti742 : INT =
    let Ti741 : INT =
      int 1
    in
    image_size.(Ti741)
  in
  let Ti744 : INT =
    let Ti743 : INT =
      int 1
    in
    add y Ti743
  in
  if Ti742 <= Ti744
    int 0
    let Ti745 : INT =
      int 0
    in
    if y <= Ti745
      int 0
      let Ti747 : INT =
        let Ti746 : INT =
          int 0
        in
        image_size.(Ti746)
      in
      let Ti749 : INT =
        let Ti748 : INT =
          int 1
        in
        add x Ti748
      in
      if Ti747 <= Ti749
        int 0
        let Ti750 : INT =
          int 0
        in
        if x <= Ti750
          int 0
          int 1
in
letrec get_surface_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> INT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (index : INT)
  let surface_ids : Array of INT =
    app
      p_surface_ids
      pixel
  in
  surface_ids.(index)
in
letrec neighbors_are_available : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> BOOL))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let sid_center : INT =
    let Tt728 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      get_surface_id
      Tt728
      nref
  in
  let Ti730 : INT =
    let Tt729 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      get_surface_id
      Tt729
      nref
  in
  if Ti730 == sid_center
    let Ti732 : INT =
      let Tt731 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        next.(x)
      in
      app
        get_surface_id
        Tt731
        nref
    in
    if Ti732 == sid_center
      let Ti736 : INT =
        let Tt735 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          let Ti734 : INT =
            let Ti733 : INT =
              int 1
            in
            sub x Ti733
          in
          cur.(Ti734)
        in
        app
          get_surface_id
          Tt735
          nref
      in
      if Ti736 == sid_center
        let Ti740 : INT =
          let Tt739 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
            let Ti738 : INT =
              let Ti737 : INT =
                int 1
              in
              add x Ti737
            in
            cur.(Ti738)
          in
          app
            get_surface_id
            Tt739
            nref
        in
        if Ti740 == sid_center
          int 1
          int 0
        int 0
      int 0
    int 0
in
letrec try_exploit_neighbors : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    cur.(x)
  in
  let Ti718 : INT =
    int 4
  in
  if nref <= Ti718
    let Ti719 : INT =
      int 0
    in
    let Ti720 : INT =
      app
        get_surface_id
        pixel
        nref
    in
    if Ti719 <= Ti720
      let Tb721 : BOOL =
        app
          neighbors_are_available
          x
          prev
          cur
          next
          nref
      in
      let Ti722 : INT =
        int 0
      in
      if Tb721 == Ti722
        let Tt723 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          do_without_neighbors
          Tt723
          nref
        let calc_diffuse : Array of BOOL =
          app
            p_calc_diffuse
            pixel
        in
        let Tu190 : UNIT =
          let Tb724 : BOOL =
            calc_diffuse.(nref)
          in
          let Ti725 : INT =
            int 0
          in
          if Tb724 == Ti725
            unit ()
            app
              calc_diffuse_using_5points
              x
              prev
              cur
              next
              nref
        in
        let Ti727 : INT =
          let Ti726 : INT =
            int 1
          in
          add nref Ti726
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti727
      unit ()
    unit ()
in
letrec write_ppm_header : (UNIT -> UNIT) =
variables : (Tu191 : UNIT)
  let Tu199 : UNIT =
    let Ti705 : INT =
      int 80
    in
    out Ti705 0
  in
  let Tu198 : UNIT =
    let Ti708 : INT =
      let Ti706 : INT =
        int 48
      in
      let Ti707 : INT =
        int 6
      in
      add Ti706 Ti707
    in
    out Ti708 0
  in
  let Tu197 : UNIT =
    let Ti709 : INT =
      int 10
    in
    out Ti709 0
  in
  let Tu196 : UNIT =
    let Ti711 : INT =
      let Ti710 : INT =
        int 0
      in
      image_size.(Ti710)
    in
    app
      print_int
      Ti711
  in
  let Tu195 : UNIT =
    let Ti712 : INT =
      int 32
    in
    out Ti712 0
  in
  let Tu194 : UNIT =
    let Ti714 : INT =
      let Ti713 : INT =
        int 1
      in
      image_size.(Ti713)
    in
    app
      print_int
      Ti714
  in
  let Tu193 : UNIT =
    let Ti715 : INT =
      int 32
    in
    out Ti715 0
  in
  let Tu192 : UNIT =
    let Ti716 : INT =
      int 255
    in
    app
      print_int
      Ti716
  in
  let Ti717 : INT =
    int 10
  in
  out Ti717 0
in
letrec write_rgb_element : (FLOAT -> UNIT) =
variables : (x : FLOAT)
  let ix : INT =
    ftoi x
  in
  let elem : INT =
    let Ti703 : INT =
      int 255
    in
    if ix <= Ti703
      let Ti704 : INT =
        int 0
      in
      if Ti704 <= ix
        ix
        int 0
      int 255
  in
  out elem 0
in
letrec write_rgb : (UNIT -> UNIT) =
variables : (Tu200 : UNIT)
  let Tu202 : UNIT =
    let Td698 : FLOAT =
      let Ti697 : INT =
        int 0
      in
      rgb.(Ti697)
    in
    app
      write_rgb_element
      Td698
  in
  let Tu201 : UNIT =
    let Td700 : FLOAT =
      let Ti699 : INT =
        int 1
      in
      rgb.(Ti699)
    in
    app
      write_rgb_element
      Td700
  in
  let Td702 : FLOAT =
    let Ti701 : INT =
      int 2
    in
    rgb.(Ti701)
  in
  app
    write_rgb_element
    Td702
in
letrec pretrace_diffuse_rays : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti687 : INT =
    int 4
  in
  if nref <= Ti687
    let sid : INT =
      app
        get_surface_id
        pixel
        nref
    in
    let Ti688 : INT =
      int 0
    in
    if Ti688 <= sid
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu205 : UNIT =
        let Tb689 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti690 : INT =
          int 0
        in
        if Tb689 == Ti690
          unit ()
          let group_id : INT =
            app
              p_group_id
              pixel
          in
          let Tu204 : UNIT =
            app
              vecbzero
              diffuse_ray
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let intersection_points : Array of Array of FLOAT =
            app
              p_intersection_points
              pixel
          in
          let Tu203 : UNIT =
            let Ta691 : Array of (Array of FLOAT * Array of Array of FLOAT) =
              dirvecs.(group_id)
            in
            let Ta692 : Array of FLOAT =
              nvectors.(nref)
            in
            let Ta693 : Array of FLOAT =
              intersection_points.(nref)
            in
            app
              trace_diffuse_rays
              Ta691
              Ta692
              Ta693
          in
          let ray20p : Array of Array of FLOAT =
            app
              p_received_ray_20percent
              pixel
          in
          let Ta694 : Array of FLOAT =
            ray20p.(nref)
          in
          app
            veccpy
            Ta694
            diffuse_ray
      in
      let Ti696 : INT =
        let Ti695 : INT =
          int 1
        in
        add nref Ti695
      in
      app
        pretrace_diffuse_rays
        pixel
        Ti696
      unit ()
    unit ()
in
letrec pretrace_pixels : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (x : INT), (group_id : INT), (lc0 : FLOAT), (lc1 : FLOAT), (lc2 : FLOAT)
  let Ti651 : INT =
    int 0
  in
  if Ti651 <= x
    let xdisp : FLOAT =
      let Td653 : FLOAT =
        let Ti652 : INT =
          int 0
        in
        scan_pitch.(Ti652)
      in
      let Td657 : FLOAT =
        let Ti656 : INT =
          let Ti655 : INT =
            let Ti654 : INT =
              int 0
            in
            image_center.(Ti654)
          in
          sub x Ti655
        in
        itof Ti656
      in
      fmul Td653 Td657
    in
    let Tu215 : UNIT =
      let Ti658 : INT =
        int 0
      in
      let Td662 : FLOAT =
        let Td661 : FLOAT =
          let Td660 : FLOAT =
            let Ti659 : INT =
              int 0
            in
            screenx_dir.(Ti659)
          in
          fmul xdisp Td660
        in
        fadd Td661 lc0
      in
      ptrace_dirvec.(Ti658) <- Td662
    in
    let Tu214 : UNIT =
      let Ti663 : INT =
        int 1
      in
      let Td667 : FLOAT =
        let Td666 : FLOAT =
          let Td665 : FLOAT =
            let Ti664 : INT =
              int 1
            in
            screenx_dir.(Ti664)
          in
          fmul xdisp Td665
        in
        fadd Td666 lc1
      in
      ptrace_dirvec.(Ti663) <- Td667
    in
    let Tu213 : UNIT =
      let Ti668 : INT =
        int 2
      in
      let Td672 : FLOAT =
        let Td671 : FLOAT =
          let Td670 : FLOAT =
            let Ti669 : INT =
              int 2
            in
            screenx_dir.(Ti669)
          in
          fmul xdisp Td670
        in
        fadd Td671 lc2
      in
      ptrace_dirvec.(Ti668) <- Td672
    in
    let Tu212 : UNIT =
      let Ti673 : INT =
        int 0
      in
      app
        vecunit_sgn
        ptrace_dirvec
        Ti673
    in
    let Tu211 : UNIT =
      app
        vecbzero
        rgb
    in
    let Tu210 : UNIT =
      app
        veccpy
        startp
        viewpoint
    in
    let Tu209 : UNIT =
      let Ti674 : INT =
        int 0
      in
      let Td675 : FLOAT =
        float 1.
      in
      let Tt676 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Td677 : FLOAT =
        float 0.
      in
      app
        trace_ray
        Ti674
        Td675
        ptrace_dirvec
        Tt676
        Td677
    in
    let Tu208 : UNIT =
      let Ta679 : Array of FLOAT =
        let Tt678 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          line.(x)
        in
        app
          p_rgb
          Tt678
      in
      app
        veccpy
        Ta679
        rgb
    in
    let Tu207 : UNIT =
      let Tt680 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      app
        p_set_group_id
        Tt680
        group_id
    in
    let Tu206 : UNIT =
      let Tt681 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Ti682 : INT =
        int 0
      in
      app
        pretrace_diffuse_rays
        Tt681
        Ti682
    in
    let Ti684 : INT =
      let Ti683 : INT =
        int 1
      in
      sub x Ti683
    in
    let Ti686 : INT =
      let Ti685 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti685
    in
    app
      pretrace_pixels
      line
      Ti684
      Ti686
      lc0
      lc1
      lc2
    unit ()
in
letrec pretrace_line : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> UNIT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (y : INT), (group_id : INT)
  let ydisp : FLOAT =
    let Td627 : FLOAT =
      let Ti626 : INT =
        int 0
      in
      scan_pitch.(Ti626)
    in
    let Td631 : FLOAT =
      let Ti630 : INT =
        let Ti629 : INT =
          let Ti628 : INT =
            int 1
          in
          image_center.(Ti628)
        in
        sub y Ti629
      in
      itof Ti630
    in
    fmul Td627 Td631
  in
  let lc0 : FLOAT =
    let Td634 : FLOAT =
      let Td633 : FLOAT =
        let Ti632 : INT =
          int 0
        in
        screeny_dir.(Ti632)
      in
      fmul ydisp Td633
    in
    let Td636 : FLOAT =
      let Ti635 : INT =
        int 0
      in
      screenz_dir.(Ti635)
    in
    fadd Td634 Td636
  in
  let lc1 : FLOAT =
    let Td639 : FLOAT =
      let Td638 : FLOAT =
        let Ti637 : INT =
          int 1
        in
        screeny_dir.(Ti637)
      in
      fmul ydisp Td638
    in
    let Td641 : FLOAT =
      let Ti640 : INT =
        int 1
      in
      screenz_dir.(Ti640)
    in
    fadd Td639 Td641
  in
  let lc2 : FLOAT =
    let Td644 : FLOAT =
      let Td643 : FLOAT =
        let Ti642 : INT =
          int 2
        in
        screeny_dir.(Ti642)
      in
      fmul ydisp Td643
    in
    let Td646 : FLOAT =
      let Ti645 : INT =
        int 2
      in
      screenz_dir.(Ti645)
    in
    fadd Td644 Td646
  in
  let Ti650 : INT =
    let Ti648 : INT =
      let Ti647 : INT =
        int 0
      in
      image_size.(Ti647)
    in
    let Ti649 : INT =
      int 1
    in
    sub Ti648 Ti649
  in
  app
    pretrace_pixels
    line
    Ti650
    group_id
    lc0
    lc1
    lc2
in
letrec scan_pixel : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> UNIT))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti615 : INT =
    let Ti614 : INT =
      int 0
    in
    image_size.(Ti614)
  in
  if Ti615 <= x
    unit ()
    let Tu218 : UNIT =
      let Ta617 : Array of FLOAT =
        let Tt616 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          p_rgb
          Tt616
      in
      app
        veccpy
        rgb
        Ta617
    in
    let Tu217 : UNIT =
      let Tb618 : BOOL =
        app
          neighbors_exist
          x
          y
          next
      in
      let Ti619 : INT =
        int 0
      in
      if Tb618 == Ti619
        let Tt620 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        let Ti621 : INT =
          int 0
        in
        app
          do_without_neighbors
          Tt620
          Ti621
        let Ti622 : INT =
          int 0
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti622
    in
    let Tu216 : UNIT =
      let Tu623 : UNIT =
        unit ()
      in
      app
        write_rgb
        Tu623
    in
    let Ti625 : INT =
      let Ti624 : INT =
        int 1
      in
      add x Ti624
    in
    app
      scan_pixel
      Ti625
      y
      prev
      cur
      next
in
letrec scan_line : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (group_id : INT)
  let Ti602 : INT =
    let Ti601 : INT =
      int 1
    in
    image_size.(Ti601)
  in
  if Ti602 <= y
    unit ()
    let Tu220 : UNIT =
      let Ti606 : INT =
        let Ti604 : INT =
          let Ti603 : INT =
            int 1
          in
          image_size.(Ti603)
        in
        let Ti605 : INT =
          int 1
        in
        sub Ti604 Ti605
      in
      if Ti606 <= y
        unit ()
        let Ti608 : INT =
          let Ti607 : INT =
            int 1
          in
          add y Ti607
        in
        app
          pretrace_line
          next
          Ti608
          group_id
    in
    let Tu219 : UNIT =
      let Ti609 : INT =
        int 0
      in
      app
        scan_pixel
        Ti609
        y
        prev
        cur
        next
    in
    let Ti611 : INT =
      let Ti610 : INT =
        int 1
      in
      add y Ti610
    in
    let Ti613 : INT =
      let Ti612 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti612
    in
    app
      scan_line
      Ti611
      cur
      next
      prev
      Ti613
in
letrec create_float5x3array : (UNIT -> Array of Array of FLOAT) =
variables : (Tu221 : UNIT)
  let vec : Array of FLOAT =
    let Ti582 : INT =
      int 3
    in
    let Td583 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti582
      Td583
  in
  let array : Array of Array of FLOAT =
    let Ti584 : INT =
      int 5
    in
    extfunapp
      create_array
      Ti584
      vec
  in
  let Tu225 : UNIT =
    let Ti585 : INT =
      int 1
    in
    let Ta588 : Array of FLOAT =
      let Ti586 : INT =
        int 3
      in
      let Td587 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti586
        Td587
    in
    array.(Ti585) <- Ta588
  in
  let Tu224 : UNIT =
    let Ti589 : INT =
      int 2
    in
    let Ta592 : Array of FLOAT =
      let Ti590 : INT =
        int 3
      in
      let Td591 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti590
        Td591
    in
    array.(Ti589) <- Ta592
  in
  let Tu223 : UNIT =
    let Ti593 : INT =
      int 3
    in
    let Ta596 : Array of FLOAT =
      let Ti594 : INT =
        int 3
      in
      let Td595 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti594
        Td595
    in
    array.(Ti593) <- Ta596
  in
  let Tu222 : UNIT =
    let Ti597 : INT =
      int 4
    in
    let Ta600 : Array of FLOAT =
      let Ti598 : INT =
        int 3
      in
      let Td599 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti598
        Td599
    in
    array.(Ti597) <- Ta600
  in
  array
in
letrec create_pixel : (UNIT -> (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu226 : UNIT)
  let m_rgb : Array of FLOAT =
    let Ti570 : INT =
      int 3
    in
    let Td571 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti570
      Td571
  in
  let m_isect_ps : Array of Array of FLOAT =
    let Tu572 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu572
  in
  let m_sids : Array of INT =
    let Ti573 : INT =
      int 5
    in
    let Ti574 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti573
      Ti574
  in
  let m_cdif : Array of BOOL =
    let Ti575 : INT =
      int 5
    in
    let Ti576 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti575
      Ti576
  in
  let m_engy : Array of Array of FLOAT =
    let Tu577 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu577
  in
  let m_r20p : Array of Array of FLOAT =
    let Tu578 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu578
  in
  let m_gid : Array of INT =
    let Ti579 : INT =
      int 1
    in
    let Ti580 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti579
      Ti580
  in
  let m_nvectors : Array of Array of FLOAT =
    let Tu581 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu581
  in
  Tuple
    m_rgb
    m_isect_ps
    m_sids
    m_cdif
    m_engy
    m_r20p
    m_gid
    m_nvectors
in
letrec init_line_elements : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (n : INT)
  let Ti565 : INT =
    int 0
  in
  if Ti565 <= n
    let Tu227 : UNIT =
      let Tt567 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        let Tu566 : UNIT =
          unit ()
        in
        app
          create_pixel
          Tu566
      in
      line.(n) <- Tt567
    in
    let Ti569 : INT =
      let Ti568 : INT =
        int 1
      in
      sub n Ti568
    in
    app
      init_line_elements
      line
      Ti569
    line
in
letrec create_pixelline : (UNIT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu228 : UNIT)
  let line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Ti558 : INT =
      let Ti557 : INT =
        int 0
      in
      image_size.(Ti557)
    in
    let Tt560 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Tu559 : UNIT =
        unit ()
      in
      app
        create_pixel
        Tu559
    in
    extfunapp
      create_array
      Ti558
      Tt560
  in
  let Ti564 : INT =
    let Ti562 : INT =
      let Ti561 : INT =
        int 0
      in
      image_size.(Ti561)
    in
    let Ti563 : INT =
      int 2
    in
    sub Ti562 Ti563
  in
  app
    init_line_elements
    line
    Ti564
in
letrec tan : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td555 : FLOAT =
    app
      sin
      x
  in
  let Td556 : FLOAT =
    app
      cos
      x
  in
  app
    fdiv
    Td555
    Td556
in
letrec adjust_position : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (h : FLOAT), (ratio : FLOAT)
  let l : FLOAT =
    let Td552 : FLOAT =
      let Td550 : FLOAT =
        fmul h h
      in
      let Td551 : FLOAT =
        float 0.1
      in
      fadd Td550 Td551
    in
    app
      sqrt
      Td552
  in
  let tan_h : FLOAT =
    let Td553 : FLOAT =
      float 1.
    in
    app
      fdiv
      Td553
      l
  in
  let theta_h : FLOAT =
    app
      atan
      tan_h
  in
  let tan_m : FLOAT =
    let Td554 : FLOAT =
      fmul theta_h ratio
    in
    app
      tan
      Td554
  in
  fmul tan_m l
in
letrec calc_dirvec : (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> UNIT))))))) =
variables : (icount : INT), (x : FLOAT), (y : FLOAT), (rx : FLOAT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti509 : INT =
    int 5
  in
  if Ti509 <= icount
    let l : FLOAT =
      let Td514 : FLOAT =
        let Td512 : FLOAT =
          let Td510 : FLOAT =
            unknown fsqr x
          in
          let Td511 : FLOAT =
            unknown fsqr y
          in
          fadd Td510 Td511
        in
        let Td513 : FLOAT =
          float 1.
        in
        fadd Td512 Td513
      in
      app
        sqrt
        Td514
    in
    let vx : FLOAT =
      app
        fdiv
        x
        l
    in
    let vy : FLOAT =
      app
        fdiv
        y
        l
    in
    let vz : FLOAT =
      let Td515 : FLOAT =
        float 1.
      in
      app
        fdiv
        Td515
        l
    in
    let dgroup : Array of (Array of FLOAT * Array of Array of FLOAT) =
      dirvecs.(group_id)
    in
    let Tu233 : UNIT =
      let Ta517 : Array of FLOAT =
        let Tt516 : (Array of FLOAT * Array of Array of FLOAT) =
          dgroup.(index)
        in
        app
          d_vec
          Tt516
      in
      app
        vecset
        Ta517
        vx
        vy
        vz
    in
    let Tu232 : UNIT =
      let Ta521 : Array of FLOAT =
        let Tt520 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti519 : INT =
            let Ti518 : INT =
              int 40
            in
            add index Ti518
          in
          dgroup.(Ti519)
        in
        app
          d_vec
          Tt520
      in
      let Td522 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta521
        vx
        vz
        Td522
    in
    let Tu231 : UNIT =
      let Ta526 : Array of FLOAT =
        let Tt525 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti524 : INT =
            let Ti523 : INT =
              int 80
            in
            add index Ti523
          in
          dgroup.(Ti524)
        in
        app
          d_vec
          Tt525
      in
      let Td527 : FLOAT =
        app
          fneg
          vx
      in
      let Td528 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta526
        vz
        Td527
        Td528
    in
    let Tu230 : UNIT =
      let Ta532 : Array of FLOAT =
        let Tt531 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti530 : INT =
            let Ti529 : INT =
              int 1
            in
            add index Ti529
          in
          dgroup.(Ti530)
        in
        app
          d_vec
          Tt531
      in
      let Td533 : FLOAT =
        app
          fneg
          vx
      in
      let Td534 : FLOAT =
        app
          fneg
          vy
      in
      let Td535 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta532
        Td533
        Td534
        Td535
    in
    let Tu229 : UNIT =
      let Ta539 : Array of FLOAT =
        let Tt538 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti537 : INT =
            let Ti536 : INT =
              int 41
            in
            add index Ti536
          in
          dgroup.(Ti537)
        in
        app
          d_vec
          Tt538
      in
      let Td540 : FLOAT =
        app
          fneg
          vx
      in
      let Td541 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta539
        Td540
        Td541
        vy
    in
    let Ta545 : Array of FLOAT =
      let Tt544 : (Array of FLOAT * Array of Array of FLOAT) =
        let Ti543 : INT =
          let Ti542 : INT =
            int 81
          in
          add index Ti542
        in
        dgroup.(Ti543)
      in
      app
        d_vec
        Tt544
    in
    let Td546 : FLOAT =
      app
        fneg
        vz
    in
    app
      vecset
      Ta545
      Td546
      vx
      vy
    let x2 : FLOAT =
      app
        adjust_position
        y
        rx
    in
    let Ti548 : INT =
      let Ti547 : INT =
        int 1
      in
      add icount Ti547
    in
    let Td549 : FLOAT =
      app
        adjust_position
        x2
        ry
    in
    app
      calc_dirvec
      Ti548
      x2
      Td549
      rx
      ry
      group_id
      index
in
letrec calc_dirvecs : (INT -> (FLOAT -> (INT -> (INT -> UNIT)))) =
variables : (col : INT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti488 : INT =
    int 0
  in
  if Ti488 <= col
    let rx : FLOAT =
      let Td491 : FLOAT =
        let Td489 : FLOAT =
          itof col
        in
        let Td490 : FLOAT =
          float 0.2
        in
        fmul Td489 Td490
      in
      let Td492 : FLOAT =
        float 0.9
      in
      fsub Td491 Td492
    in
    let Tu235 : UNIT =
      let Ti493 : INT =
        int 0
      in
      let Td494 : FLOAT =
        float 0.
      in
      let Td495 : FLOAT =
        float 0.
      in
      app
        calc_dirvec
        Ti493
        Td494
        Td495
        rx
        ry
        group_id
        index
    in
    let rx2 : FLOAT =
      let Td498 : FLOAT =
        let Td496 : FLOAT =
          itof col
        in
        let Td497 : FLOAT =
          float 0.2
        in
        fmul Td496 Td497
      in
      let Td499 : FLOAT =
        float 0.1
      in
      fadd Td498 Td499
    in
    let Tu234 : UNIT =
      let Ti500 : INT =
        int 0
      in
      let Td501 : FLOAT =
        float 0.
      in
      let Td502 : FLOAT =
        float 0.
      in
      let Ti504 : INT =
        let Ti503 : INT =
          int 2
        in
        add index Ti503
      in
      app
        calc_dirvec
        Ti500
        Td501
        Td502
        rx2
        ry
        group_id
        Ti504
    in
    let Ti506 : INT =
      let Ti505 : INT =
        int 1
      in
      sub col Ti505
    in
    let Ti508 : INT =
      let Ti507 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti507
    in
    app
      calc_dirvecs
      Ti506
      ry
      Ti508
      index
    unit ()
in
letrec calc_dirvec_rows : (INT -> (INT -> (INT -> UNIT))) =
variables : (row : INT), (group_id : INT), (index : INT)
  let Ti476 : INT =
    int 0
  in
  if Ti476 <= row
    let ry : FLOAT =
      let Td479 : FLOAT =
        let Td477 : FLOAT =
          itof row
        in
        let Td478 : FLOAT =
          float 0.2
        in
        fmul Td477 Td478
      in
      let Td480 : FLOAT =
        float 0.9
      in
      fsub Td479 Td480
    in
    let Tu236 : UNIT =
      let Ti481 : INT =
        int 4
      in
      app
        calc_dirvecs
        Ti481
        ry
        group_id
        index
    in
    let Ti483 : INT =
      let Ti482 : INT =
        int 1
      in
      sub row Ti482
    in
    let Ti485 : INT =
      let Ti484 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti484
    in
    let Ti487 : INT =
      let Ti486 : INT =
        int 4
      in
      add index Ti486
    in
    app
      calc_dirvec_rows
      Ti483
      Ti485
      Ti487
    unit ()
in
letrec create_dirvec : (UNIT -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (Tu237 : UNIT)
  let v3 : Array of FLOAT =
    let Ti472 : INT =
      int 3
    in
    let Td473 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti472
      Td473
  in
  let consts : Array of Array of FLOAT =
    let Ti475 : INT =
      let Ti474 : INT =
        int 0
      in
      n_objects.(Ti474)
    in
    extfunapp
      create_array
      Ti475
      v3
  in
  Tuple
    v3
    consts
in
letrec create_dirvec_elements : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (d : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti467 : INT =
    int 0
  in
  if Ti467 <= index
    let Tu238 : UNIT =
      let Tt469 : (Array of FLOAT * Array of Array of FLOAT) =
        let Tu468 : UNIT =
          unit ()
        in
        app
          create_dirvec
          Tu468
      in
      d.(index) <- Tt469
    in
    let Ti471 : INT =
      let Ti470 : INT =
        int 1
      in
      sub index Ti470
    in
    app
      create_dirvec_elements
      d
      Ti471
    unit ()
in
letrec create_dirvecs : (INT -> UNIT) =
variables : (index : INT)
  let Ti458 : INT =
    int 0
  in
  if Ti458 <= index
    let Tu240 : UNIT =
      let Ta462 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti459 : INT =
          int 120
        in
        let Tt461 : (Array of FLOAT * Array of Array of FLOAT) =
          let Tu460 : UNIT =
            unit ()
          in
          app
            create_dirvec
            Tu460
        in
        extfunapp
          create_array
          Ti459
          Tt461
      in
      dirvecs.(index) <- Ta462
    in
    let Tu239 : UNIT =
      let Ta463 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti464 : INT =
        int 118
      in
      app
        create_dirvec_elements
        Ta463
        Ti464
    in
    let Ti466 : INT =
      let Ti465 : INT =
        int 1
      in
      sub index Ti465
    in
    app
      create_dirvecs
      Ti466
    unit ()
in
letrec init_dirvec_constants : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (vecset : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti454 : INT =
    int 0
  in
  if Ti454 <= index
    let Tu241 : UNIT =
      let Tt455 : (Array of FLOAT * Array of Array of FLOAT) =
        vecset.(index)
      in
      app
        setup_dirvec_constants
        Tt455
    in
    let Ti457 : INT =
      let Ti456 : INT =
        int 1
      in
      sub index Ti456
    in
    app
      init_dirvec_constants
      vecset
      Ti457
    unit ()
in
letrec init_vecset_constants : (INT -> UNIT) =
variables : (index : INT)
  let Ti449 : INT =
    int 0
  in
  if Ti449 <= index
    let Tu242 : UNIT =
      let Ta450 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti451 : INT =
        int 119
      in
      app
        init_dirvec_constants
        Ta450
        Ti451
    in
    let Ti453 : INT =
      let Ti452 : INT =
        int 1
      in
      sub index Ti452
    in
    app
      init_vecset_constants
      Ti453
    unit ()
in
letrec init_dirvecs : (UNIT -> UNIT) =
variables : (Tu243 : UNIT)
  let Tu245 : UNIT =
    let Ti444 : INT =
      int 4
    in
    app
      create_dirvecs
      Ti444
  in
  let Tu244 : UNIT =
    let Ti445 : INT =
      int 9
    in
    let Ti446 : INT =
      int 0
    in
    let Ti447 : INT =
      int 0
    in
    app
      calc_dirvec_rows
      Ti445
      Ti446
      Ti447
  in
  let Ti448 : INT =
    int 4
  in
  app
    init_vecset_constants
    Ti448
in
letrec add_reflection : (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (index : INT), (surface_id : INT), (bright : FLOAT), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let dvec : (Array of FLOAT * Array of Array of FLOAT) =
    let Tu441 : UNIT =
      unit ()
    in
    app
      create_dirvec
      Tu441
  in
  let Tu247 : UNIT =
    let Ta442 : Array of FLOAT =
      app
        d_vec
        dvec
    in
    app
      vecset
      Ta442
      v0
      v1
      v2
  in
  let Tu246 : UNIT =
    app
      setup_dirvec_constants
      dvec
  in
  let Tt443 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    Tuple
      surface_id
      dvec
      bright
  in
  reflections.(index) <- Tt443
in
letrec setup_rect_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    mul obj_id 4
  in
  let nr : INT =
    let Ti413 : INT =
      int 0
    in
    n_reflections.(Ti413)
  in
  let br : FLOAT =
    let Td414 : FLOAT =
      float 1.
    in
    let Td415 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td414 Td415
  in
  let n0 : FLOAT =
    let Td417 : FLOAT =
      let Ti416 : INT =
        int 0
      in
      light.(Ti416)
    in
    app
      fneg
      Td417
  in
  let n1 : FLOAT =
    let Td419 : FLOAT =
      let Ti418 : INT =
        int 1
      in
      light.(Ti418)
    in
    app
      fneg
      Td419
  in
  let n2 : FLOAT =
    let Td421 : FLOAT =
      let Ti420 : INT =
        int 2
      in
      light.(Ti420)
    in
    app
      fneg
      Td421
  in
  let Tu250 : UNIT =
    let Ti423 : INT =
      let Ti422 : INT =
        int 1
      in
      add sid Ti422
    in
    let Td425 : FLOAT =
      let Ti424 : INT =
        int 0
      in
      light.(Ti424)
    in
    app
      add_reflection
      nr
      Ti423
      br
      Td425
      n1
      n2
  in
  let Tu249 : UNIT =
    let Ti427 : INT =
      let Ti426 : INT =
        int 1
      in
      add nr Ti426
    in
    let Ti429 : INT =
      let Ti428 : INT =
        int 2
      in
      add sid Ti428
    in
    let Td431 : FLOAT =
      let Ti430 : INT =
        int 1
      in
      light.(Ti430)
    in
    app
      add_reflection
      Ti427
      Ti429
      br
      n0
      Td431
      n2
  in
  let Tu248 : UNIT =
    let Ti433 : INT =
      let Ti432 : INT =
        int 2
      in
      add nr Ti432
    in
    let Ti435 : INT =
      let Ti434 : INT =
        int 3
      in
      add sid Ti434
    in
    let Td437 : FLOAT =
      let Ti436 : INT =
        int 2
      in
      light.(Ti436)
    in
    app
      add_reflection
      Ti433
      Ti435
      br
      n0
      n1
      Td437
  in
  let Ti438 : INT =
    int 0
  in
  let Ti440 : INT =
    let Ti439 : INT =
      int 3
    in
    add nr Ti439
  in
  n_reflections.(Ti438) <- Ti440
in
letrec setup_surface_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    let Ti383 : INT =
      mul obj_id 4
    in
    let Ti384 : INT =
      int 1
    in
    add Ti383 Ti384
  in
  let nr : INT =
    let Ti385 : INT =
      int 0
    in
    n_reflections.(Ti385)
  in
  let br : FLOAT =
    let Td386 : FLOAT =
      float 1.
    in
    let Td387 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td386 Td387
  in
  let p : FLOAT =
    let Ta388 : Array of FLOAT =
      app
        o_param_abc
        obj
    in
    app
      veciprod
      light
      Ta388
  in
  let Tu251 : UNIT =
    let Td395 : FLOAT =
      let Td392 : FLOAT =
        let Td391 : FLOAT =
          let Td389 : FLOAT =
            float 2.
          in
          let Td390 : FLOAT =
            app
              o_param_a
              obj
          in
          fmul Td389 Td390
        in
        fmul Td391 p
      in
      let Td394 : FLOAT =
        let Ti393 : INT =
          int 0
        in
        light.(Ti393)
      in
      fsub Td392 Td394
    in
    let Td402 : FLOAT =
      let Td399 : FLOAT =
        let Td398 : FLOAT =
          let Td396 : FLOAT =
            float 2.
          in
          let Td397 : FLOAT =
            app
              o_param_b
              obj
          in
          fmul Td396 Td397
        in
        fmul Td398 p
      in
      let Td401 : FLOAT =
        let Ti400 : INT =
          int 1
        in
        light.(Ti400)
      in
      fsub Td399 Td401
    in
    let Td409 : FLOAT =
      let Td406 : FLOAT =
        let Td405 : FLOAT =
          let Td403 : FLOAT =
            float 2.
          in
          let Td404 : FLOAT =
            app
              o_param_c
              obj
          in
          fmul Td403 Td404
        in
        fmul Td405 p
      in
      let Td408 : FLOAT =
        let Ti407 : INT =
          int 2
        in
        light.(Ti407)
      in
      fsub Td406 Td408
    in
    app
      add_reflection
      nr
      sid
      br
      Td395
      Td402
      Td409
  in
  let Ti410 : INT =
    int 0
  in
  let Ti412 : INT =
    let Ti411 : INT =
      int 1
    in
    add nr Ti411
  in
  n_reflections.(Ti410) <- Ti412
in
letrec setup_reflections : (INT -> UNIT) =
variables : (obj_id : INT)
  let Ti376 : INT =
    int 0
  in
  if Ti376 <= obj_id
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(obj_id)
    in
    let Ti377 : INT =
      app
        o_reflectiontype
        obj
    in
    let Ti378 : INT =
      int 2
    in
    if Ti377 == Ti378
      let Td379 : FLOAT =
        app
          o_diffuse
          obj
      in
      let Td380 : FLOAT =
        float 1.
      in
      if Td379 <. Td380
        let m_shape : INT =
          app
            o_form
            obj
        in
        let Ti381 : INT =
          int 1
        in
        if m_shape == Ti381
          app
            setup_rect_reflection
            obj_id
            obj
          let Ti382 : INT =
            int 2
          in
          if m_shape == Ti382
            app
              setup_surface_reflection
              obj_id
              obj
            unit ()
        unit ()
      unit ()
    unit ()
in
letrec rt : (INT -> (INT -> UNIT)) =
variables : (size_x : INT), (size_y : INT)
  let Tu263 : UNIT =
    let Ti351 : INT =
      int 0
    in
    image_size.(Ti351) <- size_x
  in
  let Tu262 : UNIT =
    let Ti352 : INT =
      int 1
    in
    image_size.(Ti352) <- size_y
  in
  let Tu261 : UNIT =
    let Ti353 : INT =
      int 0
    in
    let Ti354 : INT =
      div size_x 2
    in
    image_center.(Ti353) <- Ti354
  in
  let Tu260 : UNIT =
    let Ti355 : INT =
      int 1
    in
    let Ti356 : INT =
      div size_y 2
    in
    image_center.(Ti355) <- Ti356
  in
  let Tu259 : UNIT =
    let Ti357 : INT =
      int 0
    in
    let Td360 : FLOAT =
      let Td358 : FLOAT =
        float 128.
      in
      let Td359 : FLOAT =
        itof size_x
      in
      app
        fdiv
        Td358
        Td359
    in
    scan_pitch.(Ti357) <- Td360
  in
  let prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu361 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu361
  in
  let cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu362 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu362
  in
  let next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu363 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu363
  in
  let Tu258 : UNIT =
    let Tu364 : UNIT =
      unit ()
    in
    app
      read_parameter
      Tu364
  in
  let Tu257 : UNIT =
    let Tu365 : UNIT =
      unit ()
    in
    app
      write_ppm_header
      Tu365
  in
  let Tu256 : UNIT =
    let Tu366 : UNIT =
      unit ()
    in
    app
      init_dirvecs
      Tu366
  in
  let Tu255 : UNIT =
    let Ta367 : Array of FLOAT =
      app
        d_vec
        light_dirvec
    in
    app
      veccpy
      Ta367
      light
  in
  let Tu254 : UNIT =
    app
      setup_dirvec_constants
      light_dirvec
  in
  let Tu253 : UNIT =
    let Ti371 : INT =
      let Ti369 : INT =
        let Ti368 : INT =
          int 0
        in
        n_objects.(Ti368)
      in
      let Ti370 : INT =
        int 1
      in
      sub Ti369 Ti370
    in
    app
      setup_reflections
      Ti371
  in
  let Tu252 : UNIT =
    let Ti372 : INT =
      int 0
    in
    let Ti373 : INT =
      int 0
    in
    app
      pretrace_line
      cur
      Ti372
      Ti373
  in
  let Ti374 : INT =
    int 0
  in
  let Ti375 : INT =
    int 2
  in
  app
    scan_line
    Ti374
    prev
    cur
    next
    Ti375
in
let Ti349 : INT =
  int 128
in
let Ti350 : INT =
  int 128
in
app
  rt
  Ti349
  Ti350
