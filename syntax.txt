----- syntax.print -----
LETREC print_int (VAR of )
  (n : VAR of )
  LET n (VAR of )
    IF
      NOT
        LE
          INT 0
          VAR n
      LET Tu1 (UNIT)
        OUT
          INT 45        0
      NEG
        VAR n
      VAR n
  IF
    NOT
      LE
        INT 10
        VAR n
    OUT
      VAR n    48
    LET m (VAR of )
      DIVIDE BY 10
        VAR n
    LET Tu2 (UNIT)
      APP
        VAR print_int
        VAR m
    OUT
      SUB
        VAR n
        MULTIPLE 10
          VAR m    48
LETREC print_char (VAR of )
  (c : VAR of )
  OUT
    VAR c  0
LETREC print_newline (VAR of )
  (Tu3 : VAR of )
  OUT
    INT 0  10
LETREC reduction_2pi_sub1 (VAR of )
  (a : VAR of ), (p : VAR of )
  IF
    FLt
      VAR a
      VAR p
    VAR p
    APP
      VAR reduction_2pi_sub1
      VAR a
      FADD
        VAR p
        VAR p
LETREC reduction_2pi_sub2 (VAR of )
  (a : VAR of ), (p : VAR of )
  IF
    FLt
      FLOAT 6.28318530718
      VAR a
    LET a (VAR of )
      IF
        FLt
          VAR p
          VAR a
        FSUB
          VAR a
          VAR p
        FADD
          VAR a
          FLOAT 0.
    LET p (VAR of )
      FDIV
        VAR p
        FLOAT 2.
    APP
      VAR reduction_2pi_sub2
      VAR a
      VAR p
    FADD
      VAR a
      FLOAT 0.
LETREC reduction_2pi (VAR of )
  (a : VAR of )
  LET p (VAR of )
    FLOAT 6.28318530718
  LET p (VAR of )
    APP
      VAR reduction_2pi_sub1
      VAR a
      VAR p
  APP
    VAR reduction_2pi_sub2
    VAR a
    VAR p
LETREC kernel_sin (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a
  LET a5 (VAR of )
    FMUL
      VAR a3
      VAR a2
  LET a7 (VAR of )
    FMUL
      VAR a5
      VAR a2
  FADD
    FSUB
      FADD
        NEG
          FMUL
            FLOAT 0.000198411698413
            VAR a7
        FMUL
          FLOAT 0.0083333333333
          VAR a5
      FMUL
        FLOAT 0.166666666667
        VAR a3
    VAR a
LETREC kernel_cos (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a4 (VAR of )
    FMUL
      VAR a2
      VAR a2
  LET a6 (VAR of )
    FMUL
      VAR a4
      VAR a2
  FADD
    FSUB
      FADD
        NEG
          FMUL
            FLOAT 0.00138888888889
            VAR a6
        FMUL
          FLOAT 0.0416666666667
          VAR a4
      FMUL
        FLOAT 0.5
        VAR a2
    FLOAT 1.
LETREC sin (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      FADD
        VAR a
        FLOAT 0.
  LET a (VAR of )
    APP
      VAR reduction_2pi
      VAR a
  (a : VAR of ), (flag : VAR of )
    IF
      FLt
        FLOAT 3.14159265359
        VAR a
      TUPLE
        FSUB
          VAR a
          FLOAT 3.14159265359
        NOT
          VAR flag
      TUPLE
        FADD
          VAR a
          FLOAT 0.
        VAR flag
    LET a (VAR of )
      IF
        FLt
          FLOAT 1.57079632679
          VAR a
        FSUB
          FLOAT 3.14159265359
          VAR a
        FADD
          VAR a
          FLOAT 0.
    LET a (VAR of )
      IF
        FLt
          VAR a
          FLOAT 0.785398163397
        APP
          VAR kernel_cos
          FSUB
            FLOAT 1.57079632679
            VAR a
        APP
          VAR kernel_sin
          VAR a
    IF
      VAR flag
      FADD
        VAR a
        FLOAT 0.
      NEG
        VAR a
LETREC cos (VAR of )
  (a : VAR of )
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      FADD
        VAR a
        FLOAT 0.
  LET a (VAR of )
    APP
      VAR reduction_2pi
      VAR a
  (a : VAR of ), (flag : VAR of )
    IF
      FLt
        FLOAT 3.14159265359
        VAR a
      TUPLE
        FSUB
          VAR a
          FLOAT 3.14159265359
        BOOL false
      TUPLE
        VAR a
        BOOL true
    (a : VAR of ), (flag : VAR of )
      IF
        FLt
          FLOAT 1.57079632679
          VAR a
        TUPLE
          FSUB
            FLOAT 3.14159265359
            VAR a
          NOT
            VAR flag
        TUPLE
          FADD
            VAR a
            FLOAT 0.
          VAR flag
      LET a (VAR of )
        IF
          FLt
            FLOAT 0.785398163397
            VAR a
          APP
            VAR kernel_cos
            VAR a
          APP
            VAR kernel_sin
            FSUB
              FLOAT 1.57079632679
              VAR a
      IF
        VAR flag
        FADD
          VAR a
          FLOAT 0.
        NEG
          VAR a
LETREC sqrt (VAR of )
  (x : VAR of )
  LETREC inner (VAR of )
    (t : VAR of ), (i : VAR of )
    IF
      EQ
        VAR i
        INT 0
      VAR t
      APP
        VAR inner
        FDIV
          FADD
            FMUL
              VAR t
              VAR t
            VAR x
          FMUL
            FLOAT 2.
            VAR t
        SUB
          VAR i
          INT 1
  APP
    VAR inner
    UNKNOWN APP      sqrt_init
      VAR x
    INT 5
LETREC kernel_atan (VAR of )
  (a1 : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a1
      VAR a1
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a1
  LET a5 (VAR of )
    FMUL
      VAR a2
      VAR a3
  LET a7 (VAR of )
    FMUL
      VAR a2
      VAR a5
  LET a9 (VAR of )
    FMUL
      VAR a2
      VAR a7
  LET a11 (VAR of )
    FMUL
      VAR a2
      VAR a9
  LET a13 (VAR of )
    FMUL
      VAR a2
      VAR a11
  FADD
    FSUB
      FADD
        FSUB
          FADD
            FSUB
              VAR a1
              FMUL
                FLOAT 0.3333333
                VAR a3
            FMUL
              FLOAT 0.2
              VAR a5
          FMUL
            FLOAT 0.142857142
            VAR a7
        FMUL
          FLOAT 0.111111104
          VAR a9
      FMUL
        FLOAT 0.08976446
        VAR a11
    FMUL
      FLOAT 0.060035485
      VAR a13
LETREC atan (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      VAR flag
      FADD
        VAR a
        FLOAT 0.
      NEG
        VAR a
  LET b (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.4375
      APP
        VAR kernel_atan
        VAR a
      FADD
        IF
          FLt
            VAR a
            FLOAT 2.4375
          FADD
            FLOAT 0.785398163397
            APP
              VAR kernel_atan
              FDIV
                FSUB
                  VAR a
                  FLOAT 1.
                FADD
                  VAR a
                  FLOAT 1.
          FSUB
            FLOAT 1.57079632679
            APP
              VAR kernel_atan
              FDIV
                FLOAT 1.
                VAR a
        FLOAT 0.
  IF
    VAR flag
    FADD
      FLOAT 0.
      VAR b
    NEG
      VAR b
LETREC floor (VAR of )
  (x : VAR of )
  LET a (VAR of )
    int_to_float
      float_to_int
        VAR x
  IF
    FLt
      VAR x
      VAR a
    FSUB
      VAR a
      FLOAT 1.
    VAR a
LETREC fabs (VAR of )
  (f : VAR of )
  IF
    FLt
      VAR f
      FLOAT 0.
    NEG
      VAR f
    VAR f
LETREC fhalf (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.5
LETREC fsqr (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    VAR x
LETREC fneg (VAR of )
  (x : VAR of )
  NEG
    VAR x
LETREC fless (VAR of )
  (a : VAR of ), (b : VAR of )
  FLt
    VAR a
    VAR b
LETREC abs_float (VAR of )
  (x : VAR of )
  APP
    VAR fabs
    VAR x
LETREC fispos (VAR of )
  (x : VAR of )
  FLt
    FLOAT 0.
    VAR x
LETREC fisneg (VAR of )
  (x : VAR of )
  FLt
    VAR x
    FLOAT 0.
LET n_objects (VAR of )
  ARRAY
    INT 1
    INT 0
LET objects (VAR of )
  LET dummy (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  ARRAY
    INT 60
    TUPLE
      INT 0
      INT 0
      INT 0
      INT 0
      VAR dummy
      VAR dummy
      BOOL false
      VAR dummy
      VAR dummy
      VAR dummy
      VAR dummy
LET screen (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET viewpoint (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET light (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET beam (VAR of )
  ARRAY
    INT 1
    FLOAT 255.
LET and_net (VAR of )
  ARRAY
    INT 50
    ARRAY
      INT 1
      NEG
        INT 1
LET or_net (VAR of )
  ARRAY
    INT 1
    ARRAY
      INT 1
      GET
        VAR and_net
        INT 0
LET solver_dist (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET intsec_rectside (VAR of )
  ARRAY
    INT 1
    INT 0
LET tmin (VAR of )
  ARRAY
    INT 1
    FLOAT 1000000000.
LET intersection_point (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET intersected_object_id (VAR of )
  ARRAY
    INT 1
    INT 0
LET nvector (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET texture_color (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET diffuse_ray (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET rgb (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET image_size (VAR of )
  ARRAY
    INT 2
    INT 0
LET image_center (VAR of )
  ARRAY
    INT 2
    INT 0
LET scan_pitch (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET startp (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET startp_fast (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenx_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screeny_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenz_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET ptrace_dirvec (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET dirvecs (VAR of )
  LET dummyf (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff (VAR of )
    ARRAY
      INT 0
      VAR dummyf
  LET dummy_vs (VAR of )
    ARRAY
      INT 0
      TUPLE
        VAR dummyf
        VAR dummyff
  ARRAY
    INT 5
    VAR dummy_vs
LET light_dirvec (VAR of )
  LET dummyf2 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      INT 60
      VAR dummyf2
  TUPLE
    VAR v3
    VAR consts
LET reflections (VAR of )
  LET dummyf3 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff3 (VAR of )
    ARRAY
      INT 0
      VAR dummyf3
  LET dummydv (VAR of )
    TUPLE
      VAR dummyf3
      VAR dummyff3
  ARRAY
    INT 180
    TUPLE
      INT 0
      VAR dummydv
      FLOAT 0.
LET n_reflections (VAR of )
  ARRAY
    INT 1
    INT 0
LETREC xor (VAR of )
  (x : VAR of ), (y : VAR of )
  IF
    VAR x
    NOT
      VAR y
    VAR y
LETREC sgn (VAR of )
  (x : VAR of )
  IF
    FZero?
      VAR x
    FLOAT 0.
    IF
      APP
        VAR fispos
        VAR x
      FLOAT 1.
      FLOAT -1.
LETREC fneg_cond (VAR of )
  (cond : VAR of ), (x : VAR of )
  IF
    VAR cond
    VAR x
    APP
      VAR fneg
      VAR x
LETREC add_mod5 (VAR of )
  (x : VAR of ), (y : VAR of )
  LET sum (VAR of )
    ADD
      VAR x
      VAR y
  IF
    LE
      INT 5
      VAR sum
    SUB
      VAR sum
      INT 5
    VAR sum
LETREC vecset (VAR of )
  (v : VAR of ), (x : VAR of ), (y : VAR of ), (z : VAR of )
  LET Tu5 (UNIT)
    PUT
      VAR v
      INT 0
      VAR x
  LET Tu4 (UNIT)
    PUT
      VAR v
      INT 1
      VAR y
  PUT
    VAR v
    INT 2
    VAR z
LETREC vecfill (VAR of )
  (v : VAR of ), (elem : VAR of )
  LET Tu7 (UNIT)
    PUT
      VAR v
      INT 0
      VAR elem
  LET Tu6 (UNIT)
    PUT
      VAR v
      INT 1
      VAR elem
  PUT
    VAR v
    INT 2
    VAR elem
LETREC vecbzero (VAR of )
  (v : VAR of )
  APP
    VAR vecfill
    VAR v
    FLOAT 0.
LETREC veccpy (VAR of )
  (dest : VAR of ), (src : VAR of )
  LET Tu9 (UNIT)
    PUT
      VAR dest
      INT 0
      GET
        VAR src
        INT 0
  LET Tu8 (UNIT)
    PUT
      VAR dest
      INT 1
      GET
        VAR src
        INT 1
  PUT
    VAR dest
    INT 2
    GET
      VAR src
      INT 2
LETREC vecdist2 (VAR of )
  (p : VAR of ), (q : VAR of )
  FADD
    FADD
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 0
          GET
            VAR q
            INT 0
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 1
          GET
            VAR q
            INT 1
    APP
      VAR fsqr
      FSUB
        GET
          VAR p
          INT 2
        GET
          VAR q
          INT 2
LETREC vecunit (VAR of )
  (v : VAR of )
  LET il (VAR of )
    FDIV
      FLOAT 1.
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              GET
                VAR v
                INT 0
            APP
              VAR fsqr
              GET
                VAR v
                INT 1
          APP
            VAR fsqr
            GET
              VAR v
              INT 2
  LET Tu11 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu10 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC vecunit_sgn (VAR of )
  (v : VAR of ), (inv : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FADD
          APP
            VAR fsqr
            GET
              VAR v
              INT 0
          APP
            VAR fsqr
            GET
              VAR v
              INT 1
        APP
          VAR fsqr
          GET
            VAR v
            INT 2
  LET il (VAR of )
    IF
      FZero?
        VAR l
      FLOAT 1.
      IF
        VAR inv
        FDIV
          FLOAT -1.
          VAR l
        FDIV
          FLOAT 1.
          VAR l
  LET Tu13 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu12 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC veciprod (VAR of )
  (v : VAR of ), (w : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        GET
          VAR w
          INT 0
      FMUL
        GET
          VAR v
          INT 1
        GET
          VAR w
          INT 1
    FMUL
      GET
        VAR v
        INT 2
      GET
        VAR w
        INT 2
LETREC veciprod2 (VAR of )
  (v : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        VAR w0
      FMUL
        GET
          VAR v
          INT 1
        VAR w1
    FMUL
      GET
        VAR v
        INT 2
      VAR w2
LETREC vecaccum (VAR of )
  (dest : VAR of ), (scale : VAR of ), (v : VAR of )
  LET Tu15 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          VAR scale
          GET
            VAR v
            INT 0
  LET Tu14 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          VAR scale
          GET
            VAR v
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        VAR scale
        GET
          VAR v
          INT 2
LETREC vecadd (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu17 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu16 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecmul (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu19 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu18 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecscale (VAR of )
  (dest : VAR of ), (scale : VAR of )
  LET Tu21 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        VAR scale
  LET Tu20 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        VAR scale
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      VAR scale
LETREC vecaccumv (VAR of )
  (dest : VAR of ), (v : VAR of ), (w : VAR of )
  LET Tu23 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          GET
            VAR v
            INT 0
          GET
            VAR w
            INT 0
  LET Tu22 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          GET
            VAR v
            INT 1
          GET
            VAR w
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        GET
          VAR v
          INT 2
        GET
          VAR w
          INT 2
LETREC o_texturetype (VAR of )
  (m : VAR of )
  (m_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_tex
LETREC o_form (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (m_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_shape
LETREC o_reflectiontype (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_surface
LETREC o_isinvert (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (m_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_invert
LETREC o_isrot (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (m_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_isrot
LETREC o_param_a (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 0
LETREC o_param_b (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 1
LETREC o_param_c (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 2
LETREC o_param_abc (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_abc
LETREC o_param_x (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 0
LETREC o_param_y (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 1
LETREC o_param_z (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 2
LETREC o_diffuse (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 0
LETREC o_hilight (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 1
LETREC o_color_red (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 0
LETREC o_color_green (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 1
LETREC o_color_blue (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 2
LETREC o_param_r1 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 0
LETREC o_param_r2 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 1
LETREC o_param_r3 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 2
LETREC o_param_ctbl (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (m_ctbl : VAR of )
    VAR m
    VAR m_ctbl
LETREC p_rgb (VAR of )
  (pixel : VAR of )
  (m_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_rgb
LETREC p_intersection_points (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (m_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_isect_ps
LETREC p_surface_ids (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (m_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_sids
LETREC p_calc_diffuse (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (m_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_cdif
LETREC p_energy (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (m_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_engy
LETREC p_received_ray_20percent (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (m_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_r20p
LETREC p_group_id (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    GET
      VAR m_gid
      INT 0
LETREC p_set_group_id (VAR of )
  (pixel : VAR of ), (id : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    PUT
      VAR m_gid
      INT 0
      VAR id
LETREC p_nvectors (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (m_nvectors : VAR of )
    VAR pixel
    VAR m_nvectors
LETREC d_vec (VAR of )
  (d : VAR of )
  (m_vec : VAR of ), (xm_const : VAR of )
    VAR d
    VAR m_vec
LETREC d_const (VAR of )
  (d : VAR of )
  (dm_vec : VAR of ), (m_const : VAR of )
    VAR d
    VAR m_const
LETREC r_surface_id (VAR of )
  (r : VAR of )
  (m_sid : VAR of ), (xm_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_sid
LETREC r_dvec (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (m_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_dvec
LETREC r_bright (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (xm_dvec : VAR of ), (m_br : VAR of )
    VAR r
    VAR m_br
LETREC rad (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.017453293
LETREC read_screen_settings (VAR of )
  (Tu24 : VAR of )
  LET Tu38 (UNIT)
    PUT
      VAR screen
      INT 0
      UNKNOWN APP        inflt
        UNIT
  LET Tu37 (UNIT)
    PUT
      VAR screen
      INT 1
      UNKNOWN APP        inflt
        UNIT
  LET Tu36 (UNIT)
    PUT
      VAR screen
      INT 2
      UNKNOWN APP        inflt
        UNIT
  LET v1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v1 (VAR of )
    APP
      VAR cos
      VAR v1
  LET sin_v1 (VAR of )
    APP
      VAR sin
      VAR v1
  LET v2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v2 (VAR of )
    APP
      VAR cos
      VAR v2
  LET sin_v2 (VAR of )
    APP
      VAR sin
      VAR v2
  LET Tu35 (UNIT)
    PUT
      VAR screenz_dir
      INT 0
      FMUL
        FMUL
          VAR cos_v1
          VAR sin_v2
        FLOAT 200.
  LET Tu34 (UNIT)
    PUT
      VAR screenz_dir
      INT 1
      FMUL
        VAR sin_v1
        FLOAT -200.
  LET Tu33 (UNIT)
    PUT
      VAR screenz_dir
      INT 2
      FMUL
        FMUL
          VAR cos_v1
          VAR cos_v2
        FLOAT 200.
  LET Tu32 (UNIT)
    PUT
      VAR screenx_dir
      INT 0
      VAR cos_v2
  LET Tu31 (UNIT)
    PUT
      VAR screenx_dir
      INT 1
      FLOAT 0.
  LET Tu30 (UNIT)
    PUT
      VAR screenx_dir
      INT 2
      APP
        VAR fneg
        VAR sin_v2
  LET Tu29 (UNIT)
    PUT
      VAR screeny_dir
      INT 0
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR sin_v2
  LET Tu28 (UNIT)
    PUT
      VAR screeny_dir
      INT 1
      APP
        VAR fneg
        VAR cos_v1
  LET Tu27 (UNIT)
    PUT
      VAR screeny_dir
      INT 2
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR cos_v2
  LET Tu26 (UNIT)
    PUT
      VAR viewpoint
      INT 0
      FSUB
        GET
          VAR screen
          INT 0
        GET
          VAR screenz_dir
          INT 0
  LET Tu25 (UNIT)
    PUT
      VAR viewpoint
      INT 1
      FSUB
        GET
          VAR screen
          INT 1
        GET
          VAR screenz_dir
          INT 1
  PUT
    VAR viewpoint
    INT 2
    FSUB
      GET
        VAR screen
        INT 2
      GET
        VAR screenz_dir
        INT 2
LETREC read_light (VAR of )
  (Tu39 : VAR of )
  LET nl (VAR of )
    UNKNOWN APP      inint
      UNIT
  LET l1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET sl1 (VAR of )
    APP
      VAR sin
      VAR l1
  LET Tu42 (UNIT)
    PUT
      VAR light
      INT 1
      APP
        VAR fneg
        VAR sl1
  LET l2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cl1 (VAR of )
    APP
      VAR cos
      VAR l1
  LET sl2 (VAR of )
    APP
      VAR sin
      VAR l2
  LET Tu41 (UNIT)
    PUT
      VAR light
      INT 0
      FMUL
        VAR cl1
        VAR sl2
  LET cl2 (VAR of )
    APP
      VAR cos
      VAR l2
  LET Tu40 (UNIT)
    PUT
      VAR light
      INT 2
      FMUL
        VAR cl1
        VAR cl2
  PUT
    VAR beam
    INT 0
    UNKNOWN APP      inflt
      UNIT
LETREC rotate_quadratic_matrix (VAR of )
  (abc : VAR of ), (rot : VAR of )
  LET cos_x (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 0
  LET sin_x (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 0
  LET cos_y (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 1
  LET sin_y (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 1
  LET cos_z (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 2
  LET sin_z (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 2
  LET m00 (VAR of )
    FMUL
      VAR cos_y
      VAR cos_z
  LET m01 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR cos_x
        VAR sin_z
  LET m02 (VAR of )
    FADD
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR sin_x
        VAR sin_z
  LET m10 (VAR of )
    FMUL
      VAR cos_y
      VAR sin_z
  LET m11 (VAR of )
    FADD
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR cos_x
        VAR cos_z
  LET m12 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR sin_x
        VAR cos_z
  LET m20 (VAR of )
    APP
      VAR fneg
      VAR sin_y
  LET m21 (VAR of )
    FMUL
      VAR sin_x
      VAR cos_y
  LET m22 (VAR of )
    FMUL
      VAR cos_x
      VAR cos_y
  LET ao (VAR of )
    GET
      VAR abc
      INT 0
  LET bo (VAR of )
    GET
      VAR abc
      INT 1
  LET co (VAR of )
    GET
      VAR abc
      INT 2
  LET Tu47 (UNIT)
    PUT
      VAR abc
      INT 0
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m00
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m10
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m20
  LET Tu46 (UNIT)
    PUT
      VAR abc
      INT 1
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m01
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m11
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m21
  LET Tu45 (UNIT)
    PUT
      VAR abc
      INT 2
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m02
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m12
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m22
  LET Tu44 (UNIT)
    PUT
      VAR rot
      INT 0
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m01
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m11
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m21
            VAR m22
  LET Tu43 (UNIT)
    PUT
      VAR rot
      INT 1
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m00
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m10
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m20
            VAR m22
  PUT
    VAR rot
    INT 2
    FMUL
      FLOAT 2.
      FADD
        FADD
          FMUL
            FMUL
              VAR ao
              VAR m00
            VAR m01
          FMUL
            FMUL
              VAR bo
              VAR m10
            VAR m11
        FMUL
          FMUL
            VAR co
            VAR m20
          VAR m21
LETREC read_nth_object (VAR of )
  (n : VAR of )
  LET texture (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    NOT
      EQ
        VAR texture
        NEG
          INT 1
    LET form (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET refltype (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET isrot_p (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET abc (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu66 (UNIT)
      PUT
        VAR abc
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu65 (UNIT)
      PUT
        VAR abc
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu64 (UNIT)
      PUT
        VAR abc
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET xyz (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu63 (UNIT)
      PUT
        VAR xyz
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu62 (UNIT)
      PUT
        VAR xyz
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu61 (UNIT)
      PUT
        VAR xyz
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET m_invert (VAR of )
      APP
        VAR fisneg
        UNKNOWN APP          inflt
          UNIT
    LET reflparam (VAR of )
      ARRAY
        INT 2
        FLOAT 0.
    LET Tu60 (UNIT)
      PUT
        VAR reflparam
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu59 (UNIT)
      PUT
        VAR reflparam
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET color (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu58 (UNIT)
      PUT
        VAR color
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu57 (UNIT)
      PUT
        VAR color
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu56 (UNIT)
      PUT
        VAR color
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET rotation (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu55 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        LET Tu49 (UNIT)
          PUT
            VAR rotation
            INT 0
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        LET Tu48 (UNIT)
          PUT
            VAR rotation
            INT 1
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        PUT
          VAR rotation
          INT 2
          APP
            VAR rad
            UNKNOWN APP              inflt
              UNIT
        UNIT
    LET m_invert2 (VAR of )
      IF
        EQ
          VAR form
          INT 2
        BOOL true
        VAR m_invert
    LET ctbl (VAR of )
      ARRAY
        INT 4
        FLOAT 0.
    LET obj (VAR of )
      TUPLE
        VAR texture
        VAR form
        VAR refltype
        VAR isrot_p
        VAR abc
        VAR xyz
        VAR m_invert2
        VAR reflparam
        VAR color
        VAR rotation
        VAR ctbl
    LET Tu54 (UNIT)
      PUT
        VAR objects
        VAR n
        VAR obj
    LET Tu53 (UNIT)
      IF
        EQ
          VAR form
          INT 3
        LET a (VAR of )
          GET
            VAR abc
            INT 0
        LET Tu51 (UNIT)
          PUT
            VAR abc
            INT 0
            IF
              FZero?
                VAR a
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR a
                APP
                  VAR fsqr
                  VAR a
        LET b (VAR of )
          GET
            VAR abc
            INT 1
        LET Tu50 (UNIT)
          PUT
            VAR abc
            INT 1
            IF
              FZero?
                VAR b
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR b
                APP
                  VAR fsqr
                  VAR b
        LET c (VAR of )
          GET
            VAR abc
            INT 2
        PUT
          VAR abc
          INT 2
          IF
            FZero?
              VAR c
            FLOAT 0.
            FDIV
              APP
                VAR sgn
                VAR c
              APP
                VAR fsqr
                VAR c
        IF
          EQ
            VAR form
            INT 2
          APP
            VAR vecunit_sgn
            VAR abc
            NOT
              VAR m_invert
          UNIT
    LET Tu52 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        APP
          VAR rotate_quadratic_matrix
          VAR abc
          VAR rotation
        UNIT
    BOOL true
    BOOL false
LETREC read_object (VAR of )
  (n : VAR of )
  IF
    NOT
      LE
        INT 60
        VAR n
    IF
      APP
        VAR read_nth_object
        VAR n
      APP
        VAR read_object
        ADD
          VAR n
          INT 1
      PUT
        VAR n_objects
        INT 0
        VAR n
    UNIT
LETREC read_all_object (VAR of )
  (Tu67 : VAR of )
  APP
    VAR read_object
    INT 0
LETREC read_net_item (VAR of )
  (length : VAR of )
  LET item (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    EQ
      VAR item
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      NEG
        INT 1
    LET v (VAR of )
      APP
        VAR read_net_item
        ADD
          VAR length
          INT 1
    LET Tu68 (UNIT)
      PUT
        VAR v
        VAR length
        VAR item
    VAR v
LETREC read_or_network (VAR of )
  (length : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      VAR net
    LET v (VAR of )
      APP
        VAR read_or_network
        ADD
          VAR length
          INT 1
    LET Tu69 (UNIT)
      PUT
        VAR v
        VAR length
        VAR net
    VAR v
LETREC read_and_network (VAR of )
  (n : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    UNIT
    LET Tu70 (UNIT)
      PUT
        VAR and_net
        VAR n
        VAR net
    APP
      VAR read_and_network
      ADD
        VAR n
        INT 1
LETREC read_parameter (VAR of )
  (Tu71 : VAR of )
  LET Tu75 (UNIT)
    APP
      VAR read_screen_settings
      UNIT
  LET Tu74 (UNIT)
    APP
      VAR read_light
      UNIT
  LET Tu73 (UNIT)
    APP
      VAR read_all_object
      UNIT
  LET Tu72 (UNIT)
    APP
      VAR read_and_network
      INT 0
  PUT
    VAR or_net
    INT 0
    APP
      VAR read_or_network
      INT 0
LETREC solver_rect_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of ), (i0 : VAR of ), (i1 : VAR of ), (i2 : VAR of )
  IF
    FZero?
      GET
        VAR dirvec
        VAR i0
    BOOL false
    LET abc (VAR of )
      APP
        VAR o_param_abc
        VAR m
    LET d (VAR of )
      APP
        VAR fneg_cond
        APP
          VAR xor
          APP
            VAR o_isinvert
            VAR m
          APP
            VAR fisneg
            GET
              VAR dirvec
              VAR i0
        GET
          VAR abc
          VAR i0
    LET d2 (VAR of )
      FDIV
        FSUB
          VAR d
          VAR b0
        GET
          VAR dirvec
          VAR i0
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d2
              GET
                VAR dirvec
                VAR i1
            VAR b1
        GET
          VAR abc
          VAR i1
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d2
                GET
                  VAR dirvec
                  VAR i2
              VAR b2
          GET
            VAR abc
            VAR i2
        LET Tu76 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        BOOL true
        BOOL false
      BOOL false
LETREC solver_rect (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR solver_rect_surface
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
      INT 0
      INT 1
      INT 2
    INT 1
    IF
      APP
        VAR solver_rect_surface
        VAR m
        VAR dirvec
        VAR b1
        VAR b2
        VAR b0
        INT 1
        INT 2
        INT 0
      INT 2
      IF
        APP
          VAR solver_rect_surface
          VAR m
          VAR dirvec
          VAR b2
          VAR b0
          VAR b1
          INT 2
          INT 0
          INT 1
        INT 3
        INT 0
LETREC solver_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET abc (VAR of )
    APP
      VAR o_param_abc
      VAR m
  LET d (VAR of )
    APP
      VAR veciprod
      VAR dirvec
      VAR abc
  IF
    APP
      VAR fispos
      VAR d
    LET Tu77 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FDIV
          APP
            VAR fneg
            APP
              VAR veciprod2
              VAR abc
              VAR b0
              VAR b1
              VAR b2
          VAR d
    INT 1
    INT 0
LETREC quadratic (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          APP
            VAR fsqr
            VAR v0
          APP
            VAR o_param_a
            VAR m
        FMUL
          APP
            VAR fsqr
            VAR v1
          APP
            VAR o_param_b
            VAR m
      FMUL
        APP
          VAR fsqr
          VAR v2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      FADD
        FADD
          VAR diag_part
          FMUL
            FMUL
              VAR v1
              VAR v2
            APP
              VAR o_param_r1
              VAR m
        FMUL
          FMUL
            VAR v2
            VAR v0
          APP
            VAR o_param_r2
            VAR m
      FMUL
        FMUL
          VAR v0
          VAR v1
        APP
          VAR o_param_r3
          VAR m
LETREC bilinear (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          FMUL
            VAR v0
            VAR w0
          APP
            VAR o_param_a
            VAR m
        FMUL
          FMUL
            VAR v1
            VAR w1
          APP
            VAR o_param_b
            VAR m
      FMUL
        FMUL
          VAR v2
          VAR w2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      VAR diag_part
      APP
        VAR fhalf
        FADD
          FADD
            FMUL
              FADD
                FMUL
                  VAR v2
                  VAR w1
                FMUL
                  VAR v1
                  VAR w2
              APP
                VAR o_param_r1
                VAR m
            FMUL
              FADD
                FMUL
                  VAR v0
                  VAR w2
                FMUL
                  VAR v2
                  VAR w0
              APP
                VAR o_param_r2
                VAR m
          FMUL
            FADD
              FMUL
                VAR v0
                VAR w1
              FMUL
                VAR v1
                VAR w0
            APP
              VAR o_param_r3
              VAR m
LETREC solver_second (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR dirvec
        INT 0
      GET
        VAR dirvec
        INT 1
      GET
        VAR dirvec
        INT 2
  IF
    FZero?
      VAR aa
    INT 0
    LET bb (VAR of )
      APP
        VAR bilinear
        VAR m
        GET
          VAR dirvec
          INT 0
        GET
          VAR dirvec
          INT 1
        GET
          VAR dirvec
          INT 2
        VAR b0
        VAR b1
        VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET sd (VAR of )
        APP
          VAR sqrt
          VAR d
      LET t1 (VAR of )
        IF
          APP
            VAR o_isinvert
            VAR m
          VAR sd
          APP
            VAR fneg
            VAR sd
      LET Tu78 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          FDIV
            FSUB
              VAR t1
              VAR bb
            VAR aa
      INT 1
      INT 0
LETREC solver (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
LETREC solver_rect_fast (VAR of )
  (m : VAR of ), (v : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET d0 (VAR of )
    FMUL
      FSUB
        GET
          VAR dconst
          INT 0
        VAR b0
      GET
        VAR dconst
        INT 1
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d0
              GET
                VAR v
                INT 1
            VAR b1
        APP
          VAR o_param_b
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d0
                GET
                  VAR v
                  INT 2
              VAR b2
          APP
            VAR o_param_c
            VAR m
        NOT
          FZero?
            GET
              VAR dconst
              INT 1
        BOOL false
      BOOL false
    LET Tu79 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        VAR d0
    INT 1
    LET d1 (VAR of )
      FMUL
        FSUB
          GET
            VAR dconst
            INT 2
          VAR b1
        GET
          VAR dconst
          INT 3
    IF
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d1
                GET
                  VAR v
                  INT 0
              VAR b0
          APP
            VAR o_param_a
            VAR m
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d1
                  GET
                    VAR v
                    INT 2
                VAR b2
            APP
              VAR o_param_c
              VAR m
          NOT
            FZero?
              GET
                VAR dconst
                INT 3
          BOOL false
        BOOL false
      LET Tu80 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          VAR d1
      INT 2
      LET d2 (VAR of )
        FMUL
          FSUB
            GET
              VAR dconst
              INT 4
            VAR b2
          GET
            VAR dconst
            INT 5
      IF
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d2
                  GET
                    VAR v
                    INT 0
                VAR b0
            APP
              VAR o_param_a
              VAR m
          IF
            APP
              VAR fless
              APP
                VAR fabs
                FADD
                  FMUL
                    VAR d2
                    GET
                      VAR v
                      INT 1
                  VAR b1
              APP
                VAR o_param_b
                VAR m
            NOT
              FZero?
                GET
                  VAR dconst
                  INT 5
            BOOL false
          BOOL false
        LET Tu81 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        INT 3
        INT 0
LETREC solver_surface_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu82 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FADD
          FADD
            FMUL
              GET
                VAR dconst
                INT 1
              VAR b0
            FMUL
              GET
                VAR dconst
                INT 2
              VAR b1
          FMUL
            GET
              VAR dconst
              INT 3
            VAR b2
    INT 1
    INT 0
LETREC solver_second_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu83 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
LETREC solver_surface_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu84 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FMUL
          GET
            VAR dconst
            INT 0
          GET
            VAR sconst
            INT 3
    INT 1
    INT 0
LETREC solver_second_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc (VAR of )
      GET
        VAR sconst
        INT 3
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu85 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast2 (VAR of )
  (index : VAR of ), (dirvec : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET sconst (VAR of )
    APP
      VAR o_param_ctbl
      VAR m
  LET b0 (VAR of )
    GET
      VAR sconst
      INT 0
  LET b1 (VAR of )
    GET
      VAR sconst
      INT 1
  LET b2 (VAR of )
    GET
      VAR sconst
      INT 2
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
LETREC setup_rect_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 6
      FLOAT 0.
  LET Tu91 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 0
      PUT
        VAR const
        INT 1
        FLOAT 0.
      LET Tu86 (UNIT)
        PUT
          VAR const
          INT 0
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 0
            APP
              VAR o_param_a
              VAR m
      PUT
        VAR const
        INT 1
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 0
  LET Tu90 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 1
      PUT
        VAR const
        INT 3
        FLOAT 0.
      LET Tu87 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 1
            APP
              VAR o_param_b
              VAR m
      PUT
        VAR const
        INT 3
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 1
  LET Tu89 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 2
      PUT
        VAR const
        INT 5
        FLOAT 0.
      LET Tu88 (UNIT)
        PUT
          VAR const
          INT 4
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 2
            APP
              VAR o_param_c
              VAR m
      PUT
        VAR const
        INT 5
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 2
  VAR const
LETREC setup_surface_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 4
      FLOAT 0.
  LET d (VAR of )
    FADD
      FADD
        FMUL
          GET
            VAR vec
            INT 0
          APP
            VAR o_param_a
            VAR m
        FMUL
          GET
            VAR vec
            INT 1
          APP
            VAR o_param_b
            VAR m
      FMUL
        GET
          VAR vec
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu95 (UNIT)
    IF
      APP
        VAR fispos
        VAR d
      LET Tu94 (UNIT)
        PUT
          VAR const
          INT 0
          FDIV
            FLOAT -1.
            VAR d
      LET Tu93 (UNIT)
        PUT
          VAR const
          INT 1
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_a
                VAR m
              VAR d
      LET Tu92 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_b
                VAR m
              VAR d
      PUT
        VAR const
        INT 3
        APP
          VAR fneg
          FDIV
            APP
              VAR o_param_c
              VAR m
            VAR d
      PUT
        VAR const
        INT 0
        FLOAT 0.
  VAR const
LETREC setup_second_table (VAR of )
  (v : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 5
      FLOAT 0.
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
      GET
        VAR v
        INT 2
  LET c1 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 0
        APP
          VAR o_param_a
          VAR m
  LET c2 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 1
        APP
          VAR o_param_b
          VAR m
  LET c3 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu102 (UNIT)
    PUT
      VAR const
      INT 0
      VAR aa
  LET Tu101 (UNIT)
    IF
      NOT
        EQ
          APP
            VAR o_isrot
            VAR m
          INT 0
      LET Tu97 (UNIT)
        PUT
          VAR const
          INT 1
          FSUB
            VAR c1
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r2
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 1
                  APP
                    VAR o_param_r3
                    VAR m
      LET Tu96 (UNIT)
        PUT
          VAR const
          INT 2
          FSUB
            VAR c2
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r1
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 0
                  APP
                    VAR o_param_r3
                    VAR m
      PUT
        VAR const
        INT 3
        FSUB
          VAR c3
          APP
            VAR fhalf
            FADD
              FMUL
                GET
                  VAR v
                  INT 1
                APP
                  VAR o_param_r1
                  VAR m
              FMUL
                GET
                  VAR v
                  INT 0
                APP
                  VAR o_param_r2
                  VAR m
      LET Tu99 (UNIT)
        PUT
          VAR const
          INT 1
          VAR c1
      LET Tu98 (UNIT)
        PUT
          VAR const
          INT 2
          VAR c2
      PUT
        VAR const
        INT 3
        VAR c3
  LET Tu100 (UNIT)
    IF
      NOT
        FZero?
          VAR aa
      PUT
        VAR const
        INT 4
        FDIV
          FLOAT 1.
          VAR aa
      UNIT
  VAR const
LETREC iter_setup_dirvec_constants (VAR of )
  (dirvec : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET m (VAR of )
      GET
        VAR objects
        VAR index
    LET dconst (VAR of )
      APP
        VAR d_const
        VAR dirvec
    LET v (VAR of )
      APP
        VAR d_vec
        VAR dirvec
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR m
    LET Tu103 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 1
        PUT
          VAR dconst
          VAR index
          APP
            VAR setup_rect_table
            VAR v
            VAR m
        IF
          EQ
            VAR m_shape
            INT 2
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_surface_table
              VAR v
              VAR m
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_second_table
              VAR v
              VAR m
    APP
      VAR iter_setup_dirvec_constants
      VAR dirvec
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_dirvec_constants (VAR of )
  (dirvec : VAR of )
  APP
    VAR iter_setup_dirvec_constants
    VAR dirvec
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC setup_startp_constants (VAR of )
  (p : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET obj (VAR of )
      GET
        VAR objects
        VAR index
    LET sconst (VAR of )
      APP
        VAR o_param_ctbl
        VAR obj
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR obj
    LET Tu107 (UNIT)
      PUT
        VAR sconst
        INT 0
        FSUB
          GET
            VAR p
            INT 0
          APP
            VAR o_param_x
            VAR obj
    LET Tu106 (UNIT)
      PUT
        VAR sconst
        INT 1
        FSUB
          GET
            VAR p
            INT 1
          APP
            VAR o_param_y
            VAR obj
    LET Tu105 (UNIT)
      PUT
        VAR sconst
        INT 2
        FSUB
          GET
            VAR p
            INT 2
          APP
            VAR o_param_z
            VAR obj
    LET Tu104 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 2
        PUT
          VAR sconst
          INT 3
          APP
            VAR veciprod2
            APP
              VAR o_param_abc
              VAR obj
            GET
              VAR sconst
              INT 0
            GET
              VAR sconst
              INT 1
            GET
              VAR sconst
              INT 2
        IF
          NOT
            LE
              VAR m_shape
              INT 2
          LET cc0 (VAR of )
            APP
              VAR quadratic
              VAR obj
              GET
                VAR sconst
                INT 0
              GET
                VAR sconst
                INT 1
              GET
                VAR sconst
                INT 2
          PUT
            VAR sconst
            INT 3
            IF
              EQ
                VAR m_shape
                INT 3
              FSUB
                VAR cc0
                FLOAT 1.
              VAR cc0
          UNIT
    APP
      VAR setup_startp_constants
      VAR p
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_startp (VAR of )
  (p : VAR of )
  LET Tu108 (UNIT)
    APP
      VAR veccpy
      VAR startp_fast
      VAR p
  APP
    VAR setup_startp_constants
    VAR p
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC is_rect_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          VAR p0
        APP
          VAR o_param_a
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            VAR p1
          APP
            VAR o_param_b
            VAR m
        APP
          VAR fless
          APP
            VAR fabs
            VAR p2
          APP
            VAR o_param_c
            VAR m
        BOOL false
      BOOL false
    APP
      VAR o_isinvert
      VAR m
    NOT
      APP
        VAR o_isinvert
        VAR m
LETREC is_plane_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR veciprod2
      APP
        VAR o_param_abc
        VAR m
      VAR p0
      VAR p1
      VAR p2
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w
LETREC is_second_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR quadratic
      VAR m
      VAR p0
      VAR p1
      VAR p2
  LET w2 (VAR of )
    IF
      EQ
        APP
          VAR o_form
          VAR m
        INT 3
      FSUB
        VAR w
        FLOAT 1.
      VAR w
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w2
LETREC is_outside (VAR of )
  (m : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET p0 (VAR of )
    FSUB
      VAR q0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      VAR q1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      VAR q2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR is_rect_outside
      VAR m
      VAR p0
      VAR p1
      VAR p2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR is_plane_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
      APP
        VAR is_second_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
LETREC check_all_inside (VAR of )
  (ofs : VAR of ), (iand : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET head (VAR of )
    GET
      VAR iand
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL true
    IF
      APP
        VAR is_outside
        GET
          VAR objects
          VAR head
        VAR q0
        VAR q1
        VAR q2
      BOOL false
      APP
        VAR check_all_inside
        ADD
          VAR ofs
          INT 1
        VAR iand
        VAR q0
        VAR q1
        VAR q2
LETREC shadow_check_and_group (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of )
  IF
    EQ
      GET
        VAR and_group
        VAR iand_ofs
      NEG
        INT 1
    BOOL false
    LET obj (VAR of )
      GET
        VAR and_group
        VAR iand_ofs
    LET t0 (VAR of )
      APP
        VAR solver_fast
        VAR obj
        VAR light_dirvec
        VAR intersection_point
    LET t0p (VAR of )
      GET
        VAR solver_dist
        INT 0
    IF
      IF
        NOT
          EQ
            VAR t0
            INT 0
        APP
          VAR fless
          VAR t0p
          FLOAT -0.2
        BOOL false
      LET t (VAR of )
        FADD
          VAR t0p
          FLOAT 0.01
      LET q0 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 0
            VAR t
          GET
            VAR intersection_point
            INT 0
      LET q1 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 1
            VAR t
          GET
            VAR intersection_point
            INT 1
      LET q2 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 2
            VAR t
          GET
            VAR intersection_point
            INT 2
      IF
        APP
          VAR check_all_inside
          INT 0
          VAR and_group
          VAR q0
          VAR q1
          VAR q2
        BOOL true
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR obj
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
        BOOL false
LETREC shadow_check_one_or_group (VAR of )
  (ofs : VAR of ), (or_group : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL false
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET shadow_p (VAR of )
      APP
        VAR shadow_check_and_group
        INT 0
        VAR and_group
    IF
      VAR shadow_p
      BOOL true
      APP
        VAR shadow_check_one_or_group
        ADD
          VAR ofs
          INT 1
        VAR or_group
LETREC shadow_check_one_or_matrix (VAR of )
  (ofs : VAR of ), (or_matrix : VAR of )
  LET head (VAR of )
    GET
      VAR or_matrix
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    BOOL false
    IF
      IF
        EQ
          VAR range_primitive
          INT 99
        BOOL true
        LET t (VAR of )
          APP
            VAR solver_fast
            VAR range_primitive
            VAR light_dirvec
            VAR intersection_point
        IF
          NOT
            EQ
              VAR t
              INT 0
          IF
            APP
              VAR fless
              GET
                VAR solver_dist
                INT 0
              FLOAT -0.1
            IF
              APP
                VAR shadow_check_one_or_group
                INT 1
                VAR head
              BOOL true
              BOOL false
            BOOL false
          BOOL false
      IF
        APP
          VAR shadow_check_one_or_group
          INT 1
          VAR head
        BOOL true
        APP
          VAR shadow_check_one_or_matrix
          ADD
            VAR ofs
            INT 1
          VAR or_matrix
      APP
        VAR shadow_check_one_or_matrix
        ADD
          VAR ofs
          INT 1
        VAR or_matrix
LETREC solve_each_element (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver
        VAR iobj
        VAR dirvec
        VAR startp
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu112 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 0
                  VAR t
                GET
                  VAR startp
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 1
                  VAR t
                GET
                  VAR startp
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 2
                  VAR t
                GET
                  VAR startp
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu111 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu110 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu109 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu113 (UNIT)
      APP
        VAR solve_each_element
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu114 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver
            VAR range_primitive
            VAR dirvec
            VAR startp
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection (VAR of )
  (dirvec : VAR of )
  LET Tu116 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu115 (UNIT)
    APP
      VAR trace_or_matrix
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC solve_each_element_fast (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET vec (VAR of )
    APP
      VAR d_vec
      VAR dirvec
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver_fast2
        VAR iobj
        VAR dirvec
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu120 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 0
                  VAR t
                GET
                  VAR startp_fast
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 1
                  VAR t
                GET
                  VAR startp_fast
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 2
                  VAR t
                GET
                  VAR startp_fast
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu119 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu118 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu117 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element_fast
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element_fast
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network_fast (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu121 (UNIT)
      APP
        VAR solve_each_element_fast
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network_fast
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix_fast (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu122 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network_fast
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver_fast2
            VAR range_primitive
            VAR dirvec
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network_fast
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix_fast
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection_fast (VAR of )
  (dirvec : VAR of )
  LET Tu124 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu123 (UNIT)
    APP
      VAR trace_or_matrix_fast
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC get_nvector_rect (VAR of )
  (dirvec : VAR of )
  LET rectside (VAR of )
    GET
      VAR intsec_rectside
      INT 0
  LET Tu125 (UNIT)
    APP
      VAR vecbzero
      VAR nvector
  PUT
    VAR nvector
    SUB
      VAR rectside
      INT 1
    APP
      VAR fneg
      APP
        VAR sgn
        GET
          VAR dirvec
          SUB
            VAR rectside
            INT 1
LETREC get_nvector_plane (VAR of )
  (m : VAR of )
  LET Tu127 (UNIT)
    PUT
      VAR nvector
      INT 0
      APP
        VAR fneg
        APP
          VAR o_param_a
          VAR m
  LET Tu126 (UNIT)
    PUT
      VAR nvector
      INT 1
      APP
        VAR fneg
        APP
          VAR o_param_b
          VAR m
  PUT
    VAR nvector
    INT 2
    APP
      VAR fneg
      APP
        VAR o_param_c
        VAR m
LETREC get_nvector_second (VAR of )
  (m : VAR of )
  LET p0 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET d0 (VAR of )
    FMUL
      VAR p0
      APP
        VAR o_param_a
        VAR m
  LET d1 (VAR of )
    FMUL
      VAR p1
      APP
        VAR o_param_b
        VAR m
  LET d2 (VAR of )
    FMUL
      VAR p2
      APP
        VAR o_param_c
        VAR m
  LET Tu132 (UNIT)
    IF
      EQ
        APP
          VAR o_isrot
          VAR m
        INT 0
      LET Tu129 (UNIT)
        PUT
          VAR nvector
          INT 0
          VAR d0
      LET Tu128 (UNIT)
        PUT
          VAR nvector
          INT 1
          VAR d1
      PUT
        VAR nvector
        INT 2
        VAR d2
      LET Tu131 (UNIT)
        PUT
          VAR nvector
          INT 0
          FADD
            VAR d0
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p1
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r2
                    VAR m
      LET Tu130 (UNIT)
        PUT
          VAR nvector
          INT 1
          FADD
            VAR d1
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p0
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r1
                    VAR m
      PUT
        VAR nvector
        INT 2
        FADD
          VAR d2
          APP
            VAR fhalf
            FADD
              FMUL
                VAR p0
                APP
                  VAR o_param_r2
                  VAR m
              FMUL
                VAR p1
                APP
                  VAR o_param_r1
                  VAR m
  APP
    VAR vecunit_sgn
    VAR nvector
    APP
      VAR o_isinvert
      VAR m
LETREC get_nvector (VAR of )
  (m : VAR of ), (dirvec : VAR of )
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR get_nvector_rect
      VAR dirvec
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR get_nvector_plane
        VAR m
      APP
        VAR get_nvector_second
        VAR m
LETREC utexture (VAR of )
  (m : VAR of ), (p : VAR of )
  LET m_tex (VAR of )
    APP
      VAR o_texturetype
      VAR m
  LET Tu137 (UNIT)
    PUT
      VAR texture_color
      INT 0
      APP
        VAR o_color_red
        VAR m
  LET Tu136 (UNIT)
    PUT
      VAR texture_color
      INT 1
      APP
        VAR o_color_green
        VAR m
  LET Tu135 (UNIT)
    PUT
      VAR texture_color
      INT 2
      APP
        VAR o_color_blue
        VAR m
  IF
    EQ
      VAR m_tex
      INT 1
    LET w1 (VAR of )
      FSUB
        GET
          VAR p
          INT 0
        APP
          VAR o_param_x
          VAR m
    LET flag1 (VAR of )
      LET d1 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w1
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w1
          VAR d1
        FLOAT 10.
    LET w3 (VAR of )
      FSUB
        GET
          VAR p
          INT 2
        APP
          VAR o_param_z
          VAR m
    LET flag2 (VAR of )
      LET d2 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w3
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w3
          VAR d2
        FLOAT 10.
    PUT
      VAR texture_color
      INT 1
      IF
        VAR flag1
        IF
          VAR flag2
          FLOAT 255.
          FLOAT 0.
        IF
          VAR flag2
          FLOAT 0.
          FLOAT 255.
    IF
      EQ
        VAR m_tex
        INT 2
      LET w2 (VAR of )
        APP
          VAR fsqr
          APP
            VAR sin
            FMUL
              GET
                VAR p
                INT 1
              FLOAT 0.25
      LET Tu133 (UNIT)
        PUT
          VAR texture_color
          INT 0
          FMUL
            FLOAT 255.
            VAR w2
      PUT
        VAR texture_color
        INT 1
        FMUL
          FLOAT 255.
          FSUB
            FLOAT 1.
            VAR w2
      IF
        EQ
          VAR m_tex
          INT 3
        LET w1 (VAR of )
          FSUB
            GET
              VAR p
              INT 0
            APP
              VAR o_param_x
              VAR m
        LET w3 (VAR of )
          FSUB
            GET
              VAR p
              INT 2
            APP
              VAR o_param_z
              VAR m
        LET w2 (VAR of )
          FDIV
            APP
              VAR sqrt
              FADD
                APP
                  VAR fsqr
                  VAR w1
                APP
                  VAR fsqr
                  VAR w3
            FLOAT 10.
        LET w4 (VAR of )
          FMUL
            FSUB
              VAR w2
              APP
                VAR floor
                VAR w2
            FLOAT 3.1415927
        LET cws (VAR of )
          APP
            VAR fsqr
            APP
              VAR cos
              VAR w4
        LET Tu134 (UNIT)
          PUT
            VAR texture_color
            INT 1
            FMUL
              VAR cws
              FLOAT 255.
        PUT
          VAR texture_color
          INT 2
          FMUL
            FSUB
              FLOAT 1.
              VAR cws
            FLOAT 255.
        IF
          EQ
            VAR m_tex
            INT 4
          LET w1 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 0
                APP
                  VAR o_param_x
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_a
                  VAR m
          LET w3 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 2
                APP
                  VAR o_param_z
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_c
                  VAR m
          LET w4 (VAR of )
            FADD
              APP
                VAR fsqr
                VAR w1
              APP
                VAR fsqr
                VAR w3
          LET w7 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w1
                FLOAT 0.0001
              FLOAT 15.
              LET w5 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w3
                    VAR w1
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w5
                  FLOAT 30.
                FLOAT 3.1415927
          LET w9 (VAR of )
            FSUB
              VAR w7
              APP
                VAR floor
                VAR w7
          LET w2 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 1
                APP
                  VAR o_param_y
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_b
                  VAR m
          LET w8 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w4
                FLOAT 0.0001
              FLOAT 15.
              LET w6 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w2
                    VAR w4
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w6
                  FLOAT 30.
                FLOAT 3.1415927
          LET w10 (VAR of )
            FSUB
              VAR w8
              APP
                VAR floor
                VAR w8
          LET w11 (VAR of )
            FSUB
              FSUB
                FLOAT 0.15
                APP
                  VAR fsqr
                  FSUB
                    FLOAT 0.5
                    VAR w9
              APP
                VAR fsqr
                FSUB
                  FLOAT 0.5
                  VAR w10
          LET w12 (VAR of )
            IF
              APP
                VAR fisneg
                VAR w11
              FLOAT 0.
              VAR w11
          PUT
            VAR texture_color
            INT 2
            FDIV
              FMUL
                FLOAT 255.
                VAR w12
              FLOAT 0.3
          UNIT
LETREC add_light (VAR of )
  (bright : VAR of ), (hilight : VAR of ), (hilight_scale : VAR of )
  LET Tu140 (UNIT)
    IF
      APP
        VAR fispos
        VAR bright
      APP
        VAR vecaccum
        VAR rgb
        VAR bright
        VAR texture_color
      UNIT
  IF
    APP
      VAR fispos
      VAR hilight
    LET ihl (VAR of )
      FMUL
        APP
          VAR fsqr
          APP
            VAR fsqr
            VAR hilight
        VAR hilight_scale
    LET Tu139 (UNIT)
      PUT
        VAR rgb
        INT 0
        FADD
          GET
            VAR rgb
            INT 0
          VAR ihl
    LET Tu138 (UNIT)
      PUT
        VAR rgb
        INT 1
        FADD
          GET
            VAR rgb
            INT 1
          VAR ihl
    PUT
      VAR rgb
      INT 2
      FADD
        GET
          VAR rgb
          INT 2
        VAR ihl
    UNIT
LETREC trace_reflections (VAR of )
  (index : VAR of ), (diffuse : VAR of ), (hilight_scale : VAR of ), (dirvec : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET rinfo (VAR of )
      GET
        VAR reflections
        VAR index
    LET dvec (VAR of )
      APP
        VAR r_dvec
        VAR rinfo
    LET Tu141 (UNIT)
      IF
        APP
          VAR judge_intersection_fast
          VAR dvec
        LET surface_id (VAR of )
          ADD
            MULTIPLE 4
              GET
                VAR intersected_object_id
                INT 0
            GET
              VAR intsec_rectside
              INT 0
        IF
          EQ
            VAR surface_id
            APP
              VAR r_surface_id
              VAR rinfo
          IF
            NOT
              APP
                VAR shadow_check_one_or_matrix
                INT 0
                GET
                  VAR or_net
                  INT 0
            LET p (VAR of )
              APP
                VAR veciprod
                VAR nvector
                APP
                  VAR d_vec
                  VAR dvec
            LET scale (VAR of )
              APP
                VAR r_bright
                VAR rinfo
            LET bright (VAR of )
              FMUL
                FMUL
                  VAR scale
                  VAR diffuse
                VAR p
            LET hilight (VAR of )
              FMUL
                VAR scale
                APP
                  VAR veciprod
                  VAR dirvec
                  APP
                    VAR d_vec
                    VAR dvec
            APP
              VAR add_light
              VAR bright
              VAR hilight
              VAR hilight_scale
            UNIT
          UNIT
        UNIT
    APP
      VAR trace_reflections
      SUB
        VAR index
        INT 1
      VAR diffuse
      VAR hilight_scale
      VAR dirvec
    UNIT
LETREC trace_ray (VAR of )
  (nref : VAR of ), (energy : VAR of ), (dirvec : VAR of ), (pixel : VAR of ), (dist : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      APP
        VAR judge_intersection
        VAR dirvec
      LET obj_id (VAR of )
        GET
          VAR intersected_object_id
          INT 0
      LET obj (VAR of )
        GET
          VAR objects
          VAR obj_id
      LET m_surface (VAR of )
        APP
          VAR o_reflectiontype
          VAR obj
      LET diffuse (VAR of )
        FMUL
          APP
            VAR o_diffuse
            VAR obj
          VAR energy
      LET Tu155 (UNIT)
        APP
          VAR get_nvector
          VAR obj
          VAR dirvec
      LET Tu154 (UNIT)
        APP
          VAR veccpy
          VAR startp
          VAR intersection_point
      LET Tu153 (UNIT)
        APP
          VAR utexture
          VAR obj
          VAR intersection_point
      LET Tu152 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          ADD
            MULTIPLE 4
              VAR obj_id
            GET
              VAR intsec_rectside
              INT 0
      LET intersection_points (VAR of )
        APP
          VAR p_intersection_points
          VAR pixel
      LET Tu151 (UNIT)
        APP
          VAR veccpy
          GET
            VAR intersection_points
            VAR nref
          VAR intersection_point
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu150 (UNIT)
        IF
          APP
            VAR fless
            APP
              VAR o_diffuse
              VAR obj
            FLOAT 0.5
          PUT
            VAR calc_diffuse
            VAR nref
            BOOL false
          LET Tu144 (UNIT)
            PUT
              VAR calc_diffuse
              VAR nref
              BOOL true
          LET energya (VAR of )
            APP
              VAR p_energy
              VAR pixel
          LET Tu143 (UNIT)
            APP
              VAR veccpy
              GET
                VAR energya
                VAR nref
              VAR texture_color
          LET Tu142 (UNIT)
            APP
              VAR vecscale
              GET
                VAR energya
                VAR nref
              FMUL
                FDIV
                  FLOAT 1.
                  FLOAT 256.
                VAR diffuse
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR nvectors
              VAR nref
            VAR nvector
      LET w (VAR of )
        FMUL
          FLOAT -2.
          APP
            VAR veciprod
            VAR dirvec
            VAR nvector
      LET Tu149 (UNIT)
        APP
          VAR vecaccum
          VAR dirvec
          VAR w
          VAR nvector
      LET hilight_scale (VAR of )
        FMUL
          VAR energy
          APP
            VAR o_hilight
            VAR obj
      LET Tu148 (UNIT)
        IF
          NOT
            APP
              VAR shadow_check_one_or_matrix
              INT 0
              GET
                VAR or_net
                INT 0
          LET bright (VAR of )
            FMUL
              APP
                VAR fneg
                APP
                  VAR veciprod
                  VAR nvector
                  VAR light
              VAR diffuse
          LET hilight (VAR of )
            APP
              VAR fneg
              APP
                VAR veciprod
                VAR dirvec
                VAR light
          APP
            VAR add_light
            VAR bright
            VAR hilight
            VAR hilight_scale
          UNIT
      LET Tu147 (UNIT)
        APP
          VAR setup_startp
          VAR intersection_point
      LET Tu146 (UNIT)
        APP
          VAR trace_reflections
          SUB
            GET
              VAR n_reflections
              INT 0
            INT 1
          VAR diffuse
          VAR hilight_scale
          VAR dirvec
      IF
        APP
          VAR fless
          FLOAT 0.1
          VAR energy
        LET Tu145 (UNIT)
          IF
            NOT
              LE
                INT 4
                VAR nref
            PUT
              VAR surface_ids
              ADD
                VAR nref
                INT 1
              NEG
                INT 1
            UNIT
        IF
          EQ
            VAR m_surface
            INT 2
          LET energy2 (VAR of )
            FMUL
              VAR energy
              FSUB
                FLOAT 1.
                APP
                  VAR o_diffuse
                  VAR obj
          APP
            VAR trace_ray
            ADD
              VAR nref
              INT 1
            VAR energy2
            VAR dirvec
            VAR pixel
            FADD
              VAR dist
              GET
                VAR tmin
                INT 0
          UNIT
        UNIT
      LET Tu158 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          NEG
            INT 1
      IF
        NOT
          EQ
            VAR nref
            INT 0
        LET hl (VAR of )
          APP
            VAR fneg
            APP
              VAR veciprod
              VAR dirvec
              VAR light
        IF
          APP
            VAR fispos
            VAR hl
          LET ihl (VAR of )
            FMUL
              FMUL
                FMUL
                  APP
                    VAR fsqr
                    VAR hl
                  VAR hl
                VAR energy
              GET
                VAR beam
                INT 0
          LET Tu157 (UNIT)
            PUT
              VAR rgb
              INT 0
              FADD
                GET
                  VAR rgb
                  INT 0
                VAR ihl
          LET Tu156 (UNIT)
            PUT
              VAR rgb
              INT 1
              FADD
                GET
                  VAR rgb
                  INT 1
                VAR ihl
          PUT
            VAR rgb
            INT 2
            FADD
              GET
                VAR rgb
                INT 2
              VAR ihl
          UNIT
        UNIT
    UNIT
LETREC trace_diffuse_ray (VAR of )
  (dirvec : VAR of ), (energy : VAR of )
  IF
    APP
      VAR judge_intersection_fast
      VAR dirvec
    LET obj (VAR of )
      GET
        VAR objects
        GET
          VAR intersected_object_id
          INT 0
    LET Tu160 (UNIT)
      APP
        VAR get_nvector
        VAR obj
        APP
          VAR d_vec
          VAR dirvec
    LET Tu159 (UNIT)
      APP
        VAR utexture
        VAR obj
        VAR intersection_point
    IF
      NOT
        APP
          VAR shadow_check_one_or_matrix
          INT 0
          GET
            VAR or_net
            INT 0
      LET br (VAR of )
        APP
          VAR fneg
          APP
            VAR veciprod
            VAR nvector
            VAR light
      LET bright (VAR of )
        IF
          APP
            VAR fispos
            VAR br
          VAR br
          FLOAT 0.
      APP
        VAR vecaccum
        VAR diffuse_ray
        FMUL
          FMUL
            VAR energy
            VAR bright
          APP
            VAR o_diffuse
            VAR obj
        VAR texture_color
      UNIT
    UNIT
LETREC iter_trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET p (VAR of )
      APP
        VAR veciprod
        APP
          VAR d_vec
          GET
            VAR dirvec_group
            VAR index
        VAR nvector
    LET Tu161 (UNIT)
      IF
        APP
          VAR fisneg
          VAR p
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            ADD
              VAR index
              INT 1
          FDIV
            VAR p
            FLOAT -150.
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            VAR index
          FDIV
            VAR p
            FLOAT 150.
    APP
      VAR iter_trace_diffuse_rays
      VAR dirvec_group
      VAR nvector
      VAR org
      SUB
        VAR index
        INT 2
    UNIT
LETREC trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu162 (UNIT)
    APP
      VAR setup_startp
      VAR org
  APP
    VAR iter_trace_diffuse_rays
    VAR dirvec_group
    VAR nvector
    VAR org
    INT 118
LETREC trace_diffuse_ray_80percent (VAR of )
  (group_id : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu166 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 0
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 0
        VAR nvector
        VAR org
      UNIT
  LET Tu165 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 1
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 1
        VAR nvector
        VAR org
      UNIT
  LET Tu164 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 2
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 2
        VAR nvector
        VAR org
      UNIT
  LET Tu163 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 3
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 3
        VAR nvector
        VAR org
      UNIT
  IF
    NOT
      EQ
        VAR group_id
        INT 4
    APP
      VAR trace_diffuse_rays
      GET
        VAR dirvecs
        INT 4
      VAR nvector
      VAR org
    UNIT
LETREC calc_diffuse_using_1point (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  LET ray20p (VAR of )
    APP
      VAR p_received_ray_20percent
      VAR pixel
  LET nvectors (VAR of )
    APP
      VAR p_nvectors
      VAR pixel
  LET intersection_points (VAR of )
    APP
      VAR p_intersection_points
      VAR pixel
  LET energya (VAR of )
    APP
      VAR p_energy
      VAR pixel
  LET Tu168 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR ray20p
        VAR nref
  LET Tu167 (UNIT)
    APP
      VAR trace_diffuse_ray_80percent
      APP
        VAR p_group_id
        VAR pixel
      GET
        VAR nvectors
        VAR nref
      GET
        VAR intersection_points
        VAR nref
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC calc_diffuse_using_5points (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET r_up (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR prev
        VAR x
  LET r_left (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        SUB
          VAR x
          INT 1
  LET r_center (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        VAR x
  LET r_right (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        ADD
          VAR x
          INT 1
  LET r_down (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR next
        VAR x
  LET Tu173 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR r_up
        VAR nref
  LET Tu172 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_left
        VAR nref
  LET Tu171 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_center
        VAR nref
  LET Tu170 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_right
        VAR nref
  LET Tu169 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_down
        VAR nref
  LET energya (VAR of )
    APP
      VAR p_energy
      GET
        VAR cur
        VAR x
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC do_without_neighbors (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      LE
        INT 0
        GET
          VAR surface_ids
          VAR nref
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu174 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          APP
            VAR calc_diffuse_using_1point
            VAR pixel
            VAR nref
          UNIT
      APP
        VAR do_without_neighbors
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC neighbors_exist (VAR of )
  (x : VAR of ), (y : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        ADD
          VAR y
          INT 1
    IF
      NOT
        LE
          VAR y
          INT 0
      IF
        NOT
          LE
            GET
              VAR image_size
              INT 0
            ADD
              VAR x
              INT 1
        IF
          NOT
            LE
              VAR x
              INT 0
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC get_surface_id (VAR of )
  (pixel : VAR of ), (index : VAR of )
  LET surface_ids (VAR of )
    APP
      VAR p_surface_ids
      VAR pixel
  GET
    VAR surface_ids
    VAR index
LETREC neighbors_are_available (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET sid_center (VAR of )
    APP
      VAR get_surface_id
      GET
        VAR cur
        VAR x
      VAR nref
  IF
    EQ
      APP
        VAR get_surface_id
        GET
          VAR prev
          VAR x
        VAR nref
      VAR sid_center
    IF
      EQ
        APP
          VAR get_surface_id
          GET
            VAR next
            VAR x
          VAR nref
        VAR sid_center
      IF
        EQ
          APP
            VAR get_surface_id
            GET
              VAR cur
              SUB
                VAR x
                INT 1
            VAR nref
          VAR sid_center
        IF
          EQ
            APP
              VAR get_surface_id
              GET
                VAR cur
                ADD
                  VAR x
                  INT 1
              VAR nref
            VAR sid_center
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC try_exploit_neighbors (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET pixel (VAR of )
    GET
      VAR cur
      VAR x
  IF
    LE
      VAR nref
      INT 4
    IF
      LE
        INT 0
        APP
          VAR get_surface_id
          VAR pixel
          VAR nref
      IF
        APP
          VAR neighbors_are_available
          VAR x
          VAR prev
          VAR cur
          VAR next
          VAR nref
        LET calc_diffuse (VAR of )
          APP
            VAR p_calc_diffuse
            VAR pixel
        LET Tu175 (UNIT)
          IF
            GET
              VAR calc_diffuse
              VAR nref
            APP
              VAR calc_diffuse_using_5points
              VAR x
              VAR prev
              VAR cur
              VAR next
              VAR nref
            UNIT
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          ADD
            VAR nref
            INT 1
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          VAR nref
      UNIT
    UNIT
LETREC write_ppm_header (VAR of )
  (Tu176 : VAR of )
  LET Tu184 (UNIT)
    APP
      VAR print_char
      INT 80
  LET Tu183 (UNIT)
    APP
      VAR print_char
      ADD
        INT 48
        INT 3
  LET Tu182 (UNIT)
    APP
      VAR print_char
      INT 10
  LET Tu181 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 0
  LET Tu180 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu179 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 1
  LET Tu178 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu177 (UNIT)
    APP
      VAR print_int
      INT 255
  APP
    VAR print_char
    INT 10
LETREC write_rgb_element (VAR of )
  (x : VAR of )
  LET ix (VAR of )
    float_to_int
      VAR x
  LET elem (VAR of )
    IF
      NOT
        LE
          VAR ix
          INT 255
      INT 255
      IF
        NOT
          LE
            INT 0
            VAR ix
        INT 0
        VAR ix
  APP
    VAR print_int
    VAR elem
LETREC write_rgb (VAR of )
  (Tu185 : VAR of )
  LET Tu190 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 0
  LET Tu189 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu188 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 1
  LET Tu187 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu186 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 2
  APP
    VAR print_char
    INT 10
LETREC pretrace_diffuse_rays (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET sid (VAR of )
      APP
        VAR get_surface_id
        VAR pixel
        VAR nref
    IF
      LE
        INT 0
        VAR sid
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu193 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          LET group_id (VAR of )
            APP
              VAR p_group_id
              VAR pixel
          LET Tu192 (UNIT)
            APP
              VAR vecbzero
              VAR diffuse_ray
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          LET intersection_points (VAR of )
            APP
              VAR p_intersection_points
              VAR pixel
          LET Tu191 (UNIT)
            APP
              VAR trace_diffuse_rays
              GET
                VAR dirvecs
                VAR group_id
              GET
                VAR nvectors
                VAR nref
              GET
                VAR intersection_points
                VAR nref
          LET ray20p (VAR of )
            APP
              VAR p_received_ray_20percent
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR ray20p
              VAR nref
            VAR diffuse_ray
          UNIT
      APP
        VAR pretrace_diffuse_rays
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC pretrace_pixels (VAR of )
  (line : VAR of ), (x : VAR of ), (group_id : VAR of ), (lc0 : VAR of ), (lc1 : VAR of ), (lc2 : VAR of )
  IF
    LE
      INT 0
      VAR x
    LET xdisp (VAR of )
      FMUL
        GET
          VAR scan_pitch
          INT 0
        int_to_float
          SUB
            VAR x
            GET
              VAR image_center
              INT 0
    LET Tu203 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 0
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 0
          VAR lc0
    LET Tu202 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 1
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 1
          VAR lc1
    LET Tu201 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 2
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 2
          VAR lc2
    LET Tu200 (UNIT)
      APP
        VAR vecunit_sgn
        VAR ptrace_dirvec
        BOOL false
    LET Tu199 (UNIT)
      APP
        VAR vecbzero
        VAR rgb
    LET Tu198 (UNIT)
      APP
        VAR veccpy
        VAR startp
        VAR viewpoint
    LET Tu197 (UNIT)
      APP
        VAR trace_ray
        INT 0
        FLOAT 1.
        VAR ptrace_dirvec
        GET
          VAR line
          VAR x
        FLOAT 0.
    LET Tu196 (UNIT)
      APP
        VAR veccpy
        APP
          VAR p_rgb
          GET
            VAR line
            VAR x
        VAR rgb
    LET Tu195 (UNIT)
      APP
        VAR p_set_group_id
        GET
          VAR line
          VAR x
        VAR group_id
    LET Tu194 (UNIT)
      APP
        VAR pretrace_diffuse_rays
        GET
          VAR line
          VAR x
        INT 0
    APP
      VAR pretrace_pixels
      VAR line
      SUB
        VAR x
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR lc0
      VAR lc1
      VAR lc2
    UNIT
LETREC pretrace_line (VAR of )
  (line : VAR of ), (y : VAR of ), (group_id : VAR of )
  LET ydisp (VAR of )
    FMUL
      GET
        VAR scan_pitch
        INT 0
      int_to_float
        SUB
          VAR y
          GET
            VAR image_center
            INT 1
  LET lc0 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 0
      GET
        VAR screenz_dir
        INT 0
  LET lc1 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 1
      GET
        VAR screenz_dir
        INT 1
  LET lc2 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 2
      GET
        VAR screenz_dir
        INT 2
  APP
    VAR pretrace_pixels
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 1
    VAR group_id
    VAR lc0
    VAR lc1
    VAR lc2
LETREC scan_pixel (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 0
        VAR x
    LET Tu206 (UNIT)
      APP
        VAR veccpy
        VAR rgb
        APP
          VAR p_rgb
          GET
            VAR cur
            VAR x
    LET Tu205 (UNIT)
      IF
        APP
          VAR neighbors_exist
          VAR x
          VAR y
          VAR next
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          INT 0
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          INT 0
    LET Tu204 (UNIT)
      APP
        VAR write_rgb
        UNIT
    APP
      VAR scan_pixel
      ADD
        VAR x
        INT 1
      VAR y
      VAR prev
      VAR cur
      VAR next
    UNIT
LETREC scan_line (VAR of )
  (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (group_id : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        VAR y
    LET Tu208 (UNIT)
      IF
        NOT
          LE
            SUB
              GET
                VAR image_size
                INT 1
              INT 1
            VAR y
        APP
          VAR pretrace_line
          VAR next
          ADD
            VAR y
            INT 1
          VAR group_id
        UNIT
    LET Tu207 (UNIT)
      APP
        VAR scan_pixel
        INT 0
        VAR y
        VAR prev
        VAR cur
        VAR next
    APP
      VAR scan_line
      ADD
        VAR y
        INT 1
      VAR cur
      VAR next
      VAR prev
      APP
        VAR add_mod5
        VAR group_id
        INT 2
    UNIT
LETREC create_float5x3array (VAR of )
  (Tu209 : VAR of )
  LET vec (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET array (VAR of )
    ARRAY
      INT 5
      VAR vec
  LET Tu213 (UNIT)
    PUT
      VAR array
      INT 1
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu212 (UNIT)
    PUT
      VAR array
      INT 2
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu211 (UNIT)
    PUT
      VAR array
      INT 3
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu210 (UNIT)
    PUT
      VAR array
      INT 4
      ARRAY
        INT 3
        FLOAT 0.
  VAR array
LETREC create_pixel (VAR of )
  (Tu214 : VAR of )
  LET m_rgb (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET m_isect_ps (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_sids (VAR of )
    ARRAY
      INT 5
      INT 0
  LET m_cdif (VAR of )
    ARRAY
      INT 5
      BOOL false
  LET m_engy (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_r20p (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_gid (VAR of )
    ARRAY
      INT 1
      INT 0
  LET m_nvectors (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  TUPLE
    VAR m_rgb
    VAR m_isect_ps
    VAR m_sids
    VAR m_cdif
    VAR m_engy
    VAR m_r20p
    VAR m_gid
    VAR m_nvectors
LETREC init_line_elements (VAR of )
  (line : VAR of ), (n : VAR of )
  IF
    LE
      INT 0
      VAR n
    LET Tu215 (UNIT)
      PUT
        VAR line
        VAR n
        APP
          VAR create_pixel
          UNIT
    APP
      VAR init_line_elements
      VAR line
      SUB
        VAR n
        INT 1
    VAR line
LETREC create_pixelline (VAR of )
  (Tu216 : VAR of )
  LET line (VAR of )
    ARRAY
      GET
        VAR image_size
        INT 0
      APP
        VAR create_pixel
        UNIT
  APP
    VAR init_line_elements
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 2
LETREC tan (VAR of )
  (x : VAR of )
  FDIV
    APP
      VAR sin
      VAR x
    APP
      VAR cos
      VAR x
LETREC adjust_position (VAR of )
  (h : VAR of ), (ratio : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FMUL
          VAR h
          VAR h
        FLOAT 0.1
  LET tan_h (VAR of )
    FDIV
      FLOAT 1.
      VAR l
  LET theta_h (VAR of )
    APP
      VAR atan
      VAR tan_h
  LET tan_m (VAR of )
    APP
      VAR tan
      FMUL
        VAR theta_h
        VAR ratio
  FMUL
    VAR tan_m
    VAR l
LETREC calc_dirvec (VAR of )
  (icount : VAR of ), (x : VAR of ), (y : VAR of ), (rx : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 5
      VAR icount
    LET l (VAR of )
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              VAR x
            APP
              VAR fsqr
              VAR y
          FLOAT 1.
    LET vx (VAR of )
      FDIV
        VAR x
        VAR l
    LET vy (VAR of )
      FDIV
        VAR y
        VAR l
    LET vz (VAR of )
      FDIV
        FLOAT 1.
        VAR l
    LET dgroup (VAR of )
      GET
        VAR dirvecs
        VAR group_id
    LET Tu221 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            VAR index
        VAR vx
        VAR vy
        VAR vz
    LET Tu220 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 40
        VAR vx
        VAR vz
        APP
          VAR fneg
          VAR vy
    LET Tu219 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 80
        VAR vz
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
    LET Tu218 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 1
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
        APP
          VAR fneg
          VAR vz
    LET Tu217 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 41
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vz
        VAR vy
    APP
      VAR vecset
      APP
        VAR d_vec
        GET
          VAR dgroup
          ADD
            VAR index
            INT 81
      APP
        VAR fneg
        VAR vz
      VAR vx
      VAR vy
    LET x2 (VAR of )
      APP
        VAR adjust_position
        VAR y
        VAR rx
    APP
      VAR calc_dirvec
      ADD
        VAR icount
        INT 1
      VAR x2
      APP
        VAR adjust_position
        VAR x2
        VAR ry
      VAR rx
      VAR ry
      VAR group_id
      VAR index
LETREC calc_dirvecs (VAR of )
  (col : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR col
    LET rx (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.9
    LET Tu223 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx
        VAR ry
        VAR group_id
        VAR index
    LET rx2 (VAR of )
      FADD
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.1
    LET Tu222 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx2
        VAR ry
        VAR group_id
        ADD
          VAR index
          INT 2
    APP
      VAR calc_dirvecs
      SUB
        VAR col
        INT 1
      VAR ry
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR index
    UNIT
LETREC calc_dirvec_rows (VAR of )
  (row : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR row
    LET ry (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR row
          FLOAT 0.2
        FLOAT 0.9
    LET Tu224 (UNIT)
      APP
        VAR calc_dirvecs
        INT 4
        VAR ry
        VAR group_id
        VAR index
    APP
      VAR calc_dirvec_rows
      SUB
        VAR row
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 2
      ADD
        VAR index
        INT 4
    UNIT
LETREC create_dirvec (VAR of )
  (Tu225 : VAR of )
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      GET
        VAR n_objects
        INT 0
      VAR v3
  TUPLE
    VAR v3
    VAR consts
LETREC create_dirvec_elements (VAR of )
  (d : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu226 (UNIT)
      PUT
        VAR d
        VAR index
        APP
          VAR create_dirvec
          UNIT
    APP
      VAR create_dirvec_elements
      VAR d
      SUB
        VAR index
        INT 1
    UNIT
LETREC create_dirvecs (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu228 (UNIT)
      PUT
        VAR dirvecs
        VAR index
        ARRAY
          INT 120
          APP
            VAR create_dirvec
            UNIT
    LET Tu227 (UNIT)
      APP
        VAR create_dirvec_elements
        GET
          VAR dirvecs
          VAR index
        INT 118
    APP
      VAR create_dirvecs
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvec_constants (VAR of )
  (vecset : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu229 (UNIT)
      APP
        VAR setup_dirvec_constants
        GET
          VAR vecset
          VAR index
    APP
      VAR init_dirvec_constants
      VAR vecset
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_vecset_constants (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu230 (UNIT)
      APP
        VAR init_dirvec_constants
        GET
          VAR dirvecs
          VAR index
        INT 119
    APP
      VAR init_vecset_constants
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvecs (VAR of )
  (Tu231 : VAR of )
  LET Tu233 (UNIT)
    APP
      VAR create_dirvecs
      INT 4
  LET Tu232 (UNIT)
    APP
      VAR calc_dirvec_rows
      INT 9
      INT 0
      INT 0
  APP
    VAR init_vecset_constants
    INT 4
LETREC add_reflection (VAR of )
  (index : VAR of ), (surface_id : VAR of ), (bright : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET dvec (VAR of )
    APP
      VAR create_dirvec
      UNIT
  LET Tu235 (UNIT)
    APP
      VAR vecset
      APP
        VAR d_vec
        VAR dvec
      VAR v0
      VAR v1
      VAR v2
  LET Tu234 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR dvec
  PUT
    VAR reflections
    VAR index
    TUPLE
      VAR surface_id
      VAR dvec
      VAR bright
LETREC setup_rect_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    MULTIPLE 4
      VAR obj_id
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET n0 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 0
  LET n1 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 1
  LET n2 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 2
  LET Tu238 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      ADD
        VAR sid
        INT 1
      VAR br
      GET
        VAR light
        INT 0
      VAR n1
      VAR n2
  LET Tu237 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 1
      ADD
        VAR sid
        INT 2
      VAR br
      VAR n0
      GET
        VAR light
        INT 1
      VAR n2
  LET Tu236 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 2
      ADD
        VAR sid
        INT 3
      VAR br
      VAR n0
      VAR n1
      GET
        VAR light
        INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 3
LETREC setup_surface_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    ADD
      MULTIPLE 4
        VAR obj_id
      INT 1
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET p (VAR of )
    APP
      VAR veciprod
      VAR light
      APP
        VAR o_param_abc
        VAR obj
  LET Tu239 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      VAR sid
      VAR br
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_a
              VAR obj
          VAR p
        GET
          VAR light
          INT 0
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_b
              VAR obj
          VAR p
        GET
          VAR light
          INT 1
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_c
              VAR obj
          VAR p
        GET
          VAR light
          INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 1
LETREC setup_reflections (VAR of )
  (obj_id : VAR of )
  IF
    LE
      INT 0
      VAR obj_id
    LET obj (VAR of )
      GET
        VAR objects
        VAR obj_id
    IF
      EQ
        APP
          VAR o_reflectiontype
          VAR obj
        INT 2
      IF
        APP
          VAR fless
          APP
            VAR o_diffuse
            VAR obj
          FLOAT 1.
        LET m_shape (VAR of )
          APP
            VAR o_form
            VAR obj
        IF
          EQ
            VAR m_shape
            INT 1
          APP
            VAR setup_rect_reflection
            VAR obj_id
            VAR obj
          IF
            EQ
              VAR m_shape
              INT 2
            APP
              VAR setup_surface_reflection
              VAR obj_id
              VAR obj
            UNIT
        UNIT
      UNIT
    UNIT
LETREC rt (VAR of )
  (size_x : VAR of ), (size_y : VAR of )
  LET Tu251 (UNIT)
    PUT
      VAR image_size
      INT 0
      VAR size_x
  LET Tu250 (UNIT)
    PUT
      VAR image_size
      INT 1
      VAR size_y
  LET Tu249 (UNIT)
    PUT
      VAR image_center
      INT 0
      DIVIDE BY 2
        VAR size_x
  LET Tu248 (UNIT)
    PUT
      VAR image_center
      INT 1
      DIVIDE BY 2
        VAR size_y
  LET Tu247 (UNIT)
    PUT
      VAR scan_pitch
      INT 0
      FDIV
        FLOAT 128.
        int_to_float
          VAR size_x
  LET prev (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET cur (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET next (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET Tu246 (UNIT)
    APP
      VAR read_parameter
      UNIT
  LET Tu245 (UNIT)
    APP
      VAR write_ppm_header
      UNIT
  LET Tu244 (UNIT)
    APP
      VAR init_dirvecs
      UNIT
  LET Tu243 (UNIT)
    APP
      VAR veccpy
      APP
        VAR d_vec
        VAR light_dirvec
      VAR light
  LET Tu242 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR light_dirvec
  LET Tu241 (UNIT)
    APP
      VAR setup_reflections
      SUB
        GET
          VAR n_objects
          INT 0
        INT 1
  LET Tu240 (UNIT)
    APP
      VAR pretrace_line
      VAR cur
      INT 0
      INT 0
  APP
    VAR scan_line
    INT 0
    VAR prev
    VAR cur
    VAR next
    INT 2
APP
  VAR rt
  INT 512
  INT 512

----- kNormal.print -----
letrec print_int : (INT -> UNIT) =
variables : (n : INT)
  let n : INT =
    let Ti2513 : INT =
      int 0
    in
    if Ti2513 <= n
      n
      let Tu1 : UNIT =
        let Ti2514 : INT =
          int 45
        in
        out Ti2514 0
      in
      neg n
  in
  let Ti2515 : INT =
    int 10
  in
  if Ti2515 <= n
    let m : INT =
      div n 10
    in
    let Tu2 : UNIT =
      app
        print_int
        m
    in
    let Ti2517 : INT =
      let Ti2516 : INT =
        mul m 10
      in
      sub n Ti2516
    in
    out Ti2517 48
    out n 48
in
letrec print_char : (INT -> UNIT) =
variables : (c : INT)
  out c 0
in
letrec print_newline : (INT -> UNIT) =
variables : (Tu3 : INT)
  let Ti2512 : INT =
    int 0
  in
  out Ti2512 10
in
letrec reduction_2pi_sub1 : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (a : FLOAT), (p : FLOAT)
  if a <. p
    p
    let Td2511 : FLOAT =
      fadd p p
    in
    app
      reduction_2pi_sub1
      a
      Td2511
in
letrec reduction_2pi_sub2 : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (a : FLOAT), (p : FLOAT)
  let Td2507 : FLOAT =
    float 6.28318530718
  in
  if Td2507 <. a
    let a : FLOAT =
      if p <. a
        fsub a p
        let Td2508 : FLOAT =
          float 0.
        in
        fadd a Td2508
    in
    let p : FLOAT =
      let Td2509 : FLOAT =
        float 2.
      in
      fdiv p Td2509
    in
    app
      reduction_2pi_sub2
      a
      p
    let Td2510 : FLOAT =
      float 0.
    in
    fadd a Td2510
in
letrec reduction_2pi : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let p : FLOAT =
    float 6.28318530718
  in
  let p : FLOAT =
    app
      reduction_2pi_sub1
      a
      p
  in
  app
    reduction_2pi_sub2
    a
    p
in
letrec kernel_sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a3 : FLOAT =
    fmul a2 a
  in
  let a5 : FLOAT =
    fmul a3 a2
  in
  let a7 : FLOAT =
    fmul a5 a2
  in
  let Td2506 : FLOAT =
    let Td2503 : FLOAT =
      let Td2500 : FLOAT =
        let Td2499 : FLOAT =
          let Td2498 : FLOAT =
            float 0.000198411698413
          in
          fmul Td2498 a7
        in
        fneg Td2499
      in
      let Td2502 : FLOAT =
        let Td2501 : FLOAT =
          float 0.0083333333333
        in
        fmul Td2501 a5
      in
      fadd Td2500 Td2502
    in
    let Td2505 : FLOAT =
      let Td2504 : FLOAT =
        float 0.166666666667
      in
      fmul Td2504 a3
    in
    fsub Td2503 Td2505
  in
  fadd Td2506 a
in
letrec kernel_cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a4 : FLOAT =
    fmul a2 a2
  in
  let a6 : FLOAT =
    fmul a4 a2
  in
  let Td2496 : FLOAT =
    let Td2493 : FLOAT =
      let Td2490 : FLOAT =
        let Td2489 : FLOAT =
          let Td2488 : FLOAT =
            float 0.00138888888889
          in
          fmul Td2488 a6
        in
        fneg Td2489
      in
      let Td2492 : FLOAT =
        let Td2491 : FLOAT =
          float 0.0416666666667
        in
        fmul Td2491 a4
      in
      fadd Td2490 Td2492
    in
    let Td2495 : FLOAT =
      let Td2494 : FLOAT =
        float 0.5
      in
      fmul Td2494 a2
    in
    fsub Td2493 Td2495
  in
  let Td2497 : FLOAT =
    float 1.
  in
  fadd Td2496 Td2497
in
letrec sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2469 : FLOAT =
      float 0.
    in
    if Td2469 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Td2470 : FLOAT =
      float 0.
    in
    if a <. Td2470
      fneg a
      let Td2471 : FLOAT =
        float 0.
      in
      fadd a Td2471
  in
  let a : FLOAT =
    app
      reduction_2pi
      a
  in
  let Tt2479 : (FLOAT * INT) =
    let Td2472 : FLOAT =
      float 3.14159265359
    in
    if Td2472 <. a
      let Td2474 : FLOAT =
        let Td2473 : FLOAT =
          float 3.14159265359
        in
        fsub a Td2473
      in
      let Ti2476 : INT =
        let Ti2475 : INT =
          int 0
        in
        if flag == Ti2475
          int 1
          int 0
      in
      Tuple
        Td2474
        Ti2476
      let Td2478 : FLOAT =
        let Td2477 : FLOAT =
          float 0.
        in
        fadd a Td2477
      in
      Tuple
        Td2478
        flag
  in
  let tuple (a : FLOAT), (flag : BOOL)
    Tt2479
  in
    let a : FLOAT =
      let Td2480 : FLOAT =
        float 1.57079632679
      in
      if Td2480 <. a
        let Td2481 : FLOAT =
          float 3.14159265359
        in
        fsub Td2481 a
        let Td2482 : FLOAT =
          float 0.
        in
        fadd a Td2482
    in
    let a : FLOAT =
      let Td2483 : FLOAT =
        float 0.785398163397
      in
      if a <. Td2483
        let Td2485 : FLOAT =
          let Td2484 : FLOAT =
            float 1.57079632679
          in
          fsub Td2484 a
        in
        app
          kernel_cos
          Td2485
        app
          kernel_sin
          a
    in
    let Ti2486 : INT =
      int 0
    in
    if flag == Ti2486
      fneg a
      let Td2487 : FLOAT =
        float 0.
      in
      fadd a Td2487
in
letrec cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a : FLOAT =
    let Td2448 : FLOAT =
      float 0.
    in
    if a <. Td2448
      fneg a
      let Td2449 : FLOAT =
        float 0.
      in
      fadd a Td2449
  in
  let a : FLOAT =
    app
      reduction_2pi
      a
  in
  let Tt2455 : (FLOAT * INT) =
    let Td2450 : FLOAT =
      float 3.14159265359
    in
    if Td2450 <. a
      let Td2452 : FLOAT =
        let Td2451 : FLOAT =
          float 3.14159265359
        in
        fsub a Td2451
      in
      let Ti2453 : INT =
        int 0
      in
      Tuple
        Td2452
        Ti2453
      let Ti2454 : INT =
        int 1
      in
      Tuple
        a
        Ti2454
  in
  let tuple (a : FLOAT), (flag : BOOL)
    Tt2455
  in
    let Tt2463 : (FLOAT * INT) =
      let Td2456 : FLOAT =
        float 1.57079632679
      in
      if Td2456 <. a
        let Td2458 : FLOAT =
          let Td2457 : FLOAT =
            float 3.14159265359
          in
          fsub Td2457 a
        in
        let Ti2460 : INT =
          let Ti2459 : INT =
            int 0
          in
          if flag == Ti2459
            int 1
            int 0
        in
        Tuple
          Td2458
          Ti2460
        let Td2462 : FLOAT =
          let Td2461 : FLOAT =
            float 0.
          in
          fadd a Td2461
        in
        Tuple
          Td2462
          flag
    in
    let tuple (a : FLOAT), (flag : BOOL)
      Tt2463
    in
      let a : FLOAT =
        let Td2464 : FLOAT =
          float 0.785398163397
        in
        if Td2464 <. a
          app
            kernel_cos
            a
          let Td2466 : FLOAT =
            let Td2465 : FLOAT =
              float 1.57079632679
            in
            fsub Td2465 a
          in
          app
            kernel_sin
            Td2466
      in
      let Ti2467 : INT =
        int 0
      in
      if flag == Ti2467
        fneg a
        let Td2468 : FLOAT =
          float 0.
        in
        fadd a Td2468
in
letrec sqrt : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  letrec inner : (FLOAT -> (INT -> FLOAT)) =
  variables : (t : FLOAT), (i : INT)
    let Ti2440 : INT =
      int 0
    in
    if i == Ti2440
      t
      let Td2445 : FLOAT =
        let Td2442 : FLOAT =
          let Td2441 : FLOAT =
            fmul t t
          in
          fadd Td2441 x
        in
        let Td2444 : FLOAT =
          let Td2443 : FLOAT =
            float 2.
          in
          fmul Td2443 t
        in
        fdiv Td2442 Td2444
      in
      let Ti2447 : INT =
        let Ti2446 : INT =
          int 1
        in
        sub i Ti2446
      in
      app
        inner
        Td2445
        Ti2447
  in
  let Td2438 : FLOAT =
    unknown sqrt_init x
  in
  let Ti2439 : INT =
    int 5
  in
  app
    inner
    Td2438
    Ti2439
in
letrec kernel_atan : (FLOAT -> FLOAT) =
variables : (a1 : FLOAT)
  let a2 : FLOAT =
    fmul a1 a1
  in
  let a3 : FLOAT =
    fmul a2 a1
  in
  let a5 : FLOAT =
    fmul a2 a3
  in
  let a7 : FLOAT =
    fmul a2 a5
  in
  let a9 : FLOAT =
    fmul a2 a7
  in
  let a11 : FLOAT =
    fmul a2 a9
  in
  let a13 : FLOAT =
    fmul a2 a11
  in
  let Td2435 : FLOAT =
    let Td2432 : FLOAT =
      let Td2429 : FLOAT =
        let Td2426 : FLOAT =
          let Td2423 : FLOAT =
            let Td2422 : FLOAT =
              let Td2421 : FLOAT =
                float 0.3333333
              in
              fmul Td2421 a3
            in
            fsub a1 Td2422
          in
          let Td2425 : FLOAT =
            let Td2424 : FLOAT =
              float 0.2
            in
            fmul Td2424 a5
          in
          fadd Td2423 Td2425
        in
        let Td2428 : FLOAT =
          let Td2427 : FLOAT =
            float 0.142857142
          in
          fmul Td2427 a7
        in
        fsub Td2426 Td2428
      in
      let Td2431 : FLOAT =
        let Td2430 : FLOAT =
          float 0.111111104
        in
        fmul Td2430 a9
      in
      fadd Td2429 Td2431
    in
    let Td2434 : FLOAT =
      let Td2433 : FLOAT =
        float 0.08976446
      in
      fmul Td2433 a11
    in
    fsub Td2432 Td2434
  in
  let Td2437 : FLOAT =
    let Td2436 : FLOAT =
      float 0.060035485
    in
    fmul Td2436 a13
  in
  fadd Td2435 Td2437
in
letrec atan : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2401 : FLOAT =
      float 0.
    in
    if Td2401 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Ti2402 : INT =
      int 0
    in
    if flag == Ti2402
      fneg a
      let Td2403 : FLOAT =
        float 0.
      in
      fadd a Td2403
  in
  let b : FLOAT =
    let Td2404 : FLOAT =
      float 0.4375
    in
    if a <. Td2404
      app
        kernel_atan
        a
      let Td2417 : FLOAT =
        let Td2405 : FLOAT =
          float 2.4375
        in
        if a <. Td2405
          let Td2406 : FLOAT =
            float 0.785398163397
          in
          let Td2412 : FLOAT =
            let Td2411 : FLOAT =
              let Td2408 : FLOAT =
                let Td2407 : FLOAT =
                  float 1.
                in
                fsub a Td2407
              in
              let Td2410 : FLOAT =
                let Td2409 : FLOAT =
                  float 1.
                in
                fadd a Td2409
              in
              fdiv Td2408 Td2410
            in
            app
              kernel_atan
              Td2411
          in
          fadd Td2406 Td2412
          let Td2413 : FLOAT =
            float 1.57079632679
          in
          let Td2416 : FLOAT =
            let Td2415 : FLOAT =
              let Td2414 : FLOAT =
                float 1.
              in
              fdiv Td2414 a
            in
            app
              kernel_atan
              Td2415
          in
          fsub Td2413 Td2416
      in
      let Td2418 : FLOAT =
        float 0.
      in
      fadd Td2417 Td2418
  in
  let Ti2419 : INT =
    int 0
  in
  if flag == Ti2419
    fneg b
    let Td2420 : FLOAT =
      float 0.
    in
    fadd Td2420 b
in
letrec floor : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let a : FLOAT =
    let Ti2399 : INT =
      ftoi x
    in
    itof Ti2399
  in
  if x <. a
    let Td2400 : FLOAT =
      float 1.
    in
    fsub a Td2400
    a
in
letrec fabs : (FLOAT -> FLOAT) =
variables : (f : FLOAT)
  let Td2398 : FLOAT =
    float 0.
  in
  if f <. Td2398
    fneg f
    f
in
letrec fhalf : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2397 : FLOAT =
    float 0.5
  in
  fmul x Td2397
in
letrec fsqr : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fmul x x
in
letrec fneg : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fneg x
in
letrec fless : (FLOAT -> (FLOAT -> BOOL)) =
variables : (a : FLOAT), (b : FLOAT)
  if a <. b
    int 1
    int 0
in
letrec abs_float : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  app
    fabs
    x
in
letrec fispos : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2396 : FLOAT =
    float 0.
  in
  if Td2396 <. x
    int 1
    int 0
in
letrec fisneg : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2395 : FLOAT =
    float 0.
  in
  if x <. Td2395
    int 1
    int 0
in
let n_objects : Array of INT =
  let Ti252 : INT =
    int 1
  in
  let Ti253 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti252
    Ti253
in
let objects : Array of (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
  let dummy : Array of FLOAT =
    let Ti254 : INT =
      int 0
    in
    let Td255 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti254
      Td255
  in
  let Ti256 : INT =
    int 60
  in
  let Tt262 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * INT * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    let Ti257 : INT =
      int 0
    in
    let Ti258 : INT =
      int 0
    in
    let Ti259 : INT =
      int 0
    in
    let Ti260 : INT =
      int 0
    in
    let Ti261 : INT =
      int 0
    in
    Tuple
      Ti257
      Ti258
      Ti259
      Ti260
      dummy
      dummy
      Ti261
      dummy
      dummy
      dummy
      dummy
  in
  extfunapp
    create_array
    Ti256
    Tt262
in
let screen : Array of FLOAT =
  let Ti263 : INT =
    int 3
  in
  let Td264 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti263
    Td264
in
let viewpoint : Array of FLOAT =
  let Ti265 : INT =
    int 3
  in
  let Td266 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti265
    Td266
in
let light : Array of FLOAT =
  let Ti267 : INT =
    int 3
  in
  let Td268 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti267
    Td268
in
let beam : Array of FLOAT =
  let Ti269 : INT =
    int 1
  in
  let Td270 : FLOAT =
    float 255.
  in
  extfunapp
    create_float_array
    Ti269
    Td270
in
let and_net : Array of Array of INT =
  let Ti271 : INT =
    int 50
  in
  let Ta275 : Array of INT =
    let Ti272 : INT =
      int 1
    in
    let Ti274 : INT =
      let Ti273 : INT =
        int 1
      in
      neg Ti273
    in
    extfunapp
      create_array
      Ti272
      Ti274
  in
  extfunapp
    create_array
    Ti271
    Ta275
in
let or_net : Array of Array of Array of INT =
  let Ti276 : INT =
    int 1
  in
  let Ta280 : Array of Array of INT =
    let Ti277 : INT =
      int 1
    in
    let Ta279 : Array of INT =
      let Ti278 : INT =
        int 0
      in
      and_net.(Ti278)
    in
    extfunapp
      create_array
      Ti277
      Ta279
  in
  extfunapp
    create_array
    Ti276
    Ta280
in
let solver_dist : Array of FLOAT =
  let Ti281 : INT =
    int 1
  in
  let Td282 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti281
    Td282
in
let intsec_rectside : Array of INT =
  let Ti283 : INT =
    int 1
  in
  let Ti284 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti283
    Ti284
in
let tmin : Array of FLOAT =
  let Ti285 : INT =
    int 1
  in
  let Td286 : FLOAT =
    float 1000000000.
  in
  extfunapp
    create_float_array
    Ti285
    Td286
in
let intersection_point : Array of FLOAT =
  let Ti287 : INT =
    int 3
  in
  let Td288 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti287
    Td288
in
let intersected_object_id : Array of INT =
  let Ti289 : INT =
    int 1
  in
  let Ti290 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti289
    Ti290
in
let nvector : Array of FLOAT =
  let Ti291 : INT =
    int 3
  in
  let Td292 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti291
    Td292
in
let texture_color : Array of FLOAT =
  let Ti293 : INT =
    int 3
  in
  let Td294 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti293
    Td294
in
let diffuse_ray : Array of FLOAT =
  let Ti295 : INT =
    int 3
  in
  let Td296 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti295
    Td296
in
let rgb : Array of FLOAT =
  let Ti297 : INT =
    int 3
  in
  let Td298 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti297
    Td298
in
let image_size : Array of INT =
  let Ti299 : INT =
    int 2
  in
  let Ti300 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti299
    Ti300
in
let image_center : Array of INT =
  let Ti301 : INT =
    int 2
  in
  let Ti302 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti301
    Ti302
in
let scan_pitch : Array of FLOAT =
  let Ti303 : INT =
    int 1
  in
  let Td304 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti303
    Td304
in
let startp : Array of FLOAT =
  let Ti305 : INT =
    int 3
  in
  let Td306 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti305
    Td306
in
let startp_fast : Array of FLOAT =
  let Ti307 : INT =
    int 3
  in
  let Td308 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti307
    Td308
in
let screenx_dir : Array of FLOAT =
  let Ti309 : INT =
    int 3
  in
  let Td310 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti309
    Td310
in
let screeny_dir : Array of FLOAT =
  let Ti311 : INT =
    int 3
  in
  let Td312 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti311
    Td312
in
let screenz_dir : Array of FLOAT =
  let Ti313 : INT =
    int 3
  in
  let Td314 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti313
    Td314
in
let ptrace_dirvec : Array of FLOAT =
  let Ti315 : INT =
    int 3
  in
  let Td316 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti315
    Td316
in
let dirvecs : Array of Array of (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf : Array of FLOAT =
    let Ti317 : INT =
      int 0
    in
    let Td318 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti317
      Td318
  in
  let dummyff : Array of Array of FLOAT =
    let Ti319 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti319
      dummyf
  in
  let dummy_vs : Array of (Array of FLOAT * Array of Array of FLOAT) =
    let Ti320 : INT =
      int 0
    in
    let Tt321 : (Array of FLOAT * Array of Array of FLOAT) =
      Tuple
        dummyf
        dummyff
    in
    extfunapp
      create_array
      Ti320
      Tt321
  in
  let Ti322 : INT =
    int 5
  in
  extfunapp
    create_array
    Ti322
    dummy_vs
in
let light_dirvec : (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf2 : Array of FLOAT =
    let Ti323 : INT =
      int 0
    in
    let Td324 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti323
      Td324
  in
  let v3 : Array of FLOAT =
    let Ti325 : INT =
      int 3
    in
    let Td326 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti325
      Td326
  in
  let consts : Array of Array of FLOAT =
    let Ti327 : INT =
      int 60
    in
    extfunapp
      create_array
      Ti327
      dummyf2
  in
  Tuple
    v3
    consts
in
let reflections : Array of (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
  let dummyf3 : Array of FLOAT =
    let Ti328 : INT =
      int 0
    in
    let Td329 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti328
      Td329
  in
  let dummyff3 : Array of Array of FLOAT =
    let Ti330 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti330
      dummyf3
  in
  let dummydv : (Array of FLOAT * Array of Array of FLOAT) =
    Tuple
      dummyf3
      dummyff3
  in
  let Ti331 : INT =
    int 180
  in
  let Tt334 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    let Ti332 : INT =
      int 0
    in
    let Td333 : FLOAT =
      float 0.
    in
    Tuple
      Ti332
      dummydv
      Td333
  in
  extfunapp
    create_array
    Ti331
    Tt334
in
let n_reflections : Array of INT =
  let Ti335 : INT =
    int 1
  in
  let Ti336 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti335
    Ti336
in
letrec xor : (BOOL -> (BOOL -> BOOL)) =
variables : (x : BOOL), (y : BOOL)
  let Ti2393 : INT =
    int 0
  in
  if x == Ti2393
    y
    let Ti2394 : INT =
      int 0
    in
    if y == Ti2394
      int 1
      int 0
in
letrec sgn : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  if x == 0.0 
    float 0.
    let Tb2391 : BOOL =
      app
        fispos
        x
    in
    let Ti2392 : INT =
      int 0
    in
    if Tb2391 == Ti2392
      float -1.
      float 1.
in
letrec fneg_cond : (BOOL -> (FLOAT -> FLOAT)) =
variables : (cond : BOOL), (x : FLOAT)
  let Ti2390 : INT =
    int 0
  in
  if cond == Ti2390
    app
      fneg
      x
    x
in
letrec add_mod5 : (INT -> (INT -> INT)) =
variables : (x : INT), (y : INT)
  let sum : INT =
    add x y
  in
  let Ti2388 : INT =
    int 5
  in
  if Ti2388 <= sum
    let Ti2389 : INT =
      int 5
    in
    sub sum Ti2389
    sum
in
letrec vecset : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))) =
variables : (v : Array of FLOAT), (x : FLOAT), (y : FLOAT), (z : FLOAT)
  let Tu5 : UNIT =
    let Ti2385 : INT =
      int 0
    in
    v.(Ti2385) <- x
  in
  let Tu4 : UNIT =
    let Ti2386 : INT =
      int 1
    in
    v.(Ti2386) <- y
  in
  let Ti2387 : INT =
    int 2
  in
  v.(Ti2387) <- z
in
letrec vecfill : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (v : Array of FLOAT), (elem : FLOAT)
  let Tu7 : UNIT =
    let Ti2382 : INT =
      int 0
    in
    v.(Ti2382) <- elem
  in
  let Tu6 : UNIT =
    let Ti2383 : INT =
      int 1
    in
    v.(Ti2383) <- elem
  in
  let Ti2384 : INT =
    int 2
  in
  v.(Ti2384) <- elem
in
letrec vecbzero : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2381 : FLOAT =
    float 0.
  in
  app
    vecfill
    v
    Td2381
in
letrec veccpy : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (src : Array of FLOAT)
  let Tu9 : UNIT =
    let Ti2372 : INT =
      int 0
    in
    let Td2374 : FLOAT =
      let Ti2373 : INT =
        int 0
      in
      src.(Ti2373)
    in
    dest.(Ti2372) <- Td2374
  in
  let Tu8 : UNIT =
    let Ti2375 : INT =
      int 1
    in
    let Td2377 : FLOAT =
      let Ti2376 : INT =
        int 1
      in
      src.(Ti2376)
    in
    dest.(Ti2375) <- Td2377
  in
  let Ti2378 : INT =
    int 2
  in
  let Td2380 : FLOAT =
    let Ti2379 : INT =
      int 2
    in
    src.(Ti2379)
  in
  dest.(Ti2378) <- Td2380
in
letrec vecdist2 : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (p : Array of FLOAT), (q : Array of FLOAT)
  let Td2365 : FLOAT =
    let Td2358 : FLOAT =
      let Td2357 : FLOAT =
        let Td2354 : FLOAT =
          let Ti2353 : INT =
            int 0
          in
          p.(Ti2353)
        in
        let Td2356 : FLOAT =
          let Ti2355 : INT =
            int 0
          in
          q.(Ti2355)
        in
        fsub Td2354 Td2356
      in
      app
        fsqr
        Td2357
    in
    let Td2364 : FLOAT =
      let Td2363 : FLOAT =
        let Td2360 : FLOAT =
          let Ti2359 : INT =
            int 1
          in
          p.(Ti2359)
        in
        let Td2362 : FLOAT =
          let Ti2361 : INT =
            int 1
          in
          q.(Ti2361)
        in
        fsub Td2360 Td2362
      in
      app
        fsqr
        Td2363
    in
    fadd Td2358 Td2364
  in
  let Td2371 : FLOAT =
    let Td2370 : FLOAT =
      let Td2367 : FLOAT =
        let Ti2366 : INT =
          int 2
        in
        p.(Ti2366)
      in
      let Td2369 : FLOAT =
        let Ti2368 : INT =
          int 2
        in
        q.(Ti2368)
      in
      fsub Td2367 Td2369
    in
    app
      fsqr
      Td2370
  in
  fadd Td2365 Td2371
in
letrec vecunit : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let il : FLOAT =
    let Td2328 : FLOAT =
      float 1.
    in
    let Td2340 : FLOAT =
      let Td2339 : FLOAT =
        let Td2335 : FLOAT =
          let Td2331 : FLOAT =
            let Td2330 : FLOAT =
              let Ti2329 : INT =
                int 0
              in
              v.(Ti2329)
            in
            app
              fsqr
              Td2330
          in
          let Td2334 : FLOAT =
            let Td2333 : FLOAT =
              let Ti2332 : INT =
                int 1
              in
              v.(Ti2332)
            in
            app
              fsqr
              Td2333
          in
          fadd Td2331 Td2334
        in
        let Td2338 : FLOAT =
          let Td2337 : FLOAT =
            let Ti2336 : INT =
              int 2
            in
            v.(Ti2336)
          in
          app
            fsqr
            Td2337
        in
        fadd Td2335 Td2338
      in
      app
        sqrt
        Td2339
    in
    fdiv Td2328 Td2340
  in
  let Tu11 : UNIT =
    let Ti2341 : INT =
      int 0
    in
    let Td2344 : FLOAT =
      let Td2343 : FLOAT =
        let Ti2342 : INT =
          int 0
        in
        v.(Ti2342)
      in
      fmul Td2343 il
    in
    v.(Ti2341) <- Td2344
  in
  let Tu10 : UNIT =
    let Ti2345 : INT =
      int 1
    in
    let Td2348 : FLOAT =
      let Td2347 : FLOAT =
        let Ti2346 : INT =
          int 1
        in
        v.(Ti2346)
      in
      fmul Td2347 il
    in
    v.(Ti2345) <- Td2348
  in
  let Ti2349 : INT =
    int 2
  in
  let Td2352 : FLOAT =
    let Td2351 : FLOAT =
      let Ti2350 : INT =
        int 2
      in
      v.(Ti2350)
    in
    fmul Td2351 il
  in
  v.(Ti2349) <- Td2352
in
letrec vecunit_sgn : (Array of FLOAT -> (BOOL -> UNIT)) =
variables : (v : Array of FLOAT), (inv : BOOL)
  let l : FLOAT =
    let Td2312 : FLOAT =
      let Td2308 : FLOAT =
        let Td2304 : FLOAT =
          let Td2303 : FLOAT =
            let Ti2302 : INT =
              int 0
            in
            v.(Ti2302)
          in
          app
            fsqr
            Td2303
        in
        let Td2307 : FLOAT =
          let Td2306 : FLOAT =
            let Ti2305 : INT =
              int 1
            in
            v.(Ti2305)
          in
          app
            fsqr
            Td2306
        in
        fadd Td2304 Td2307
      in
      let Td2311 : FLOAT =
        let Td2310 : FLOAT =
          let Ti2309 : INT =
            int 2
          in
          v.(Ti2309)
        in
        app
          fsqr
          Td2310
      in
      fadd Td2308 Td2311
    in
    app
      sqrt
      Td2312
  in
  let il : FLOAT =
    if l == 0.0 
      float 1.
      let Ti2313 : INT =
        int 0
      in
      if inv == Ti2313
        let Td2314 : FLOAT =
          float 1.
        in
        fdiv Td2314 l
        let Td2315 : FLOAT =
          float -1.
        in
        fdiv Td2315 l
  in
  let Tu13 : UNIT =
    let Ti2316 : INT =
      int 0
    in
    let Td2319 : FLOAT =
      let Td2318 : FLOAT =
        let Ti2317 : INT =
          int 0
        in
        v.(Ti2317)
      in
      fmul Td2318 il
    in
    v.(Ti2316) <- Td2319
  in
  let Tu12 : UNIT =
    let Ti2320 : INT =
      int 1
    in
    let Td2323 : FLOAT =
      let Td2322 : FLOAT =
        let Ti2321 : INT =
          int 1
        in
        v.(Ti2321)
      in
      fmul Td2322 il
    in
    v.(Ti2320) <- Td2323
  in
  let Ti2324 : INT =
    int 2
  in
  let Td2327 : FLOAT =
    let Td2326 : FLOAT =
      let Ti2325 : INT =
        int 2
      in
      v.(Ti2325)
    in
    fmul Td2326 il
  in
  v.(Ti2324) <- Td2327
in
letrec veciprod : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (v : Array of FLOAT), (w : Array of FLOAT)
  let Td2296 : FLOAT =
    let Td2290 : FLOAT =
      let Td2287 : FLOAT =
        let Ti2286 : INT =
          int 0
        in
        v.(Ti2286)
      in
      let Td2289 : FLOAT =
        let Ti2288 : INT =
          int 0
        in
        w.(Ti2288)
      in
      fmul Td2287 Td2289
    in
    let Td2295 : FLOAT =
      let Td2292 : FLOAT =
        let Ti2291 : INT =
          int 1
        in
        v.(Ti2291)
      in
      let Td2294 : FLOAT =
        let Ti2293 : INT =
          int 1
        in
        w.(Ti2293)
      in
      fmul Td2292 Td2294
    in
    fadd Td2290 Td2295
  in
  let Td2301 : FLOAT =
    let Td2298 : FLOAT =
      let Ti2297 : INT =
        int 2
      in
      v.(Ti2297)
    in
    let Td2300 : FLOAT =
      let Ti2299 : INT =
        int 2
      in
      w.(Ti2299)
    in
    fmul Td2298 Td2300
  in
  fadd Td2296 Td2301
in
letrec veciprod2 : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (v : Array of FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let Td2282 : FLOAT =
    let Td2278 : FLOAT =
      let Td2277 : FLOAT =
        let Ti2276 : INT =
          int 0
        in
        v.(Ti2276)
      in
      fmul Td2277 w0
    in
    let Td2281 : FLOAT =
      let Td2280 : FLOAT =
        let Ti2279 : INT =
          int 1
        in
        v.(Ti2279)
      in
      fmul Td2280 w1
    in
    fadd Td2278 Td2281
  in
  let Td2285 : FLOAT =
    let Td2284 : FLOAT =
      let Ti2283 : INT =
        int 2
      in
      v.(Ti2283)
    in
    fmul Td2284 w2
  in
  fadd Td2282 Td2285
in
letrec vecaccum : (Array of FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (scale : FLOAT), (v : Array of FLOAT)
  let Tu15 : UNIT =
    let Ti2255 : INT =
      int 0
    in
    let Td2261 : FLOAT =
      let Td2257 : FLOAT =
        let Ti2256 : INT =
          int 0
        in
        dest.(Ti2256)
      in
      let Td2260 : FLOAT =
        let Td2259 : FLOAT =
          let Ti2258 : INT =
            int 0
          in
          v.(Ti2258)
        in
        fmul scale Td2259
      in
      fadd Td2257 Td2260
    in
    dest.(Ti2255) <- Td2261
  in
  let Tu14 : UNIT =
    let Ti2262 : INT =
      int 1
    in
    let Td2268 : FLOAT =
      let Td2264 : FLOAT =
        let Ti2263 : INT =
          int 1
        in
        dest.(Ti2263)
      in
      let Td2267 : FLOAT =
        let Td2266 : FLOAT =
          let Ti2265 : INT =
            int 1
          in
          v.(Ti2265)
        in
        fmul scale Td2266
      in
      fadd Td2264 Td2267
    in
    dest.(Ti2262) <- Td2268
  in
  let Ti2269 : INT =
    int 2
  in
  let Td2275 : FLOAT =
    let Td2271 : FLOAT =
      let Ti2270 : INT =
        int 2
      in
      dest.(Ti2270)
    in
    let Td2274 : FLOAT =
      let Td2273 : FLOAT =
        let Ti2272 : INT =
          int 2
        in
        v.(Ti2272)
      in
      fmul scale Td2273
    in
    fadd Td2271 Td2274
  in
  dest.(Ti2269) <- Td2275
in
letrec vecadd : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu17 : UNIT =
    let Ti2237 : INT =
      int 0
    in
    let Td2242 : FLOAT =
      let Td2239 : FLOAT =
        let Ti2238 : INT =
          int 0
        in
        dest.(Ti2238)
      in
      let Td2241 : FLOAT =
        let Ti2240 : INT =
          int 0
        in
        v.(Ti2240)
      in
      fadd Td2239 Td2241
    in
    dest.(Ti2237) <- Td2242
  in
  let Tu16 : UNIT =
    let Ti2243 : INT =
      int 1
    in
    let Td2248 : FLOAT =
      let Td2245 : FLOAT =
        let Ti2244 : INT =
          int 1
        in
        dest.(Ti2244)
      in
      let Td2247 : FLOAT =
        let Ti2246 : INT =
          int 1
        in
        v.(Ti2246)
      in
      fadd Td2245 Td2247
    in
    dest.(Ti2243) <- Td2248
  in
  let Ti2249 : INT =
    int 2
  in
  let Td2254 : FLOAT =
    let Td2251 : FLOAT =
      let Ti2250 : INT =
        int 2
      in
      dest.(Ti2250)
    in
    let Td2253 : FLOAT =
      let Ti2252 : INT =
        int 2
      in
      v.(Ti2252)
    in
    fadd Td2251 Td2253
  in
  dest.(Ti2249) <- Td2254
in
letrec vecmul : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu19 : UNIT =
    let Ti2219 : INT =
      int 0
    in
    let Td2224 : FLOAT =
      let Td2221 : FLOAT =
        let Ti2220 : INT =
          int 0
        in
        dest.(Ti2220)
      in
      let Td2223 : FLOAT =
        let Ti2222 : INT =
          int 0
        in
        v.(Ti2222)
      in
      fmul Td2221 Td2223
    in
    dest.(Ti2219) <- Td2224
  in
  let Tu18 : UNIT =
    let Ti2225 : INT =
      int 1
    in
    let Td2230 : FLOAT =
      let Td2227 : FLOAT =
        let Ti2226 : INT =
          int 1
        in
        dest.(Ti2226)
      in
      let Td2229 : FLOAT =
        let Ti2228 : INT =
          int 1
        in
        v.(Ti2228)
      in
      fmul Td2227 Td2229
    in
    dest.(Ti2225) <- Td2230
  in
  let Ti2231 : INT =
    int 2
  in
  let Td2236 : FLOAT =
    let Td2233 : FLOAT =
      let Ti2232 : INT =
        int 2
      in
      dest.(Ti2232)
    in
    let Td2235 : FLOAT =
      let Ti2234 : INT =
        int 2
      in
      v.(Ti2234)
    in
    fmul Td2233 Td2235
  in
  dest.(Ti2231) <- Td2236
in
letrec vecscale : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (scale : FLOAT)
  let Tu21 : UNIT =
    let Ti2207 : INT =
      int 0
    in
    let Td2210 : FLOAT =
      let Td2209 : FLOAT =
        let Ti2208 : INT =
          int 0
        in
        dest.(Ti2208)
      in
      fmul Td2209 scale
    in
    dest.(Ti2207) <- Td2210
  in
  let Tu20 : UNIT =
    let Ti2211 : INT =
      int 1
    in
    let Td2214 : FLOAT =
      let Td2213 : FLOAT =
        let Ti2212 : INT =
          int 1
        in
        dest.(Ti2212)
      in
      fmul Td2213 scale
    in
    dest.(Ti2211) <- Td2214
  in
  let Ti2215 : INT =
    int 2
  in
  let Td2218 : FLOAT =
    let Td2217 : FLOAT =
      let Ti2216 : INT =
        int 2
      in
      dest.(Ti2216)
    in
    fmul Td2217 scale
  in
  dest.(Ti2215) <- Td2218
in
letrec vecaccumv : (Array of FLOAT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT), (w : Array of FLOAT)
  let Tu23 : UNIT =
    let Ti2180 : INT =
      int 0
    in
    let Td2188 : FLOAT =
      let Td2182 : FLOAT =
        let Ti2181 : INT =
          int 0
        in
        dest.(Ti2181)
      in
      let Td2187 : FLOAT =
        let Td2184 : FLOAT =
          let Ti2183 : INT =
            int 0
          in
          v.(Ti2183)
        in
        let Td2186 : FLOAT =
          let Ti2185 : INT =
            int 0
          in
          w.(Ti2185)
        in
        fmul Td2184 Td2186
      in
      fadd Td2182 Td2187
    in
    dest.(Ti2180) <- Td2188
  in
  let Tu22 : UNIT =
    let Ti2189 : INT =
      int 1
    in
    let Td2197 : FLOAT =
      let Td2191 : FLOAT =
        let Ti2190 : INT =
          int 1
        in
        dest.(Ti2190)
      in
      let Td2196 : FLOAT =
        let Td2193 : FLOAT =
          let Ti2192 : INT =
            int 1
          in
          v.(Ti2192)
        in
        let Td2195 : FLOAT =
          let Ti2194 : INT =
            int 1
          in
          w.(Ti2194)
        in
        fmul Td2193 Td2195
      in
      fadd Td2191 Td2196
    in
    dest.(Ti2189) <- Td2197
  in
  let Ti2198 : INT =
    int 2
  in
  let Td2206 : FLOAT =
    let Td2200 : FLOAT =
      let Ti2199 : INT =
        int 2
      in
      dest.(Ti2199)
    in
    let Td2205 : FLOAT =
      let Td2202 : FLOAT =
        let Ti2201 : INT =
          int 2
        in
        v.(Ti2201)
      in
      let Td2204 : FLOAT =
        let Ti2203 : INT =
          int 2
        in
        w.(Ti2203)
      in
      fmul Td2202 Td2204
    in
    fadd Td2200 Td2205
  in
  dest.(Ti2198) <- Td2206
in
letrec o_texturetype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (m_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_tex
in
letrec o_form : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (m_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_shape
in
letrec o_reflectiontype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_surface
in
letrec o_isinvert : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> BOOL) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (m_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_invert
in
letrec o_isrot : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (m_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_isrot
in
letrec o_param_a : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2179 : INT =
      int 0
    in
    m_abc.(Ti2179)
in
letrec o_param_b : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2178 : INT =
      int 1
    in
    m_abc.(Ti2178)
in
letrec o_param_c : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2177 : INT =
      int 2
    in
    m_abc.(Ti2177)
in
letrec o_param_abc : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_abc
in
letrec o_param_x : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2176 : INT =
      int 0
    in
    m_xyz.(Ti2176)
in
letrec o_param_y : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2175 : INT =
      int 1
    in
    m_xyz.(Ti2175)
in
letrec o_param_z : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2174 : INT =
      int 2
    in
    m_xyz.(Ti2174)
in
letrec o_diffuse : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2173 : INT =
      int 0
    in
    m_surfparams.(Ti2173)
in
letrec o_hilight : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2172 : INT =
      int 1
    in
    m_surfparams.(Ti2172)
in
letrec o_color_red : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2171 : INT =
      int 0
    in
    m_color.(Ti2171)
in
letrec o_color_green : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2170 : INT =
      int 1
    in
    m_color.(Ti2170)
in
letrec o_color_blue : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2169 : INT =
      int 2
    in
    m_color.(Ti2169)
in
letrec o_param_r1 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2168 : INT =
      int 0
    in
    m_rot123.(Ti2168)
in
letrec o_param_r2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2167 : INT =
      int 1
    in
    m_rot123.(Ti2167)
in
letrec o_param_r3 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2166 : INT =
      int 2
    in
    m_rot123.(Ti2166)
in
letrec o_param_ctbl : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (m_ctbl : Array of FLOAT)
    m
  in
    m_ctbl
in
letrec p_rgb : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (m_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_rgb
in
letrec p_intersection_points : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (m_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_isect_ps
in
letrec p_surface_ids : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (m_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_sids
in
letrec p_calc_diffuse : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of BOOL) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (m_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_cdif
in
letrec p_energy : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (m_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_engy
in
letrec p_received_ray_20percent : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (m_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_r20p
in
letrec p_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2165 : INT =
      int 0
    in
    m_gid.(Ti2165)
in
letrec p_set_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (id : INT)
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2164 : INT =
      int 0
    in
    m_gid.(Ti2164) <- id
in
letrec p_nvectors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (m_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_nvectors
in
letrec d_vec : ((Array of FLOAT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (m_vec : Array of FLOAT), (xm_const : Array of Array of FLOAT)
    d
  in
    m_vec
in
letrec d_const : ((Array of FLOAT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (dm_vec : Array of FLOAT), (m_const : Array of Array of FLOAT)
    d
  in
    m_const
in
letrec r_surface_id : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> INT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (m_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_sid
in
letrec r_dvec : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (m_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_dvec
in
letrec r_bright : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> FLOAT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (m_br : FLOAT)
    r
  in
    m_br
in
letrec rad : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2163 : FLOAT =
    float 0.017453293
  in
  fmul x Td2163
in
letrec read_screen_settings : (UNIT -> UNIT) =
variables : (Tu24 : UNIT)
  let Tu38 : UNIT =
    let Ti2108 : INT =
      int 0
    in
    let Td2110 : FLOAT =
      let Tu2109 : UNIT =
        unit ()
      in
      unknown inflt Tu2109
    in
    screen.(Ti2108) <- Td2110
  in
  let Tu37 : UNIT =
    let Ti2111 : INT =
      int 1
    in
    let Td2113 : FLOAT =
      let Tu2112 : UNIT =
        unit ()
      in
      unknown inflt Tu2112
    in
    screen.(Ti2111) <- Td2113
  in
  let Tu36 : UNIT =
    let Ti2114 : INT =
      int 2
    in
    let Td2116 : FLOAT =
      let Tu2115 : UNIT =
        unit ()
      in
      unknown inflt Tu2115
    in
    screen.(Ti2114) <- Td2116
  in
  let v1 : FLOAT =
    let Td2118 : FLOAT =
      let Tu2117 : UNIT =
        unit ()
      in
      unknown inflt Tu2117
    in
    app
      rad
      Td2118
  in
  let cos_v1 : FLOAT =
    app
      cos
      v1
  in
  let sin_v1 : FLOAT =
    app
      sin
      v1
  in
  let v2 : FLOAT =
    let Td2120 : FLOAT =
      let Tu2119 : UNIT =
        unit ()
      in
      unknown inflt Tu2119
    in
    app
      rad
      Td2120
  in
  let cos_v2 : FLOAT =
    app
      cos
      v2
  in
  let sin_v2 : FLOAT =
    app
      sin
      v2
  in
  let Tu35 : UNIT =
    let Ti2121 : INT =
      int 0
    in
    let Td2124 : FLOAT =
      let Td2122 : FLOAT =
        fmul cos_v1 sin_v2
      in
      let Td2123 : FLOAT =
        float 200.
      in
      fmul Td2122 Td2123
    in
    screenz_dir.(Ti2121) <- Td2124
  in
  let Tu34 : UNIT =
    let Ti2125 : INT =
      int 1
    in
    let Td2127 : FLOAT =
      let Td2126 : FLOAT =
        float -200.
      in
      fmul sin_v1 Td2126
    in
    screenz_dir.(Ti2125) <- Td2127
  in
  let Tu33 : UNIT =
    let Ti2128 : INT =
      int 2
    in
    let Td2131 : FLOAT =
      let Td2129 : FLOAT =
        fmul cos_v1 cos_v2
      in
      let Td2130 : FLOAT =
        float 200.
      in
      fmul Td2129 Td2130
    in
    screenz_dir.(Ti2128) <- Td2131
  in
  let Tu32 : UNIT =
    let Ti2132 : INT =
      int 0
    in
    screenx_dir.(Ti2132) <- cos_v2
  in
  let Tu31 : UNIT =
    let Ti2133 : INT =
      int 1
    in
    let Td2134 : FLOAT =
      float 0.
    in
    screenx_dir.(Ti2133) <- Td2134
  in
  let Tu30 : UNIT =
    let Ti2135 : INT =
      int 2
    in
    let Td2136 : FLOAT =
      app
        fneg
        sin_v2
    in
    screenx_dir.(Ti2135) <- Td2136
  in
  let Tu29 : UNIT =
    let Ti2137 : INT =
      int 0
    in
    let Td2139 : FLOAT =
      let Td2138 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2138 sin_v2
    in
    screeny_dir.(Ti2137) <- Td2139
  in
  let Tu28 : UNIT =
    let Ti2140 : INT =
      int 1
    in
    let Td2141 : FLOAT =
      app
        fneg
        cos_v1
    in
    screeny_dir.(Ti2140) <- Td2141
  in
  let Tu27 : UNIT =
    let Ti2142 : INT =
      int 2
    in
    let Td2144 : FLOAT =
      let Td2143 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2143 cos_v2
    in
    screeny_dir.(Ti2142) <- Td2144
  in
  let Tu26 : UNIT =
    let Ti2145 : INT =
      int 0
    in
    let Td2150 : FLOAT =
      let Td2147 : FLOAT =
        let Ti2146 : INT =
          int 0
        in
        screen.(Ti2146)
      in
      let Td2149 : FLOAT =
        let Ti2148 : INT =
          int 0
        in
        screenz_dir.(Ti2148)
      in
      fsub Td2147 Td2149
    in
    viewpoint.(Ti2145) <- Td2150
  in
  let Tu25 : UNIT =
    let Ti2151 : INT =
      int 1
    in
    let Td2156 : FLOAT =
      let Td2153 : FLOAT =
        let Ti2152 : INT =
          int 1
        in
        screen.(Ti2152)
      in
      let Td2155 : FLOAT =
        let Ti2154 : INT =
          int 1
        in
        screenz_dir.(Ti2154)
      in
      fsub Td2153 Td2155
    in
    viewpoint.(Ti2151) <- Td2156
  in
  let Ti2157 : INT =
    int 2
  in
  let Td2162 : FLOAT =
    let Td2159 : FLOAT =
      let Ti2158 : INT =
        int 2
      in
      screen.(Ti2158)
    in
    let Td2161 : FLOAT =
      let Ti2160 : INT =
        int 2
      in
      screenz_dir.(Ti2160)
    in
    fsub Td2159 Td2161
  in
  viewpoint.(Ti2157) <- Td2162
in
letrec read_light : (UNIT -> UNIT) =
variables : (Tu39 : UNIT)
  let nl : INT =
    let Tu2094 : UNIT =
      unit ()
    in
    unknown inint Tu2094
  in
  let l1 : FLOAT =
    let Td2096 : FLOAT =
      let Tu2095 : UNIT =
        unit ()
      in
      unknown inflt Tu2095
    in
    app
      rad
      Td2096
  in
  let sl1 : FLOAT =
    app
      sin
      l1
  in
  let Tu42 : UNIT =
    let Ti2097 : INT =
      int 1
    in
    let Td2098 : FLOAT =
      app
        fneg
        sl1
    in
    light.(Ti2097) <- Td2098
  in
  let l2 : FLOAT =
    let Td2100 : FLOAT =
      let Tu2099 : UNIT =
        unit ()
      in
      unknown inflt Tu2099
    in
    app
      rad
      Td2100
  in
  let cl1 : FLOAT =
    app
      cos
      l1
  in
  let sl2 : FLOAT =
    app
      sin
      l2
  in
  let Tu41 : UNIT =
    let Ti2101 : INT =
      int 0
    in
    let Td2102 : FLOAT =
      fmul cl1 sl2
    in
    light.(Ti2101) <- Td2102
  in
  let cl2 : FLOAT =
    app
      cos
      l2
  in
  let Tu40 : UNIT =
    let Ti2103 : INT =
      int 2
    in
    let Td2104 : FLOAT =
      fmul cl1 cl2
    in
    light.(Ti2103) <- Td2104
  in
  let Ti2105 : INT =
    int 0
  in
  let Td2107 : FLOAT =
    let Tu2106 : UNIT =
      unit ()
    in
    unknown inflt Tu2106
  in
  beam.(Ti2105) <- Td2107
in
letrec rotate_quadratic_matrix : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (abc : Array of FLOAT), (rot : Array of FLOAT)
  let cos_x : FLOAT =
    let Td2008 : FLOAT =
      let Ti2007 : INT =
        int 0
      in
      rot.(Ti2007)
    in
    app
      cos
      Td2008
  in
  let sin_x : FLOAT =
    let Td2010 : FLOAT =
      let Ti2009 : INT =
        int 0
      in
      rot.(Ti2009)
    in
    app
      sin
      Td2010
  in
  let cos_y : FLOAT =
    let Td2012 : FLOAT =
      let Ti2011 : INT =
        int 1
      in
      rot.(Ti2011)
    in
    app
      cos
      Td2012
  in
  let sin_y : FLOAT =
    let Td2014 : FLOAT =
      let Ti2013 : INT =
        int 1
      in
      rot.(Ti2013)
    in
    app
      sin
      Td2014
  in
  let cos_z : FLOAT =
    let Td2016 : FLOAT =
      let Ti2015 : INT =
        int 2
      in
      rot.(Ti2015)
    in
    app
      cos
      Td2016
  in
  let sin_z : FLOAT =
    let Td2018 : FLOAT =
      let Ti2017 : INT =
        int 2
      in
      rot.(Ti2017)
    in
    app
      sin
      Td2018
  in
  let m00 : FLOAT =
    fmul cos_y cos_z
  in
  let m01 : FLOAT =
    let Td2020 : FLOAT =
      let Td2019 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2019 cos_z
    in
    let Td2021 : FLOAT =
      fmul cos_x sin_z
    in
    fsub Td2020 Td2021
  in
  let m02 : FLOAT =
    let Td2023 : FLOAT =
      let Td2022 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2022 cos_z
    in
    let Td2024 : FLOAT =
      fmul sin_x sin_z
    in
    fadd Td2023 Td2024
  in
  let m10 : FLOAT =
    fmul cos_y sin_z
  in
  let m11 : FLOAT =
    let Td2026 : FLOAT =
      let Td2025 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2025 sin_z
    in
    let Td2027 : FLOAT =
      fmul cos_x cos_z
    in
    fadd Td2026 Td2027
  in
  let m12 : FLOAT =
    let Td2029 : FLOAT =
      let Td2028 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2028 sin_z
    in
    let Td2030 : FLOAT =
      fmul sin_x cos_z
    in
    fsub Td2029 Td2030
  in
  let m20 : FLOAT =
    app
      fneg
      sin_y
  in
  let m21 : FLOAT =
    fmul sin_x cos_y
  in
  let m22 : FLOAT =
    fmul cos_x cos_y
  in
  let ao : FLOAT =
    let Ti2031 : INT =
      int 0
    in
    abc.(Ti2031)
  in
  let bo : FLOAT =
    let Ti2032 : INT =
      int 1
    in
    abc.(Ti2032)
  in
  let co : FLOAT =
    let Ti2033 : INT =
      int 2
    in
    abc.(Ti2033)
  in
  let Tu47 : UNIT =
    let Ti2034 : INT =
      int 0
    in
    let Td2042 : FLOAT =
      let Td2039 : FLOAT =
        let Td2036 : FLOAT =
          let Td2035 : FLOAT =
            app
              fsqr
              m00
          in
          fmul ao Td2035
        in
        let Td2038 : FLOAT =
          let Td2037 : FLOAT =
            app
              fsqr
              m10
          in
          fmul bo Td2037
        in
        fadd Td2036 Td2038
      in
      let Td2041 : FLOAT =
        let Td2040 : FLOAT =
          app
            fsqr
            m20
        in
        fmul co Td2040
      in
      fadd Td2039 Td2041
    in
    abc.(Ti2034) <- Td2042
  in
  let Tu46 : UNIT =
    let Ti2043 : INT =
      int 1
    in
    let Td2051 : FLOAT =
      let Td2048 : FLOAT =
        let Td2045 : FLOAT =
          let Td2044 : FLOAT =
            app
              fsqr
              m01
          in
          fmul ao Td2044
        in
        let Td2047 : FLOAT =
          let Td2046 : FLOAT =
            app
              fsqr
              m11
          in
          fmul bo Td2046
        in
        fadd Td2045 Td2047
      in
      let Td2050 : FLOAT =
        let Td2049 : FLOAT =
          app
            fsqr
            m21
        in
        fmul co Td2049
      in
      fadd Td2048 Td2050
    in
    abc.(Ti2043) <- Td2051
  in
  let Tu45 : UNIT =
    let Ti2052 : INT =
      int 2
    in
    let Td2060 : FLOAT =
      let Td2057 : FLOAT =
        let Td2054 : FLOAT =
          let Td2053 : FLOAT =
            app
              fsqr
              m02
          in
          fmul ao Td2053
        in
        let Td2056 : FLOAT =
          let Td2055 : FLOAT =
            app
              fsqr
              m12
          in
          fmul bo Td2055
        in
        fadd Td2054 Td2056
      in
      let Td2059 : FLOAT =
        let Td2058 : FLOAT =
          app
            fsqr
            m22
        in
        fmul co Td2058
      in
      fadd Td2057 Td2059
    in
    abc.(Ti2052) <- Td2060
  in
  let Tu44 : UNIT =
    let Ti2061 : INT =
      int 0
    in
    let Td2071 : FLOAT =
      let Td2062 : FLOAT =
        float 2.
      in
      let Td2070 : FLOAT =
        let Td2067 : FLOAT =
          let Td2064 : FLOAT =
            let Td2063 : FLOAT =
              fmul ao m01
            in
            fmul Td2063 m02
          in
          let Td2066 : FLOAT =
            let Td2065 : FLOAT =
              fmul bo m11
            in
            fmul Td2065 m12
          in
          fadd Td2064 Td2066
        in
        let Td2069 : FLOAT =
          let Td2068 : FLOAT =
            fmul co m21
          in
          fmul Td2068 m22
        in
        fadd Td2067 Td2069
      in
      fmul Td2062 Td2070
    in
    rot.(Ti2061) <- Td2071
  in
  let Tu43 : UNIT =
    let Ti2072 : INT =
      int 1
    in
    let Td2082 : FLOAT =
      let Td2073 : FLOAT =
        float 2.
      in
      let Td2081 : FLOAT =
        let Td2078 : FLOAT =
          let Td2075 : FLOAT =
            let Td2074 : FLOAT =
              fmul ao m00
            in
            fmul Td2074 m02
          in
          let Td2077 : FLOAT =
            let Td2076 : FLOAT =
              fmul bo m10
            in
            fmul Td2076 m12
          in
          fadd Td2075 Td2077
        in
        let Td2080 : FLOAT =
          let Td2079 : FLOAT =
            fmul co m20
          in
          fmul Td2079 m22
        in
        fadd Td2078 Td2080
      in
      fmul Td2073 Td2081
    in
    rot.(Ti2072) <- Td2082
  in
  let Ti2083 : INT =
    int 2
  in
  let Td2093 : FLOAT =
    let Td2084 : FLOAT =
      float 2.
    in
    let Td2092 : FLOAT =
      let Td2089 : FLOAT =
        let Td2086 : FLOAT =
          let Td2085 : FLOAT =
            fmul ao m00
          in
          fmul Td2085 m01
        in
        let Td2088 : FLOAT =
          let Td2087 : FLOAT =
            fmul bo m10
          in
          fmul Td2087 m11
        in
        fadd Td2086 Td2088
      in
      let Td2091 : FLOAT =
        let Td2090 : FLOAT =
          fmul co m20
        in
        fmul Td2090 m21
      in
      fadd Td2089 Td2091
    in
    fmul Td2084 Td2092
  in
  rot.(Ti2083) <- Td2093
in
letrec read_nth_object : (INT -> BOOL) =
variables : (n : INT)
  let texture : INT =
    let Tu1920 : UNIT =
      unit ()
    in
    unknown inint Tu1920
  in
  let Ti1922 : INT =
    let Ti1921 : INT =
      int 1
    in
    neg Ti1921
  in
  if texture == Ti1922
    int 0
    let form : INT =
      let Tu1923 : UNIT =
        unit ()
      in
      unknown inint Tu1923
    in
    let refltype : INT =
      let Tu1924 : UNIT =
        unit ()
      in
      unknown inint Tu1924
    in
    let isrot_p : INT =
      let Tu1925 : UNIT =
        unit ()
      in
      unknown inint Tu1925
    in
    let abc : Array of FLOAT =
      let Ti1926 : INT =
        int 3
      in
      let Td1927 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1926
        Td1927
    in
    let Tu66 : UNIT =
      let Ti1928 : INT =
        int 0
      in
      let Td1930 : FLOAT =
        let Tu1929 : UNIT =
          unit ()
        in
        unknown inflt Tu1929
      in
      abc.(Ti1928) <- Td1930
    in
    let Tu65 : UNIT =
      let Ti1931 : INT =
        int 1
      in
      let Td1933 : FLOAT =
        let Tu1932 : UNIT =
          unit ()
        in
        unknown inflt Tu1932
      in
      abc.(Ti1931) <- Td1933
    in
    let Tu64 : UNIT =
      let Ti1934 : INT =
        int 2
      in
      let Td1936 : FLOAT =
        let Tu1935 : UNIT =
          unit ()
        in
        unknown inflt Tu1935
      in
      abc.(Ti1934) <- Td1936
    in
    let xyz : Array of FLOAT =
      let Ti1937 : INT =
        int 3
      in
      let Td1938 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1937
        Td1938
    in
    let Tu63 : UNIT =
      let Ti1939 : INT =
        int 0
      in
      let Td1941 : FLOAT =
        let Tu1940 : UNIT =
          unit ()
        in
        unknown inflt Tu1940
      in
      xyz.(Ti1939) <- Td1941
    in
    let Tu62 : UNIT =
      let Ti1942 : INT =
        int 1
      in
      let Td1944 : FLOAT =
        let Tu1943 : UNIT =
          unit ()
        in
        unknown inflt Tu1943
      in
      xyz.(Ti1942) <- Td1944
    in
    let Tu61 : UNIT =
      let Ti1945 : INT =
        int 2
      in
      let Td1947 : FLOAT =
        let Tu1946 : UNIT =
          unit ()
        in
        unknown inflt Tu1946
      in
      xyz.(Ti1945) <- Td1947
    in
    let m_invert : BOOL =
      let Td1949 : FLOAT =
        let Tu1948 : UNIT =
          unit ()
        in
        unknown inflt Tu1948
      in
      app
        fisneg
        Td1949
    in
    let reflparam : Array of FLOAT =
      let Ti1950 : INT =
        int 2
      in
      let Td1951 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1950
        Td1951
    in
    let Tu60 : UNIT =
      let Ti1952 : INT =
        int 0
      in
      let Td1954 : FLOAT =
        let Tu1953 : UNIT =
          unit ()
        in
        unknown inflt Tu1953
      in
      reflparam.(Ti1952) <- Td1954
    in
    let Tu59 : UNIT =
      let Ti1955 : INT =
        int 1
      in
      let Td1957 : FLOAT =
        let Tu1956 : UNIT =
          unit ()
        in
        unknown inflt Tu1956
      in
      reflparam.(Ti1955) <- Td1957
    in
    let color : Array of FLOAT =
      let Ti1958 : INT =
        int 3
      in
      let Td1959 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1958
        Td1959
    in
    let Tu58 : UNIT =
      let Ti1960 : INT =
        int 0
      in
      let Td1962 : FLOAT =
        let Tu1961 : UNIT =
          unit ()
        in
        unknown inflt Tu1961
      in
      color.(Ti1960) <- Td1962
    in
    let Tu57 : UNIT =
      let Ti1963 : INT =
        int 1
      in
      let Td1965 : FLOAT =
        let Tu1964 : UNIT =
          unit ()
        in
        unknown inflt Tu1964
      in
      color.(Ti1963) <- Td1965
    in
    let Tu56 : UNIT =
      let Ti1966 : INT =
        int 2
      in
      let Td1968 : FLOAT =
        let Tu1967 : UNIT =
          unit ()
        in
        unknown inflt Tu1967
      in
      color.(Ti1966) <- Td1968
    in
    let rotation : Array of FLOAT =
      let Ti1969 : INT =
        int 3
      in
      let Td1970 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1969
        Td1970
    in
    let Tu55 : UNIT =
      let Ti1971 : INT =
        int 0
      in
      if isrot_p == Ti1971
        unit ()
        let Tu49 : UNIT =
          let Ti1972 : INT =
            int 0
          in
          let Td1975 : FLOAT =
            let Td1974 : FLOAT =
              let Tu1973 : UNIT =
                unit ()
              in
              unknown inflt Tu1973
            in
            app
              rad
              Td1974
          in
          rotation.(Ti1972) <- Td1975
        in
        let Tu48 : UNIT =
          let Ti1976 : INT =
            int 1
          in
          let Td1979 : FLOAT =
            let Td1978 : FLOAT =
              let Tu1977 : UNIT =
                unit ()
              in
              unknown inflt Tu1977
            in
            app
              rad
              Td1978
          in
          rotation.(Ti1976) <- Td1979
        in
        let Ti1980 : INT =
          int 2
        in
        let Td1983 : FLOAT =
          let Td1982 : FLOAT =
            let Tu1981 : UNIT =
              unit ()
            in
            unknown inflt Tu1981
          in
          app
            rad
            Td1982
        in
        rotation.(Ti1980) <- Td1983
    in
    let m_invert2 : BOOL =
      let Ti1984 : INT =
        int 2
      in
      if form == Ti1984
        int 1
        m_invert
    in
    let ctbl : Array of FLOAT =
      let Ti1985 : INT =
        int 4
      in
      let Td1986 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1985
        Td1986
    in
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      Tuple
        texture
        form
        refltype
        isrot_p
        abc
        xyz
        m_invert2
        reflparam
        color
        rotation
        ctbl
    in
    let Tu54 : UNIT =
      objects.(n) <- obj
    in
    let Tu53 : UNIT =
      let Ti1987 : INT =
        int 3
      in
      if form == Ti1987
        let a : FLOAT =
          let Ti1988 : INT =
            int 0
          in
          abc.(Ti1988)
        in
        let Tu51 : UNIT =
          let Ti1989 : INT =
            int 0
          in
          let Td1992 : FLOAT =
            if a == 0.0 
              float 0.
              let Td1990 : FLOAT =
                app
                  sgn
                  a
              in
              let Td1991 : FLOAT =
                app
                  fsqr
                  a
              in
              fdiv Td1990 Td1991
          in
          abc.(Ti1989) <- Td1992
        in
        let b : FLOAT =
          let Ti1993 : INT =
            int 1
          in
          abc.(Ti1993)
        in
        let Tu50 : UNIT =
          let Ti1994 : INT =
            int 1
          in
          let Td1997 : FLOAT =
            if b == 0.0 
              float 0.
              let Td1995 : FLOAT =
                app
                  sgn
                  b
              in
              let Td1996 : FLOAT =
                app
                  fsqr
                  b
              in
              fdiv Td1995 Td1996
          in
          abc.(Ti1994) <- Td1997
        in
        let c : FLOAT =
          let Ti1998 : INT =
            int 2
          in
          abc.(Ti1998)
        in
        let Ti1999 : INT =
          int 2
        in
        let Td2002 : FLOAT =
          if c == 0.0 
            float 0.
            let Td2000 : FLOAT =
              app
                sgn
                c
            in
            let Td2001 : FLOAT =
              app
                fsqr
                c
            in
            fdiv Td2000 Td2001
        in
        abc.(Ti1999) <- Td2002
        let Ti2003 : INT =
          int 2
        in
        if form == Ti2003
          let Ti2005 : INT =
            let Ti2004 : INT =
              int 0
            in
            if m_invert == Ti2004
              int 1
              int 0
          in
          app
            vecunit_sgn
            abc
            Ti2005
          unit ()
    in
    let Tu52 : UNIT =
      let Ti2006 : INT =
        int 0
      in
      if isrot_p == Ti2006
        unit ()
        app
          rotate_quadratic_matrix
          abc
          rotation
    in
    int 1
in
letrec read_object : (INT -> UNIT) =
variables : (n : INT)
  let Ti1914 : INT =
    int 60
  in
  if Ti1914 <= n
    unit ()
    let Tb1915 : BOOL =
      app
        read_nth_object
        n
    in
    let Ti1916 : INT =
      int 0
    in
    if Tb1915 == Ti1916
      let Ti1917 : INT =
        int 0
      in
      n_objects.(Ti1917) <- n
      let Ti1919 : INT =
        let Ti1918 : INT =
          int 1
        in
        add n Ti1918
      in
      app
        read_object
        Ti1919
in
letrec read_all_object : (UNIT -> UNIT) =
variables : (Tu67 : UNIT)
  let Ti1913 : INT =
    int 0
  in
  app
    read_object
    Ti1913
in
letrec read_net_item : (INT -> Array of INT) =
variables : (length : INT)
  let item : INT =
    let Tu1904 : UNIT =
      unit ()
    in
    unknown inint Tu1904
  in
  let Ti1906 : INT =
    let Ti1905 : INT =
      int 1
    in
    neg Ti1905
  in
  if item == Ti1906
    let Ti1908 : INT =
      let Ti1907 : INT =
        int 1
      in
      add length Ti1907
    in
    let Ti1910 : INT =
      let Ti1909 : INT =
        int 1
      in
      neg Ti1909
    in
    extfunapp
      create_array
      Ti1908
      Ti1910
    let v : Array of INT =
      let Ti1912 : INT =
        let Ti1911 : INT =
          int 1
        in
        add length Ti1911
      in
      app
        read_net_item
        Ti1912
    in
    let Tu68 : UNIT =
      v.(length) <- item
    in
    v
in
letrec read_or_network : (INT -> Array of Array of INT) =
variables : (length : INT)
  let net : Array of INT =
    let Ti1895 : INT =
      int 0
    in
    app
      read_net_item
      Ti1895
  in
  let Ti1897 : INT =
    let Ti1896 : INT =
      int 0
    in
    net.(Ti1896)
  in
  let Ti1899 : INT =
    let Ti1898 : INT =
      int 1
    in
    neg Ti1898
  in
  if Ti1897 == Ti1899
    let Ti1901 : INT =
      let Ti1900 : INT =
        int 1
      in
      add length Ti1900
    in
    extfunapp
      create_array
      Ti1901
      net
    let v : Array of Array of INT =
      let Ti1903 : INT =
        let Ti1902 : INT =
          int 1
        in
        add length Ti1902
      in
      app
        read_or_network
        Ti1903
    in
    let Tu69 : UNIT =
      v.(length) <- net
    in
    v
in
letrec read_and_network : (INT -> UNIT) =
variables : (n : INT)
  let net : Array of INT =
    let Ti1888 : INT =
      int 0
    in
    app
      read_net_item
      Ti1888
  in
  let Ti1890 : INT =
    let Ti1889 : INT =
      int 0
    in
    net.(Ti1889)
  in
  let Ti1892 : INT =
    let Ti1891 : INT =
      int 1
    in
    neg Ti1891
  in
  if Ti1890 == Ti1892
    unit ()
    let Tu70 : UNIT =
      and_net.(n) <- net
    in
    let Ti1894 : INT =
      let Ti1893 : INT =
        int 1
      in
      add n Ti1893
    in
    app
      read_and_network
      Ti1894
in
letrec read_parameter : (UNIT -> UNIT) =
variables : (Tu71 : UNIT)
  let Tu75 : UNIT =
    let Tu1881 : UNIT =
      unit ()
    in
    app
      read_screen_settings
      Tu1881
  in
  let Tu74 : UNIT =
    let Tu1882 : UNIT =
      unit ()
    in
    app
      read_light
      Tu1882
  in
  let Tu73 : UNIT =
    let Tu1883 : UNIT =
      unit ()
    in
    app
      read_all_object
      Tu1883
  in
  let Tu72 : UNIT =
    let Ti1884 : INT =
      int 0
    in
    app
      read_and_network
      Ti1884
  in
  let Ti1885 : INT =
    int 0
  in
  let Ta1887 : Array of Array of INT =
    let Ti1886 : INT =
      int 0
    in
    app
      read_or_network
      Ti1886
  in
  or_net.(Ti1885) <- Ta1887
in
letrec solver_rect_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> (INT -> BOOL)))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT), (i0 : INT), (i1 : INT), (i2 : INT)
  let Td1858 : FLOAT =
    dirvec.(i0)
  in
  if Td1858 == 0.0 
    int 0
    let abc : Array of FLOAT =
      app
        o_param_abc
        m
    in
    let d : FLOAT =
      let Tb1862 : BOOL =
        let Tb1859 : BOOL =
          app
            o_isinvert
            m
        in
        let Tb1861 : BOOL =
          let Td1860 : FLOAT =
            dirvec.(i0)
          in
          app
            fisneg
            Td1860
        in
        app
          xor
          Tb1859
          Tb1861
      in
      let Td1863 : FLOAT =
        abc.(i0)
      in
      app
        fneg_cond
        Tb1862
        Td1863
    in
    let d2 : FLOAT =
      let Td1864 : FLOAT =
        fsub d b0
      in
      let Td1865 : FLOAT =
        dirvec.(i0)
      in
      fdiv Td1864 Td1865
    in
    let Tb1871 : BOOL =
      let Td1869 : FLOAT =
        let Td1868 : FLOAT =
          let Td1867 : FLOAT =
            let Td1866 : FLOAT =
              dirvec.(i1)
            in
            fmul d2 Td1866
          in
          fadd Td1867 b1
        in
        app
          fabs
          Td1868
      in
      let Td1870 : FLOAT =
        abc.(i1)
      in
      app
        fless
        Td1869
        Td1870
    in
    let Ti1872 : INT =
      int 0
    in
    if Tb1871 == Ti1872
      int 0
      let Tb1878 : BOOL =
        let Td1876 : FLOAT =
          let Td1875 : FLOAT =
            let Td1874 : FLOAT =
              let Td1873 : FLOAT =
                dirvec.(i2)
              in
              fmul d2 Td1873
            in
            fadd Td1874 b2
          in
          app
            fabs
            Td1875
        in
        let Td1877 : FLOAT =
          abc.(i2)
        in
        app
          fless
          Td1876
          Td1877
      in
      let Ti1879 : INT =
        int 0
      in
      if Tb1878 == Ti1879
        int 0
        let Tu76 : UNIT =
          let Ti1880 : INT =
            int 0
          in
          solver_dist.(Ti1880) <- d2
        in
        int 1
in
letrec solver_rect : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1846 : BOOL =
    let Ti1843 : INT =
      int 0
    in
    let Ti1844 : INT =
      int 1
    in
    let Ti1845 : INT =
      int 2
    in
    app
      solver_rect_surface
      m
      dirvec
      b0
      b1
      b2
      Ti1843
      Ti1844
      Ti1845
  in
  let Ti1847 : INT =
    int 0
  in
  if Tb1846 == Ti1847
    let Tb1851 : BOOL =
      let Ti1848 : INT =
        int 1
      in
      let Ti1849 : INT =
        int 2
      in
      let Ti1850 : INT =
        int 0
      in
      app
        solver_rect_surface
        m
        dirvec
        b1
        b2
        b0
        Ti1848
        Ti1849
        Ti1850
    in
    let Ti1852 : INT =
      int 0
    in
    if Tb1851 == Ti1852
      let Tb1856 : BOOL =
        let Ti1853 : INT =
          int 2
        in
        let Ti1854 : INT =
          int 0
        in
        let Ti1855 : INT =
          int 1
        in
        app
          solver_rect_surface
          m
          dirvec
          b2
          b0
          b1
          Ti1853
          Ti1854
          Ti1855
      in
      let Ti1857 : INT =
        int 0
      in
      if Tb1856 == Ti1857
        int 0
        int 3
      int 2
    int 1
in
letrec solver_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let abc : Array of FLOAT =
    app
      o_param_abc
      m
  in
  let d : FLOAT =
    app
      veciprod
      dirvec
      abc
  in
  let Tb1837 : BOOL =
    app
      fispos
      d
  in
  let Ti1838 : INT =
    int 0
  in
  if Tb1837 == Ti1838
    int 0
    let Tu77 : UNIT =
      let Ti1839 : INT =
        int 0
      in
      let Td1842 : FLOAT =
        let Td1841 : FLOAT =
          let Td1840 : FLOAT =
            app
              veciprod2
              abc
              b0
              b1
              b2
          in
          app
            fneg
            Td1840
        in
        fdiv Td1841 d
      in
      solver_dist.(Ti1839) <- Td1842
    in
    int 1
in
letrec quadratic : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let diag_part : FLOAT =
    let Td1820 : FLOAT =
      let Td1816 : FLOAT =
        let Td1814 : FLOAT =
          app
            fsqr
            v0
        in
        let Td1815 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1814 Td1815
      in
      let Td1819 : FLOAT =
        let Td1817 : FLOAT =
          app
            fsqr
            v1
        in
        let Td1818 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1817 Td1818
      in
      fadd Td1816 Td1819
    in
    let Td1823 : FLOAT =
      let Td1821 : FLOAT =
        app
          fsqr
          v2
      in
      let Td1822 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1821 Td1822
    in
    fadd Td1820 Td1823
  in
  let Ti1824 : INT =
    app
      o_isrot
      m
  in
  let Ti1825 : INT =
    int 0
  in
  if Ti1824 == Ti1825
    diag_part
    let Td1833 : FLOAT =
      let Td1829 : FLOAT =
        let Td1828 : FLOAT =
          let Td1826 : FLOAT =
            fmul v1 v2
          in
          let Td1827 : FLOAT =
            app
              o_param_r1
              m
          in
          fmul Td1826 Td1827
        in
        fadd diag_part Td1828
      in
      let Td1832 : FLOAT =
        let Td1830 : FLOAT =
          fmul v2 v0
        in
        let Td1831 : FLOAT =
          app
            o_param_r2
            m
        in
        fmul Td1830 Td1831
      in
      fadd Td1829 Td1832
    in
    let Td1836 : FLOAT =
      let Td1834 : FLOAT =
        fmul v0 v1
      in
      let Td1835 : FLOAT =
        app
          o_param_r3
          m
      in
      fmul Td1834 Td1835
    in
    fadd Td1833 Td1836
in
letrec bilinear : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let diag_part : FLOAT =
    let Td1790 : FLOAT =
      let Td1786 : FLOAT =
        let Td1784 : FLOAT =
          fmul v0 w0
        in
        let Td1785 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1784 Td1785
      in
      let Td1789 : FLOAT =
        let Td1787 : FLOAT =
          fmul v1 w1
        in
        let Td1788 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1787 Td1788
      in
      fadd Td1786 Td1789
    in
    let Td1793 : FLOAT =
      let Td1791 : FLOAT =
        fmul v2 w2
      in
      let Td1792 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1791 Td1792
    in
    fadd Td1790 Td1793
  in
  let Ti1794 : INT =
    app
      o_isrot
      m
  in
  let Ti1795 : INT =
    int 0
  in
  if Ti1794 == Ti1795
    diag_part
    let Td1813 : FLOAT =
      let Td1812 : FLOAT =
        let Td1806 : FLOAT =
          let Td1800 : FLOAT =
            let Td1798 : FLOAT =
              let Td1796 : FLOAT =
                fmul v2 w1
              in
              let Td1797 : FLOAT =
                fmul v1 w2
              in
              fadd Td1796 Td1797
            in
            let Td1799 : FLOAT =
              app
                o_param_r1
                m
            in
            fmul Td1798 Td1799
          in
          let Td1805 : FLOAT =
            let Td1803 : FLOAT =
              let Td1801 : FLOAT =
                fmul v0 w2
              in
              let Td1802 : FLOAT =
                fmul v2 w0
              in
              fadd Td1801 Td1802
            in
            let Td1804 : FLOAT =
              app
                o_param_r2
                m
            in
            fmul Td1803 Td1804
          in
          fadd Td1800 Td1805
        in
        let Td1811 : FLOAT =
          let Td1809 : FLOAT =
            let Td1807 : FLOAT =
              fmul v0 w1
            in
            let Td1808 : FLOAT =
              fmul v1 w0
            in
            fadd Td1807 Td1808
          in
          let Td1810 : FLOAT =
            app
              o_param_r3
              m
          in
          fmul Td1809 Td1810
        in
        fadd Td1806 Td1811
      in
      app
        fhalf
        Td1812
    in
    fadd diag_part Td1813
in
letrec solver_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Td1761 : FLOAT =
      let Ti1760 : INT =
        int 0
      in
      dirvec.(Ti1760)
    in
    let Td1763 : FLOAT =
      let Ti1762 : INT =
        int 1
      in
      dirvec.(Ti1762)
    in
    let Td1765 : FLOAT =
      let Ti1764 : INT =
        int 2
      in
      dirvec.(Ti1764)
    in
    app
      quadratic
      m
      Td1761
      Td1763
      Td1765
  in
  if aa == 0.0 
    int 0
    let bb : FLOAT =
      let Td1767 : FLOAT =
        let Ti1766 : INT =
          int 0
        in
        dirvec.(Ti1766)
      in
      let Td1769 : FLOAT =
        let Ti1768 : INT =
          int 1
        in
        dirvec.(Ti1768)
      in
      let Td1771 : FLOAT =
        let Ti1770 : INT =
          int 2
        in
        dirvec.(Ti1770)
      in
      app
        bilinear
        m
        Td1767
        Td1769
        Td1771
        b0
        b1
        b2
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1772 : INT =
        app
          o_form
          m
      in
      let Ti1773 : INT =
        int 3
      in
      if Ti1772 == Ti1773
        let Td1774 : FLOAT =
          float 1.
        in
        fsub cc0 Td1774
        cc0
    in
    let d : FLOAT =
      let Td1775 : FLOAT =
        app
          fsqr
          bb
      in
      let Td1776 : FLOAT =
        fmul aa cc
      in
      fsub Td1775 Td1776
    in
    let Tb1777 : BOOL =
      app
        fispos
        d
    in
    let Ti1778 : INT =
      int 0
    in
    if Tb1777 == Ti1778
      int 0
      let sd : FLOAT =
        app
          sqrt
          d
      in
      let t1 : FLOAT =
        let Tb1779 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1780 : INT =
          int 0
        in
        if Tb1779 == Ti1780
          app
            fneg
            sd
          sd
      in
      let Tu78 : UNIT =
        let Ti1781 : INT =
          int 0
        in
        let Td1783 : FLOAT =
          let Td1782 : FLOAT =
            fsub t1 bb
          in
          fdiv Td1782 aa
        in
        solver_dist.(Ti1781) <- Td1783
      in
      int 1
in
letrec solver : (INT -> (Array of FLOAT -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : Array of FLOAT), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1750 : FLOAT =
      let Ti1749 : INT =
        int 0
      in
      org.(Ti1749)
    in
    let Td1751 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1750 Td1751
  in
  let b1 : FLOAT =
    let Td1753 : FLOAT =
      let Ti1752 : INT =
        int 1
      in
      org.(Ti1752)
    in
    let Td1754 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1753 Td1754
  in
  let b2 : FLOAT =
    let Td1756 : FLOAT =
      let Ti1755 : INT =
        int 2
      in
      org.(Ti1755)
    in
    let Td1757 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1756 Td1757
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1758 : INT =
    int 1
  in
  if m_shape == Ti1758
    app
      solver_rect
      m
      dirvec
      b0
      b1
      b2
    let Ti1759 : INT =
      int 2
    in
    if m_shape == Ti1759
      app
        solver_surface
        m
        dirvec
        b0
        b1
        b2
      app
        solver_second
        m
        dirvec
        b0
        b1
        b2
in
letrec solver_rect_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v : Array of FLOAT), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let d0 : FLOAT =
    let Td1673 : FLOAT =
      let Td1672 : FLOAT =
        let Ti1671 : INT =
          int 0
        in
        dconst.(Ti1671)
      in
      fsub Td1672 b0
    in
    let Td1675 : FLOAT =
      let Ti1674 : INT =
        int 1
      in
      dconst.(Ti1674)
    in
    fmul Td1673 Td1675
  in
  let Ti1694 : INT =
    let Tb1682 : BOOL =
      let Td1680 : FLOAT =
        let Td1679 : FLOAT =
          let Td1678 : FLOAT =
            let Td1677 : FLOAT =
              let Ti1676 : INT =
                int 1
              in
              v.(Ti1676)
            in
            fmul d0 Td1677
          in
          fadd Td1678 b1
        in
        app
          fabs
          Td1679
      in
      let Td1681 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fless
        Td1680
        Td1681
    in
    let Ti1683 : INT =
      int 0
    in
    if Tb1682 == Ti1683
      int 0
      let Tb1690 : BOOL =
        let Td1688 : FLOAT =
          let Td1687 : FLOAT =
            let Td1686 : FLOAT =
              let Td1685 : FLOAT =
                let Ti1684 : INT =
                  int 2
                in
                v.(Ti1684)
              in
              fmul d0 Td1685
            in
            fadd Td1686 b2
          in
          app
            fabs
            Td1687
        in
        let Td1689 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1688
          Td1689
      in
      let Ti1691 : INT =
        int 0
      in
      if Tb1690 == Ti1691
        int 0
        let Td1693 : FLOAT =
          let Ti1692 : INT =
            int 1
          in
          dconst.(Ti1692)
        in
        if Td1693 == 0.0 
          int 0
          int 1
  in
  let Ti1695 : INT =
    int 0
  in
  if Ti1694 == Ti1695
    let d1 : FLOAT =
      let Td1698 : FLOAT =
        let Td1697 : FLOAT =
          let Ti1696 : INT =
            int 2
          in
          dconst.(Ti1696)
        in
        fsub Td1697 b1
      in
      let Td1700 : FLOAT =
        let Ti1699 : INT =
          int 3
        in
        dconst.(Ti1699)
      in
      fmul Td1698 Td1700
    in
    let Ti1719 : INT =
      let Tb1707 : BOOL =
        let Td1705 : FLOAT =
          let Td1704 : FLOAT =
            let Td1703 : FLOAT =
              let Td1702 : FLOAT =
                let Ti1701 : INT =
                  int 0
                in
                v.(Ti1701)
              in
              fmul d1 Td1702
            in
            fadd Td1703 b0
          in
          app
            fabs
            Td1704
        in
        let Td1706 : FLOAT =
          app
            o_param_a
            m
        in
        app
          fless
          Td1705
          Td1706
      in
      let Ti1708 : INT =
        int 0
      in
      if Tb1707 == Ti1708
        int 0
        let Tb1715 : BOOL =
          let Td1713 : FLOAT =
            let Td1712 : FLOAT =
              let Td1711 : FLOAT =
                let Td1710 : FLOAT =
                  let Ti1709 : INT =
                    int 2
                  in
                  v.(Ti1709)
                in
                fmul d1 Td1710
              in
              fadd Td1711 b2
            in
            app
              fabs
              Td1712
          in
          let Td1714 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fless
            Td1713
            Td1714
        in
        let Ti1716 : INT =
          int 0
        in
        if Tb1715 == Ti1716
          int 0
          let Td1718 : FLOAT =
            let Ti1717 : INT =
              int 3
            in
            dconst.(Ti1717)
          in
          if Td1718 == 0.0 
            int 0
            int 1
    in
    let Ti1720 : INT =
      int 0
    in
    if Ti1719 == Ti1720
      let d2 : FLOAT =
        let Td1723 : FLOAT =
          let Td1722 : FLOAT =
            let Ti1721 : INT =
              int 4
            in
            dconst.(Ti1721)
          in
          fsub Td1722 b2
        in
        let Td1725 : FLOAT =
          let Ti1724 : INT =
            int 5
          in
          dconst.(Ti1724)
        in
        fmul Td1723 Td1725
      in
      let Ti1744 : INT =
        let Tb1732 : BOOL =
          let Td1730 : FLOAT =
            let Td1729 : FLOAT =
              let Td1728 : FLOAT =
                let Td1727 : FLOAT =
                  let Ti1726 : INT =
                    int 0
                  in
                  v.(Ti1726)
                in
                fmul d2 Td1727
              in
              fadd Td1728 b0
            in
            app
              fabs
              Td1729
          in
          let Td1731 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fless
            Td1730
            Td1731
        in
        let Ti1733 : INT =
          int 0
        in
        if Tb1732 == Ti1733
          int 0
          let Tb1740 : BOOL =
            let Td1738 : FLOAT =
              let Td1737 : FLOAT =
                let Td1736 : FLOAT =
                  let Td1735 : FLOAT =
                    let Ti1734 : INT =
                      int 1
                    in
                    v.(Ti1734)
                  in
                  fmul d2 Td1735
                in
                fadd Td1736 b1
              in
              app
                fabs
                Td1737
            in
            let Td1739 : FLOAT =
              app
                o_param_b
                m
            in
            app
              fless
              Td1738
              Td1739
          in
          let Ti1741 : INT =
            int 0
          in
          if Tb1740 == Ti1741
            int 0
            let Td1743 : FLOAT =
              let Ti1742 : INT =
                int 5
              in
              dconst.(Ti1742)
            in
            if Td1743 == 0.0 
              int 0
              int 1
      in
      let Ti1745 : INT =
        int 0
      in
      if Ti1744 == Ti1745
        int 0
        let Tu81 : UNIT =
          let Ti1746 : INT =
            int 0
          in
          solver_dist.(Ti1746) <- d2
        in
        int 3
      let Tu80 : UNIT =
        let Ti1747 : INT =
          int 0
        in
        solver_dist.(Ti1747) <- d1
      in
      int 2
    let Tu79 : UNIT =
      let Ti1748 : INT =
        int 0
      in
      solver_dist.(Ti1748) <- d0
    in
    int 1
in
letrec solver_surface_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1657 : BOOL =
    let Td1656 : FLOAT =
      let Ti1655 : INT =
        int 0
      in
      dconst.(Ti1655)
    in
    app
      fisneg
      Td1656
  in
  let Ti1658 : INT =
    int 0
  in
  if Tb1657 == Ti1658
    int 0
    let Tu82 : UNIT =
      let Ti1659 : INT =
        int 0
      in
      let Td1670 : FLOAT =
        let Td1666 : FLOAT =
          let Td1662 : FLOAT =
            let Td1661 : FLOAT =
              let Ti1660 : INT =
                int 1
              in
              dconst.(Ti1660)
            in
            fmul Td1661 b0
          in
          let Td1665 : FLOAT =
            let Td1664 : FLOAT =
              let Ti1663 : INT =
                int 2
              in
              dconst.(Ti1663)
            in
            fmul Td1664 b1
          in
          fadd Td1662 Td1665
        in
        let Td1669 : FLOAT =
          let Td1668 : FLOAT =
            let Ti1667 : INT =
              int 3
            in
            dconst.(Ti1667)
          in
          fmul Td1668 b2
        in
        fadd Td1666 Td1669
      in
      solver_dist.(Ti1659) <- Td1670
    in
    int 1
in
letrec solver_second_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1623 : INT =
      int 0
    in
    dconst.(Ti1623)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1630 : FLOAT =
        let Td1626 : FLOAT =
          let Td1625 : FLOAT =
            let Ti1624 : INT =
              int 1
            in
            dconst.(Ti1624)
          in
          fmul Td1625 b0
        in
        let Td1629 : FLOAT =
          let Td1628 : FLOAT =
            let Ti1627 : INT =
              int 2
            in
            dconst.(Ti1627)
          in
          fmul Td1628 b1
        in
        fadd Td1626 Td1629
      in
      let Td1633 : FLOAT =
        let Td1632 : FLOAT =
          let Ti1631 : INT =
            int 3
          in
          dconst.(Ti1631)
        in
        fmul Td1632 b2
      in
      fadd Td1630 Td1633
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1634 : INT =
        app
          o_form
          m
      in
      let Ti1635 : INT =
        int 3
      in
      if Ti1634 == Ti1635
        let Td1636 : FLOAT =
          float 1.
        in
        fsub cc0 Td1636
        cc0
    in
    let d : FLOAT =
      let Td1637 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1638 : FLOAT =
        fmul aa cc
      in
      fsub Td1637 Td1638
    in
    let Tb1639 : BOOL =
      app
        fispos
        d
    in
    let Ti1640 : INT =
      int 0
    in
    if Tb1639 == Ti1640
      int 0
      let Tu83 : UNIT =
        let Tb1641 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1642 : INT =
          int 0
        in
        if Tb1641 == Ti1642
          let Ti1643 : INT =
            int 0
          in
          let Td1648 : FLOAT =
            let Td1645 : FLOAT =
              let Td1644 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1644
            in
            let Td1647 : FLOAT =
              let Ti1646 : INT =
                int 4
              in
              dconst.(Ti1646)
            in
            fmul Td1645 Td1647
          in
          solver_dist.(Ti1643) <- Td1648
          let Ti1649 : INT =
            int 0
          in
          let Td1654 : FLOAT =
            let Td1651 : FLOAT =
              let Td1650 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1650
            in
            let Td1653 : FLOAT =
              let Ti1652 : INT =
                int 4
              in
              dconst.(Ti1652)
            in
            fmul Td1651 Td1653
          in
          solver_dist.(Ti1649) <- Td1654
      in
      int 1
in
letrec solver_fast : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1612 : FLOAT =
      let Ti1611 : INT =
        int 0
      in
      org.(Ti1611)
    in
    let Td1613 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1612 Td1613
  in
  let b1 : FLOAT =
    let Td1615 : FLOAT =
      let Ti1614 : INT =
        int 1
      in
      org.(Ti1614)
    in
    let Td1616 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1615 Td1616
  in
  let b2 : FLOAT =
    let Td1618 : FLOAT =
      let Ti1617 : INT =
        int 2
      in
      org.(Ti1617)
    in
    let Td1619 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1618 Td1619
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1620 : INT =
    int 1
  in
  if m_shape == Ti1620
    let Ta1621 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1621
      dconst
      b0
      b1
      b2
    let Ti1622 : INT =
      int 2
    in
    if m_shape == Ti1622
      app
        solver_surface_fast
        m
        dconst
        b0
        b1
        b2
      app
        solver_second_fast
        m
        dconst
        b0
        b1
        b2
in
letrec solver_surface_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1603 : BOOL =
    let Td1602 : FLOAT =
      let Ti1601 : INT =
        int 0
      in
      dconst.(Ti1601)
    in
    app
      fisneg
      Td1602
  in
  let Ti1604 : INT =
    int 0
  in
  if Tb1603 == Ti1604
    int 0
    let Tu84 : UNIT =
      let Ti1605 : INT =
        int 0
      in
      let Td1610 : FLOAT =
        let Td1607 : FLOAT =
          let Ti1606 : INT =
            int 0
          in
          dconst.(Ti1606)
        in
        let Td1609 : FLOAT =
          let Ti1608 : INT =
            int 3
          in
          sconst.(Ti1608)
        in
        fmul Td1607 Td1609
      in
      solver_dist.(Ti1605) <- Td1610
    in
    int 1
in
letrec solver_second_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1571 : INT =
      int 0
    in
    dconst.(Ti1571)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1578 : FLOAT =
        let Td1574 : FLOAT =
          let Td1573 : FLOAT =
            let Ti1572 : INT =
              int 1
            in
            dconst.(Ti1572)
          in
          fmul Td1573 b0
        in
        let Td1577 : FLOAT =
          let Td1576 : FLOAT =
            let Ti1575 : INT =
              int 2
            in
            dconst.(Ti1575)
          in
          fmul Td1576 b1
        in
        fadd Td1574 Td1577
      in
      let Td1581 : FLOAT =
        let Td1580 : FLOAT =
          let Ti1579 : INT =
            int 3
          in
          dconst.(Ti1579)
        in
        fmul Td1580 b2
      in
      fadd Td1578 Td1581
    in
    let cc : FLOAT =
      let Ti1582 : INT =
        int 3
      in
      sconst.(Ti1582)
    in
    let d : FLOAT =
      let Td1583 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1584 : FLOAT =
        fmul aa cc
      in
      fsub Td1583 Td1584
    in
    let Tb1585 : BOOL =
      app
        fispos
        d
    in
    let Ti1586 : INT =
      int 0
    in
    if Tb1585 == Ti1586
      int 0
      let Tu85 : UNIT =
        let Tb1587 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1588 : INT =
          int 0
        in
        if Tb1587 == Ti1588
          let Ti1589 : INT =
            int 0
          in
          let Td1594 : FLOAT =
            let Td1591 : FLOAT =
              let Td1590 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1590
            in
            let Td1593 : FLOAT =
              let Ti1592 : INT =
                int 4
              in
              dconst.(Ti1592)
            in
            fmul Td1591 Td1593
          in
          solver_dist.(Ti1589) <- Td1594
          let Ti1595 : INT =
            int 0
          in
          let Td1600 : FLOAT =
            let Td1597 : FLOAT =
              let Td1596 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1596
            in
            let Td1599 : FLOAT =
              let Ti1598 : INT =
                int 4
              in
              dconst.(Ti1598)
            in
            fmul Td1597 Td1599
          in
          solver_dist.(Ti1595) <- Td1600
      in
      int 1
in
letrec solver_fast2 : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> INT)) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let sconst : Array of FLOAT =
    app
      o_param_ctbl
      m
  in
  let b0 : FLOAT =
    let Ti1565 : INT =
      int 0
    in
    sconst.(Ti1565)
  in
  let b1 : FLOAT =
    let Ti1566 : INT =
      int 1
    in
    sconst.(Ti1566)
  in
  let b2 : FLOAT =
    let Ti1567 : INT =
      int 2
    in
    sconst.(Ti1567)
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1568 : INT =
    int 1
  in
  if m_shape == Ti1568
    let Ta1569 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1569
      dconst
      b0
      b1
      b2
    let Ti1570 : INT =
      int 2
    in
    if m_shape == Ti1570
      app
        solver_surface_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
      app
        solver_second_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
in
letrec setup_rect_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1512 : INT =
      int 6
    in
    let Td1513 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1512
      Td1513
  in
  let Tu91 : UNIT =
    let Td1515 : FLOAT =
      let Ti1514 : INT =
        int 0
      in
      vec.(Ti1514)
    in
    if Td1515 == 0.0 
      let Ti1516 : INT =
        int 1
      in
      let Td1517 : FLOAT =
        float 0.
      in
      const.(Ti1516) <- Td1517
      let Tu86 : UNIT =
        let Ti1518 : INT =
          int 0
        in
        let Td1525 : FLOAT =
          let Tb1523 : BOOL =
            let Tb1519 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1522 : BOOL =
              let Td1521 : FLOAT =
                let Ti1520 : INT =
                  int 0
                in
                vec.(Ti1520)
              in
              app
                fisneg
                Td1521
            in
            app
              xor
              Tb1519
              Tb1522
          in
          let Td1524 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fneg_cond
            Tb1523
            Td1524
        in
        const.(Ti1518) <- Td1525
      in
      let Ti1526 : INT =
        int 1
      in
      let Td1530 : FLOAT =
        let Td1527 : FLOAT =
          float 1.
        in
        let Td1529 : FLOAT =
          let Ti1528 : INT =
            int 0
          in
          vec.(Ti1528)
        in
        fdiv Td1527 Td1529
      in
      const.(Ti1526) <- Td1530
  in
  let Tu90 : UNIT =
    let Td1532 : FLOAT =
      let Ti1531 : INT =
        int 1
      in
      vec.(Ti1531)
    in
    if Td1532 == 0.0 
      let Ti1533 : INT =
        int 3
      in
      let Td1534 : FLOAT =
        float 0.
      in
      const.(Ti1533) <- Td1534
      let Tu87 : UNIT =
        let Ti1535 : INT =
          int 2
        in
        let Td1542 : FLOAT =
          let Tb1540 : BOOL =
            let Tb1536 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1539 : BOOL =
              let Td1538 : FLOAT =
                let Ti1537 : INT =
                  int 1
                in
                vec.(Ti1537)
              in
              app
                fisneg
                Td1538
            in
            app
              xor
              Tb1536
              Tb1539
          in
          let Td1541 : FLOAT =
            app
              o_param_b
              m
          in
          app
            fneg_cond
            Tb1540
            Td1541
        in
        const.(Ti1535) <- Td1542
      in
      let Ti1543 : INT =
        int 3
      in
      let Td1547 : FLOAT =
        let Td1544 : FLOAT =
          float 1.
        in
        let Td1546 : FLOAT =
          let Ti1545 : INT =
            int 1
          in
          vec.(Ti1545)
        in
        fdiv Td1544 Td1546
      in
      const.(Ti1543) <- Td1547
  in
  let Tu89 : UNIT =
    let Td1549 : FLOAT =
      let Ti1548 : INT =
        int 2
      in
      vec.(Ti1548)
    in
    if Td1549 == 0.0 
      let Ti1550 : INT =
        int 5
      in
      let Td1551 : FLOAT =
        float 0.
      in
      const.(Ti1550) <- Td1551
      let Tu88 : UNIT =
        let Ti1552 : INT =
          int 4
        in
        let Td1559 : FLOAT =
          let Tb1557 : BOOL =
            let Tb1553 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1556 : BOOL =
              let Td1555 : FLOAT =
                let Ti1554 : INT =
                  int 2
                in
                vec.(Ti1554)
              in
              app
                fisneg
                Td1555
            in
            app
              xor
              Tb1553
              Tb1556
          in
          let Td1558 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fneg_cond
            Tb1557
            Td1558
        in
        const.(Ti1552) <- Td1559
      in
      let Ti1560 : INT =
        int 5
      in
      let Td1564 : FLOAT =
        let Td1561 : FLOAT =
          float 1.
        in
        let Td1563 : FLOAT =
          let Ti1562 : INT =
            int 2
          in
          vec.(Ti1562)
        in
        fdiv Td1561 Td1563
      in
      const.(Ti1560) <- Td1564
  in
  const
in
letrec setup_surface_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1478 : INT =
      int 4
    in
    let Td1479 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1478
      Td1479
  in
  let d : FLOAT =
    let Td1488 : FLOAT =
      let Td1483 : FLOAT =
        let Td1481 : FLOAT =
          let Ti1480 : INT =
            int 0
          in
          vec.(Ti1480)
        in
        let Td1482 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1481 Td1482
      in
      let Td1487 : FLOAT =
        let Td1485 : FLOAT =
          let Ti1484 : INT =
            int 1
          in
          vec.(Ti1484)
        in
        let Td1486 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1485 Td1486
      in
      fadd Td1483 Td1487
    in
    let Td1492 : FLOAT =
      let Td1490 : FLOAT =
        let Ti1489 : INT =
          int 2
        in
        vec.(Ti1489)
      in
      let Td1491 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1490 Td1491
    in
    fadd Td1488 Td1492
  in
  let Tu95 : UNIT =
    let Tb1493 : BOOL =
      app
        fispos
        d
    in
    let Ti1494 : INT =
      int 0
    in
    if Tb1493 == Ti1494
      let Ti1495 : INT =
        int 0
      in
      let Td1496 : FLOAT =
        float 0.
      in
      const.(Ti1495) <- Td1496
      let Tu94 : UNIT =
        let Ti1497 : INT =
          int 0
        in
        let Td1499 : FLOAT =
          let Td1498 : FLOAT =
            float -1.
          in
          fdiv Td1498 d
        in
        const.(Ti1497) <- Td1499
      in
      let Tu93 : UNIT =
        let Ti1500 : INT =
          int 1
        in
        let Td1503 : FLOAT =
          let Td1502 : FLOAT =
            let Td1501 : FLOAT =
              app
                o_param_a
                m
            in
            fdiv Td1501 d
          in
          app
            fneg
            Td1502
        in
        const.(Ti1500) <- Td1503
      in
      let Tu92 : UNIT =
        let Ti1504 : INT =
          int 2
        in
        let Td1507 : FLOAT =
          let Td1506 : FLOAT =
            let Td1505 : FLOAT =
              app
                o_param_b
                m
            in
            fdiv Td1505 d
          in
          app
            fneg
            Td1506
        in
        const.(Ti1504) <- Td1507
      in
      let Ti1508 : INT =
        int 3
      in
      let Td1511 : FLOAT =
        let Td1510 : FLOAT =
          let Td1509 : FLOAT =
            app
              o_param_c
              m
          in
          fdiv Td1509 d
        in
        app
          fneg
          Td1510
      in
      const.(Ti1508) <- Td1511
  in
  const
in
letrec setup_second_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (v : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1413 : INT =
      int 5
    in
    let Td1414 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1413
      Td1414
  in
  let aa : FLOAT =
    let Td1416 : FLOAT =
      let Ti1415 : INT =
        int 0
      in
      v.(Ti1415)
    in
    let Td1418 : FLOAT =
      let Ti1417 : INT =
        int 1
      in
      v.(Ti1417)
    in
    let Td1420 : FLOAT =
      let Ti1419 : INT =
        int 2
      in
      v.(Ti1419)
    in
    app
      quadratic
      m
      Td1416
      Td1418
      Td1420
  in
  let c1 : FLOAT =
    let Td1424 : FLOAT =
      let Td1422 : FLOAT =
        let Ti1421 : INT =
          int 0
        in
        v.(Ti1421)
      in
      let Td1423 : FLOAT =
        app
          o_param_a
          m
      in
      fmul Td1422 Td1423
    in
    app
      fneg
      Td1424
  in
  let c2 : FLOAT =
    let Td1428 : FLOAT =
      let Td1426 : FLOAT =
        let Ti1425 : INT =
          int 1
        in
        v.(Ti1425)
      in
      let Td1427 : FLOAT =
        app
          o_param_b
          m
      in
      fmul Td1426 Td1427
    in
    app
      fneg
      Td1428
  in
  let c3 : FLOAT =
    let Td1432 : FLOAT =
      let Td1430 : FLOAT =
        let Ti1429 : INT =
          int 2
        in
        v.(Ti1429)
      in
      let Td1431 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1430 Td1431
    in
    app
      fneg
      Td1432
  in
  let Tu102 : UNIT =
    let Ti1433 : INT =
      int 0
    in
    const.(Ti1433) <- aa
  in
  let Tu101 : UNIT =
    let Ti1434 : INT =
      app
        o_isrot
        m
    in
    let Ti1435 : INT =
      int 0
    in
    if Ti1434 == Ti1435
      let Tu99 : UNIT =
        let Ti1436 : INT =
          int 1
        in
        const.(Ti1436) <- c1
      in
      let Tu98 : UNIT =
        let Ti1437 : INT =
          int 2
        in
        const.(Ti1437) <- c2
      in
      let Ti1438 : INT =
        int 3
      in
      const.(Ti1438) <- c3
      let Tu97 : UNIT =
        let Ti1439 : INT =
          int 1
        in
        let Td1450 : FLOAT =
          let Td1449 : FLOAT =
            let Td1448 : FLOAT =
              let Td1443 : FLOAT =
                let Td1441 : FLOAT =
                  let Ti1440 : INT =
                    int 2
                  in
                  v.(Ti1440)
                in
                let Td1442 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul Td1441 Td1442
              in
              let Td1447 : FLOAT =
                let Td1445 : FLOAT =
                  let Ti1444 : INT =
                    int 1
                  in
                  v.(Ti1444)
                in
                let Td1446 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1445 Td1446
              in
              fadd Td1443 Td1447
            in
            app
              fhalf
              Td1448
          in
          fsub c1 Td1449
        in
        const.(Ti1439) <- Td1450
      in
      let Tu96 : UNIT =
        let Ti1451 : INT =
          int 2
        in
        let Td1462 : FLOAT =
          let Td1461 : FLOAT =
            let Td1460 : FLOAT =
              let Td1455 : FLOAT =
                let Td1453 : FLOAT =
                  let Ti1452 : INT =
                    int 2
                  in
                  v.(Ti1452)
                in
                let Td1454 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul Td1453 Td1454
              in
              let Td1459 : FLOAT =
                let Td1457 : FLOAT =
                  let Ti1456 : INT =
                    int 0
                  in
                  v.(Ti1456)
                in
                let Td1458 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1457 Td1458
              in
              fadd Td1455 Td1459
            in
            app
              fhalf
              Td1460
          in
          fsub c2 Td1461
        in
        const.(Ti1451) <- Td1462
      in
      let Ti1463 : INT =
        int 3
      in
      let Td1474 : FLOAT =
        let Td1473 : FLOAT =
          let Td1472 : FLOAT =
            let Td1467 : FLOAT =
              let Td1465 : FLOAT =
                let Ti1464 : INT =
                  int 1
                in
                v.(Ti1464)
              in
              let Td1466 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul Td1465 Td1466
            in
            let Td1471 : FLOAT =
              let Td1469 : FLOAT =
                let Ti1468 : INT =
                  int 0
                in
                v.(Ti1468)
              in
              let Td1470 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul Td1469 Td1470
            in
            fadd Td1467 Td1471
          in
          app
            fhalf
            Td1472
        in
        fsub c3 Td1473
      in
      const.(Ti1463) <- Td1474
  in
  let Tu100 : UNIT =
    if aa == 0.0 
      unit ()
      let Ti1475 : INT =
        int 4
      in
      let Td1477 : FLOAT =
        let Td1476 : FLOAT =
          float 1.
        in
        fdiv Td1476 aa
      in
      const.(Ti1475) <- Td1477
  in
  const
in
letrec iter_setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti1405 : INT =
    int 0
  in
  if Ti1405 <= index
    let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let dconst : Array of Array of FLOAT =
      app
        d_const
        dirvec
    in
    let v : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    let m_shape : INT =
      app
        o_form
        m
    in
    let Tu103 : UNIT =
      let Ti1406 : INT =
        int 1
      in
      if m_shape == Ti1406
        let Ta1407 : Array of FLOAT =
          app
            setup_rect_table
            v
            m
        in
        dconst.(index) <- Ta1407
        let Ti1408 : INT =
          int 2
        in
        if m_shape == Ti1408
          let Ta1409 : Array of FLOAT =
            app
              setup_surface_table
              v
              m
          in
          dconst.(index) <- Ta1409
          let Ta1410 : Array of FLOAT =
            app
              setup_second_table
              v
              m
          in
          dconst.(index) <- Ta1410
    in
    let Ti1412 : INT =
      let Ti1411 : INT =
        int 1
      in
      sub index Ti1411
    in
    app
      iter_setup_dirvec_constants
      dirvec
      Ti1412
    unit ()
in
letrec setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> UNIT) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Ti1404 : INT =
    let Ti1402 : INT =
      let Ti1401 : INT =
        int 0
      in
      n_objects.(Ti1401)
    in
    let Ti1403 : INT =
      int 1
    in
    sub Ti1402 Ti1403
  in
  app
    iter_setup_dirvec_constants
    dirvec
    Ti1404
in
letrec setup_startp_constants : (Array of FLOAT -> (INT -> UNIT)) =
variables : (p : Array of FLOAT), (index : INT)
  let Ti1362 : INT =
    int 0
  in
  if Ti1362 <= index
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let sconst : Array of FLOAT =
      app
        o_param_ctbl
        obj
    in
    let m_shape : INT =
      app
        o_form
        obj
    in
    let Tu107 : UNIT =
      let Ti1363 : INT =
        int 0
      in
      let Td1367 : FLOAT =
        let Td1365 : FLOAT =
          let Ti1364 : INT =
            int 0
          in
          p.(Ti1364)
        in
        let Td1366 : FLOAT =
          app
            o_param_x
            obj
        in
        fsub Td1365 Td1366
      in
      sconst.(Ti1363) <- Td1367
    in
    let Tu106 : UNIT =
      let Ti1368 : INT =
        int 1
      in
      let Td1372 : FLOAT =
        let Td1370 : FLOAT =
          let Ti1369 : INT =
            int 1
          in
          p.(Ti1369)
        in
        let Td1371 : FLOAT =
          app
            o_param_y
            obj
        in
        fsub Td1370 Td1371
      in
      sconst.(Ti1368) <- Td1372
    in
    let Tu105 : UNIT =
      let Ti1373 : INT =
        int 2
      in
      let Td1377 : FLOAT =
        let Td1375 : FLOAT =
          let Ti1374 : INT =
            int 2
          in
          p.(Ti1374)
        in
        let Td1376 : FLOAT =
          app
            o_param_z
            obj
        in
        fsub Td1375 Td1376
      in
      sconst.(Ti1373) <- Td1377
    in
    let Tu104 : UNIT =
      let Ti1378 : INT =
        int 2
      in
      if m_shape == Ti1378
        let Ti1379 : INT =
          int 3
        in
        let Td1387 : FLOAT =
          let Ta1380 : Array of FLOAT =
            app
              o_param_abc
              obj
          in
          let Td1382 : FLOAT =
            let Ti1381 : INT =
              int 0
            in
            sconst.(Ti1381)
          in
          let Td1384 : FLOAT =
            let Ti1383 : INT =
              int 1
            in
            sconst.(Ti1383)
          in
          let Td1386 : FLOAT =
            let Ti1385 : INT =
              int 2
            in
            sconst.(Ti1385)
          in
          app
            veciprod2
            Ta1380
            Td1382
            Td1384
            Td1386
        in
        sconst.(Ti1379) <- Td1387
        let Ti1388 : INT =
          int 2
        in
        if m_shape <= Ti1388
          unit ()
          let cc0 : FLOAT =
            let Td1390 : FLOAT =
              let Ti1389 : INT =
                int 0
              in
              sconst.(Ti1389)
            in
            let Td1392 : FLOAT =
              let Ti1391 : INT =
                int 1
              in
              sconst.(Ti1391)
            in
            let Td1394 : FLOAT =
              let Ti1393 : INT =
                int 2
              in
              sconst.(Ti1393)
            in
            app
              quadratic
              obj
              Td1390
              Td1392
              Td1394
          in
          let Ti1395 : INT =
            int 3
          in
          let Td1398 : FLOAT =
            let Ti1396 : INT =
              int 3
            in
            if m_shape == Ti1396
              let Td1397 : FLOAT =
                float 1.
              in
              fsub cc0 Td1397
              cc0
          in
          sconst.(Ti1395) <- Td1398
    in
    let Ti1400 : INT =
      let Ti1399 : INT =
        int 1
      in
      sub index Ti1399
    in
    app
      setup_startp_constants
      p
      Ti1400
    unit ()
in
letrec setup_startp : (Array of FLOAT -> UNIT) =
variables : (p : Array of FLOAT)
  let Tu108 : UNIT =
    app
      veccpy
      startp_fast
      p
  in
  let Ti1361 : INT =
    let Ti1359 : INT =
      let Ti1358 : INT =
        int 0
      in
      n_objects.(Ti1358)
    in
    let Ti1360 : INT =
      int 1
    in
    sub Ti1359 Ti1360
  in
  app
    setup_startp_constants
    p
    Ti1361
in
letrec is_rect_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let Ti1354 : INT =
    let Tb1346 : BOOL =
      let Td1344 : FLOAT =
        app
          fabs
          p0
      in
      let Td1345 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fless
        Td1344
        Td1345
    in
    let Ti1347 : INT =
      int 0
    in
    if Tb1346 == Ti1347
      int 0
      let Tb1350 : BOOL =
        let Td1348 : FLOAT =
          app
            fabs
            p1
        in
        let Td1349 : FLOAT =
          app
            o_param_b
            m
        in
        app
          fless
          Td1348
          Td1349
      in
      let Ti1351 : INT =
        int 0
      in
      if Tb1350 == Ti1351
        int 0
        let Td1352 : FLOAT =
          app
            fabs
            p2
        in
        let Td1353 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1352
          Td1353
  in
  let Ti1355 : INT =
    int 0
  in
  if Ti1354 == Ti1355
    let Tb1356 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1357 : INT =
      int 0
    in
    if Tb1356 == Ti1357
      int 1
      int 0
    app
      o_isinvert
      m
in
letrec is_plane_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    let Ta1339 : Array of FLOAT =
      app
        o_param_abc
        m
    in
    app
      veciprod2
      Ta1339
      p0
      p1
      p2
  in
  let Tb1342 : BOOL =
    let Tb1340 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1341 : BOOL =
      app
        fisneg
        w
    in
    app
      xor
      Tb1340
      Tb1341
  in
  let Ti1343 : INT =
    int 0
  in
  if Tb1342 == Ti1343
    int 1
    int 0
in
letrec is_second_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    app
      quadratic
      m
      p0
      p1
      p2
  in
  let w2 : FLOAT =
    let Ti1332 : INT =
      app
        o_form
        m
    in
    let Ti1333 : INT =
      int 3
    in
    if Ti1332 == Ti1333
      let Td1334 : FLOAT =
        float 1.
      in
      fsub w Td1334
      w
  in
  let Tb1337 : BOOL =
    let Tb1335 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1336 : BOOL =
      app
        fisneg
        w2
    in
    app
      xor
      Tb1335
      Tb1336
  in
  let Ti1338 : INT =
    int 0
  in
  if Tb1337 == Ti1338
    int 1
    int 0
in
letrec is_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let p0 : FLOAT =
    let Td1327 : FLOAT =
      app
        o_param_x
        m
    in
    fsub q0 Td1327
  in
  let p1 : FLOAT =
    let Td1328 : FLOAT =
      app
        o_param_y
        m
    in
    fsub q1 Td1328
  in
  let p2 : FLOAT =
    let Td1329 : FLOAT =
      app
        o_param_z
        m
    in
    fsub q2 Td1329
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1330 : INT =
    int 1
  in
  if m_shape == Ti1330
    app
      is_rect_outside
      m
      p0
      p1
      p2
    let Ti1331 : INT =
      int 2
    in
    if m_shape == Ti1331
      app
        is_plane_outside
        m
        p0
        p1
        p2
      app
        is_second_outside
        m
        p0
        p1
        p2
in
letrec check_all_inside : (INT -> (Array of INT -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL))))) =
variables : (ofs : INT), (iand : Array of INT), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let head : INT =
    iand.(ofs)
  in
  let Ti1321 : INT =
    let Ti1320 : INT =
      int 1
    in
    neg Ti1320
  in
  if head == Ti1321
    int 1
    let Tb1323 : BOOL =
      let Tt1322 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(head)
      in
      app
        is_outside
        Tt1322
        q0
        q1
        q2
    in
    let Ti1324 : INT =
      int 0
    in
    if Tb1323 == Ti1324
      let Ti1326 : INT =
        let Ti1325 : INT =
          int 1
        in
        add ofs Ti1325
      in
      app
        check_all_inside
        Ti1326
        iand
        q0
        q1
        q2
      int 0
in
letrec shadow_check_and_group : (INT -> (Array of INT -> BOOL)) =
variables : (iand_ofs : INT), (and_group : Array of INT)
  let Ti1286 : INT =
    and_group.(iand_ofs)
  in
  let Ti1288 : INT =
    let Ti1287 : INT =
      int 1
    in
    neg Ti1287
  in
  if Ti1286 == Ti1288
    int 0
    let obj : INT =
      and_group.(iand_ofs)
    in
    let t0 : INT =
      app
        solver_fast
        obj
        light_dirvec
        intersection_point
    in
    let t0p : FLOAT =
      let Ti1289 : INT =
        int 0
      in
      solver_dist.(Ti1289)
    in
    let Ti1292 : INT =
      let Ti1290 : INT =
        int 0
      in
      if t0 == Ti1290
        int 0
        let Td1291 : FLOAT =
          float -0.2
        in
        app
          fless
          t0p
          Td1291
    in
    let Ti1293 : INT =
      int 0
    in
    if Ti1292 == Ti1293
      let Tb1295 : BOOL =
        let Tt1294 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(obj)
        in
        app
          o_isinvert
          Tt1294
      in
      let Ti1296 : INT =
        int 0
      in
      if Tb1295 == Ti1296
        int 0
        let Ti1298 : INT =
          let Ti1297 : INT =
            int 1
          in
          add iand_ofs Ti1297
        in
        app
          shadow_check_and_group
          Ti1298
          and_group
      let t : FLOAT =
        let Td1299 : FLOAT =
          float 0.01
        in
        fadd t0p Td1299
      in
      let q0 : FLOAT =
        let Td1302 : FLOAT =
          let Td1301 : FLOAT =
            let Ti1300 : INT =
              int 0
            in
            light.(Ti1300)
          in
          fmul Td1301 t
        in
        let Td1304 : FLOAT =
          let Ti1303 : INT =
            int 0
          in
          intersection_point.(Ti1303)
        in
        fadd Td1302 Td1304
      in
      let q1 : FLOAT =
        let Td1307 : FLOAT =
          let Td1306 : FLOAT =
            let Ti1305 : INT =
              int 1
            in
            light.(Ti1305)
          in
          fmul Td1306 t
        in
        let Td1309 : FLOAT =
          let Ti1308 : INT =
            int 1
          in
          intersection_point.(Ti1308)
        in
        fadd Td1307 Td1309
      in
      let q2 : FLOAT =
        let Td1312 : FLOAT =
          let Td1311 : FLOAT =
            let Ti1310 : INT =
              int 2
            in
            light.(Ti1310)
          in
          fmul Td1311 t
        in
        let Td1314 : FLOAT =
          let Ti1313 : INT =
            int 2
          in
          intersection_point.(Ti1313)
        in
        fadd Td1312 Td1314
      in
      let Tb1316 : BOOL =
        let Ti1315 : INT =
          int 0
        in
        app
          check_all_inside
          Ti1315
          and_group
          q0
          q1
          q2
      in
      let Ti1317 : INT =
        int 0
      in
      if Tb1316 == Ti1317
        let Ti1319 : INT =
          let Ti1318 : INT =
            int 1
          in
          add iand_ofs Ti1318
        in
        app
          shadow_check_and_group
          Ti1319
          and_group
        int 1
in
letrec shadow_check_one_or_group : (INT -> (Array of INT -> BOOL)) =
variables : (ofs : INT), (or_group : Array of INT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1281 : INT =
    let Ti1280 : INT =
      int 1
    in
    neg Ti1280
  in
  if head == Ti1281
    int 0
    let and_group : Array of INT =
      and_net.(head)
    in
    let shadow_p : BOOL =
      let Ti1282 : INT =
        int 0
      in
      app
        shadow_check_and_group
        Ti1282
        and_group
    in
    let Ti1283 : INT =
      int 0
    in
    if shadow_p == Ti1283
      let Ti1285 : INT =
        let Ti1284 : INT =
          int 1
        in
        add ofs Ti1284
      in
      app
        shadow_check_one_or_group
        Ti1285
        or_group
      int 1
in
letrec shadow_check_one_or_matrix : (INT -> (Array of Array of INT -> BOOL)) =
variables : (ofs : INT), (or_matrix : Array of Array of INT)
  let head : Array of INT =
    or_matrix.(ofs)
  in
  let range_primitive : INT =
    let Ti1258 : INT =
      int 0
    in
    head.(Ti1258)
  in
  let Ti1260 : INT =
    let Ti1259 : INT =
      int 1
    in
    neg Ti1259
  in
  if range_primitive == Ti1260
    int 0
    let Ti1271 : INT =
      let Ti1261 : INT =
        int 99
      in
      if range_primitive == Ti1261
        int 1
        let t : INT =
          app
            solver_fast
            range_primitive
            light_dirvec
            intersection_point
        in
        let Ti1262 : INT =
          int 0
        in
        if t == Ti1262
          int 0
          let Tb1266 : BOOL =
            let Td1264 : FLOAT =
              let Ti1263 : INT =
                int 0
              in
              solver_dist.(Ti1263)
            in
            let Td1265 : FLOAT =
              float -0.1
            in
            app
              fless
              Td1264
              Td1265
          in
          let Ti1267 : INT =
            int 0
          in
          if Tb1266 == Ti1267
            int 0
            let Tb1269 : BOOL =
              let Ti1268 : INT =
                int 1
              in
              app
                shadow_check_one_or_group
                Ti1268
                head
            in
            let Ti1270 : INT =
              int 0
            in
            if Tb1269 == Ti1270
              int 0
              int 1
    in
    let Ti1272 : INT =
      int 0
    in
    if Ti1271 == Ti1272
      let Ti1274 : INT =
        let Ti1273 : INT =
          int 1
        in
        add ofs Ti1273
      in
      app
        shadow_check_one_or_matrix
        Ti1274
        or_matrix
      let Tb1276 : BOOL =
        let Ti1275 : INT =
          int 1
        in
        app
          shadow_check_one_or_group
          Ti1275
          head
      in
      let Ti1277 : INT =
        int 0
      in
      if Tb1276 == Ti1277
        let Ti1279 : INT =
          let Ti1278 : INT =
            int 1
          in
          add ofs Ti1278
        in
        app
          shadow_check_one_or_matrix
          Ti1279
          or_matrix
        int 1
in
letrec solve_each_element : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : Array of FLOAT)
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1219 : INT =
    let Ti1218 : INT =
      int 1
    in
    neg Ti1218
  in
  if iobj == Ti1219
    unit ()
    let t0 : INT =
      app
        solver
        iobj
        dirvec
        startp
    in
    let Ti1220 : INT =
      int 0
    in
    if t0 == Ti1220
      let Tb1222 : BOOL =
        let Tt1221 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1221
      in
      let Ti1223 : INT =
        int 0
      in
      if Tb1222 == Ti1223
        unit ()
        let Ti1225 : INT =
          let Ti1224 : INT =
            int 1
          in
          add iand_ofs Ti1224
        in
        app
          solve_each_element
          Ti1225
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1226 : INT =
          int 0
        in
        solver_dist.(Ti1226)
      in
      let Tu112 : UNIT =
        let Tb1228 : BOOL =
          let Td1227 : FLOAT =
            float 0.
          in
          app
            fless
            Td1227
            t0p
        in
        let Ti1229 : INT =
          int 0
        in
        if Tb1228 == Ti1229
          unit ()
          let Tb1232 : BOOL =
            let Td1231 : FLOAT =
              let Ti1230 : INT =
                int 0
              in
              tmin.(Ti1230)
            in
            app
              fless
              t0p
              Td1231
          in
          let Ti1233 : INT =
            int 0
          in
          if Tb1232 == Ti1233
            unit ()
            let t : FLOAT =
              let Td1234 : FLOAT =
                float 0.01
              in
              fadd t0p Td1234
            in
            let q0 : FLOAT =
              let Td1237 : FLOAT =
                let Td1236 : FLOAT =
                  let Ti1235 : INT =
                    int 0
                  in
                  dirvec.(Ti1235)
                in
                fmul Td1236 t
              in
              let Td1239 : FLOAT =
                let Ti1238 : INT =
                  int 0
                in
                startp.(Ti1238)
              in
              fadd Td1237 Td1239
            in
            let q1 : FLOAT =
              let Td1242 : FLOAT =
                let Td1241 : FLOAT =
                  let Ti1240 : INT =
                    int 1
                  in
                  dirvec.(Ti1240)
                in
                fmul Td1241 t
              in
              let Td1244 : FLOAT =
                let Ti1243 : INT =
                  int 1
                in
                startp.(Ti1243)
              in
              fadd Td1242 Td1244
            in
            let q2 : FLOAT =
              let Td1247 : FLOAT =
                let Td1246 : FLOAT =
                  let Ti1245 : INT =
                    int 2
                  in
                  dirvec.(Ti1245)
                in
                fmul Td1246 t
              in
              let Td1249 : FLOAT =
                let Ti1248 : INT =
                  int 2
                in
                startp.(Ti1248)
              in
              fadd Td1247 Td1249
            in
            let Tb1251 : BOOL =
              let Ti1250 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1250
                and_group
                q0
                q1
                q2
            in
            let Ti1252 : INT =
              int 0
            in
            if Tb1251 == Ti1252
              unit ()
              let Tu111 : UNIT =
                let Ti1253 : INT =
                  int 0
                in
                tmin.(Ti1253) <- t
              in
              let Tu110 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu109 : UNIT =
                let Ti1254 : INT =
                  int 0
                in
                intersected_object_id.(Ti1254) <- iobj
              in
              let Ti1255 : INT =
                int 0
              in
              intsec_rectside.(Ti1255) <- t0
      in
      let Ti1257 : INT =
        let Ti1256 : INT =
          int 1
        in
        add iand_ofs Ti1256
      in
      app
        solve_each_element
        Ti1257
        and_group
        dirvec
in
letrec solve_one_or_network : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : Array of FLOAT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1214 : INT =
    let Ti1213 : INT =
      int 1
    in
    neg Ti1213
  in
  if head == Ti1214
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu113 : UNIT =
      let Ti1215 : INT =
        int 0
      in
      app
        solve_each_element
        Ti1215
        and_group
        dirvec
    in
    let Ti1217 : INT =
      let Ti1216 : INT =
        int 1
      in
      add ofs Ti1216
    in
    app
      solve_one_or_network
      Ti1217
      or_group
      dirvec
in
letrec trace_or_matrix : (INT -> (Array of Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : Array of FLOAT)
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1199 : INT =
      int 0
    in
    head.(Ti1199)
  in
  let Ti1201 : INT =
    let Ti1200 : INT =
      int 1
    in
    neg Ti1200
  in
  if range_primitive == Ti1201
    unit ()
    let Tu114 : UNIT =
      let Ti1202 : INT =
        int 99
      in
      if range_primitive == Ti1202
        let Ti1203 : INT =
          int 1
        in
        app
          solve_one_or_network
          Ti1203
          head
          dirvec
        let t : INT =
          app
            solver
            range_primitive
            dirvec
            startp
        in
        let Ti1204 : INT =
          int 0
        in
        if t == Ti1204
          unit ()
          let tp : FLOAT =
            let Ti1205 : INT =
              int 0
            in
            solver_dist.(Ti1205)
          in
          let Tb1208 : BOOL =
            let Td1207 : FLOAT =
              let Ti1206 : INT =
                int 0
              in
              tmin.(Ti1206)
            in
            app
              fless
              tp
              Td1207
          in
          let Ti1209 : INT =
            int 0
          in
          if Tb1208 == Ti1209
            unit ()
            let Ti1210 : INT =
              int 1
            in
            app
              solve_one_or_network
              Ti1210
              head
              dirvec
    in
    let Ti1212 : INT =
      let Ti1211 : INT =
        int 1
      in
      add ofs Ti1211
    in
    app
      trace_or_matrix
      Ti1212
      or_network
      dirvec
in
letrec judge_intersection : (Array of FLOAT -> BOOL) =
variables : (dirvec : Array of FLOAT)
  let Tu116 : UNIT =
    let Ti1189 : INT =
      int 0
    in
    let Td1190 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1189) <- Td1190
  in
  let Tu115 : UNIT =
    let Ti1191 : INT =
      int 0
    in
    let Ta1193 : Array of Array of INT =
      let Ti1192 : INT =
        int 0
      in
      or_net.(Ti1192)
    in
    app
      trace_or_matrix
      Ti1191
      Ta1193
      dirvec
  in
  let t : FLOAT =
    let Ti1194 : INT =
      int 0
    in
    tmin.(Ti1194)
  in
  let Tb1196 : BOOL =
    let Td1195 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1195
      t
  in
  let Ti1197 : INT =
    int 0
  in
  if Tb1196 == Ti1197
    int 0
    let Td1198 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1198
in
letrec solve_each_element_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let vec : Array of FLOAT =
    app
      d_vec
      dirvec
  in
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1150 : INT =
    let Ti1149 : INT =
      int 1
    in
    neg Ti1149
  in
  if iobj == Ti1150
    unit ()
    let t0 : INT =
      app
        solver_fast2
        iobj
        dirvec
    in
    let Ti1151 : INT =
      int 0
    in
    if t0 == Ti1151
      let Tb1153 : BOOL =
        let Tt1152 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1152
      in
      let Ti1154 : INT =
        int 0
      in
      if Tb1153 == Ti1154
        unit ()
        let Ti1156 : INT =
          let Ti1155 : INT =
            int 1
          in
          add iand_ofs Ti1155
        in
        app
          solve_each_element_fast
          Ti1156
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1157 : INT =
          int 0
        in
        solver_dist.(Ti1157)
      in
      let Tu120 : UNIT =
        let Tb1159 : BOOL =
          let Td1158 : FLOAT =
            float 0.
          in
          app
            fless
            Td1158
            t0p
        in
        let Ti1160 : INT =
          int 0
        in
        if Tb1159 == Ti1160
          unit ()
          let Tb1163 : BOOL =
            let Td1162 : FLOAT =
              let Ti1161 : INT =
                int 0
              in
              tmin.(Ti1161)
            in
            app
              fless
              t0p
              Td1162
          in
          let Ti1164 : INT =
            int 0
          in
          if Tb1163 == Ti1164
            unit ()
            let t : FLOAT =
              let Td1165 : FLOAT =
                float 0.01
              in
              fadd t0p Td1165
            in
            let q0 : FLOAT =
              let Td1168 : FLOAT =
                let Td1167 : FLOAT =
                  let Ti1166 : INT =
                    int 0
                  in
                  vec.(Ti1166)
                in
                fmul Td1167 t
              in
              let Td1170 : FLOAT =
                let Ti1169 : INT =
                  int 0
                in
                startp_fast.(Ti1169)
              in
              fadd Td1168 Td1170
            in
            let q1 : FLOAT =
              let Td1173 : FLOAT =
                let Td1172 : FLOAT =
                  let Ti1171 : INT =
                    int 1
                  in
                  vec.(Ti1171)
                in
                fmul Td1172 t
              in
              let Td1175 : FLOAT =
                let Ti1174 : INT =
                  int 1
                in
                startp_fast.(Ti1174)
              in
              fadd Td1173 Td1175
            in
            let q2 : FLOAT =
              let Td1178 : FLOAT =
                let Td1177 : FLOAT =
                  let Ti1176 : INT =
                    int 2
                  in
                  vec.(Ti1176)
                in
                fmul Td1177 t
              in
              let Td1180 : FLOAT =
                let Ti1179 : INT =
                  int 2
                in
                startp_fast.(Ti1179)
              in
              fadd Td1178 Td1180
            in
            let Tb1182 : BOOL =
              let Ti1181 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1181
                and_group
                q0
                q1
                q2
            in
            let Ti1183 : INT =
              int 0
            in
            if Tb1182 == Ti1183
              unit ()
              let Tu119 : UNIT =
                let Ti1184 : INT =
                  int 0
                in
                tmin.(Ti1184) <- t
              in
              let Tu118 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu117 : UNIT =
                let Ti1185 : INT =
                  int 0
                in
                intersected_object_id.(Ti1185) <- iobj
              in
              let Ti1186 : INT =
                int 0
              in
              intsec_rectside.(Ti1186) <- t0
      in
      let Ti1188 : INT =
        let Ti1187 : INT =
          int 1
        in
        add iand_ofs Ti1187
      in
      app
        solve_each_element_fast
        Ti1188
        and_group
        dirvec
in
letrec solve_one_or_network_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : INT =
    or_group.(ofs)
  in
  let Ti1145 : INT =
    let Ti1144 : INT =
      int 1
    in
    neg Ti1144
  in
  if head == Ti1145
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu121 : UNIT =
      let Ti1146 : INT =
        int 0
      in
      app
        solve_each_element_fast
        Ti1146
        and_group
        dirvec
    in
    let Ti1148 : INT =
      let Ti1147 : INT =
        int 1
      in
      add ofs Ti1147
    in
    app
      solve_one_or_network_fast
      Ti1148
      or_group
      dirvec
in
letrec trace_or_matrix_fast : (INT -> (Array of Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1130 : INT =
      int 0
    in
    head.(Ti1130)
  in
  let Ti1132 : INT =
    let Ti1131 : INT =
      int 1
    in
    neg Ti1131
  in
  if range_primitive == Ti1132
    unit ()
    let Tu122 : UNIT =
      let Ti1133 : INT =
        int 99
      in
      if range_primitive == Ti1133
        let Ti1134 : INT =
          int 1
        in
        app
          solve_one_or_network_fast
          Ti1134
          head
          dirvec
        let t : INT =
          app
            solver_fast2
            range_primitive
            dirvec
        in
        let Ti1135 : INT =
          int 0
        in
        if t == Ti1135
          unit ()
          let tp : FLOAT =
            let Ti1136 : INT =
              int 0
            in
            solver_dist.(Ti1136)
          in
          let Tb1139 : BOOL =
            let Td1138 : FLOAT =
              let Ti1137 : INT =
                int 0
              in
              tmin.(Ti1137)
            in
            app
              fless
              tp
              Td1138
          in
          let Ti1140 : INT =
            int 0
          in
          if Tb1139 == Ti1140
            unit ()
            let Ti1141 : INT =
              int 1
            in
            app
              solve_one_or_network_fast
              Ti1141
              head
              dirvec
    in
    let Ti1143 : INT =
      let Ti1142 : INT =
        int 1
      in
      add ofs Ti1142
    in
    app
      trace_or_matrix_fast
      Ti1143
      or_network
      dirvec
in
letrec judge_intersection_fast : ((Array of FLOAT * Array of Array of FLOAT) -> BOOL) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Tu124 : UNIT =
    let Ti1120 : INT =
      int 0
    in
    let Td1121 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1120) <- Td1121
  in
  let Tu123 : UNIT =
    let Ti1122 : INT =
      int 0
    in
    let Ta1124 : Array of Array of INT =
      let Ti1123 : INT =
        int 0
      in
      or_net.(Ti1123)
    in
    app
      trace_or_matrix_fast
      Ti1122
      Ta1124
      dirvec
  in
  let t : FLOAT =
    let Ti1125 : INT =
      int 0
    in
    tmin.(Ti1125)
  in
  let Tb1127 : BOOL =
    let Td1126 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1126
      t
  in
  let Ti1128 : INT =
    int 0
  in
  if Tb1127 == Ti1128
    int 0
    let Td1129 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1129
in
letrec get_nvector_rect : (Array of FLOAT -> UNIT) =
variables : (dirvec : Array of FLOAT)
  let rectside : INT =
    let Ti1112 : INT =
      int 0
    in
    intsec_rectside.(Ti1112)
  in
  let Tu125 : UNIT =
    app
      vecbzero
      nvector
  in
  let Ti1114 : INT =
    let Ti1113 : INT =
      int 1
    in
    sub rectside Ti1113
  in
  let Td1119 : FLOAT =
    let Td1118 : FLOAT =
      let Td1117 : FLOAT =
        let Ti1116 : INT =
          let Ti1115 : INT =
            int 1
          in
          sub rectside Ti1115
        in
        dirvec.(Ti1116)
      in
      app
        sgn
        Td1117
    in
    app
      fneg
      Td1118
  in
  nvector.(Ti1114) <- Td1119
in
letrec get_nvector_plane : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let Tu127 : UNIT =
    let Ti1103 : INT =
      int 0
    in
    let Td1105 : FLOAT =
      let Td1104 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fneg
        Td1104
    in
    nvector.(Ti1103) <- Td1105
  in
  let Tu126 : UNIT =
    let Ti1106 : INT =
      int 1
    in
    let Td1108 : FLOAT =
      let Td1107 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fneg
        Td1107
    in
    nvector.(Ti1106) <- Td1108
  in
  let Ti1109 : INT =
    int 2
  in
  let Td1111 : FLOAT =
    let Td1110 : FLOAT =
      app
        o_param_c
        m
    in
    app
      fneg
      Td1110
  in
  nvector.(Ti1109) <- Td1111
in
letrec get_nvector_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let p0 : FLOAT =
    let Td1062 : FLOAT =
      let Ti1061 : INT =
        int 0
      in
      intersection_point.(Ti1061)
    in
    let Td1063 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1062 Td1063
  in
  let p1 : FLOAT =
    let Td1065 : FLOAT =
      let Ti1064 : INT =
        int 1
      in
      intersection_point.(Ti1064)
    in
    let Td1066 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1065 Td1066
  in
  let p2 : FLOAT =
    let Td1068 : FLOAT =
      let Ti1067 : INT =
        int 2
      in
      intersection_point.(Ti1067)
    in
    let Td1069 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1068 Td1069
  in
  let d0 : FLOAT =
    let Td1070 : FLOAT =
      app
        o_param_a
        m
    in
    fmul p0 Td1070
  in
  let d1 : FLOAT =
    let Td1071 : FLOAT =
      app
        o_param_b
        m
    in
    fmul p1 Td1071
  in
  let d2 : FLOAT =
    let Td1072 : FLOAT =
      app
        o_param_c
        m
    in
    fmul p2 Td1072
  in
  let Tu132 : UNIT =
    let Ti1073 : INT =
      app
        o_isrot
        m
    in
    let Ti1074 : INT =
      int 0
    in
    if Ti1073 == Ti1074
      let Tu129 : UNIT =
        let Ti1075 : INT =
          int 0
        in
        nvector.(Ti1075) <- d0
      in
      let Tu128 : UNIT =
        let Ti1076 : INT =
          int 1
        in
        nvector.(Ti1076) <- d1
      in
      let Ti1077 : INT =
        int 2
      in
      nvector.(Ti1077) <- d2
      let Tu131 : UNIT =
        let Ti1078 : INT =
          int 0
        in
        let Td1085 : FLOAT =
          let Td1084 : FLOAT =
            let Td1083 : FLOAT =
              let Td1080 : FLOAT =
                let Td1079 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p1 Td1079
              in
              let Td1082 : FLOAT =
                let Td1081 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul p2 Td1081
              in
              fadd Td1080 Td1082
            in
            app
              fhalf
              Td1083
          in
          fadd d0 Td1084
        in
        nvector.(Ti1078) <- Td1085
      in
      let Tu130 : UNIT =
        let Ti1086 : INT =
          int 1
        in
        let Td1093 : FLOAT =
          let Td1092 : FLOAT =
            let Td1091 : FLOAT =
              let Td1088 : FLOAT =
                let Td1087 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p0 Td1087
              in
              let Td1090 : FLOAT =
                let Td1089 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul p2 Td1089
              in
              fadd Td1088 Td1090
            in
            app
              fhalf
              Td1091
          in
          fadd d1 Td1092
        in
        nvector.(Ti1086) <- Td1093
      in
      let Ti1094 : INT =
        int 2
      in
      let Td1101 : FLOAT =
        let Td1100 : FLOAT =
          let Td1099 : FLOAT =
            let Td1096 : FLOAT =
              let Td1095 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul p0 Td1095
            in
            let Td1098 : FLOAT =
              let Td1097 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul p1 Td1097
            in
            fadd Td1096 Td1098
          in
          app
            fhalf
            Td1099
        in
        fadd d2 Td1100
      in
      nvector.(Ti1094) <- Td1101
  in
  let Tb1102 : BOOL =
    app
      o_isinvert
      m
  in
  app
    vecunit_sgn
    nvector
    Tb1102
in
letrec get_nvector : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT)
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1059 : INT =
    int 1
  in
  if m_shape == Ti1059
    app
      get_nvector_rect
      dirvec
    let Ti1060 : INT =
      int 2
    in
    if m_shape == Ti1060
      app
        get_nvector_plane
        m
      app
        get_nvector_second
        m
in
letrec utexture : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p : Array of FLOAT)
  let m_tex : INT =
    app
      o_texturetype
      m
  in
  let Tu137 : UNIT =
    let Ti935 : INT =
      int 0
    in
    let Td936 : FLOAT =
      app
        o_color_red
        m
    in
    texture_color.(Ti935) <- Td936
  in
  let Tu136 : UNIT =
    let Ti937 : INT =
      int 1
    in
    let Td938 : FLOAT =
      app
        o_color_green
        m
    in
    texture_color.(Ti937) <- Td938
  in
  let Tu135 : UNIT =
    let Ti939 : INT =
      int 2
    in
    let Td940 : FLOAT =
      app
        o_color_blue
        m
    in
    texture_color.(Ti939) <- Td940
  in
  let Ti941 : INT =
    int 1
  in
  if m_tex == Ti941
    let w1 : FLOAT =
      let Td943 : FLOAT =
        let Ti942 : INT =
          int 0
        in
        p.(Ti942)
      in
      let Td944 : FLOAT =
        app
          o_param_x
          m
      in
      fsub Td943 Td944
    in
    let flag1 : BOOL =
      let d1 : FLOAT =
        let Td947 : FLOAT =
          let Td946 : FLOAT =
            let Td945 : FLOAT =
              float 0.05
            in
            fmul w1 Td945
          in
          app
            floor
            Td946
        in
        let Td948 : FLOAT =
          float 20.
        in
        fmul Td947 Td948
      in
      let Td949 : FLOAT =
        fsub w1 d1
      in
      let Td950 : FLOAT =
        float 10.
      in
      app
        fless
        Td949
        Td950
    in
    let w3 : FLOAT =
      let Td952 : FLOAT =
        let Ti951 : INT =
          int 2
        in
        p.(Ti951)
      in
      let Td953 : FLOAT =
        app
          o_param_z
          m
      in
      fsub Td952 Td953
    in
    let flag2 : BOOL =
      let d2 : FLOAT =
        let Td956 : FLOAT =
          let Td955 : FLOAT =
            let Td954 : FLOAT =
              float 0.05
            in
            fmul w3 Td954
          in
          app
            floor
            Td955
        in
        let Td957 : FLOAT =
          float 20.
        in
        fmul Td956 Td957
      in
      let Td958 : FLOAT =
        fsub w3 d2
      in
      let Td959 : FLOAT =
        float 10.
      in
      app
        fless
        Td958
        Td959
    in
    let Ti960 : INT =
      int 1
    in
    let Td964 : FLOAT =
      let Ti961 : INT =
        int 0
      in
      if flag1 == Ti961
        let Ti962 : INT =
          int 0
        in
        if flag2 == Ti962
          float 255.
          float 0.
        let Ti963 : INT =
          int 0
        in
        if flag2 == Ti963
          float 0.
          float 255.
    in
    texture_color.(Ti960) <- Td964
    let Ti965 : INT =
      int 2
    in
    if m_tex == Ti965
      let w2 : FLOAT =
        let Td970 : FLOAT =
          let Td969 : FLOAT =
            let Td967 : FLOAT =
              let Ti966 : INT =
                int 1
              in
              p.(Ti966)
            in
            let Td968 : FLOAT =
              float 0.25
            in
            fmul Td967 Td968
          in
          app
            sin
            Td969
        in
        app
          fsqr
          Td970
      in
      let Tu133 : UNIT =
        let Ti971 : INT =
          int 0
        in
        let Td973 : FLOAT =
          let Td972 : FLOAT =
            float 255.
          in
          fmul Td972 w2
        in
        texture_color.(Ti971) <- Td973
      in
      let Ti974 : INT =
        int 1
      in
      let Td978 : FLOAT =
        let Td975 : FLOAT =
          float 255.
        in
        let Td977 : FLOAT =
          let Td976 : FLOAT =
            float 1.
          in
          fsub Td976 w2
        in
        fmul Td975 Td977
      in
      texture_color.(Ti974) <- Td978
      let Ti979 : INT =
        int 3
      in
      if m_tex == Ti979
        let w1 : FLOAT =
          let Td981 : FLOAT =
            let Ti980 : INT =
              int 0
            in
            p.(Ti980)
          in
          let Td982 : FLOAT =
            app
              o_param_x
              m
          in
          fsub Td981 Td982
        in
        let w3 : FLOAT =
          let Td984 : FLOAT =
            let Ti983 : INT =
              int 2
            in
            p.(Ti983)
          in
          let Td985 : FLOAT =
            app
              o_param_z
              m
          in
          fsub Td984 Td985
        in
        let w2 : FLOAT =
          let Td989 : FLOAT =
            let Td988 : FLOAT =
              let Td986 : FLOAT =
                app
                  fsqr
                  w1
              in
              let Td987 : FLOAT =
                app
                  fsqr
                  w3
              in
              fadd Td986 Td987
            in
            app
              sqrt
              Td988
          in
          let Td990 : FLOAT =
            float 10.
          in
          fdiv Td989 Td990
        in
        let w4 : FLOAT =
          let Td992 : FLOAT =
            let Td991 : FLOAT =
              app
                floor
                w2
            in
            fsub w2 Td991
          in
          let Td993 : FLOAT =
            float 3.1415927
          in
          fmul Td992 Td993
        in
        let cws : FLOAT =
          let Td994 : FLOAT =
            app
              cos
              w4
          in
          app
            fsqr
            Td994
        in
        let Tu134 : UNIT =
          let Ti995 : INT =
            int 1
          in
          let Td997 : FLOAT =
            let Td996 : FLOAT =
              float 255.
            in
            fmul cws Td996
          in
          texture_color.(Ti995) <- Td997
        in
        let Ti998 : INT =
          int 2
        in
        let Td1002 : FLOAT =
          let Td1000 : FLOAT =
            let Td999 : FLOAT =
              float 1.
            in
            fsub Td999 cws
          in
          let Td1001 : FLOAT =
            float 255.
          in
          fmul Td1000 Td1001
        in
        texture_color.(Ti998) <- Td1002
        let Ti1003 : INT =
          int 4
        in
        if m_tex == Ti1003
          let w1 : FLOAT =
            let Td1007 : FLOAT =
              let Td1005 : FLOAT =
                let Ti1004 : INT =
                  int 0
                in
                p.(Ti1004)
              in
              let Td1006 : FLOAT =
                app
                  o_param_x
                  m
              in
              fsub Td1005 Td1006
            in
            let Td1009 : FLOAT =
              let Td1008 : FLOAT =
                app
                  o_param_a
                  m
              in
              app
                sqrt
                Td1008
            in
            fmul Td1007 Td1009
          in
          let w3 : FLOAT =
            let Td1013 : FLOAT =
              let Td1011 : FLOAT =
                let Ti1010 : INT =
                  int 2
                in
                p.(Ti1010)
              in
              let Td1012 : FLOAT =
                app
                  o_param_z
                  m
              in
              fsub Td1011 Td1012
            in
            let Td1015 : FLOAT =
              let Td1014 : FLOAT =
                app
                  o_param_c
                  m
              in
              app
                sqrt
                Td1014
            in
            fmul Td1013 Td1015
          in
          let w4 : FLOAT =
            let Td1016 : FLOAT =
              app
                fsqr
                w1
            in
            let Td1017 : FLOAT =
              app
                fsqr
                w3
            in
            fadd Td1016 Td1017
          in
          let w7 : FLOAT =
            let Tb1020 : BOOL =
              let Td1018 : FLOAT =
                app
                  fabs
                  w1
              in
              let Td1019 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1018
                Td1019
            in
            let Ti1021 : INT =
              int 0
            in
            if Tb1020 == Ti1021
              let w5 : FLOAT =
                let Td1022 : FLOAT =
                  fdiv w3 w1
                in
                app
                  fabs
                  Td1022
              in
              let Td1025 : FLOAT =
                let Td1023 : FLOAT =
                  app
                    atan
                    w5
                in
                let Td1024 : FLOAT =
                  float 30.
                in
                fmul Td1023 Td1024
              in
              let Td1026 : FLOAT =
                float 3.1415927
              in
              fdiv Td1025 Td1026
              float 15.
          in
          let w9 : FLOAT =
            let Td1027 : FLOAT =
              app
                floor
                w7
            in
            fsub w7 Td1027
          in
          let w2 : FLOAT =
            let Td1031 : FLOAT =
              let Td1029 : FLOAT =
                let Ti1028 : INT =
                  int 1
                in
                p.(Ti1028)
              in
              let Td1030 : FLOAT =
                app
                  o_param_y
                  m
              in
              fsub Td1029 Td1030
            in
            let Td1033 : FLOAT =
              let Td1032 : FLOAT =
                app
                  o_param_b
                  m
              in
              app
                sqrt
                Td1032
            in
            fmul Td1031 Td1033
          in
          let w8 : FLOAT =
            let Tb1036 : BOOL =
              let Td1034 : FLOAT =
                app
                  fabs
                  w4
              in
              let Td1035 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1034
                Td1035
            in
            let Ti1037 : INT =
              int 0
            in
            if Tb1036 == Ti1037
              let w6 : FLOAT =
                let Td1038 : FLOAT =
                  fdiv w2 w4
                in
                app
                  fabs
                  Td1038
              in
              let Td1041 : FLOAT =
                let Td1039 : FLOAT =
                  app
                    atan
                    w6
                in
                let Td1040 : FLOAT =
                  float 30.
                in
                fmul Td1039 Td1040
              in
              let Td1042 : FLOAT =
                float 3.1415927
              in
              fdiv Td1041 Td1042
              float 15.
          in
          let w10 : FLOAT =
            let Td1043 : FLOAT =
              app
                floor
                w8
            in
            fsub w8 Td1043
          in
          let w11 : FLOAT =
            let Td1048 : FLOAT =
              let Td1044 : FLOAT =
                float 0.15
              in
              let Td1047 : FLOAT =
                let Td1046 : FLOAT =
                  let Td1045 : FLOAT =
                    float 0.5
                  in
                  fsub Td1045 w9
                in
                app
                  fsqr
                  Td1046
              in
              fsub Td1044 Td1047
            in
            let Td1051 : FLOAT =
              let Td1050 : FLOAT =
                let Td1049 : FLOAT =
                  float 0.5
                in
                fsub Td1049 w10
              in
              app
                fsqr
                Td1050
            in
            fsub Td1048 Td1051
          in
          let w12 : FLOAT =
            let Tb1052 : BOOL =
              app
                fisneg
                w11
            in
            let Ti1053 : INT =
              int 0
            in
            if Tb1052 == Ti1053
              w11
              float 0.
          in
          let Ti1054 : INT =
            int 2
          in
          let Td1058 : FLOAT =
            let Td1056 : FLOAT =
              let Td1055 : FLOAT =
                float 255.
              in
              fmul Td1055 w12
            in
            let Td1057 : FLOAT =
              float 0.3
            in
            fdiv Td1056 Td1057
          in
          texture_color.(Ti1054) <- Td1058
          unit ()
in
letrec add_light : (FLOAT -> (FLOAT -> (FLOAT -> UNIT))) =
variables : (bright : FLOAT), (hilight : FLOAT), (hilight_scale : FLOAT)
  let Tu140 : UNIT =
    let Tb917 : BOOL =
      app
        fispos
        bright
    in
    let Ti918 : INT =
      int 0
    in
    if Tb917 == Ti918
      unit ()
      app
        vecaccum
        rgb
        bright
        texture_color
  in
  let Tb919 : BOOL =
    app
      fispos
      hilight
  in
  let Ti920 : INT =
    int 0
  in
  if Tb919 == Ti920
    unit ()
    let ihl : FLOAT =
      let Td922 : FLOAT =
        let Td921 : FLOAT =
          app
            fsqr
            hilight
        in
        app
          fsqr
          Td921
      in
      fmul Td922 hilight_scale
    in
    let Tu139 : UNIT =
      let Ti923 : INT =
        int 0
      in
      let Td926 : FLOAT =
        let Td925 : FLOAT =
          let Ti924 : INT =
            int 0
          in
          rgb.(Ti924)
        in
        fadd Td925 ihl
      in
      rgb.(Ti923) <- Td926
    in
    let Tu138 : UNIT =
      let Ti927 : INT =
        int 1
      in
      let Td930 : FLOAT =
        let Td929 : FLOAT =
          let Ti928 : INT =
            int 1
          in
          rgb.(Ti928)
        in
        fadd Td929 ihl
      in
      rgb.(Ti927) <- Td930
    in
    let Ti931 : INT =
      int 2
    in
    let Td934 : FLOAT =
      let Td933 : FLOAT =
        let Ti932 : INT =
          int 2
        in
        rgb.(Ti932)
      in
      fadd Td933 ihl
    in
    rgb.(Ti931) <- Td934
in
letrec trace_reflections : (INT -> (FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT)))) =
variables : (index : INT), (diffuse : FLOAT), (hilight_scale : FLOAT), (dirvec : Array of FLOAT)
  let Ti897 : INT =
    int 0
  in
  if Ti897 <= index
    let rinfo : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
      reflections.(index)
    in
    let dvec : (Array of FLOAT * Array of Array of FLOAT) =
      app
        r_dvec
        rinfo
    in
    let Tu141 : UNIT =
      let Tb898 : BOOL =
        app
          judge_intersection_fast
          dvec
      in
      let Ti899 : INT =
        int 0
      in
      if Tb898 == Ti899
        unit ()
        let surface_id : INT =
          let Ti902 : INT =
            let Ti901 : INT =
              let Ti900 : INT =
                int 0
              in
              intersected_object_id.(Ti900)
            in
            mul Ti901 4
          in
          let Ti904 : INT =
            let Ti903 : INT =
              int 0
            in
            intsec_rectside.(Ti903)
          in
          add Ti902 Ti904
        in
        let Ti905 : INT =
          app
            r_surface_id
            rinfo
        in
        if surface_id == Ti905
          let Tb909 : BOOL =
            let Ti906 : INT =
              int 0
            in
            let Ta908 : Array of Array of INT =
              let Ti907 : INT =
                int 0
              in
              or_net.(Ti907)
            in
            app
              shadow_check_one_or_matrix
              Ti906
              Ta908
          in
          let Ti910 : INT =
            int 0
          in
          if Tb909 == Ti910
            let p : FLOAT =
              let Ta911 : Array of FLOAT =
                app
                  d_vec
                  dvec
              in
              app
                veciprod
                nvector
                Ta911
            in
            let scale : FLOAT =
              app
                r_bright
                rinfo
            in
            let bright : FLOAT =
              let Td912 : FLOAT =
                fmul scale diffuse
              in
              fmul Td912 p
            in
            let hilight : FLOAT =
              let Td914 : FLOAT =
                let Ta913 : Array of FLOAT =
                  app
                    d_vec
                    dvec
                in
                app
                  veciprod
                  dirvec
                  Ta913
              in
              fmul scale Td914
            in
            app
              add_light
              bright
              hilight
              hilight_scale
            unit ()
          unit ()
    in
    let Ti916 : INT =
      let Ti915 : INT =
        int 1
      in
      sub index Ti915
    in
    app
      trace_reflections
      Ti916
      diffuse
      hilight_scale
      dirvec
    unit ()
in
letrec trace_ray : (INT -> (FLOAT -> (Array of FLOAT -> ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (FLOAT -> UNIT))))) =
variables : (nref : INT), (energy : FLOAT), (dirvec : Array of FLOAT), (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (dist : FLOAT)
  let Ti819 : INT =
    int 4
  in
  if nref <= Ti819
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Tb820 : BOOL =
      app
        judge_intersection
        dirvec
    in
    let Ti821 : INT =
      int 0
    in
    if Tb820 == Ti821
      let Tu158 : UNIT =
        let Ti823 : INT =
          let Ti822 : INT =
            int 1
          in
          neg Ti822
        in
        surface_ids.(nref) <- Ti823
      in
      let Ti824 : INT =
        int 0
      in
      if nref == Ti824
        unit ()
        let hl : FLOAT =
          let Td825 : FLOAT =
            app
              veciprod
              dirvec
              light
          in
          app
            fneg
            Td825
        in
        let Tb826 : BOOL =
          app
            fispos
            hl
        in
        let Ti827 : INT =
          int 0
        in
        if Tb826 == Ti827
          unit ()
          let ihl : FLOAT =
            let Td830 : FLOAT =
              let Td829 : FLOAT =
                let Td828 : FLOAT =
                  app
                    fsqr
                    hl
                in
                fmul Td828 hl
              in
              fmul Td829 energy
            in
            let Td832 : FLOAT =
              let Ti831 : INT =
                int 0
              in
              beam.(Ti831)
            in
            fmul Td830 Td832
          in
          let Tu157 : UNIT =
            let Ti833 : INT =
              int 0
            in
            let Td836 : FLOAT =
              let Td835 : FLOAT =
                let Ti834 : INT =
                  int 0
                in
                rgb.(Ti834)
              in
              fadd Td835 ihl
            in
            rgb.(Ti833) <- Td836
          in
          let Tu156 : UNIT =
            let Ti837 : INT =
              int 1
            in
            let Td840 : FLOAT =
              let Td839 : FLOAT =
                let Ti838 : INT =
                  int 1
                in
                rgb.(Ti838)
              in
              fadd Td839 ihl
            in
            rgb.(Ti837) <- Td840
          in
          let Ti841 : INT =
            int 2
          in
          let Td844 : FLOAT =
            let Td843 : FLOAT =
              let Ti842 : INT =
                int 2
              in
              rgb.(Ti842)
            in
            fadd Td843 ihl
          in
          rgb.(Ti841) <- Td844
      let obj_id : INT =
        let Ti845 : INT =
          int 0
        in
        intersected_object_id.(Ti845)
      in
      let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(obj_id)
      in
      let m_surface : INT =
        app
          o_reflectiontype
          obj
      in
      let diffuse : FLOAT =
        let Td846 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td846 energy
      in
      let Tu155 : UNIT =
        app
          get_nvector
          obj
          dirvec
      in
      let Tu154 : UNIT =
        app
          veccpy
          startp
          intersection_point
      in
      let Tu153 : UNIT =
        app
          utexture
          obj
          intersection_point
      in
      let Tu152 : UNIT =
        let Ti850 : INT =
          let Ti847 : INT =
            mul obj_id 4
          in
          let Ti849 : INT =
            let Ti848 : INT =
              int 0
            in
            intsec_rectside.(Ti848)
          in
          add Ti847 Ti849
        in
        surface_ids.(nref) <- Ti850
      in
      let intersection_points : Array of Array of FLOAT =
        app
          p_intersection_points
          pixel
      in
      let Tu151 : UNIT =
        let Ta851 : Array of FLOAT =
          intersection_points.(nref)
        in
        app
          veccpy
          Ta851
          intersection_point
      in
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu150 : UNIT =
        let Tb854 : BOOL =
          let Td852 : FLOAT =
            app
              o_diffuse
              obj
          in
          let Td853 : FLOAT =
            float 0.5
          in
          app
            fless
            Td852
            Td853
        in
        let Ti855 : INT =
          int 0
        in
        if Tb854 == Ti855
          let Tu144 : UNIT =
            let Ti856 : INT =
              int 1
            in
            calc_diffuse.(nref) <- Ti856
          in
          let energya : Array of Array of FLOAT =
            app
              p_energy
              pixel
          in
          let Tu143 : UNIT =
            let Ta857 : Array of FLOAT =
              energya.(nref)
            in
            app
              veccpy
              Ta857
              texture_color
          in
          let Tu142 : UNIT =
            let Ta858 : Array of FLOAT =
              energya.(nref)
            in
            let Td862 : FLOAT =
              let Td861 : FLOAT =
                let Td859 : FLOAT =
                  float 1.
                in
                let Td860 : FLOAT =
                  float 256.
                in
                fdiv Td859 Td860
              in
              fmul Td861 diffuse
            in
            app
              vecscale
              Ta858
              Td862
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let Ta863 : Array of FLOAT =
            nvectors.(nref)
          in
          app
            veccpy
            Ta863
            nvector
          let Ti864 : INT =
            int 0
          in
          calc_diffuse.(nref) <- Ti864
      in
      let w : FLOAT =
        let Td865 : FLOAT =
          float -2.
        in
        let Td866 : FLOAT =
          app
            veciprod
            dirvec
            nvector
        in
        fmul Td865 Td866
      in
      let Tu149 : UNIT =
        app
          vecaccum
          dirvec
          w
          nvector
      in
      let hilight_scale : FLOAT =
        let Td867 : FLOAT =
          app
            o_hilight
            obj
        in
        fmul energy Td867
      in
      let Tu148 : UNIT =
        let Tb871 : BOOL =
          let Ti868 : INT =
            int 0
          in
          let Ta870 : Array of Array of INT =
            let Ti869 : INT =
              int 0
            in
            or_net.(Ti869)
          in
          app
            shadow_check_one_or_matrix
            Ti868
            Ta870
        in
        let Ti872 : INT =
          int 0
        in
        if Tb871 == Ti872
          let bright : FLOAT =
            let Td874 : FLOAT =
              let Td873 : FLOAT =
                app
                  veciprod
                  nvector
                  light
              in
              app
                fneg
                Td873
            in
            fmul Td874 diffuse
          in
          let hilight : FLOAT =
            let Td875 : FLOAT =
              app
                veciprod
                dirvec
                light
            in
            app
              fneg
              Td875
          in
          app
            add_light
            bright
            hilight
            hilight_scale
          unit ()
      in
      let Tu147 : UNIT =
        app
          setup_startp
          intersection_point
      in
      let Tu146 : UNIT =
        let Ti879 : INT =
          let Ti877 : INT =
            let Ti876 : INT =
              int 0
            in
            n_reflections.(Ti876)
          in
          let Ti878 : INT =
            int 1
          in
          sub Ti877 Ti878
        in
        app
          trace_reflections
          Ti879
          diffuse
          hilight_scale
          dirvec
      in
      let Tb881 : BOOL =
        let Td880 : FLOAT =
          float 0.1
        in
        app
          fless
          Td880
          energy
      in
      let Ti882 : INT =
        int 0
      in
      if Tb881 == Ti882
        unit ()
        let Tu145 : UNIT =
          let Ti883 : INT =
            int 4
          in
          if Ti883 <= nref
            unit ()
            let Ti885 : INT =
              let Ti884 : INT =
                int 1
              in
              add nref Ti884
            in
            let Ti887 : INT =
              let Ti886 : INT =
                int 1
              in
              neg Ti886
            in
            surface_ids.(Ti885) <- Ti887
        in
        let Ti888 : INT =
          int 2
        in
        if m_surface == Ti888
          let energy2 : FLOAT =
            let Td891 : FLOAT =
              let Td889 : FLOAT =
                float 1.
              in
              let Td890 : FLOAT =
                app
                  o_diffuse
                  obj
              in
              fsub Td889 Td890
            in
            fmul energy Td891
          in
          let Ti893 : INT =
            let Ti892 : INT =
              int 1
            in
            add nref Ti892
          in
          let Td896 : FLOAT =
            let Td895 : FLOAT =
              let Ti894 : INT =
                int 0
              in
              tmin.(Ti894)
            in
            fadd dist Td895
          in
          app
            trace_ray
            Ti893
            energy2
            dirvec
            pixel
            Td896
          unit ()
    unit ()
in
letrec trace_diffuse_ray : ((Array of FLOAT * Array of Array of FLOAT) -> (FLOAT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (energy : FLOAT)
  let Tb803 : BOOL =
    app
      judge_intersection_fast
      dirvec
  in
  let Ti804 : INT =
    int 0
  in
  if Tb803 == Ti804
    unit ()
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      let Ti806 : INT =
        let Ti805 : INT =
          int 0
        in
        intersected_object_id.(Ti805)
      in
      objects.(Ti806)
    in
    let Tu160 : UNIT =
      let Ta807 : Array of FLOAT =
        app
          d_vec
          dirvec
      in
      app
        get_nvector
        obj
        Ta807
    in
    let Tu159 : UNIT =
      app
        utexture
        obj
        intersection_point
    in
    let Tb811 : BOOL =
      let Ti808 : INT =
        int 0
      in
      let Ta810 : Array of Array of INT =
        let Ti809 : INT =
          int 0
        in
        or_net.(Ti809)
      in
      app
        shadow_check_one_or_matrix
        Ti808
        Ta810
    in
    let Ti812 : INT =
      int 0
    in
    if Tb811 == Ti812
      let br : FLOAT =
        let Td813 : FLOAT =
          app
            veciprod
            nvector
            light
        in
        app
          fneg
          Td813
      in
      let bright : FLOAT =
        let Tb814 : BOOL =
          app
            fispos
            br
        in
        let Ti815 : INT =
          int 0
        in
        if Tb814 == Ti815
          float 0.
          br
      in
      let Td818 : FLOAT =
        let Td816 : FLOAT =
          fmul energy bright
        in
        let Td817 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td816 Td817
      in
      app
        vecaccum
        diffuse_ray
        Td818
        texture_color
      unit ()
in
letrec iter_trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (INT -> UNIT)))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT), (index : INT)
  let Ti788 : INT =
    int 0
  in
  if Ti788 <= index
    let p : FLOAT =
      let Ta790 : Array of FLOAT =
        let Tt789 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        app
          d_vec
          Tt789
      in
      app
        veciprod
        Ta790
        nvector
    in
    let Tu161 : UNIT =
      let Tb791 : BOOL =
        app
          fisneg
          p
      in
      let Ti792 : INT =
        int 0
      in
      if Tb791 == Ti792
        let Tt793 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        let Td795 : FLOAT =
          let Td794 : FLOAT =
            float 150.
          in
          fdiv p Td794
        in
        app
          trace_diffuse_ray
          Tt793
          Td795
        let Tt798 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti797 : INT =
            let Ti796 : INT =
              int 1
            in
            add index Ti796
          in
          dirvec_group.(Ti797)
        in
        let Td800 : FLOAT =
          let Td799 : FLOAT =
            float -150.
          in
          fdiv p Td799
        in
        app
          trace_diffuse_ray
          Tt798
          Td800
    in
    let Ti802 : INT =
      let Ti801 : INT =
        int 2
      in
      sub index Ti801
    in
    app
      iter_trace_diffuse_rays
      dirvec_group
      nvector
      org
      Ti802
    unit ()
in
letrec trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu162 : UNIT =
    app
      setup_startp
      org
  in
  let Ti787 : INT =
    int 118
  in
  app
    iter_trace_diffuse_rays
    dirvec_group
    nvector
    org
    Ti787
in
letrec trace_diffuse_ray_80percent : (INT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (group_id : INT), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu166 : UNIT =
    let Ti772 : INT =
      int 0
    in
    if group_id == Ti772
      unit ()
      let Ta774 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti773 : INT =
          int 0
        in
        dirvecs.(Ti773)
      in
      app
        trace_diffuse_rays
        Ta774
        nvector
        org
  in
  let Tu165 : UNIT =
    let Ti775 : INT =
      int 1
    in
    if group_id == Ti775
      unit ()
      let Ta777 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti776 : INT =
          int 1
        in
        dirvecs.(Ti776)
      in
      app
        trace_diffuse_rays
        Ta777
        nvector
        org
  in
  let Tu164 : UNIT =
    let Ti778 : INT =
      int 2
    in
    if group_id == Ti778
      unit ()
      let Ta780 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti779 : INT =
          int 2
        in
        dirvecs.(Ti779)
      in
      app
        trace_diffuse_rays
        Ta780
        nvector
        org
  in
  let Tu163 : UNIT =
    let Ti781 : INT =
      int 3
    in
    if group_id == Ti781
      unit ()
      let Ta783 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti782 : INT =
          int 3
        in
        dirvecs.(Ti782)
      in
      app
        trace_diffuse_rays
        Ta783
        nvector
        org
  in
  let Ti784 : INT =
    int 4
  in
  if group_id == Ti784
    unit ()
    let Ta786 : Array of (Array of FLOAT * Array of Array of FLOAT) =
      let Ti785 : INT =
        int 4
      in
      dirvecs.(Ti785)
    in
    app
      trace_diffuse_rays
      Ta786
      nvector
      org
in
letrec calc_diffuse_using_1point : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let ray20p : Array of Array of FLOAT =
    app
      p_received_ray_20percent
      pixel
  in
  let nvectors : Array of Array of FLOAT =
    app
      p_nvectors
      pixel
  in
  let intersection_points : Array of Array of FLOAT =
    app
      p_intersection_points
      pixel
  in
  let energya : Array of Array of FLOAT =
    app
      p_energy
      pixel
  in
  let Tu168 : UNIT =
    let Ta767 : Array of FLOAT =
      ray20p.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta767
  in
  let Tu167 : UNIT =
    let Ti768 : INT =
      app
        p_group_id
        pixel
    in
    let Ta769 : Array of FLOAT =
      nvectors.(nref)
    in
    let Ta770 : Array of FLOAT =
      intersection_points.(nref)
    in
    app
      trace_diffuse_ray_80percent
      Ti768
      Ta769
      Ta770
  in
  let Ta771 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta771
    diffuse_ray
in
letrec calc_diffuse_using_5points : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let r_up : Array of Array of FLOAT =
    let Tt751 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      p_received_ray_20percent
      Tt751
  in
  let r_left : Array of Array of FLOAT =
    let Tt754 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti753 : INT =
        let Ti752 : INT =
          int 1
        in
        sub x Ti752
      in
      cur.(Ti753)
    in
    app
      p_received_ray_20percent
      Tt754
  in
  let r_center : Array of Array of FLOAT =
    let Tt755 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_received_ray_20percent
      Tt755
  in
  let r_right : Array of Array of FLOAT =
    let Tt758 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti757 : INT =
        let Ti756 : INT =
          int 1
        in
        add x Ti756
      in
      cur.(Ti757)
    in
    app
      p_received_ray_20percent
      Tt758
  in
  let r_down : Array of Array of FLOAT =
    let Tt759 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      next.(x)
    in
    app
      p_received_ray_20percent
      Tt759
  in
  let Tu173 : UNIT =
    let Ta760 : Array of FLOAT =
      r_up.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta760
  in
  let Tu172 : UNIT =
    let Ta761 : Array of FLOAT =
      r_left.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta761
  in
  let Tu171 : UNIT =
    let Ta762 : Array of FLOAT =
      r_center.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta762
  in
  let Tu170 : UNIT =
    let Ta763 : Array of FLOAT =
      r_right.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta763
  in
  let Tu169 : UNIT =
    let Ta764 : Array of FLOAT =
      r_down.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta764
  in
  let energya : Array of Array of FLOAT =
    let Tt765 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_energy
      Tt765
  in
  let Ta766 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta766
    diffuse_ray
in
letrec do_without_neighbors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti744 : INT =
    int 4
  in
  if nref <= Ti744
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Ti745 : INT =
      int 0
    in
    let Ti746 : INT =
      surface_ids.(nref)
    in
    if Ti745 <= Ti746
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu174 : UNIT =
        let Tb747 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti748 : INT =
          int 0
        in
        if Tb747 == Ti748
          unit ()
          app
            calc_diffuse_using_1point
            pixel
            nref
      in
      let Ti750 : INT =
        let Ti749 : INT =
          int 1
        in
        add nref Ti749
      in
      app
        do_without_neighbors
        pixel
        Ti750
      unit ()
    unit ()
in
letrec neighbors_exist : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> BOOL))) =
variables : (x : INT), (y : INT), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti735 : INT =
    let Ti734 : INT =
      int 1
    in
    image_size.(Ti734)
  in
  let Ti737 : INT =
    let Ti736 : INT =
      int 1
    in
    add y Ti736
  in
  if Ti735 <= Ti737
    int 0
    let Ti738 : INT =
      int 0
    in
    if y <= Ti738
      int 0
      let Ti740 : INT =
        let Ti739 : INT =
          int 0
        in
        image_size.(Ti739)
      in
      let Ti742 : INT =
        let Ti741 : INT =
          int 1
        in
        add x Ti741
      in
      if Ti740 <= Ti742
        int 0
        let Ti743 : INT =
          int 0
        in
        if x <= Ti743
          int 0
          int 1
in
letrec get_surface_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> INT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (index : INT)
  let surface_ids : Array of INT =
    app
      p_surface_ids
      pixel
  in
  surface_ids.(index)
in
letrec neighbors_are_available : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> BOOL))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let sid_center : INT =
    let Tt721 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      get_surface_id
      Tt721
      nref
  in
  let Ti723 : INT =
    let Tt722 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      get_surface_id
      Tt722
      nref
  in
  if Ti723 == sid_center
    let Ti725 : INT =
      let Tt724 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        next.(x)
      in
      app
        get_surface_id
        Tt724
        nref
    in
    if Ti725 == sid_center
      let Ti729 : INT =
        let Tt728 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          let Ti727 : INT =
            let Ti726 : INT =
              int 1
            in
            sub x Ti726
          in
          cur.(Ti727)
        in
        app
          get_surface_id
          Tt728
          nref
      in
      if Ti729 == sid_center
        let Ti733 : INT =
          let Tt732 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
            let Ti731 : INT =
              let Ti730 : INT =
                int 1
              in
              add x Ti730
            in
            cur.(Ti731)
          in
          app
            get_surface_id
            Tt732
            nref
        in
        if Ti733 == sid_center
          int 1
          int 0
        int 0
      int 0
    int 0
in
letrec try_exploit_neighbors : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    cur.(x)
  in
  let Ti711 : INT =
    int 4
  in
  if nref <= Ti711
    let Ti712 : INT =
      int 0
    in
    let Ti713 : INT =
      app
        get_surface_id
        pixel
        nref
    in
    if Ti712 <= Ti713
      let Tb714 : BOOL =
        app
          neighbors_are_available
          x
          prev
          cur
          next
          nref
      in
      let Ti715 : INT =
        int 0
      in
      if Tb714 == Ti715
        let Tt716 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          do_without_neighbors
          Tt716
          nref
        let calc_diffuse : Array of BOOL =
          app
            p_calc_diffuse
            pixel
        in
        let Tu175 : UNIT =
          let Tb717 : BOOL =
            calc_diffuse.(nref)
          in
          let Ti718 : INT =
            int 0
          in
          if Tb717 == Ti718
            unit ()
            app
              calc_diffuse_using_5points
              x
              prev
              cur
              next
              nref
        in
        let Ti720 : INT =
          let Ti719 : INT =
            int 1
          in
          add nref Ti719
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti720
      unit ()
    unit ()
in
letrec write_ppm_header : (UNIT -> UNIT) =
variables : (Tu176 : UNIT)
  let Tu184 : UNIT =
    let Ti698 : INT =
      int 80
    in
    app
      print_char
      Ti698
  in
  let Tu183 : UNIT =
    let Ti701 : INT =
      let Ti699 : INT =
        int 48
      in
      let Ti700 : INT =
        int 3
      in
      add Ti699 Ti700
    in
    app
      print_char
      Ti701
  in
  let Tu182 : UNIT =
    let Ti702 : INT =
      int 10
    in
    app
      print_char
      Ti702
  in
  let Tu181 : UNIT =
    let Ti704 : INT =
      let Ti703 : INT =
        int 0
      in
      image_size.(Ti703)
    in
    app
      print_int
      Ti704
  in
  let Tu180 : UNIT =
    let Ti705 : INT =
      int 32
    in
    app
      print_char
      Ti705
  in
  let Tu179 : UNIT =
    let Ti707 : INT =
      let Ti706 : INT =
        int 1
      in
      image_size.(Ti706)
    in
    app
      print_int
      Ti707
  in
  let Tu178 : UNIT =
    let Ti708 : INT =
      int 32
    in
    app
      print_char
      Ti708
  in
  let Tu177 : UNIT =
    let Ti709 : INT =
      int 255
    in
    app
      print_int
      Ti709
  in
  let Ti710 : INT =
    int 10
  in
  app
    print_char
    Ti710
in
letrec write_rgb_element : (FLOAT -> UNIT) =
variables : (x : FLOAT)
  let ix : INT =
    ftoi x
  in
  let elem : INT =
    let Ti696 : INT =
      int 255
    in
    if ix <= Ti696
      let Ti697 : INT =
        int 0
      in
      if Ti697 <= ix
        ix
        int 0
      int 255
  in
  app
    print_int
    elem
in
letrec write_rgb : (UNIT -> UNIT) =
variables : (Tu185 : UNIT)
  let Tu190 : UNIT =
    let Td688 : FLOAT =
      let Ti687 : INT =
        int 0
      in
      rgb.(Ti687)
    in
    app
      write_rgb_element
      Td688
  in
  let Tu189 : UNIT =
    let Ti689 : INT =
      int 32
    in
    app
      print_char
      Ti689
  in
  let Tu188 : UNIT =
    let Td691 : FLOAT =
      let Ti690 : INT =
        int 1
      in
      rgb.(Ti690)
    in
    app
      write_rgb_element
      Td691
  in
  let Tu187 : UNIT =
    let Ti692 : INT =
      int 32
    in
    app
      print_char
      Ti692
  in
  let Tu186 : UNIT =
    let Td694 : FLOAT =
      let Ti693 : INT =
        int 2
      in
      rgb.(Ti693)
    in
    app
      write_rgb_element
      Td694
  in
  let Ti695 : INT =
    int 10
  in
  app
    print_char
    Ti695
in
letrec pretrace_diffuse_rays : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti677 : INT =
    int 4
  in
  if nref <= Ti677
    let sid : INT =
      app
        get_surface_id
        pixel
        nref
    in
    let Ti678 : INT =
      int 0
    in
    if Ti678 <= sid
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu193 : UNIT =
        let Tb679 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti680 : INT =
          int 0
        in
        if Tb679 == Ti680
          unit ()
          let group_id : INT =
            app
              p_group_id
              pixel
          in
          let Tu192 : UNIT =
            app
              vecbzero
              diffuse_ray
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let intersection_points : Array of Array of FLOAT =
            app
              p_intersection_points
              pixel
          in
          let Tu191 : UNIT =
            let Ta681 : Array of (Array of FLOAT * Array of Array of FLOAT) =
              dirvecs.(group_id)
            in
            let Ta682 : Array of FLOAT =
              nvectors.(nref)
            in
            let Ta683 : Array of FLOAT =
              intersection_points.(nref)
            in
            app
              trace_diffuse_rays
              Ta681
              Ta682
              Ta683
          in
          let ray20p : Array of Array of FLOAT =
            app
              p_received_ray_20percent
              pixel
          in
          let Ta684 : Array of FLOAT =
            ray20p.(nref)
          in
          app
            veccpy
            Ta684
            diffuse_ray
      in
      let Ti686 : INT =
        let Ti685 : INT =
          int 1
        in
        add nref Ti685
      in
      app
        pretrace_diffuse_rays
        pixel
        Ti686
      unit ()
    unit ()
in
letrec pretrace_pixels : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (x : INT), (group_id : INT), (lc0 : FLOAT), (lc1 : FLOAT), (lc2 : FLOAT)
  let Ti641 : INT =
    int 0
  in
  if Ti641 <= x
    let xdisp : FLOAT =
      let Td643 : FLOAT =
        let Ti642 : INT =
          int 0
        in
        scan_pitch.(Ti642)
      in
      let Td647 : FLOAT =
        let Ti646 : INT =
          let Ti645 : INT =
            let Ti644 : INT =
              int 0
            in
            image_center.(Ti644)
          in
          sub x Ti645
        in
        itof Ti646
      in
      fmul Td643 Td647
    in
    let Tu203 : UNIT =
      let Ti648 : INT =
        int 0
      in
      let Td652 : FLOAT =
        let Td651 : FLOAT =
          let Td650 : FLOAT =
            let Ti649 : INT =
              int 0
            in
            screenx_dir.(Ti649)
          in
          fmul xdisp Td650
        in
        fadd Td651 lc0
      in
      ptrace_dirvec.(Ti648) <- Td652
    in
    let Tu202 : UNIT =
      let Ti653 : INT =
        int 1
      in
      let Td657 : FLOAT =
        let Td656 : FLOAT =
          let Td655 : FLOAT =
            let Ti654 : INT =
              int 1
            in
            screenx_dir.(Ti654)
          in
          fmul xdisp Td655
        in
        fadd Td656 lc1
      in
      ptrace_dirvec.(Ti653) <- Td657
    in
    let Tu201 : UNIT =
      let Ti658 : INT =
        int 2
      in
      let Td662 : FLOAT =
        let Td661 : FLOAT =
          let Td660 : FLOAT =
            let Ti659 : INT =
              int 2
            in
            screenx_dir.(Ti659)
          in
          fmul xdisp Td660
        in
        fadd Td661 lc2
      in
      ptrace_dirvec.(Ti658) <- Td662
    in
    let Tu200 : UNIT =
      let Ti663 : INT =
        int 0
      in
      app
        vecunit_sgn
        ptrace_dirvec
        Ti663
    in
    let Tu199 : UNIT =
      app
        vecbzero
        rgb
    in
    let Tu198 : UNIT =
      app
        veccpy
        startp
        viewpoint
    in
    let Tu197 : UNIT =
      let Ti664 : INT =
        int 0
      in
      let Td665 : FLOAT =
        float 1.
      in
      let Tt666 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Td667 : FLOAT =
        float 0.
      in
      app
        trace_ray
        Ti664
        Td665
        ptrace_dirvec
        Tt666
        Td667
    in
    let Tu196 : UNIT =
      let Ta669 : Array of FLOAT =
        let Tt668 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          line.(x)
        in
        app
          p_rgb
          Tt668
      in
      app
        veccpy
        Ta669
        rgb
    in
    let Tu195 : UNIT =
      let Tt670 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      app
        p_set_group_id
        Tt670
        group_id
    in
    let Tu194 : UNIT =
      let Tt671 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Ti672 : INT =
        int 0
      in
      app
        pretrace_diffuse_rays
        Tt671
        Ti672
    in
    let Ti674 : INT =
      let Ti673 : INT =
        int 1
      in
      sub x Ti673
    in
    let Ti676 : INT =
      let Ti675 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti675
    in
    app
      pretrace_pixels
      line
      Ti674
      Ti676
      lc0
      lc1
      lc2
    unit ()
in
letrec pretrace_line : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> UNIT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (y : INT), (group_id : INT)
  let ydisp : FLOAT =
    let Td617 : FLOAT =
      let Ti616 : INT =
        int 0
      in
      scan_pitch.(Ti616)
    in
    let Td621 : FLOAT =
      let Ti620 : INT =
        let Ti619 : INT =
          let Ti618 : INT =
            int 1
          in
          image_center.(Ti618)
        in
        sub y Ti619
      in
      itof Ti620
    in
    fmul Td617 Td621
  in
  let lc0 : FLOAT =
    let Td624 : FLOAT =
      let Td623 : FLOAT =
        let Ti622 : INT =
          int 0
        in
        screeny_dir.(Ti622)
      in
      fmul ydisp Td623
    in
    let Td626 : FLOAT =
      let Ti625 : INT =
        int 0
      in
      screenz_dir.(Ti625)
    in
    fadd Td624 Td626
  in
  let lc1 : FLOAT =
    let Td629 : FLOAT =
      let Td628 : FLOAT =
        let Ti627 : INT =
          int 1
        in
        screeny_dir.(Ti627)
      in
      fmul ydisp Td628
    in
    let Td631 : FLOAT =
      let Ti630 : INT =
        int 1
      in
      screenz_dir.(Ti630)
    in
    fadd Td629 Td631
  in
  let lc2 : FLOAT =
    let Td634 : FLOAT =
      let Td633 : FLOAT =
        let Ti632 : INT =
          int 2
        in
        screeny_dir.(Ti632)
      in
      fmul ydisp Td633
    in
    let Td636 : FLOAT =
      let Ti635 : INT =
        int 2
      in
      screenz_dir.(Ti635)
    in
    fadd Td634 Td636
  in
  let Ti640 : INT =
    let Ti638 : INT =
      let Ti637 : INT =
        int 0
      in
      image_size.(Ti637)
    in
    let Ti639 : INT =
      int 1
    in
    sub Ti638 Ti639
  in
  app
    pretrace_pixels
    line
    Ti640
    group_id
    lc0
    lc1
    lc2
in
letrec scan_pixel : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> UNIT))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti605 : INT =
    let Ti604 : INT =
      int 0
    in
    image_size.(Ti604)
  in
  if Ti605 <= x
    unit ()
    let Tu206 : UNIT =
      let Ta607 : Array of FLOAT =
        let Tt606 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          p_rgb
          Tt606
      in
      app
        veccpy
        rgb
        Ta607
    in
    let Tu205 : UNIT =
      let Tb608 : BOOL =
        app
          neighbors_exist
          x
          y
          next
      in
      let Ti609 : INT =
        int 0
      in
      if Tb608 == Ti609
        let Tt610 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        let Ti611 : INT =
          int 0
        in
        app
          do_without_neighbors
          Tt610
          Ti611
        let Ti612 : INT =
          int 0
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti612
    in
    let Tu204 : UNIT =
      let Tu613 : UNIT =
        unit ()
      in
      app
        write_rgb
        Tu613
    in
    let Ti615 : INT =
      let Ti614 : INT =
        int 1
      in
      add x Ti614
    in
    app
      scan_pixel
      Ti615
      y
      prev
      cur
      next
in
letrec scan_line : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (group_id : INT)
  let Ti592 : INT =
    let Ti591 : INT =
      int 1
    in
    image_size.(Ti591)
  in
  if Ti592 <= y
    unit ()
    let Tu208 : UNIT =
      let Ti596 : INT =
        let Ti594 : INT =
          let Ti593 : INT =
            int 1
          in
          image_size.(Ti593)
        in
        let Ti595 : INT =
          int 1
        in
        sub Ti594 Ti595
      in
      if Ti596 <= y
        unit ()
        let Ti598 : INT =
          let Ti597 : INT =
            int 1
          in
          add y Ti597
        in
        app
          pretrace_line
          next
          Ti598
          group_id
    in
    let Tu207 : UNIT =
      let Ti599 : INT =
        int 0
      in
      app
        scan_pixel
        Ti599
        y
        prev
        cur
        next
    in
    let Ti601 : INT =
      let Ti600 : INT =
        int 1
      in
      add y Ti600
    in
    let Ti603 : INT =
      let Ti602 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti602
    in
    app
      scan_line
      Ti601
      cur
      next
      prev
      Ti603
in
letrec create_float5x3array : (UNIT -> Array of Array of FLOAT) =
variables : (Tu209 : UNIT)
  let vec : Array of FLOAT =
    let Ti572 : INT =
      int 3
    in
    let Td573 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti572
      Td573
  in
  let array : Array of Array of FLOAT =
    let Ti574 : INT =
      int 5
    in
    extfunapp
      create_array
      Ti574
      vec
  in
  let Tu213 : UNIT =
    let Ti575 : INT =
      int 1
    in
    let Ta578 : Array of FLOAT =
      let Ti576 : INT =
        int 3
      in
      let Td577 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti576
        Td577
    in
    array.(Ti575) <- Ta578
  in
  let Tu212 : UNIT =
    let Ti579 : INT =
      int 2
    in
    let Ta582 : Array of FLOAT =
      let Ti580 : INT =
        int 3
      in
      let Td581 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti580
        Td581
    in
    array.(Ti579) <- Ta582
  in
  let Tu211 : UNIT =
    let Ti583 : INT =
      int 3
    in
    let Ta586 : Array of FLOAT =
      let Ti584 : INT =
        int 3
      in
      let Td585 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti584
        Td585
    in
    array.(Ti583) <- Ta586
  in
  let Tu210 : UNIT =
    let Ti587 : INT =
      int 4
    in
    let Ta590 : Array of FLOAT =
      let Ti588 : INT =
        int 3
      in
      let Td589 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti588
        Td589
    in
    array.(Ti587) <- Ta590
  in
  array
in
letrec create_pixel : (UNIT -> (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu214 : UNIT)
  let m_rgb : Array of FLOAT =
    let Ti560 : INT =
      int 3
    in
    let Td561 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti560
      Td561
  in
  let m_isect_ps : Array of Array of FLOAT =
    let Tu562 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu562
  in
  let m_sids : Array of INT =
    let Ti563 : INT =
      int 5
    in
    let Ti564 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti563
      Ti564
  in
  let m_cdif : Array of BOOL =
    let Ti565 : INT =
      int 5
    in
    let Ti566 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti565
      Ti566
  in
  let m_engy : Array of Array of FLOAT =
    let Tu567 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu567
  in
  let m_r20p : Array of Array of FLOAT =
    let Tu568 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu568
  in
  let m_gid : Array of INT =
    let Ti569 : INT =
      int 1
    in
    let Ti570 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti569
      Ti570
  in
  let m_nvectors : Array of Array of FLOAT =
    let Tu571 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu571
  in
  Tuple
    m_rgb
    m_isect_ps
    m_sids
    m_cdif
    m_engy
    m_r20p
    m_gid
    m_nvectors
in
letrec init_line_elements : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (n : INT)
  let Ti555 : INT =
    int 0
  in
  if Ti555 <= n
    let Tu215 : UNIT =
      let Tt557 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        let Tu556 : UNIT =
          unit ()
        in
        app
          create_pixel
          Tu556
      in
      line.(n) <- Tt557
    in
    let Ti559 : INT =
      let Ti558 : INT =
        int 1
      in
      sub n Ti558
    in
    app
      init_line_elements
      line
      Ti559
    line
in
letrec create_pixelline : (UNIT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu216 : UNIT)
  let line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Ti548 : INT =
      let Ti547 : INT =
        int 0
      in
      image_size.(Ti547)
    in
    let Tt550 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Tu549 : UNIT =
        unit ()
      in
      app
        create_pixel
        Tu549
    in
    extfunapp
      create_array
      Ti548
      Tt550
  in
  let Ti554 : INT =
    let Ti552 : INT =
      let Ti551 : INT =
        int 0
      in
      image_size.(Ti551)
    in
    let Ti553 : INT =
      int 2
    in
    sub Ti552 Ti553
  in
  app
    init_line_elements
    line
    Ti554
in
letrec tan : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td545 : FLOAT =
    app
      sin
      x
  in
  let Td546 : FLOAT =
    app
      cos
      x
  in
  fdiv Td545 Td546
in
letrec adjust_position : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (h : FLOAT), (ratio : FLOAT)
  let l : FLOAT =
    let Td542 : FLOAT =
      let Td540 : FLOAT =
        fmul h h
      in
      let Td541 : FLOAT =
        float 0.1
      in
      fadd Td540 Td541
    in
    app
      sqrt
      Td542
  in
  let tan_h : FLOAT =
    let Td543 : FLOAT =
      float 1.
    in
    fdiv Td543 l
  in
  let theta_h : FLOAT =
    app
      atan
      tan_h
  in
  let tan_m : FLOAT =
    let Td544 : FLOAT =
      fmul theta_h ratio
    in
    app
      tan
      Td544
  in
  fmul tan_m l
in
letrec calc_dirvec : (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> UNIT))))))) =
variables : (icount : INT), (x : FLOAT), (y : FLOAT), (rx : FLOAT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti499 : INT =
    int 5
  in
  if Ti499 <= icount
    let l : FLOAT =
      let Td504 : FLOAT =
        let Td502 : FLOAT =
          let Td500 : FLOAT =
            app
              fsqr
              x
          in
          let Td501 : FLOAT =
            app
              fsqr
              y
          in
          fadd Td500 Td501
        in
        let Td503 : FLOAT =
          float 1.
        in
        fadd Td502 Td503
      in
      app
        sqrt
        Td504
    in
    let vx : FLOAT =
      fdiv x l
    in
    let vy : FLOAT =
      fdiv y l
    in
    let vz : FLOAT =
      let Td505 : FLOAT =
        float 1.
      in
      fdiv Td505 l
    in
    let dgroup : Array of (Array of FLOAT * Array of Array of FLOAT) =
      dirvecs.(group_id)
    in
    let Tu221 : UNIT =
      let Ta507 : Array of FLOAT =
        let Tt506 : (Array of FLOAT * Array of Array of FLOAT) =
          dgroup.(index)
        in
        app
          d_vec
          Tt506
      in
      app
        vecset
        Ta507
        vx
        vy
        vz
    in
    let Tu220 : UNIT =
      let Ta511 : Array of FLOAT =
        let Tt510 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti509 : INT =
            let Ti508 : INT =
              int 40
            in
            add index Ti508
          in
          dgroup.(Ti509)
        in
        app
          d_vec
          Tt510
      in
      let Td512 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta511
        vx
        vz
        Td512
    in
    let Tu219 : UNIT =
      let Ta516 : Array of FLOAT =
        let Tt515 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti514 : INT =
            let Ti513 : INT =
              int 80
            in
            add index Ti513
          in
          dgroup.(Ti514)
        in
        app
          d_vec
          Tt515
      in
      let Td517 : FLOAT =
        app
          fneg
          vx
      in
      let Td518 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta516
        vz
        Td517
        Td518
    in
    let Tu218 : UNIT =
      let Ta522 : Array of FLOAT =
        let Tt521 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti520 : INT =
            let Ti519 : INT =
              int 1
            in
            add index Ti519
          in
          dgroup.(Ti520)
        in
        app
          d_vec
          Tt521
      in
      let Td523 : FLOAT =
        app
          fneg
          vx
      in
      let Td524 : FLOAT =
        app
          fneg
          vy
      in
      let Td525 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta522
        Td523
        Td524
        Td525
    in
    let Tu217 : UNIT =
      let Ta529 : Array of FLOAT =
        let Tt528 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti527 : INT =
            let Ti526 : INT =
              int 41
            in
            add index Ti526
          in
          dgroup.(Ti527)
        in
        app
          d_vec
          Tt528
      in
      let Td530 : FLOAT =
        app
          fneg
          vx
      in
      let Td531 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta529
        Td530
        Td531
        vy
    in
    let Ta535 : Array of FLOAT =
      let Tt534 : (Array of FLOAT * Array of Array of FLOAT) =
        let Ti533 : INT =
          let Ti532 : INT =
            int 81
          in
          add index Ti532
        in
        dgroup.(Ti533)
      in
      app
        d_vec
        Tt534
    in
    let Td536 : FLOAT =
      app
        fneg
        vz
    in
    app
      vecset
      Ta535
      Td536
      vx
      vy
    let x2 : FLOAT =
      app
        adjust_position
        y
        rx
    in
    let Ti538 : INT =
      let Ti537 : INT =
        int 1
      in
      add icount Ti537
    in
    let Td539 : FLOAT =
      app
        adjust_position
        x2
        ry
    in
    app
      calc_dirvec
      Ti538
      x2
      Td539
      rx
      ry
      group_id
      index
in
letrec calc_dirvecs : (INT -> (FLOAT -> (INT -> (INT -> UNIT)))) =
variables : (col : INT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti478 : INT =
    int 0
  in
  if Ti478 <= col
    let rx : FLOAT =
      let Td481 : FLOAT =
        let Td479 : FLOAT =
          itof col
        in
        let Td480 : FLOAT =
          float 0.2
        in
        fmul Td479 Td480
      in
      let Td482 : FLOAT =
        float 0.9
      in
      fsub Td481 Td482
    in
    let Tu223 : UNIT =
      let Ti483 : INT =
        int 0
      in
      let Td484 : FLOAT =
        float 0.
      in
      let Td485 : FLOAT =
        float 0.
      in
      app
        calc_dirvec
        Ti483
        Td484
        Td485
        rx
        ry
        group_id
        index
    in
    let rx2 : FLOAT =
      let Td488 : FLOAT =
        let Td486 : FLOAT =
          itof col
        in
        let Td487 : FLOAT =
          float 0.2
        in
        fmul Td486 Td487
      in
      let Td489 : FLOAT =
        float 0.1
      in
      fadd Td488 Td489
    in
    let Tu222 : UNIT =
      let Ti490 : INT =
        int 0
      in
      let Td491 : FLOAT =
        float 0.
      in
      let Td492 : FLOAT =
        float 0.
      in
      let Ti494 : INT =
        let Ti493 : INT =
          int 2
        in
        add index Ti493
      in
      app
        calc_dirvec
        Ti490
        Td491
        Td492
        rx2
        ry
        group_id
        Ti494
    in
    let Ti496 : INT =
      let Ti495 : INT =
        int 1
      in
      sub col Ti495
    in
    let Ti498 : INT =
      let Ti497 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti497
    in
    app
      calc_dirvecs
      Ti496
      ry
      Ti498
      index
    unit ()
in
letrec calc_dirvec_rows : (INT -> (INT -> (INT -> UNIT))) =
variables : (row : INT), (group_id : INT), (index : INT)
  let Ti466 : INT =
    int 0
  in
  if Ti466 <= row
    let ry : FLOAT =
      let Td469 : FLOAT =
        let Td467 : FLOAT =
          itof row
        in
        let Td468 : FLOAT =
          float 0.2
        in
        fmul Td467 Td468
      in
      let Td470 : FLOAT =
        float 0.9
      in
      fsub Td469 Td470
    in
    let Tu224 : UNIT =
      let Ti471 : INT =
        int 4
      in
      app
        calc_dirvecs
        Ti471
        ry
        group_id
        index
    in
    let Ti473 : INT =
      let Ti472 : INT =
        int 1
      in
      sub row Ti472
    in
    let Ti475 : INT =
      let Ti474 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti474
    in
    let Ti477 : INT =
      let Ti476 : INT =
        int 4
      in
      add index Ti476
    in
    app
      calc_dirvec_rows
      Ti473
      Ti475
      Ti477
    unit ()
in
letrec create_dirvec : (UNIT -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (Tu225 : UNIT)
  let v3 : Array of FLOAT =
    let Ti462 : INT =
      int 3
    in
    let Td463 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti462
      Td463
  in
  let consts : Array of Array of FLOAT =
    let Ti465 : INT =
      let Ti464 : INT =
        int 0
      in
      n_objects.(Ti464)
    in
    extfunapp
      create_array
      Ti465
      v3
  in
  Tuple
    v3
    consts
in
letrec create_dirvec_elements : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (d : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti457 : INT =
    int 0
  in
  if Ti457 <= index
    let Tu226 : UNIT =
      let Tt459 : (Array of FLOAT * Array of Array of FLOAT) =
        let Tu458 : UNIT =
          unit ()
        in
        app
          create_dirvec
          Tu458
      in
      d.(index) <- Tt459
    in
    let Ti461 : INT =
      let Ti460 : INT =
        int 1
      in
      sub index Ti460
    in
    app
      create_dirvec_elements
      d
      Ti461
    unit ()
in
letrec create_dirvecs : (INT -> UNIT) =
variables : (index : INT)
  let Ti448 : INT =
    int 0
  in
  if Ti448 <= index
    let Tu228 : UNIT =
      let Ta452 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti449 : INT =
          int 120
        in
        let Tt451 : (Array of FLOAT * Array of Array of FLOAT) =
          let Tu450 : UNIT =
            unit ()
          in
          app
            create_dirvec
            Tu450
        in
        extfunapp
          create_array
          Ti449
          Tt451
      in
      dirvecs.(index) <- Ta452
    in
    let Tu227 : UNIT =
      let Ta453 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti454 : INT =
        int 118
      in
      app
        create_dirvec_elements
        Ta453
        Ti454
    in
    let Ti456 : INT =
      let Ti455 : INT =
        int 1
      in
      sub index Ti455
    in
    app
      create_dirvecs
      Ti456
    unit ()
in
letrec init_dirvec_constants : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (vecset : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti444 : INT =
    int 0
  in
  if Ti444 <= index
    let Tu229 : UNIT =
      let Tt445 : (Array of FLOAT * Array of Array of FLOAT) =
        vecset.(index)
      in
      app
        setup_dirvec_constants
        Tt445
    in
    let Ti447 : INT =
      let Ti446 : INT =
        int 1
      in
      sub index Ti446
    in
    app
      init_dirvec_constants
      vecset
      Ti447
    unit ()
in
letrec init_vecset_constants : (INT -> UNIT) =
variables : (index : INT)
  let Ti439 : INT =
    int 0
  in
  if Ti439 <= index
    let Tu230 : UNIT =
      let Ta440 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti441 : INT =
        int 119
      in
      app
        init_dirvec_constants
        Ta440
        Ti441
    in
    let Ti443 : INT =
      let Ti442 : INT =
        int 1
      in
      sub index Ti442
    in
    app
      init_vecset_constants
      Ti443
    unit ()
in
letrec init_dirvecs : (UNIT -> UNIT) =
variables : (Tu231 : UNIT)
  let Tu233 : UNIT =
    let Ti434 : INT =
      int 4
    in
    app
      create_dirvecs
      Ti434
  in
  let Tu232 : UNIT =
    let Ti435 : INT =
      int 9
    in
    let Ti436 : INT =
      int 0
    in
    let Ti437 : INT =
      int 0
    in
    app
      calc_dirvec_rows
      Ti435
      Ti436
      Ti437
  in
  let Ti438 : INT =
    int 4
  in
  app
    init_vecset_constants
    Ti438
in
letrec add_reflection : (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (index : INT), (surface_id : INT), (bright : FLOAT), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let dvec : (Array of FLOAT * Array of Array of FLOAT) =
    let Tu431 : UNIT =
      unit ()
    in
    app
      create_dirvec
      Tu431
  in
  let Tu235 : UNIT =
    let Ta432 : Array of FLOAT =
      app
        d_vec
        dvec
    in
    app
      vecset
      Ta432
      v0
      v1
      v2
  in
  let Tu234 : UNIT =
    app
      setup_dirvec_constants
      dvec
  in
  let Tt433 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    Tuple
      surface_id
      dvec
      bright
  in
  reflections.(index) <- Tt433
in
letrec setup_rect_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    mul obj_id 4
  in
  let nr : INT =
    let Ti403 : INT =
      int 0
    in
    n_reflections.(Ti403)
  in
  let br : FLOAT =
    let Td404 : FLOAT =
      float 1.
    in
    let Td405 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td404 Td405
  in
  let n0 : FLOAT =
    let Td407 : FLOAT =
      let Ti406 : INT =
        int 0
      in
      light.(Ti406)
    in
    app
      fneg
      Td407
  in
  let n1 : FLOAT =
    let Td409 : FLOAT =
      let Ti408 : INT =
        int 1
      in
      light.(Ti408)
    in
    app
      fneg
      Td409
  in
  let n2 : FLOAT =
    let Td411 : FLOAT =
      let Ti410 : INT =
        int 2
      in
      light.(Ti410)
    in
    app
      fneg
      Td411
  in
  let Tu238 : UNIT =
    let Ti413 : INT =
      let Ti412 : INT =
        int 1
      in
      add sid Ti412
    in
    let Td415 : FLOAT =
      let Ti414 : INT =
        int 0
      in
      light.(Ti414)
    in
    app
      add_reflection
      nr
      Ti413
      br
      Td415
      n1
      n2
  in
  let Tu237 : UNIT =
    let Ti417 : INT =
      let Ti416 : INT =
        int 1
      in
      add nr Ti416
    in
    let Ti419 : INT =
      let Ti418 : INT =
        int 2
      in
      add sid Ti418
    in
    let Td421 : FLOAT =
      let Ti420 : INT =
        int 1
      in
      light.(Ti420)
    in
    app
      add_reflection
      Ti417
      Ti419
      br
      n0
      Td421
      n2
  in
  let Tu236 : UNIT =
    let Ti423 : INT =
      let Ti422 : INT =
        int 2
      in
      add nr Ti422
    in
    let Ti425 : INT =
      let Ti424 : INT =
        int 3
      in
      add sid Ti424
    in
    let Td427 : FLOAT =
      let Ti426 : INT =
        int 2
      in
      light.(Ti426)
    in
    app
      add_reflection
      Ti423
      Ti425
      br
      n0
      n1
      Td427
  in
  let Ti428 : INT =
    int 0
  in
  let Ti430 : INT =
    let Ti429 : INT =
      int 3
    in
    add nr Ti429
  in
  n_reflections.(Ti428) <- Ti430
in
letrec setup_surface_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    let Ti373 : INT =
      mul obj_id 4
    in
    let Ti374 : INT =
      int 1
    in
    add Ti373 Ti374
  in
  let nr : INT =
    let Ti375 : INT =
      int 0
    in
    n_reflections.(Ti375)
  in
  let br : FLOAT =
    let Td376 : FLOAT =
      float 1.
    in
    let Td377 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td376 Td377
  in
  let p : FLOAT =
    let Ta378 : Array of FLOAT =
      app
        o_param_abc
        obj
    in
    app
      veciprod
      light
      Ta378
  in
  let Tu239 : UNIT =
    let Td385 : FLOAT =
      let Td382 : FLOAT =
        let Td381 : FLOAT =
          let Td379 : FLOAT =
            float 2.
          in
          let Td380 : FLOAT =
            app
              o_param_a
              obj
          in
          fmul Td379 Td380
        in
        fmul Td381 p
      in
      let Td384 : FLOAT =
        let Ti383 : INT =
          int 0
        in
        light.(Ti383)
      in
      fsub Td382 Td384
    in
    let Td392 : FLOAT =
      let Td389 : FLOAT =
        let Td388 : FLOAT =
          let Td386 : FLOAT =
            float 2.
          in
          let Td387 : FLOAT =
            app
              o_param_b
              obj
          in
          fmul Td386 Td387
        in
        fmul Td388 p
      in
      let Td391 : FLOAT =
        let Ti390 : INT =
          int 1
        in
        light.(Ti390)
      in
      fsub Td389 Td391
    in
    let Td399 : FLOAT =
      let Td396 : FLOAT =
        let Td395 : FLOAT =
          let Td393 : FLOAT =
            float 2.
          in
          let Td394 : FLOAT =
            app
              o_param_c
              obj
          in
          fmul Td393 Td394
        in
        fmul Td395 p
      in
      let Td398 : FLOAT =
        let Ti397 : INT =
          int 2
        in
        light.(Ti397)
      in
      fsub Td396 Td398
    in
    app
      add_reflection
      nr
      sid
      br
      Td385
      Td392
      Td399
  in
  let Ti400 : INT =
    int 0
  in
  let Ti402 : INT =
    let Ti401 : INT =
      int 1
    in
    add nr Ti401
  in
  n_reflections.(Ti400) <- Ti402
in
letrec setup_reflections : (INT -> UNIT) =
variables : (obj_id : INT)
  let Ti364 : INT =
    int 0
  in
  if Ti364 <= obj_id
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(obj_id)
    in
    let Ti365 : INT =
      app
        o_reflectiontype
        obj
    in
    let Ti366 : INT =
      int 2
    in
    if Ti365 == Ti366
      let Tb369 : BOOL =
        let Td367 : FLOAT =
          app
            o_diffuse
            obj
        in
        let Td368 : FLOAT =
          float 1.
        in
        app
          fless
          Td367
          Td368
      in
      let Ti370 : INT =
        int 0
      in
      if Tb369 == Ti370
        unit ()
        let m_shape : INT =
          app
            o_form
            obj
        in
        let Ti371 : INT =
          int 1
        in
        if m_shape == Ti371
          app
            setup_rect_reflection
            obj_id
            obj
          let Ti372 : INT =
            int 2
          in
          if m_shape == Ti372
            app
              setup_surface_reflection
              obj_id
              obj
            unit ()
      unit ()
    unit ()
in
letrec rt : (INT -> (INT -> UNIT)) =
variables : (size_x : INT), (size_y : INT)
  let Tu251 : UNIT =
    let Ti339 : INT =
      int 0
    in
    image_size.(Ti339) <- size_x
  in
  let Tu250 : UNIT =
    let Ti340 : INT =
      int 1
    in
    image_size.(Ti340) <- size_y
  in
  let Tu249 : UNIT =
    let Ti341 : INT =
      int 0
    in
    let Ti342 : INT =
      div size_x 2
    in
    image_center.(Ti341) <- Ti342
  in
  let Tu248 : UNIT =
    let Ti343 : INT =
      int 1
    in
    let Ti344 : INT =
      div size_y 2
    in
    image_center.(Ti343) <- Ti344
  in
  let Tu247 : UNIT =
    let Ti345 : INT =
      int 0
    in
    let Td348 : FLOAT =
      let Td346 : FLOAT =
        float 128.
      in
      let Td347 : FLOAT =
        itof size_x
      in
      fdiv Td346 Td347
    in
    scan_pitch.(Ti345) <- Td348
  in
  let prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu349 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu349
  in
  let cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu350 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu350
  in
  let next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu351 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu351
  in
  let Tu246 : UNIT =
    let Tu352 : UNIT =
      unit ()
    in
    app
      read_parameter
      Tu352
  in
  let Tu245 : UNIT =
    let Tu353 : UNIT =
      unit ()
    in
    app
      write_ppm_header
      Tu353
  in
  let Tu244 : UNIT =
    let Tu354 : UNIT =
      unit ()
    in
    app
      init_dirvecs
      Tu354
  in
  let Tu243 : UNIT =
    let Ta355 : Array of FLOAT =
      app
        d_vec
        light_dirvec
    in
    app
      veccpy
      Ta355
      light
  in
  let Tu242 : UNIT =
    app
      setup_dirvec_constants
      light_dirvec
  in
  let Tu241 : UNIT =
    let Ti359 : INT =
      let Ti357 : INT =
        let Ti356 : INT =
          int 0
        in
        n_objects.(Ti356)
      in
      let Ti358 : INT =
        int 1
      in
      sub Ti357 Ti358
    in
    app
      setup_reflections
      Ti359
  in
  let Tu240 : UNIT =
    let Ti360 : INT =
      int 0
    in
    let Ti361 : INT =
      int 0
    in
    app
      pretrace_line
      cur
      Ti360
      Ti361
  in
  let Ti362 : INT =
    int 0
  in
  let Ti363 : INT =
    int 2
  in
  app
    scan_line
    Ti362
    prev
    cur
    next
    Ti363
in
let Ti337 : INT =
  int 512
in
let Ti338 : INT =
  int 512
in
app
  rt
  Ti337
  Ti338
