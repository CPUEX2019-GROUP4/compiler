----- syntax.print -----
LETREC print_int (VAR of )
  (n : VAR of )
  LET n (VAR of )
    IF
      NOT
        LE
          INT 0
          VAR n
      LET Tu1 (UNIT)
        OUT
          INT 45        0
      NEG
        VAR n
      VAR n
  IF
    NOT
      LE
        INT 10
        VAR n
    OUT
      VAR n    48
    LET m (VAR of )
      DIVIDE BY 10
        VAR n
    LET Tu2 (UNIT)
      APP
        VAR print_int
        VAR m
    OUT
      SUB
        VAR n
        MULTIPLE 10
          VAR m    48
LETREC print_newline (VAR of )
  (Tu3 : VAR of )
  OUT
    INT 0  10
LETREC reduction_2pi_sub1 (VAR of )
  (v : VAR of )
  IF
    FLt
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
    UNIT
    LET Tu4 (UNIT)
      PUT
        VAR v
        INT 1
        FMUL
          GET
            VAR v
            INT 1
          FLOAT 2.
    APP
      VAR reduction_2pi_sub1
      VAR v
LETREC reduction_2pi_sub2 (VAR of )
  (v : VAR of )
  IF
    FLt
      FLOAT 6.28318530718
      GET
        VAR v
        INT 0
    LET Tu6 (UNIT)
      IF
        FLt
          GET
            VAR v
            INT 1
          GET
            VAR v
            INT 0
        PUT
          VAR v
          INT 0
          FSUB
            GET
              VAR v
              INT 0
            GET
              VAR v
              INT 1
        UNIT
    LET Tu5 (UNIT)
      PUT
        VAR v
        INT 1
        FDIV
          GET
            VAR v
            INT 1
          FLOAT 2.
    APP
      VAR reduction_2pi_sub2
      VAR v
    UNIT
LETREC reduction_2pi (VAR of )
  (v : VAR of )
  LET Tu8 (UNIT)
    PUT
      VAR v
      INT 1
      FLOAT 6.28318530718
  LET Tu7 (UNIT)
    APP
      VAR reduction_2pi_sub1
      VAR v
  APP
    VAR reduction_2pi_sub2
    VAR v
LETREC kernel_sin (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a
  LET a5 (VAR of )
    FMUL
      VAR a3
      VAR a2
  LET a7 (VAR of )
    FMUL
      VAR a5
      VAR a2
  FSUB
    FADD
      FSUB
        VAR a
        FMUL
          FLOAT 0.16666668
          VAR a3
      FMUL
        FLOAT 0.008332824
        VAR a5
    FMUL
      FLOAT 0.00019587841
      VAR a7
LETREC kernel_cos (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a4 (VAR of )
    FMUL
      VAR a2
      VAR a2
  LET a6 (VAR of )
    FMUL
      VAR a4
      VAR a2
  FSUB
    FADD
      FSUB
        FLOAT 1.
        FMUL
          FLOAT 0.5
          VAR a2
      FMUL
        FLOAT 0.04166368
        VAR a4
    FMUL
      FLOAT 0.0013695068
      VAR a6
LETREC sin (VAR of )
  (a : VAR of )
  LET v (VAR of )
    ARRAY
      INT 3
      VAR a
  LET Tu13 (UNIT)
    IF
      FLt
        VAR a
        FLOAT 0.
      PUT
        VAR v
        INT 0
        NEG
          VAR a
      UNIT
  LET Tu12 (UNIT)
    APP
      VAR reduction_2pi
      VAR v
  LET Tu11 (UNIT)
    IF
      FLt
        FLOAT 3.14159265359
        GET
          VAR v
          INT 0
      LET Tu9 (UNIT)
        PUT
          VAR v
          INT 0
          FSUB
            GET
              VAR v
              INT 0
            FLOAT 3.14159265359
      PUT
        VAR v
        INT 2
        NEG
          GET
            VAR v
            INT 2
      UNIT
  LET Tu10 (UNIT)
    IF
      FLt
        FLOAT 1.57079632679
        GET
          VAR v
          INT 0
      PUT
        VAR v
        INT 0
        FSUB
          FLOAT 3.14159265359
          GET
            VAR v
            INT 0
      UNIT
  LET x (VAR of )
    IF
      FLt
        FLOAT 0.785398163397
        GET
          VAR v
          INT 0
      APP
        VAR kernel_cos
        FSUB
          FLOAT 1.57079632679
          GET
            VAR v
            INT 0
      APP
        VAR kernel_sin
        GET
          VAR v
          INT 0
  IF
    FLt
      GET
        VAR v
        INT 2
      FLOAT 0.
    NEG
      VAR x
    VAR x
LETREC cos (VAR of )
  (a : VAR of )
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      VAR a
  LET v (VAR of )
    ARRAY
      INT 3
      VAR a
  LET Tu18 (UNIT)
    APP
      VAR reduction_2pi
      VAR v
  LET Tu17 (UNIT)
    IF
      FLt
        FLOAT 3.14159265359
        GET
          VAR v
          INT 0
      LET Tu14 (UNIT)
        PUT
          VAR v
          INT 0
          FSUB
            GET
              VAR v
              INT 0
            FLOAT 3.14159265359
      PUT
        VAR v
        INT 2
        FLOAT -1.
      UNIT
  LET Tu16 (UNIT)
    IF
      FLt
        FLOAT 1.57079632679
        GET
          VAR v
          INT 0
      LET Tu15 (UNIT)
        PUT
          VAR v
          INT 0
          FSUB
            FLOAT 3.14159265359
            GET
              VAR v
              INT 0
      PUT
        VAR v
        INT 2
        NEG
          GET
            VAR v
            INT 2
      UNIT
  LET x (VAR of )
    IF
      FLt
        GET
          VAR v
          INT 0
        FLOAT 0.785398163397
      APP
        VAR kernel_cos
        GET
          VAR v
          INT 0
      APP
        VAR kernel_sin
        FSUB
          FLOAT 1.57079632679
          GET
            VAR v
            INT 0
  IF
    FLt
      GET
        VAR v
        INT 2
      FLOAT 0.
    NEG
      VAR x
    VAR x
LETREC sqrt (VAR of )
  (x : VAR of )
  IF
    FLt
      FLOAT 0.
      VAR x
    LET t (VAR of )
      UNKNOWN APP        sqrt_init
        VAR x
    LET t (VAR of )
      FDIV
        FADD
          FMUL
            VAR t
            VAR t
          VAR x
        FADD
          VAR t
          VAR t
    LET t (VAR of )
      FDIV
        FADD
          FMUL
            VAR t
            VAR t
          VAR x
        FADD
          VAR t
          VAR t
    LET t (VAR of )
      FDIV
        FADD
          FMUL
            VAR t
            VAR t
          VAR x
        FADD
          VAR t
          VAR t
    VAR t
    FLOAT 0.
LETREC kernel_atan (VAR of )
  (a1 : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a1
      VAR a1
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a1
  LET a5 (VAR of )
    FMUL
      VAR a2
      VAR a3
  LET a7 (VAR of )
    FMUL
      VAR a2
      VAR a5
  LET a9 (VAR of )
    FMUL
      VAR a2
      VAR a7
  LET a11 (VAR of )
    FMUL
      VAR a2
      VAR a9
  LET a13 (VAR of )
    FMUL
      VAR a2
      VAR a11
  FADD
    FSUB
      FADD
        FSUB
          FADD
            FSUB
              VAR a1
              FMUL
                FLOAT 0.3333333
                VAR a3
            FMUL
              FLOAT 0.2
              VAR a5
          FMUL
            FLOAT 0.142857142
            VAR a7
        FMUL
          FLOAT 0.111111104
          VAR a9
      FMUL
        FLOAT 0.08976446
        VAR a11
    FMUL
      FLOAT 0.060035485
      VAR a13
LETREC atan (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      VAR flag
      VAR a
      NEG
        VAR a
  LET b (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.4375
      APP
        VAR kernel_atan
        VAR a
      IF
        FLt
          VAR a
          FLOAT 2.4375
        FADD
          FLOAT 0.785398163397
          APP
            VAR kernel_atan
            FDIV
              FSUB
                VAR a
                FLOAT 1.
              FADD
                VAR a
                FLOAT 1.
        FSUB
          FLOAT 1.57079632679
          APP
            VAR kernel_atan
            FDIV
              FLOAT 1.
              VAR a
  IF
    VAR flag
    VAR b
    NEG
      VAR b
LETREC floor (VAR of )
  (x : VAR of )
  LET a (VAR of )
    int_to_float
      float_to_int
        VAR x
  IF
    FLt
      VAR x
      VAR a
    FSUB
      VAR a
      FLOAT 1.
    VAR a
LETREC fabs (VAR of )
  (f : VAR of )
  IF
    FLt
      VAR f
      FLOAT 0.
    NEG
      VAR f
    VAR f
LETREC fhalf (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.5
LETREC fsqr (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    VAR x
LETREC fneg (VAR of )
  (x : VAR of )
  NEG
    VAR x
LETREC fless (VAR of )
  (a : VAR of ), (b : VAR of )
  FLt
    VAR a
    VAR b
LETREC abs_float (VAR of )
  (x : VAR of )
  APP
    VAR fabs
    VAR x
LETREC fispos (VAR of )
  (x : VAR of )
  FLt
    FLOAT 0.
    VAR x
LETREC fisneg (VAR of )
  (x : VAR of )
  FLt
    VAR x
    FLOAT 0.
LET n_objects (VAR of )
  ARRAY
    INT 1
    INT 0
LET objects (VAR of )
  LET dummy (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  ARRAY
    INT 60
    TUPLE
      INT 0
      INT 0
      INT 0
      INT 0
      VAR dummy
      VAR dummy
      BOOL false
      VAR dummy
      VAR dummy
      VAR dummy
      VAR dummy
LET screen (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET viewpoint (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET light (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET beam (VAR of )
  ARRAY
    INT 1
    FLOAT 255.
LET and_net (VAR of )
  ARRAY
    INT 50
    ARRAY
      INT 1
      NEG
        INT 1
LET or_net (VAR of )
  ARRAY
    INT 1
    ARRAY
      INT 1
      GET
        VAR and_net
        INT 0
LET solver_dist (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET intsec_rectside (VAR of )
  ARRAY
    INT 1
    INT 0
LET tmin (VAR of )
  ARRAY
    INT 1
    FLOAT 1000000000.
LET intersection_point (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET intersected_object_id (VAR of )
  ARRAY
    INT 1
    INT 0
LET nvector (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET texture_color (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET diffuse_ray (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET rgb (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET image_size (VAR of )
  ARRAY
    INT 2
    INT 0
LET image_center (VAR of )
  ARRAY
    INT 2
    INT 0
LET scan_pitch (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET startp (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET startp_fast (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenx_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screeny_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenz_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET ptrace_dirvec (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET dirvecs (VAR of )
  LET dummyf (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff (VAR of )
    ARRAY
      INT 0
      VAR dummyf
  LET dummy_vs (VAR of )
    ARRAY
      INT 0
      TUPLE
        VAR dummyf
        VAR dummyff
  ARRAY
    INT 5
    VAR dummy_vs
LET light_dirvec (VAR of )
  LET dummyf2 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      INT 60
      VAR dummyf2
  TUPLE
    VAR v3
    VAR consts
LET reflections (VAR of )
  LET dummyf3 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff3 (VAR of )
    ARRAY
      INT 0
      VAR dummyf3
  LET dummydv (VAR of )
    TUPLE
      VAR dummyf3
      VAR dummyff3
  ARRAY
    INT 180
    TUPLE
      INT 0
      VAR dummydv
      FLOAT 0.
LET n_reflections (VAR of )
  ARRAY
    INT 1
    INT 0
LETREC xor (VAR of )
  (x : VAR of ), (y : VAR of )
  IF
    VAR x
    NOT
      VAR y
    VAR y
LETREC sgn (VAR of )
  (x : VAR of )
  IF
    FZero?
      VAR x
    FLOAT 0.
    IF
      APP
        VAR fispos
        VAR x
      FLOAT 1.
      FLOAT -1.
LETREC fneg_cond (VAR of )
  (cond : VAR of ), (x : VAR of )
  IF
    VAR cond
    VAR x
    APP
      VAR fneg
      VAR x
LETREC add_mod5 (VAR of )
  (x : VAR of ), (y : VAR of )
  LET sum (VAR of )
    ADD
      VAR x
      VAR y
  IF
    LE
      INT 5
      VAR sum
    SUB
      VAR sum
      INT 5
    VAR sum
LETREC vecset (VAR of )
  (v : VAR of ), (x : VAR of ), (y : VAR of ), (z : VAR of )
  LET Tu20 (UNIT)
    PUT
      VAR v
      INT 0
      VAR x
  LET Tu19 (UNIT)
    PUT
      VAR v
      INT 1
      VAR y
  PUT
    VAR v
    INT 2
    VAR z
LETREC vecfill (VAR of )
  (v : VAR of ), (elem : VAR of )
  LET Tu22 (UNIT)
    PUT
      VAR v
      INT 0
      VAR elem
  LET Tu21 (UNIT)
    PUT
      VAR v
      INT 1
      VAR elem
  PUT
    VAR v
    INT 2
    VAR elem
LETREC vecbzero (VAR of )
  (v : VAR of )
  APP
    VAR vecfill
    VAR v
    FLOAT 0.
LETREC veccpy (VAR of )
  (dest : VAR of ), (src : VAR of )
  LET Tu24 (UNIT)
    PUT
      VAR dest
      INT 0
      GET
        VAR src
        INT 0
  LET Tu23 (UNIT)
    PUT
      VAR dest
      INT 1
      GET
        VAR src
        INT 1
  PUT
    VAR dest
    INT 2
    GET
      VAR src
      INT 2
LETREC vecdist2 (VAR of )
  (p : VAR of ), (q : VAR of )
  FADD
    FADD
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 0
          GET
            VAR q
            INT 0
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 1
          GET
            VAR q
            INT 1
    APP
      VAR fsqr
      FSUB
        GET
          VAR p
          INT 2
        GET
          VAR q
          INT 2
LETREC vecunit (VAR of )
  (v : VAR of )
  LET il (VAR of )
    FDIV
      FLOAT 1.
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              GET
                VAR v
                INT 0
            APP
              VAR fsqr
              GET
                VAR v
                INT 1
          APP
            VAR fsqr
            GET
              VAR v
              INT 2
  LET Tu26 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu25 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC vecunit_sgn (VAR of )
  (v : VAR of ), (inv : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FADD
          APP
            VAR fsqr
            GET
              VAR v
              INT 0
          APP
            VAR fsqr
            GET
              VAR v
              INT 1
        APP
          VAR fsqr
          GET
            VAR v
            INT 2
  LET il (VAR of )
    IF
      FZero?
        VAR l
      FLOAT 1.
      IF
        VAR inv
        FDIV
          FLOAT -1.
          VAR l
        FDIV
          FLOAT 1.
          VAR l
  LET Tu28 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu27 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC veciprod (VAR of )
  (v : VAR of ), (w : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        GET
          VAR w
          INT 0
      FMUL
        GET
          VAR v
          INT 1
        GET
          VAR w
          INT 1
    FMUL
      GET
        VAR v
        INT 2
      GET
        VAR w
        INT 2
LETREC veciprod2 (VAR of )
  (v : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        VAR w0
      FMUL
        GET
          VAR v
          INT 1
        VAR w1
    FMUL
      GET
        VAR v
        INT 2
      VAR w2
LETREC vecaccum (VAR of )
  (dest : VAR of ), (scale : VAR of ), (v : VAR of )
  LET Tu30 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          VAR scale
          GET
            VAR v
            INT 0
  LET Tu29 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          VAR scale
          GET
            VAR v
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        VAR scale
        GET
          VAR v
          INT 2
LETREC vecadd (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu32 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu31 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecmul (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu34 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu33 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecscale (VAR of )
  (dest : VAR of ), (scale : VAR of )
  LET Tu36 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        VAR scale
  LET Tu35 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        VAR scale
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      VAR scale
LETREC vecaccumv (VAR of )
  (dest : VAR of ), (v : VAR of ), (w : VAR of )
  LET Tu38 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          GET
            VAR v
            INT 0
          GET
            VAR w
            INT 0
  LET Tu37 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          GET
            VAR v
            INT 1
          GET
            VAR w
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        GET
          VAR v
          INT 2
        GET
          VAR w
          INT 2
LETREC o_texturetype (VAR of )
  (m : VAR of )
  (m_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_tex
LETREC o_form (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (m_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_shape
LETREC o_reflectiontype (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_surface
LETREC o_isinvert (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (m_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_invert
LETREC o_isrot (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (m_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_isrot
LETREC o_param_a (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 0
LETREC o_param_b (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 1
LETREC o_param_c (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 2
LETREC o_param_abc (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_abc
LETREC o_param_x (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 0
LETREC o_param_y (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 1
LETREC o_param_z (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 2
LETREC o_diffuse (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 0
LETREC o_hilight (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 1
LETREC o_color_red (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 0
LETREC o_color_green (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 1
LETREC o_color_blue (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 2
LETREC o_param_r1 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 0
LETREC o_param_r2 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 1
LETREC o_param_r3 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 2
LETREC o_param_ctbl (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (m_ctbl : VAR of )
    VAR m
    VAR m_ctbl
LETREC p_rgb (VAR of )
  (pixel : VAR of )
  (m_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_rgb
LETREC p_intersection_points (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (m_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_isect_ps
LETREC p_surface_ids (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (m_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_sids
LETREC p_calc_diffuse (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (m_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_cdif
LETREC p_energy (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (m_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_engy
LETREC p_received_ray_20percent (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (m_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_r20p
LETREC p_group_id (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    GET
      VAR m_gid
      INT 0
LETREC p_set_group_id (VAR of )
  (pixel : VAR of ), (id : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    PUT
      VAR m_gid
      INT 0
      VAR id
LETREC p_nvectors (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (m_nvectors : VAR of )
    VAR pixel
    VAR m_nvectors
LETREC d_vec (VAR of )
  (d : VAR of )
  (m_vec : VAR of ), (xm_const : VAR of )
    VAR d
    VAR m_vec
LETREC d_const (VAR of )
  (d : VAR of )
  (dm_vec : VAR of ), (m_const : VAR of )
    VAR d
    VAR m_const
LETREC r_surface_id (VAR of )
  (r : VAR of )
  (m_sid : VAR of ), (xm_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_sid
LETREC r_dvec (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (m_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_dvec
LETREC r_bright (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (xm_dvec : VAR of ), (m_br : VAR of )
    VAR r
    VAR m_br
LETREC rad (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.017453293
LETREC read_screen_settings (VAR of )
  (Tu39 : VAR of )
  LET Tu53 (UNIT)
    PUT
      VAR screen
      INT 0
      UNKNOWN APP        inflt
        UNIT
  LET Tu52 (UNIT)
    PUT
      VAR screen
      INT 1
      UNKNOWN APP        inflt
        UNIT
  LET Tu51 (UNIT)
    PUT
      VAR screen
      INT 2
      UNKNOWN APP        inflt
        UNIT
  LET v1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v1 (VAR of )
    APP
      VAR cos
      VAR v1
  LET sin_v1 (VAR of )
    APP
      VAR sin
      VAR v1
  LET v2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v2 (VAR of )
    APP
      VAR cos
      VAR v2
  LET sin_v2 (VAR of )
    APP
      VAR sin
      VAR v2
  LET Tu50 (UNIT)
    PUT
      VAR screenz_dir
      INT 0
      FMUL
        FMUL
          VAR cos_v1
          VAR sin_v2
        FLOAT 200.
  LET Tu49 (UNIT)
    PUT
      VAR screenz_dir
      INT 1
      FMUL
        VAR sin_v1
        FLOAT -200.
  LET Tu48 (UNIT)
    PUT
      VAR screenz_dir
      INT 2
      FMUL
        FMUL
          VAR cos_v1
          VAR cos_v2
        FLOAT 200.
  LET Tu47 (UNIT)
    PUT
      VAR screenx_dir
      INT 0
      VAR cos_v2
  LET Tu46 (UNIT)
    PUT
      VAR screenx_dir
      INT 1
      FLOAT 0.
  LET Tu45 (UNIT)
    PUT
      VAR screenx_dir
      INT 2
      APP
        VAR fneg
        VAR sin_v2
  LET Tu44 (UNIT)
    PUT
      VAR screeny_dir
      INT 0
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR sin_v2
  LET Tu43 (UNIT)
    PUT
      VAR screeny_dir
      INT 1
      APP
        VAR fneg
        VAR cos_v1
  LET Tu42 (UNIT)
    PUT
      VAR screeny_dir
      INT 2
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR cos_v2
  LET Tu41 (UNIT)
    PUT
      VAR viewpoint
      INT 0
      FSUB
        GET
          VAR screen
          INT 0
        GET
          VAR screenz_dir
          INT 0
  LET Tu40 (UNIT)
    PUT
      VAR viewpoint
      INT 1
      FSUB
        GET
          VAR screen
          INT 1
        GET
          VAR screenz_dir
          INT 1
  PUT
    VAR viewpoint
    INT 2
    FSUB
      GET
        VAR screen
        INT 2
      GET
        VAR screenz_dir
        INT 2
LETREC read_light (VAR of )
  (Tu54 : VAR of )
  LET nl (VAR of )
    UNKNOWN APP      inint
      UNIT
  LET l1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET sl1 (VAR of )
    APP
      VAR sin
      VAR l1
  LET Tu57 (UNIT)
    PUT
      VAR light
      INT 1
      APP
        VAR fneg
        VAR sl1
  LET l2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cl1 (VAR of )
    APP
      VAR cos
      VAR l1
  LET sl2 (VAR of )
    APP
      VAR sin
      VAR l2
  LET Tu56 (UNIT)
    PUT
      VAR light
      INT 0
      FMUL
        VAR cl1
        VAR sl2
  LET cl2 (VAR of )
    APP
      VAR cos
      VAR l2
  LET Tu55 (UNIT)
    PUT
      VAR light
      INT 2
      FMUL
        VAR cl1
        VAR cl2
  PUT
    VAR beam
    INT 0
    UNKNOWN APP      inflt
      UNIT
LETREC rotate_quadratic_matrix (VAR of )
  (abc : VAR of ), (rot : VAR of )
  LET cos_x (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 0
  LET sin_x (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 0
  LET cos_y (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 1
  LET sin_y (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 1
  LET cos_z (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 2
  LET sin_z (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 2
  LET m00 (VAR of )
    FMUL
      VAR cos_y
      VAR cos_z
  LET m01 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR cos_x
        VAR sin_z
  LET m02 (VAR of )
    FADD
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR sin_x
        VAR sin_z
  LET m10 (VAR of )
    FMUL
      VAR cos_y
      VAR sin_z
  LET m11 (VAR of )
    FADD
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR cos_x
        VAR cos_z
  LET m12 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR sin_x
        VAR cos_z
  LET m20 (VAR of )
    APP
      VAR fneg
      VAR sin_y
  LET m21 (VAR of )
    FMUL
      VAR sin_x
      VAR cos_y
  LET m22 (VAR of )
    FMUL
      VAR cos_x
      VAR cos_y
  LET ao (VAR of )
    GET
      VAR abc
      INT 0
  LET bo (VAR of )
    GET
      VAR abc
      INT 1
  LET co (VAR of )
    GET
      VAR abc
      INT 2
  LET Tu62 (UNIT)
    PUT
      VAR abc
      INT 0
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m00
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m10
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m20
  LET Tu61 (UNIT)
    PUT
      VAR abc
      INT 1
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m01
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m11
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m21
  LET Tu60 (UNIT)
    PUT
      VAR abc
      INT 2
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m02
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m12
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m22
  LET Tu59 (UNIT)
    PUT
      VAR rot
      INT 0
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m01
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m11
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m21
            VAR m22
  LET Tu58 (UNIT)
    PUT
      VAR rot
      INT 1
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m00
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m10
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m20
            VAR m22
  PUT
    VAR rot
    INT 2
    FMUL
      FLOAT 2.
      FADD
        FADD
          FMUL
            FMUL
              VAR ao
              VAR m00
            VAR m01
          FMUL
            FMUL
              VAR bo
              VAR m10
            VAR m11
        FMUL
          FMUL
            VAR co
            VAR m20
          VAR m21
LETREC read_nth_object (VAR of )
  (n : VAR of )
  LET texture (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    NOT
      EQ
        VAR texture
        NEG
          INT 1
    LET form (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET refltype (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET isrot_p (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET abc (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu81 (UNIT)
      PUT
        VAR abc
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu80 (UNIT)
      PUT
        VAR abc
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu79 (UNIT)
      PUT
        VAR abc
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET xyz (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu78 (UNIT)
      PUT
        VAR xyz
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu77 (UNIT)
      PUT
        VAR xyz
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu76 (UNIT)
      PUT
        VAR xyz
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET m_invert (VAR of )
      APP
        VAR fisneg
        UNKNOWN APP          inflt
          UNIT
    LET reflparam (VAR of )
      ARRAY
        INT 2
        FLOAT 0.
    LET Tu75 (UNIT)
      PUT
        VAR reflparam
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu74 (UNIT)
      PUT
        VAR reflparam
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET color (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu73 (UNIT)
      PUT
        VAR color
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu72 (UNIT)
      PUT
        VAR color
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu71 (UNIT)
      PUT
        VAR color
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET rotation (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu70 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        LET Tu64 (UNIT)
          PUT
            VAR rotation
            INT 0
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        LET Tu63 (UNIT)
          PUT
            VAR rotation
            INT 1
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        PUT
          VAR rotation
          INT 2
          APP
            VAR rad
            UNKNOWN APP              inflt
              UNIT
        UNIT
    LET m_invert2 (VAR of )
      IF
        EQ
          VAR form
          INT 2
        BOOL true
        VAR m_invert
    LET ctbl (VAR of )
      ARRAY
        INT 4
        FLOAT 0.
    LET obj (VAR of )
      TUPLE
        VAR texture
        VAR form
        VAR refltype
        VAR isrot_p
        VAR abc
        VAR xyz
        VAR m_invert2
        VAR reflparam
        VAR color
        VAR rotation
        VAR ctbl
    LET Tu69 (UNIT)
      PUT
        VAR objects
        VAR n
        VAR obj
    LET Tu68 (UNIT)
      IF
        EQ
          VAR form
          INT 3
        LET a (VAR of )
          GET
            VAR abc
            INT 0
        LET Tu66 (UNIT)
          PUT
            VAR abc
            INT 0
            IF
              FZero?
                VAR a
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR a
                APP
                  VAR fsqr
                  VAR a
        LET b (VAR of )
          GET
            VAR abc
            INT 1
        LET Tu65 (UNIT)
          PUT
            VAR abc
            INT 1
            IF
              FZero?
                VAR b
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR b
                APP
                  VAR fsqr
                  VAR b
        LET c (VAR of )
          GET
            VAR abc
            INT 2
        PUT
          VAR abc
          INT 2
          IF
            FZero?
              VAR c
            FLOAT 0.
            FDIV
              APP
                VAR sgn
                VAR c
              APP
                VAR fsqr
                VAR c
        IF
          EQ
            VAR form
            INT 2
          APP
            VAR vecunit_sgn
            VAR abc
            NOT
              VAR m_invert
          UNIT
    LET Tu67 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        APP
          VAR rotate_quadratic_matrix
          VAR abc
          VAR rotation
        UNIT
    BOOL true
    BOOL false
LETREC read_object (VAR of )
  (n : VAR of )
  IF
    NOT
      LE
        INT 60
        VAR n
    IF
      APP
        VAR read_nth_object
        VAR n
      APP
        VAR read_object
        ADD
          VAR n
          INT 1
      PUT
        VAR n_objects
        INT 0
        VAR n
    UNIT
LETREC read_all_object (VAR of )
  (Tu82 : VAR of )
  APP
    VAR read_object
    INT 0
LETREC read_net_item (VAR of )
  (length : VAR of )
  LET item (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    EQ
      VAR item
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      NEG
        INT 1
    LET v (VAR of )
      APP
        VAR read_net_item
        ADD
          VAR length
          INT 1
    LET Tu83 (UNIT)
      PUT
        VAR v
        VAR length
        VAR item
    VAR v
LETREC read_or_network (VAR of )
  (length : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      VAR net
    LET v (VAR of )
      APP
        VAR read_or_network
        ADD
          VAR length
          INT 1
    LET Tu84 (UNIT)
      PUT
        VAR v
        VAR length
        VAR net
    VAR v
LETREC read_and_network (VAR of )
  (n : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    UNIT
    LET Tu85 (UNIT)
      PUT
        VAR and_net
        VAR n
        VAR net
    APP
      VAR read_and_network
      ADD
        VAR n
        INT 1
LETREC read_parameter (VAR of )
  (Tu86 : VAR of )
  LET Tu90 (UNIT)
    APP
      VAR read_screen_settings
      UNIT
  LET Tu89 (UNIT)
    APP
      VAR read_light
      UNIT
  LET Tu88 (UNIT)
    APP
      VAR read_all_object
      UNIT
  LET Tu87 (UNIT)
    APP
      VAR read_and_network
      INT 0
  PUT
    VAR or_net
    INT 0
    APP
      VAR read_or_network
      INT 0
LETREC solver_rect_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of ), (i0 : VAR of ), (i1 : VAR of ), (i2 : VAR of )
  IF
    FZero?
      GET
        VAR dirvec
        VAR i0
    BOOL false
    LET abc (VAR of )
      APP
        VAR o_param_abc
        VAR m
    LET d (VAR of )
      APP
        VAR fneg_cond
        APP
          VAR xor
          APP
            VAR o_isinvert
            VAR m
          APP
            VAR fisneg
            GET
              VAR dirvec
              VAR i0
        GET
          VAR abc
          VAR i0
    LET d2 (VAR of )
      FDIV
        FSUB
          VAR d
          VAR b0
        GET
          VAR dirvec
          VAR i0
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d2
              GET
                VAR dirvec
                VAR i1
            VAR b1
        GET
          VAR abc
          VAR i1
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d2
                GET
                  VAR dirvec
                  VAR i2
              VAR b2
          GET
            VAR abc
            VAR i2
        LET Tu91 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        BOOL true
        BOOL false
      BOOL false
LETREC solver_rect (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR solver_rect_surface
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
      INT 0
      INT 1
      INT 2
    INT 1
    IF
      APP
        VAR solver_rect_surface
        VAR m
        VAR dirvec
        VAR b1
        VAR b2
        VAR b0
        INT 1
        INT 2
        INT 0
      INT 2
      IF
        APP
          VAR solver_rect_surface
          VAR m
          VAR dirvec
          VAR b2
          VAR b0
          VAR b1
          INT 2
          INT 0
          INT 1
        INT 3
        INT 0
LETREC solver_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET abc (VAR of )
    APP
      VAR o_param_abc
      VAR m
  LET d (VAR of )
    APP
      VAR veciprod
      VAR dirvec
      VAR abc
  IF
    APP
      VAR fispos
      VAR d
    LET Tu92 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FDIV
          APP
            VAR fneg
            APP
              VAR veciprod2
              VAR abc
              VAR b0
              VAR b1
              VAR b2
          VAR d
    INT 1
    INT 0
LETREC quadratic (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          APP
            VAR fsqr
            VAR v0
          APP
            VAR o_param_a
            VAR m
        FMUL
          APP
            VAR fsqr
            VAR v1
          APP
            VAR o_param_b
            VAR m
      FMUL
        APP
          VAR fsqr
          VAR v2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      FADD
        FADD
          VAR diag_part
          FMUL
            FMUL
              VAR v1
              VAR v2
            APP
              VAR o_param_r1
              VAR m
        FMUL
          FMUL
            VAR v2
            VAR v0
          APP
            VAR o_param_r2
            VAR m
      FMUL
        FMUL
          VAR v0
          VAR v1
        APP
          VAR o_param_r3
          VAR m
LETREC bilinear (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          FMUL
            VAR v0
            VAR w0
          APP
            VAR o_param_a
            VAR m
        FMUL
          FMUL
            VAR v1
            VAR w1
          APP
            VAR o_param_b
            VAR m
      FMUL
        FMUL
          VAR v2
          VAR w2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      VAR diag_part
      APP
        VAR fhalf
        FADD
          FADD
            FMUL
              FADD
                FMUL
                  VAR v2
                  VAR w1
                FMUL
                  VAR v1
                  VAR w2
              APP
                VAR o_param_r1
                VAR m
            FMUL
              FADD
                FMUL
                  VAR v0
                  VAR w2
                FMUL
                  VAR v2
                  VAR w0
              APP
                VAR o_param_r2
                VAR m
          FMUL
            FADD
              FMUL
                VAR v0
                VAR w1
              FMUL
                VAR v1
                VAR w0
            APP
              VAR o_param_r3
              VAR m
LETREC solver_second (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR dirvec
        INT 0
      GET
        VAR dirvec
        INT 1
      GET
        VAR dirvec
        INT 2
  IF
    FZero?
      VAR aa
    INT 0
    LET bb (VAR of )
      APP
        VAR bilinear
        VAR m
        GET
          VAR dirvec
          INT 0
        GET
          VAR dirvec
          INT 1
        GET
          VAR dirvec
          INT 2
        VAR b0
        VAR b1
        VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET sd (VAR of )
        APP
          VAR sqrt
          VAR d
      LET t1 (VAR of )
        IF
          APP
            VAR o_isinvert
            VAR m
          VAR sd
          APP
            VAR fneg
            VAR sd
      LET Tu93 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          FDIV
            FSUB
              VAR t1
              VAR bb
            VAR aa
      INT 1
      INT 0
LETREC solver (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
LETREC solver_rect_fast (VAR of )
  (m : VAR of ), (v : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET d0 (VAR of )
    FMUL
      FSUB
        GET
          VAR dconst
          INT 0
        VAR b0
      GET
        VAR dconst
        INT 1
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d0
              GET
                VAR v
                INT 1
            VAR b1
        APP
          VAR o_param_b
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d0
                GET
                  VAR v
                  INT 2
              VAR b2
          APP
            VAR o_param_c
            VAR m
        NOT
          FZero?
            GET
              VAR dconst
              INT 1
        BOOL false
      BOOL false
    LET Tu94 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        VAR d0
    INT 1
    LET d1 (VAR of )
      FMUL
        FSUB
          GET
            VAR dconst
            INT 2
          VAR b1
        GET
          VAR dconst
          INT 3
    IF
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d1
                GET
                  VAR v
                  INT 0
              VAR b0
          APP
            VAR o_param_a
            VAR m
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d1
                  GET
                    VAR v
                    INT 2
                VAR b2
            APP
              VAR o_param_c
              VAR m
          NOT
            FZero?
              GET
                VAR dconst
                INT 3
          BOOL false
        BOOL false
      LET Tu95 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          VAR d1
      INT 2
      LET d2 (VAR of )
        FMUL
          FSUB
            GET
              VAR dconst
              INT 4
            VAR b2
          GET
            VAR dconst
            INT 5
      IF
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d2
                  GET
                    VAR v
                    INT 0
                VAR b0
            APP
              VAR o_param_a
              VAR m
          IF
            APP
              VAR fless
              APP
                VAR fabs
                FADD
                  FMUL
                    VAR d2
                    GET
                      VAR v
                      INT 1
                  VAR b1
              APP
                VAR o_param_b
                VAR m
            NOT
              FZero?
                GET
                  VAR dconst
                  INT 5
            BOOL false
          BOOL false
        LET Tu96 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        INT 3
        INT 0
LETREC solver_surface_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu97 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FADD
          FADD
            FMUL
              GET
                VAR dconst
                INT 1
              VAR b0
            FMUL
              GET
                VAR dconst
                INT 2
              VAR b1
          FMUL
            GET
              VAR dconst
              INT 3
            VAR b2
    INT 1
    INT 0
LETREC solver_second_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu98 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
LETREC solver_surface_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu99 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FMUL
          GET
            VAR dconst
            INT 0
          GET
            VAR sconst
            INT 3
    INT 1
    INT 0
LETREC solver_second_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc (VAR of )
      GET
        VAR sconst
        INT 3
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu100 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast2 (VAR of )
  (index : VAR of ), (dirvec : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET sconst (VAR of )
    APP
      VAR o_param_ctbl
      VAR m
  LET b0 (VAR of )
    GET
      VAR sconst
      INT 0
  LET b1 (VAR of )
    GET
      VAR sconst
      INT 1
  LET b2 (VAR of )
    GET
      VAR sconst
      INT 2
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
LETREC setup_rect_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 6
      FLOAT 0.
  LET Tu106 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 0
      PUT
        VAR const
        INT 1
        FLOAT 0.
      LET Tu101 (UNIT)
        PUT
          VAR const
          INT 0
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 0
            APP
              VAR o_param_a
              VAR m
      PUT
        VAR const
        INT 1
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 0
  LET Tu105 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 1
      PUT
        VAR const
        INT 3
        FLOAT 0.
      LET Tu102 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 1
            APP
              VAR o_param_b
              VAR m
      PUT
        VAR const
        INT 3
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 1
  LET Tu104 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 2
      PUT
        VAR const
        INT 5
        FLOAT 0.
      LET Tu103 (UNIT)
        PUT
          VAR const
          INT 4
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 2
            APP
              VAR o_param_c
              VAR m
      PUT
        VAR const
        INT 5
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 2
  VAR const
LETREC setup_surface_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 4
      FLOAT 0.
  LET d (VAR of )
    FADD
      FADD
        FMUL
          GET
            VAR vec
            INT 0
          APP
            VAR o_param_a
            VAR m
        FMUL
          GET
            VAR vec
            INT 1
          APP
            VAR o_param_b
            VAR m
      FMUL
        GET
          VAR vec
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu110 (UNIT)
    IF
      APP
        VAR fispos
        VAR d
      LET Tu109 (UNIT)
        PUT
          VAR const
          INT 0
          FDIV
            FLOAT -1.
            VAR d
      LET Tu108 (UNIT)
        PUT
          VAR const
          INT 1
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_a
                VAR m
              VAR d
      LET Tu107 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_b
                VAR m
              VAR d
      PUT
        VAR const
        INT 3
        APP
          VAR fneg
          FDIV
            APP
              VAR o_param_c
              VAR m
            VAR d
      PUT
        VAR const
        INT 0
        FLOAT 0.
  VAR const
LETREC setup_second_table (VAR of )
  (v : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 5
      FLOAT 0.
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
      GET
        VAR v
        INT 2
  LET c1 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 0
        APP
          VAR o_param_a
          VAR m
  LET c2 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 1
        APP
          VAR o_param_b
          VAR m
  LET c3 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu117 (UNIT)
    PUT
      VAR const
      INT 0
      VAR aa
  LET Tu116 (UNIT)
    IF
      NOT
        EQ
          APP
            VAR o_isrot
            VAR m
          INT 0
      LET Tu112 (UNIT)
        PUT
          VAR const
          INT 1
          FSUB
            VAR c1
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r2
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 1
                  APP
                    VAR o_param_r3
                    VAR m
      LET Tu111 (UNIT)
        PUT
          VAR const
          INT 2
          FSUB
            VAR c2
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r1
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 0
                  APP
                    VAR o_param_r3
                    VAR m
      PUT
        VAR const
        INT 3
        FSUB
          VAR c3
          APP
            VAR fhalf
            FADD
              FMUL
                GET
                  VAR v
                  INT 1
                APP
                  VAR o_param_r1
                  VAR m
              FMUL
                GET
                  VAR v
                  INT 0
                APP
                  VAR o_param_r2
                  VAR m
      LET Tu114 (UNIT)
        PUT
          VAR const
          INT 1
          VAR c1
      LET Tu113 (UNIT)
        PUT
          VAR const
          INT 2
          VAR c2
      PUT
        VAR const
        INT 3
        VAR c3
  LET Tu115 (UNIT)
    IF
      NOT
        FZero?
          VAR aa
      PUT
        VAR const
        INT 4
        FDIV
          FLOAT 1.
          VAR aa
      UNIT
  VAR const
LETREC iter_setup_dirvec_constants (VAR of )
  (dirvec : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET m (VAR of )
      GET
        VAR objects
        VAR index
    LET dconst (VAR of )
      APP
        VAR d_const
        VAR dirvec
    LET v (VAR of )
      APP
        VAR d_vec
        VAR dirvec
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR m
    LET Tu118 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 1
        PUT
          VAR dconst
          VAR index
          APP
            VAR setup_rect_table
            VAR v
            VAR m
        IF
          EQ
            VAR m_shape
            INT 2
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_surface_table
              VAR v
              VAR m
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_second_table
              VAR v
              VAR m
    APP
      VAR iter_setup_dirvec_constants
      VAR dirvec
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_dirvec_constants (VAR of )
  (dirvec : VAR of )
  APP
    VAR iter_setup_dirvec_constants
    VAR dirvec
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC setup_startp_constants (VAR of )
  (p : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET obj (VAR of )
      GET
        VAR objects
        VAR index
    LET sconst (VAR of )
      APP
        VAR o_param_ctbl
        VAR obj
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR obj
    LET Tu122 (UNIT)
      PUT
        VAR sconst
        INT 0
        FSUB
          GET
            VAR p
            INT 0
          APP
            VAR o_param_x
            VAR obj
    LET Tu121 (UNIT)
      PUT
        VAR sconst
        INT 1
        FSUB
          GET
            VAR p
            INT 1
          APP
            VAR o_param_y
            VAR obj
    LET Tu120 (UNIT)
      PUT
        VAR sconst
        INT 2
        FSUB
          GET
            VAR p
            INT 2
          APP
            VAR o_param_z
            VAR obj
    LET Tu119 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 2
        PUT
          VAR sconst
          INT 3
          APP
            VAR veciprod2
            APP
              VAR o_param_abc
              VAR obj
            GET
              VAR sconst
              INT 0
            GET
              VAR sconst
              INT 1
            GET
              VAR sconst
              INT 2
        IF
          NOT
            LE
              VAR m_shape
              INT 2
          LET cc0 (VAR of )
            APP
              VAR quadratic
              VAR obj
              GET
                VAR sconst
                INT 0
              GET
                VAR sconst
                INT 1
              GET
                VAR sconst
                INT 2
          PUT
            VAR sconst
            INT 3
            IF
              EQ
                VAR m_shape
                INT 3
              FSUB
                VAR cc0
                FLOAT 1.
              VAR cc0
          UNIT
    APP
      VAR setup_startp_constants
      VAR p
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_startp (VAR of )
  (p : VAR of )
  LET Tu123 (UNIT)
    APP
      VAR veccpy
      VAR startp_fast
      VAR p
  APP
    VAR setup_startp_constants
    VAR p
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC is_rect_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          VAR p0
        APP
          VAR o_param_a
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            VAR p1
          APP
            VAR o_param_b
            VAR m
        APP
          VAR fless
          APP
            VAR fabs
            VAR p2
          APP
            VAR o_param_c
            VAR m
        BOOL false
      BOOL false
    APP
      VAR o_isinvert
      VAR m
    NOT
      APP
        VAR o_isinvert
        VAR m
LETREC is_plane_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR veciprod2
      APP
        VAR o_param_abc
        VAR m
      VAR p0
      VAR p1
      VAR p2
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w
LETREC is_second_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR quadratic
      VAR m
      VAR p0
      VAR p1
      VAR p2
  LET w2 (VAR of )
    IF
      EQ
        APP
          VAR o_form
          VAR m
        INT 3
      FSUB
        VAR w
        FLOAT 1.
      VAR w
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w2
LETREC is_outside (VAR of )
  (m : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET p0 (VAR of )
    FSUB
      VAR q0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      VAR q1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      VAR q2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR is_rect_outside
      VAR m
      VAR p0
      VAR p1
      VAR p2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR is_plane_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
      APP
        VAR is_second_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
LETREC check_all_inside (VAR of )
  (ofs : VAR of ), (iand : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET head (VAR of )
    GET
      VAR iand
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL true
    IF
      APP
        VAR is_outside
        GET
          VAR objects
          VAR head
        VAR q0
        VAR q1
        VAR q2
      BOOL false
      APP
        VAR check_all_inside
        ADD
          VAR ofs
          INT 1
        VAR iand
        VAR q0
        VAR q1
        VAR q2
LETREC shadow_check_and_group (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of )
  IF
    EQ
      GET
        VAR and_group
        VAR iand_ofs
      NEG
        INT 1
    BOOL false
    LET obj (VAR of )
      GET
        VAR and_group
        VAR iand_ofs
    LET t0 (VAR of )
      APP
        VAR solver_fast
        VAR obj
        VAR light_dirvec
        VAR intersection_point
    LET t0p (VAR of )
      GET
        VAR solver_dist
        INT 0
    IF
      IF
        NOT
          EQ
            VAR t0
            INT 0
        APP
          VAR fless
          VAR t0p
          FLOAT -0.2
        BOOL false
      LET t (VAR of )
        FADD
          VAR t0p
          FLOAT 0.01
      LET q0 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 0
            VAR t
          GET
            VAR intersection_point
            INT 0
      LET q1 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 1
            VAR t
          GET
            VAR intersection_point
            INT 1
      LET q2 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 2
            VAR t
          GET
            VAR intersection_point
            INT 2
      IF
        APP
          VAR check_all_inside
          INT 0
          VAR and_group
          VAR q0
          VAR q1
          VAR q2
        BOOL true
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR obj
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
        BOOL false
LETREC shadow_check_one_or_group (VAR of )
  (ofs : VAR of ), (or_group : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL false
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET shadow_p (VAR of )
      APP
        VAR shadow_check_and_group
        INT 0
        VAR and_group
    IF
      VAR shadow_p
      BOOL true
      APP
        VAR shadow_check_one_or_group
        ADD
          VAR ofs
          INT 1
        VAR or_group
LETREC shadow_check_one_or_matrix (VAR of )
  (ofs : VAR of ), (or_matrix : VAR of )
  LET head (VAR of )
    GET
      VAR or_matrix
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    BOOL false
    IF
      IF
        EQ
          VAR range_primitive
          INT 99
        BOOL true
        LET t (VAR of )
          APP
            VAR solver_fast
            VAR range_primitive
            VAR light_dirvec
            VAR intersection_point
        IF
          NOT
            EQ
              VAR t
              INT 0
          IF
            APP
              VAR fless
              GET
                VAR solver_dist
                INT 0
              FLOAT -0.1
            IF
              APP
                VAR shadow_check_one_or_group
                INT 1
                VAR head
              BOOL true
              BOOL false
            BOOL false
          BOOL false
      IF
        APP
          VAR shadow_check_one_or_group
          INT 1
          VAR head
        BOOL true
        APP
          VAR shadow_check_one_or_matrix
          ADD
            VAR ofs
            INT 1
          VAR or_matrix
      APP
        VAR shadow_check_one_or_matrix
        ADD
          VAR ofs
          INT 1
        VAR or_matrix
LETREC solve_each_element (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver
        VAR iobj
        VAR dirvec
        VAR startp
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu127 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 0
                  VAR t
                GET
                  VAR startp
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 1
                  VAR t
                GET
                  VAR startp
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 2
                  VAR t
                GET
                  VAR startp
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu126 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu125 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu124 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu128 (UNIT)
      APP
        VAR solve_each_element
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu129 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver
            VAR range_primitive
            VAR dirvec
            VAR startp
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection (VAR of )
  (dirvec : VAR of )
  LET Tu131 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu130 (UNIT)
    APP
      VAR trace_or_matrix
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC solve_each_element_fast (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET vec (VAR of )
    APP
      VAR d_vec
      VAR dirvec
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver_fast2
        VAR iobj
        VAR dirvec
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu135 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 0
                  VAR t
                GET
                  VAR startp_fast
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 1
                  VAR t
                GET
                  VAR startp_fast
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 2
                  VAR t
                GET
                  VAR startp_fast
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu134 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu133 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu132 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element_fast
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element_fast
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network_fast (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu136 (UNIT)
      APP
        VAR solve_each_element_fast
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network_fast
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix_fast (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu137 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network_fast
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver_fast2
            VAR range_primitive
            VAR dirvec
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network_fast
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix_fast
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection_fast (VAR of )
  (dirvec : VAR of )
  LET Tu139 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu138 (UNIT)
    APP
      VAR trace_or_matrix_fast
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC get_nvector_rect (VAR of )
  (dirvec : VAR of )
  LET rectside (VAR of )
    GET
      VAR intsec_rectside
      INT 0
  LET Tu140 (UNIT)
    APP
      VAR vecbzero
      VAR nvector
  PUT
    VAR nvector
    SUB
      VAR rectside
      INT 1
    APP
      VAR fneg
      APP
        VAR sgn
        GET
          VAR dirvec
          SUB
            VAR rectside
            INT 1
LETREC get_nvector_plane (VAR of )
  (m : VAR of )
  LET Tu142 (UNIT)
    PUT
      VAR nvector
      INT 0
      APP
        VAR fneg
        APP
          VAR o_param_a
          VAR m
  LET Tu141 (UNIT)
    PUT
      VAR nvector
      INT 1
      APP
        VAR fneg
        APP
          VAR o_param_b
          VAR m
  PUT
    VAR nvector
    INT 2
    APP
      VAR fneg
      APP
        VAR o_param_c
        VAR m
LETREC get_nvector_second (VAR of )
  (m : VAR of )
  LET p0 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET d0 (VAR of )
    FMUL
      VAR p0
      APP
        VAR o_param_a
        VAR m
  LET d1 (VAR of )
    FMUL
      VAR p1
      APP
        VAR o_param_b
        VAR m
  LET d2 (VAR of )
    FMUL
      VAR p2
      APP
        VAR o_param_c
        VAR m
  LET Tu147 (UNIT)
    IF
      EQ
        APP
          VAR o_isrot
          VAR m
        INT 0
      LET Tu144 (UNIT)
        PUT
          VAR nvector
          INT 0
          VAR d0
      LET Tu143 (UNIT)
        PUT
          VAR nvector
          INT 1
          VAR d1
      PUT
        VAR nvector
        INT 2
        VAR d2
      LET Tu146 (UNIT)
        PUT
          VAR nvector
          INT 0
          FADD
            VAR d0
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p1
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r2
                    VAR m
      LET Tu145 (UNIT)
        PUT
          VAR nvector
          INT 1
          FADD
            VAR d1
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p0
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r1
                    VAR m
      PUT
        VAR nvector
        INT 2
        FADD
          VAR d2
          APP
            VAR fhalf
            FADD
              FMUL
                VAR p0
                APP
                  VAR o_param_r2
                  VAR m
              FMUL
                VAR p1
                APP
                  VAR o_param_r1
                  VAR m
  APP
    VAR vecunit_sgn
    VAR nvector
    APP
      VAR o_isinvert
      VAR m
LETREC get_nvector (VAR of )
  (m : VAR of ), (dirvec : VAR of )
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR get_nvector_rect
      VAR dirvec
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR get_nvector_plane
        VAR m
      APP
        VAR get_nvector_second
        VAR m
LETREC utexture (VAR of )
  (m : VAR of ), (p : VAR of )
  LET m_tex (VAR of )
    APP
      VAR o_texturetype
      VAR m
  LET Tu152 (UNIT)
    PUT
      VAR texture_color
      INT 0
      APP
        VAR o_color_red
        VAR m
  LET Tu151 (UNIT)
    PUT
      VAR texture_color
      INT 1
      APP
        VAR o_color_green
        VAR m
  LET Tu150 (UNIT)
    PUT
      VAR texture_color
      INT 2
      APP
        VAR o_color_blue
        VAR m
  IF
    EQ
      VAR m_tex
      INT 1
    LET w1 (VAR of )
      FSUB
        GET
          VAR p
          INT 0
        APP
          VAR o_param_x
          VAR m
    LET flag1 (VAR of )
      LET d1 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w1
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w1
          VAR d1
        FLOAT 10.
    LET w3 (VAR of )
      FSUB
        GET
          VAR p
          INT 2
        APP
          VAR o_param_z
          VAR m
    LET flag2 (VAR of )
      LET d2 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w3
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w3
          VAR d2
        FLOAT 10.
    PUT
      VAR texture_color
      INT 1
      IF
        VAR flag1
        IF
          VAR flag2
          FLOAT 255.
          FLOAT 0.
        IF
          VAR flag2
          FLOAT 0.
          FLOAT 255.
    IF
      EQ
        VAR m_tex
        INT 2
      LET w2 (VAR of )
        APP
          VAR fsqr
          APP
            VAR sin
            FMUL
              GET
                VAR p
                INT 1
              FLOAT 0.25
      LET Tu148 (UNIT)
        PUT
          VAR texture_color
          INT 0
          FMUL
            FLOAT 255.
            VAR w2
      PUT
        VAR texture_color
        INT 1
        FMUL
          FLOAT 255.
          FSUB
            FLOAT 1.
            VAR w2
      IF
        EQ
          VAR m_tex
          INT 3
        LET w1 (VAR of )
          FSUB
            GET
              VAR p
              INT 0
            APP
              VAR o_param_x
              VAR m
        LET w3 (VAR of )
          FSUB
            GET
              VAR p
              INT 2
            APP
              VAR o_param_z
              VAR m
        LET w2 (VAR of )
          FDIV
            APP
              VAR sqrt
              FADD
                APP
                  VAR fsqr
                  VAR w1
                APP
                  VAR fsqr
                  VAR w3
            FLOAT 10.
        LET w4 (VAR of )
          FMUL
            FSUB
              VAR w2
              APP
                VAR floor
                VAR w2
            FLOAT 3.1415927
        LET cws (VAR of )
          APP
            VAR fsqr
            APP
              VAR cos
              VAR w4
        LET Tu149 (UNIT)
          PUT
            VAR texture_color
            INT 1
            FMUL
              VAR cws
              FLOAT 255.
        PUT
          VAR texture_color
          INT 2
          FMUL
            FSUB
              FLOAT 1.
              VAR cws
            FLOAT 255.
        IF
          EQ
            VAR m_tex
            INT 4
          LET w1 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 0
                APP
                  VAR o_param_x
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_a
                  VAR m
          LET w3 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 2
                APP
                  VAR o_param_z
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_c
                  VAR m
          LET w4 (VAR of )
            FADD
              APP
                VAR fsqr
                VAR w1
              APP
                VAR fsqr
                VAR w3
          LET w7 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w1
                FLOAT 0.0001
              FLOAT 15.
              LET w5 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w3
                    VAR w1
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w5
                  FLOAT 30.
                FLOAT 3.1415927
          LET w9 (VAR of )
            FSUB
              VAR w7
              APP
                VAR floor
                VAR w7
          LET w2 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 1
                APP
                  VAR o_param_y
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_b
                  VAR m
          LET w8 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w4
                FLOAT 0.0001
              FLOAT 15.
              LET w6 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w2
                    VAR w4
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w6
                  FLOAT 30.
                FLOAT 3.1415927
          LET w10 (VAR of )
            FSUB
              VAR w8
              APP
                VAR floor
                VAR w8
          LET w11 (VAR of )
            FSUB
              FSUB
                FLOAT 0.15
                APP
                  VAR fsqr
                  FSUB
                    FLOAT 0.5
                    VAR w9
              APP
                VAR fsqr
                FSUB
                  FLOAT 0.5
                  VAR w10
          LET w12 (VAR of )
            IF
              APP
                VAR fisneg
                VAR w11
              FLOAT 0.
              VAR w11
          PUT
            VAR texture_color
            INT 2
            FDIV
              FMUL
                FLOAT 255.
                VAR w12
              FLOAT 0.3
          UNIT
LETREC add_light (VAR of )
  (bright : VAR of ), (hilight : VAR of ), (hilight_scale : VAR of )
  LET Tu155 (UNIT)
    IF
      APP
        VAR fispos
        VAR bright
      APP
        VAR vecaccum
        VAR rgb
        VAR bright
        VAR texture_color
      UNIT
  IF
    APP
      VAR fispos
      VAR hilight
    LET ihl (VAR of )
      FMUL
        APP
          VAR fsqr
          APP
            VAR fsqr
            VAR hilight
        VAR hilight_scale
    LET Tu154 (UNIT)
      PUT
        VAR rgb
        INT 0
        FADD
          GET
            VAR rgb
            INT 0
          VAR ihl
    LET Tu153 (UNIT)
      PUT
        VAR rgb
        INT 1
        FADD
          GET
            VAR rgb
            INT 1
          VAR ihl
    PUT
      VAR rgb
      INT 2
      FADD
        GET
          VAR rgb
          INT 2
        VAR ihl
    UNIT
LETREC trace_reflections (VAR of )
  (index : VAR of ), (diffuse : VAR of ), (hilight_scale : VAR of ), (dirvec : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET rinfo (VAR of )
      GET
        VAR reflections
        VAR index
    LET dvec (VAR of )
      APP
        VAR r_dvec
        VAR rinfo
    LET Tu156 (UNIT)
      IF
        APP
          VAR judge_intersection_fast
          VAR dvec
        LET surface_id (VAR of )
          ADD
            MULTIPLE 4
              GET
                VAR intersected_object_id
                INT 0
            GET
              VAR intsec_rectside
              INT 0
        IF
          EQ
            VAR surface_id
            APP
              VAR r_surface_id
              VAR rinfo
          IF
            NOT
              APP
                VAR shadow_check_one_or_matrix
                INT 0
                GET
                  VAR or_net
                  INT 0
            LET p (VAR of )
              APP
                VAR veciprod
                VAR nvector
                APP
                  VAR d_vec
                  VAR dvec
            LET scale (VAR of )
              APP
                VAR r_bright
                VAR rinfo
            LET bright (VAR of )
              FMUL
                FMUL
                  VAR scale
                  VAR diffuse
                VAR p
            LET hilight (VAR of )
              FMUL
                VAR scale
                APP
                  VAR veciprod
                  VAR dirvec
                  APP
                    VAR d_vec
                    VAR dvec
            APP
              VAR add_light
              VAR bright
              VAR hilight
              VAR hilight_scale
            UNIT
          UNIT
        UNIT
    APP
      VAR trace_reflections
      SUB
        VAR index
        INT 1
      VAR diffuse
      VAR hilight_scale
      VAR dirvec
    UNIT
LETREC trace_ray (VAR of )
  (nref : VAR of ), (energy : VAR of ), (dirvec : VAR of ), (pixel : VAR of ), (dist : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      APP
        VAR judge_intersection
        VAR dirvec
      LET obj_id (VAR of )
        GET
          VAR intersected_object_id
          INT 0
      LET obj (VAR of )
        GET
          VAR objects
          VAR obj_id
      LET m_surface (VAR of )
        APP
          VAR o_reflectiontype
          VAR obj
      LET diffuse (VAR of )
        FMUL
          APP
            VAR o_diffuse
            VAR obj
          VAR energy
      LET Tu170 (UNIT)
        APP
          VAR get_nvector
          VAR obj
          VAR dirvec
      LET Tu169 (UNIT)
        APP
          VAR veccpy
          VAR startp
          VAR intersection_point
      LET Tu168 (UNIT)
        APP
          VAR utexture
          VAR obj
          VAR intersection_point
      LET Tu167 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          ADD
            MULTIPLE 4
              VAR obj_id
            GET
              VAR intsec_rectside
              INT 0
      LET intersection_points (VAR of )
        APP
          VAR p_intersection_points
          VAR pixel
      LET Tu166 (UNIT)
        APP
          VAR veccpy
          GET
            VAR intersection_points
            VAR nref
          VAR intersection_point
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu165 (UNIT)
        IF
          APP
            VAR fless
            APP
              VAR o_diffuse
              VAR obj
            FLOAT 0.5
          PUT
            VAR calc_diffuse
            VAR nref
            BOOL false
          LET Tu159 (UNIT)
            PUT
              VAR calc_diffuse
              VAR nref
              BOOL true
          LET energya (VAR of )
            APP
              VAR p_energy
              VAR pixel
          LET Tu158 (UNIT)
            APP
              VAR veccpy
              GET
                VAR energya
                VAR nref
              VAR texture_color
          LET Tu157 (UNIT)
            APP
              VAR vecscale
              GET
                VAR energya
                VAR nref
              FMUL
                FDIV
                  FLOAT 1.
                  FLOAT 256.
                VAR diffuse
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR nvectors
              VAR nref
            VAR nvector
      LET w (VAR of )
        FMUL
          FLOAT -2.
          APP
            VAR veciprod
            VAR dirvec
            VAR nvector
      LET Tu164 (UNIT)
        APP
          VAR vecaccum
          VAR dirvec
          VAR w
          VAR nvector
      LET hilight_scale (VAR of )
        FMUL
          VAR energy
          APP
            VAR o_hilight
            VAR obj
      LET Tu163 (UNIT)
        IF
          NOT
            APP
              VAR shadow_check_one_or_matrix
              INT 0
              GET
                VAR or_net
                INT 0
          LET bright (VAR of )
            FMUL
              APP
                VAR fneg
                APP
                  VAR veciprod
                  VAR nvector
                  VAR light
              VAR diffuse
          LET hilight (VAR of )
            APP
              VAR fneg
              APP
                VAR veciprod
                VAR dirvec
                VAR light
          APP
            VAR add_light
            VAR bright
            VAR hilight
            VAR hilight_scale
          UNIT
      LET Tu162 (UNIT)
        APP
          VAR setup_startp
          VAR intersection_point
      LET Tu161 (UNIT)
        APP
          VAR trace_reflections
          SUB
            GET
              VAR n_reflections
              INT 0
            INT 1
          VAR diffuse
          VAR hilight_scale
          VAR dirvec
      IF
        APP
          VAR fless
          FLOAT 0.1
          VAR energy
        LET Tu160 (UNIT)
          IF
            NOT
              LE
                INT 4
                VAR nref
            PUT
              VAR surface_ids
              ADD
                VAR nref
                INT 1
              NEG
                INT 1
            UNIT
        IF
          EQ
            VAR m_surface
            INT 2
          LET energy2 (VAR of )
            FMUL
              VAR energy
              FSUB
                FLOAT 1.
                APP
                  VAR o_diffuse
                  VAR obj
          APP
            VAR trace_ray
            ADD
              VAR nref
              INT 1
            VAR energy2
            VAR dirvec
            VAR pixel
            FADD
              VAR dist
              GET
                VAR tmin
                INT 0
          UNIT
        UNIT
      LET Tu173 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          NEG
            INT 1
      IF
        NOT
          EQ
            VAR nref
            INT 0
        LET hl (VAR of )
          APP
            VAR fneg
            APP
              VAR veciprod
              VAR dirvec
              VAR light
        IF
          APP
            VAR fispos
            VAR hl
          LET ihl (VAR of )
            FMUL
              FMUL
                FMUL
                  APP
                    VAR fsqr
                    VAR hl
                  VAR hl
                VAR energy
              GET
                VAR beam
                INT 0
          LET Tu172 (UNIT)
            PUT
              VAR rgb
              INT 0
              FADD
                GET
                  VAR rgb
                  INT 0
                VAR ihl
          LET Tu171 (UNIT)
            PUT
              VAR rgb
              INT 1
              FADD
                GET
                  VAR rgb
                  INT 1
                VAR ihl
          PUT
            VAR rgb
            INT 2
            FADD
              GET
                VAR rgb
                INT 2
              VAR ihl
          UNIT
        UNIT
    UNIT
LETREC trace_diffuse_ray (VAR of )
  (dirvec : VAR of ), (energy : VAR of )
  IF
    APP
      VAR judge_intersection_fast
      VAR dirvec
    LET obj (VAR of )
      GET
        VAR objects
        GET
          VAR intersected_object_id
          INT 0
    LET Tu175 (UNIT)
      APP
        VAR get_nvector
        VAR obj
        APP
          VAR d_vec
          VAR dirvec
    LET Tu174 (UNIT)
      APP
        VAR utexture
        VAR obj
        VAR intersection_point
    IF
      NOT
        APP
          VAR shadow_check_one_or_matrix
          INT 0
          GET
            VAR or_net
            INT 0
      LET br (VAR of )
        APP
          VAR fneg
          APP
            VAR veciprod
            VAR nvector
            VAR light
      LET bright (VAR of )
        IF
          APP
            VAR fispos
            VAR br
          VAR br
          FLOAT 0.
      APP
        VAR vecaccum
        VAR diffuse_ray
        FMUL
          FMUL
            VAR energy
            VAR bright
          APP
            VAR o_diffuse
            VAR obj
        VAR texture_color
      UNIT
    UNIT
LETREC iter_trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET p (VAR of )
      APP
        VAR veciprod
        APP
          VAR d_vec
          GET
            VAR dirvec_group
            VAR index
        VAR nvector
    LET Tu176 (UNIT)
      IF
        APP
          VAR fisneg
          VAR p
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            ADD
              VAR index
              INT 1
          FDIV
            VAR p
            FLOAT -150.
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            VAR index
          FDIV
            VAR p
            FLOAT 150.
    APP
      VAR iter_trace_diffuse_rays
      VAR dirvec_group
      VAR nvector
      VAR org
      SUB
        VAR index
        INT 2
    UNIT
LETREC trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu177 (UNIT)
    APP
      VAR setup_startp
      VAR org
  APP
    VAR iter_trace_diffuse_rays
    VAR dirvec_group
    VAR nvector
    VAR org
    INT 118
LETREC trace_diffuse_ray_80percent (VAR of )
  (group_id : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu181 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 0
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 0
        VAR nvector
        VAR org
      UNIT
  LET Tu180 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 1
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 1
        VAR nvector
        VAR org
      UNIT
  LET Tu179 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 2
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 2
        VAR nvector
        VAR org
      UNIT
  LET Tu178 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 3
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 3
        VAR nvector
        VAR org
      UNIT
  IF
    NOT
      EQ
        VAR group_id
        INT 4
    APP
      VAR trace_diffuse_rays
      GET
        VAR dirvecs
        INT 4
      VAR nvector
      VAR org
    UNIT
LETREC calc_diffuse_using_1point (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  LET ray20p (VAR of )
    APP
      VAR p_received_ray_20percent
      VAR pixel
  LET nvectors (VAR of )
    APP
      VAR p_nvectors
      VAR pixel
  LET intersection_points (VAR of )
    APP
      VAR p_intersection_points
      VAR pixel
  LET energya (VAR of )
    APP
      VAR p_energy
      VAR pixel
  LET Tu183 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR ray20p
        VAR nref
  LET Tu182 (UNIT)
    APP
      VAR trace_diffuse_ray_80percent
      APP
        VAR p_group_id
        VAR pixel
      GET
        VAR nvectors
        VAR nref
      GET
        VAR intersection_points
        VAR nref
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC calc_diffuse_using_5points (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET r_up (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR prev
        VAR x
  LET r_left (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        SUB
          VAR x
          INT 1
  LET r_center (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        VAR x
  LET r_right (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        ADD
          VAR x
          INT 1
  LET r_down (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR next
        VAR x
  LET Tu188 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR r_up
        VAR nref
  LET Tu187 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_left
        VAR nref
  LET Tu186 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_center
        VAR nref
  LET Tu185 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_right
        VAR nref
  LET Tu184 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_down
        VAR nref
  LET energya (VAR of )
    APP
      VAR p_energy
      GET
        VAR cur
        VAR x
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC do_without_neighbors (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      LE
        INT 0
        GET
          VAR surface_ids
          VAR nref
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu189 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          APP
            VAR calc_diffuse_using_1point
            VAR pixel
            VAR nref
          UNIT
      APP
        VAR do_without_neighbors
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC neighbors_exist (VAR of )
  (x : VAR of ), (y : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        ADD
          VAR y
          INT 1
    IF
      NOT
        LE
          VAR y
          INT 0
      IF
        NOT
          LE
            GET
              VAR image_size
              INT 0
            ADD
              VAR x
              INT 1
        IF
          NOT
            LE
              VAR x
              INT 0
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC get_surface_id (VAR of )
  (pixel : VAR of ), (index : VAR of )
  LET surface_ids (VAR of )
    APP
      VAR p_surface_ids
      VAR pixel
  GET
    VAR surface_ids
    VAR index
LETREC neighbors_are_available (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET sid_center (VAR of )
    APP
      VAR get_surface_id
      GET
        VAR cur
        VAR x
      VAR nref
  IF
    EQ
      APP
        VAR get_surface_id
        GET
          VAR prev
          VAR x
        VAR nref
      VAR sid_center
    IF
      EQ
        APP
          VAR get_surface_id
          GET
            VAR next
            VAR x
          VAR nref
        VAR sid_center
      IF
        EQ
          APP
            VAR get_surface_id
            GET
              VAR cur
              SUB
                VAR x
                INT 1
            VAR nref
          VAR sid_center
        IF
          EQ
            APP
              VAR get_surface_id
              GET
                VAR cur
                ADD
                  VAR x
                  INT 1
              VAR nref
            VAR sid_center
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC try_exploit_neighbors (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET pixel (VAR of )
    GET
      VAR cur
      VAR x
  IF
    LE
      VAR nref
      INT 4
    IF
      LE
        INT 0
        APP
          VAR get_surface_id
          VAR pixel
          VAR nref
      IF
        APP
          VAR neighbors_are_available
          VAR x
          VAR prev
          VAR cur
          VAR next
          VAR nref
        LET calc_diffuse (VAR of )
          APP
            VAR p_calc_diffuse
            VAR pixel
        LET Tu190 (UNIT)
          IF
            GET
              VAR calc_diffuse
              VAR nref
            APP
              VAR calc_diffuse_using_5points
              VAR x
              VAR prev
              VAR cur
              VAR next
              VAR nref
            UNIT
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          ADD
            VAR nref
            INT 1
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          VAR nref
      UNIT
    UNIT
LETREC write_ppm_header (VAR of )
  (Tu191 : VAR of )
  LET Tu199 (UNIT)
    OUT
      INT 80    0
  LET Tu198 (UNIT)
    OUT
      ADD
        INT 48
        INT 6    0
  LET Tu197 (UNIT)
    OUT
      INT 10    0
  LET Tu196 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 0
  LET Tu195 (UNIT)
    OUT
      INT 32    0
  LET Tu194 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 1
  LET Tu193 (UNIT)
    OUT
      INT 32    0
  LET Tu192 (UNIT)
    APP
      VAR print_int
      INT 255
  OUT
    INT 10  0
LETREC write_rgb_element (VAR of )
  (x : VAR of )
  LET ix (VAR of )
    float_to_int
      VAR x
  LET elem (VAR of )
    IF
      NOT
        LE
          VAR ix
          INT 255
      INT 255
      IF
        NOT
          LE
            INT 0
            VAR ix
        INT 0
        VAR ix
  OUT
    VAR elem  0
LETREC write_rgb (VAR of )
  (Tu200 : VAR of )
  LET Tu202 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 0
  LET Tu201 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 1
  APP
    VAR write_rgb_element
    GET
      VAR rgb
      INT 2
LETREC pretrace_diffuse_rays (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET sid (VAR of )
      APP
        VAR get_surface_id
        VAR pixel
        VAR nref
    IF
      LE
        INT 0
        VAR sid
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu205 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          LET group_id (VAR of )
            APP
              VAR p_group_id
              VAR pixel
          LET Tu204 (UNIT)
            APP
              VAR vecbzero
              VAR diffuse_ray
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          LET intersection_points (VAR of )
            APP
              VAR p_intersection_points
              VAR pixel
          LET Tu203 (UNIT)
            APP
              VAR trace_diffuse_rays
              GET
                VAR dirvecs
                VAR group_id
              GET
                VAR nvectors
                VAR nref
              GET
                VAR intersection_points
                VAR nref
          LET ray20p (VAR of )
            APP
              VAR p_received_ray_20percent
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR ray20p
              VAR nref
            VAR diffuse_ray
          UNIT
      APP
        VAR pretrace_diffuse_rays
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC pretrace_pixels (VAR of )
  (line : VAR of ), (x : VAR of ), (group_id : VAR of ), (lc0 : VAR of ), (lc1 : VAR of ), (lc2 : VAR of )
  IF
    LE
      INT 0
      VAR x
    LET xdisp (VAR of )
      FMUL
        GET
          VAR scan_pitch
          INT 0
        int_to_float
          SUB
            VAR x
            GET
              VAR image_center
              INT 0
    LET Tu215 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 0
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 0
          VAR lc0
    LET Tu214 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 1
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 1
          VAR lc1
    LET Tu213 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 2
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 2
          VAR lc2
    LET Tu212 (UNIT)
      APP
        VAR vecunit_sgn
        VAR ptrace_dirvec
        BOOL false
    LET Tu211 (UNIT)
      APP
        VAR vecbzero
        VAR rgb
    LET Tu210 (UNIT)
      APP
        VAR veccpy
        VAR startp
        VAR viewpoint
    LET Tu209 (UNIT)
      APP
        VAR trace_ray
        INT 0
        FLOAT 1.
        VAR ptrace_dirvec
        GET
          VAR line
          VAR x
        FLOAT 0.
    LET Tu208 (UNIT)
      APP
        VAR veccpy
        APP
          VAR p_rgb
          GET
            VAR line
            VAR x
        VAR rgb
    LET Tu207 (UNIT)
      APP
        VAR p_set_group_id
        GET
          VAR line
          VAR x
        VAR group_id
    LET Tu206 (UNIT)
      APP
        VAR pretrace_diffuse_rays
        GET
          VAR line
          VAR x
        INT 0
    APP
      VAR pretrace_pixels
      VAR line
      SUB
        VAR x
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR lc0
      VAR lc1
      VAR lc2
    UNIT
LETREC pretrace_line (VAR of )
  (line : VAR of ), (y : VAR of ), (group_id : VAR of )
  LET ydisp (VAR of )
    FMUL
      GET
        VAR scan_pitch
        INT 0
      int_to_float
        SUB
          VAR y
          GET
            VAR image_center
            INT 1
  LET lc0 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 0
      GET
        VAR screenz_dir
        INT 0
  LET lc1 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 1
      GET
        VAR screenz_dir
        INT 1
  LET lc2 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 2
      GET
        VAR screenz_dir
        INT 2
  APP
    VAR pretrace_pixels
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 1
    VAR group_id
    VAR lc0
    VAR lc1
    VAR lc2
LETREC scan_pixel (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 0
        VAR x
    LET Tu218 (UNIT)
      APP
        VAR veccpy
        VAR rgb
        APP
          VAR p_rgb
          GET
            VAR cur
            VAR x
    LET Tu217 (UNIT)
      IF
        APP
          VAR neighbors_exist
          VAR x
          VAR y
          VAR next
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          INT 0
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          INT 0
    LET Tu216 (UNIT)
      APP
        VAR write_rgb
        UNIT
    APP
      VAR scan_pixel
      ADD
        VAR x
        INT 1
      VAR y
      VAR prev
      VAR cur
      VAR next
    UNIT
LETREC scan_line (VAR of )
  (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (group_id : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        VAR y
    LET Tu220 (UNIT)
      IF
        NOT
          LE
            SUB
              GET
                VAR image_size
                INT 1
              INT 1
            VAR y
        APP
          VAR pretrace_line
          VAR next
          ADD
            VAR y
            INT 1
          VAR group_id
        UNIT
    LET Tu219 (UNIT)
      APP
        VAR scan_pixel
        INT 0
        VAR y
        VAR prev
        VAR cur
        VAR next
    APP
      VAR scan_line
      ADD
        VAR y
        INT 1
      VAR cur
      VAR next
      VAR prev
      APP
        VAR add_mod5
        VAR group_id
        INT 2
    UNIT
LETREC create_float5x3array (VAR of )
  (Tu221 : VAR of )
  LET vec (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET array (VAR of )
    ARRAY
      INT 5
      VAR vec
  LET Tu225 (UNIT)
    PUT
      VAR array
      INT 1
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu224 (UNIT)
    PUT
      VAR array
      INT 2
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu223 (UNIT)
    PUT
      VAR array
      INT 3
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu222 (UNIT)
    PUT
      VAR array
      INT 4
      ARRAY
        INT 3
        FLOAT 0.
  VAR array
LETREC create_pixel (VAR of )
  (Tu226 : VAR of )
  LET m_rgb (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET m_isect_ps (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_sids (VAR of )
    ARRAY
      INT 5
      INT 0
  LET m_cdif (VAR of )
    ARRAY
      INT 5
      BOOL false
  LET m_engy (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_r20p (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_gid (VAR of )
    ARRAY
      INT 1
      INT 0
  LET m_nvectors (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  TUPLE
    VAR m_rgb
    VAR m_isect_ps
    VAR m_sids
    VAR m_cdif
    VAR m_engy
    VAR m_r20p
    VAR m_gid
    VAR m_nvectors
LETREC init_line_elements (VAR of )
  (line : VAR of ), (n : VAR of )
  IF
    LE
      INT 0
      VAR n
    LET Tu227 (UNIT)
      PUT
        VAR line
        VAR n
        APP
          VAR create_pixel
          UNIT
    APP
      VAR init_line_elements
      VAR line
      SUB
        VAR n
        INT 1
    VAR line
LETREC create_pixelline (VAR of )
  (Tu228 : VAR of )
  LET line (VAR of )
    ARRAY
      GET
        VAR image_size
        INT 0
      APP
        VAR create_pixel
        UNIT
  APP
    VAR init_line_elements
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 2
LETREC tan (VAR of )
  (x : VAR of )
  FDIV
    APP
      VAR sin
      VAR x
    APP
      VAR cos
      VAR x
LETREC adjust_position (VAR of )
  (h : VAR of ), (ratio : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FMUL
          VAR h
          VAR h
        FLOAT 0.1
  LET tan_h (VAR of )
    FDIV
      FLOAT 1.
      VAR l
  LET theta_h (VAR of )
    APP
      VAR atan
      VAR tan_h
  LET tan_m (VAR of )
    APP
      VAR tan
      FMUL
        VAR theta_h
        VAR ratio
  FMUL
    VAR tan_m
    VAR l
LETREC calc_dirvec (VAR of )
  (icount : VAR of ), (x : VAR of ), (y : VAR of ), (rx : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 5
      VAR icount
    LET l (VAR of )
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              VAR x
            APP
              VAR fsqr
              VAR y
          FLOAT 1.
    LET vx (VAR of )
      FDIV
        VAR x
        VAR l
    LET vy (VAR of )
      FDIV
        VAR y
        VAR l
    LET vz (VAR of )
      FDIV
        FLOAT 1.
        VAR l
    LET dgroup (VAR of )
      GET
        VAR dirvecs
        VAR group_id
    LET Tu233 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            VAR index
        VAR vx
        VAR vy
        VAR vz
    LET Tu232 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 40
        VAR vx
        VAR vz
        APP
          VAR fneg
          VAR vy
    LET Tu231 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 80
        VAR vz
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
    LET Tu230 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 1
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
        APP
          VAR fneg
          VAR vz
    LET Tu229 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 41
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vz
        VAR vy
    APP
      VAR vecset
      APP
        VAR d_vec
        GET
          VAR dgroup
          ADD
            VAR index
            INT 81
      APP
        VAR fneg
        VAR vz
      VAR vx
      VAR vy
    LET x2 (VAR of )
      APP
        VAR adjust_position
        VAR y
        VAR rx
    APP
      VAR calc_dirvec
      ADD
        VAR icount
        INT 1
      VAR x2
      APP
        VAR adjust_position
        VAR x2
        VAR ry
      VAR rx
      VAR ry
      VAR group_id
      VAR index
LETREC calc_dirvecs (VAR of )
  (col : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR col
    LET rx (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.9
    LET Tu235 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx
        VAR ry
        VAR group_id
        VAR index
    LET rx2 (VAR of )
      FADD
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.1
    LET Tu234 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx2
        VAR ry
        VAR group_id
        ADD
          VAR index
          INT 2
    APP
      VAR calc_dirvecs
      SUB
        VAR col
        INT 1
      VAR ry
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR index
    UNIT
LETREC calc_dirvec_rows (VAR of )
  (row : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR row
    LET ry (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR row
          FLOAT 0.2
        FLOAT 0.9
    LET Tu236 (UNIT)
      APP
        VAR calc_dirvecs
        INT 4
        VAR ry
        VAR group_id
        VAR index
    APP
      VAR calc_dirvec_rows
      SUB
        VAR row
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 2
      ADD
        VAR index
        INT 4
    UNIT
LETREC create_dirvec (VAR of )
  (Tu237 : VAR of )
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      GET
        VAR n_objects
        INT 0
      VAR v3
  TUPLE
    VAR v3
    VAR consts
LETREC create_dirvec_elements (VAR of )
  (d : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu238 (UNIT)
      PUT
        VAR d
        VAR index
        APP
          VAR create_dirvec
          UNIT
    APP
      VAR create_dirvec_elements
      VAR d
      SUB
        VAR index
        INT 1
    UNIT
LETREC create_dirvecs (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu240 (UNIT)
      PUT
        VAR dirvecs
        VAR index
        ARRAY
          INT 120
          APP
            VAR create_dirvec
            UNIT
    LET Tu239 (UNIT)
      APP
        VAR create_dirvec_elements
        GET
          VAR dirvecs
          VAR index
        INT 118
    APP
      VAR create_dirvecs
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvec_constants (VAR of )
  (vecset : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu241 (UNIT)
      APP
        VAR setup_dirvec_constants
        GET
          VAR vecset
          VAR index
    APP
      VAR init_dirvec_constants
      VAR vecset
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_vecset_constants (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu242 (UNIT)
      APP
        VAR init_dirvec_constants
        GET
          VAR dirvecs
          VAR index
        INT 119
    APP
      VAR init_vecset_constants
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvecs (VAR of )
  (Tu243 : VAR of )
  LET Tu245 (UNIT)
    APP
      VAR create_dirvecs
      INT 4
  LET Tu244 (UNIT)
    APP
      VAR calc_dirvec_rows
      INT 9
      INT 0
      INT 0
  APP
    VAR init_vecset_constants
    INT 4
LETREC add_reflection (VAR of )
  (index : VAR of ), (surface_id : VAR of ), (bright : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET dvec (VAR of )
    APP
      VAR create_dirvec
      UNIT
  LET Tu247 (UNIT)
    APP
      VAR vecset
      APP
        VAR d_vec
        VAR dvec
      VAR v0
      VAR v1
      VAR v2
  LET Tu246 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR dvec
  PUT
    VAR reflections
    VAR index
    TUPLE
      VAR surface_id
      VAR dvec
      VAR bright
LETREC setup_rect_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    MULTIPLE 4
      VAR obj_id
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET n0 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 0
  LET n1 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 1
  LET n2 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 2
  LET Tu250 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      ADD
        VAR sid
        INT 1
      VAR br
      GET
        VAR light
        INT 0
      VAR n1
      VAR n2
  LET Tu249 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 1
      ADD
        VAR sid
        INT 2
      VAR br
      VAR n0
      GET
        VAR light
        INT 1
      VAR n2
  LET Tu248 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 2
      ADD
        VAR sid
        INT 3
      VAR br
      VAR n0
      VAR n1
      GET
        VAR light
        INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 3
LETREC setup_surface_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    ADD
      MULTIPLE 4
        VAR obj_id
      INT 1
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET p (VAR of )
    APP
      VAR veciprod
      VAR light
      APP
        VAR o_param_abc
        VAR obj
  LET Tu251 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      VAR sid
      VAR br
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_a
              VAR obj
          VAR p
        GET
          VAR light
          INT 0
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_b
              VAR obj
          VAR p
        GET
          VAR light
          INT 1
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_c
              VAR obj
          VAR p
        GET
          VAR light
          INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 1
LETREC setup_reflections (VAR of )
  (obj_id : VAR of )
  IF
    LE
      INT 0
      VAR obj_id
    LET obj (VAR of )
      GET
        VAR objects
        VAR obj_id
    IF
      EQ
        APP
          VAR o_reflectiontype
          VAR obj
        INT 2
      IF
        APP
          VAR fless
          APP
            VAR o_diffuse
            VAR obj
          FLOAT 1.
        LET m_shape (VAR of )
          APP
            VAR o_form
            VAR obj
        IF
          EQ
            VAR m_shape
            INT 1
          APP
            VAR setup_rect_reflection
            VAR obj_id
            VAR obj
          IF
            EQ
              VAR m_shape
              INT 2
            APP
              VAR setup_surface_reflection
              VAR obj_id
              VAR obj
            UNIT
        UNIT
      UNIT
    UNIT
LETREC rt (VAR of )
  (size_x : VAR of ), (size_y : VAR of )
  LET Tu263 (UNIT)
    PUT
      VAR image_size
      INT 0
      VAR size_x
  LET Tu262 (UNIT)
    PUT
      VAR image_size
      INT 1
      VAR size_y
  LET Tu261 (UNIT)
    PUT
      VAR image_center
      INT 0
      DIVIDE BY 2
        VAR size_x
  LET Tu260 (UNIT)
    PUT
      VAR image_center
      INT 1
      DIVIDE BY 2
        VAR size_y
  LET Tu259 (UNIT)
    PUT
      VAR scan_pitch
      INT 0
      FDIV
        FLOAT 128.
        int_to_float
          VAR size_x
  LET prev (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET cur (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET next (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET Tu258 (UNIT)
    APP
      VAR read_parameter
      UNIT
  LET Tu257 (UNIT)
    APP
      VAR write_ppm_header
      UNIT
  LET Tu256 (UNIT)
    APP
      VAR init_dirvecs
      UNIT
  LET Tu255 (UNIT)
    APP
      VAR veccpy
      APP
        VAR d_vec
        VAR light_dirvec
      VAR light
  LET Tu254 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR light_dirvec
  LET Tu253 (UNIT)
    APP
      VAR setup_reflections
      SUB
        GET
          VAR n_objects
          INT 0
        INT 1
  LET Tu252 (UNIT)
    APP
      VAR pretrace_line
      VAR cur
      INT 0
      INT 0
  APP
    VAR scan_line
    INT 0
    VAR prev
    VAR cur
    VAR next
    INT 2
APP
  VAR rt
  INT 128
  INT 128

----- kNormal.print -----
letrec print_int : (INT -> UNIT) =
variables : (n : INT)
  let n : INT =
    let Ti2572 : INT =
      int 0
    in
    if Ti2572 <= n
      n
      let Tu1 : UNIT =
        let Ti2573 : INT =
          int 45
        in
        out Ti2573 0
      in
      neg n
  in
  let Ti2574 : INT =
    int 10
  in
  if Ti2574 <= n
    let m : INT =
      div n 10
    in
    let Tu2 : UNIT =
      app
        print_int
        m
    in
    let Ti2576 : INT =
      let Ti2575 : INT =
        mul m 10
      in
      sub n Ti2575
    in
    out Ti2576 48
    out n 48
in
letrec print_newline : (INT -> UNIT) =
variables : (Tu3 : INT)
  let Ti2571 : INT =
    int 0
  in
  out Ti2571 10
in
letrec reduction_2pi_sub1 : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2563 : FLOAT =
    let Ti2562 : INT =
      int 0
    in
    v.(Ti2562)
  in
  let Td2565 : FLOAT =
    let Ti2564 : INT =
      int 1
    in
    v.(Ti2564)
  in
  if Td2563 <. Td2565
    unit ()
    let Tu4 : UNIT =
      let Ti2566 : INT =
        int 1
      in
      let Td2570 : FLOAT =
        let Td2568 : FLOAT =
          let Ti2567 : INT =
            int 1
          in
          v.(Ti2567)
        in
        let Td2569 : FLOAT =
          float 2.
        in
        fmul Td2568 Td2569
      in
      v.(Ti2566) <- Td2570
    in
    app
      reduction_2pi_sub1
      v
in
letrec reduction_2pi_sub2 : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2544 : FLOAT =
    float 6.28318530718
  in
  let Td2546 : FLOAT =
    let Ti2545 : INT =
      int 0
    in
    v.(Ti2545)
  in
  if Td2544 <. Td2546
    let Tu6 : UNIT =
      let Td2548 : FLOAT =
        let Ti2547 : INT =
          int 1
        in
        v.(Ti2547)
      in
      let Td2550 : FLOAT =
        let Ti2549 : INT =
          int 0
        in
        v.(Ti2549)
      in
      if Td2548 <. Td2550
        let Ti2551 : INT =
          int 0
        in
        let Td2556 : FLOAT =
          let Td2553 : FLOAT =
            let Ti2552 : INT =
              int 0
            in
            v.(Ti2552)
          in
          let Td2555 : FLOAT =
            let Ti2554 : INT =
              int 1
            in
            v.(Ti2554)
          in
          fsub Td2553 Td2555
        in
        v.(Ti2551) <- Td2556
        unit ()
    in
    let Tu5 : UNIT =
      let Ti2557 : INT =
        int 1
      in
      let Td2561 : FLOAT =
        let Td2559 : FLOAT =
          let Ti2558 : INT =
            int 1
          in
          v.(Ti2558)
        in
        let Td2560 : FLOAT =
          float 2.
        in
        fdiv Td2559 Td2560
      in
      v.(Ti2557) <- Td2561
    in
    app
      reduction_2pi_sub2
      v
    unit ()
in
letrec reduction_2pi : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Tu8 : UNIT =
    let Ti2542 : INT =
      int 1
    in
    let Td2543 : FLOAT =
      float 6.28318530718
    in
    v.(Ti2542) <- Td2543
  in
  let Tu7 : UNIT =
    app
      reduction_2pi_sub1
      v
  in
  app
    reduction_2pi_sub2
    v
in
letrec kernel_sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a3 : FLOAT =
    fmul a2 a
  in
  let a5 : FLOAT =
    fmul a3 a2
  in
  let a7 : FLOAT =
    fmul a5 a2
  in
  let Td2539 : FLOAT =
    let Td2536 : FLOAT =
      let Td2535 : FLOAT =
        let Td2534 : FLOAT =
          float 0.16666668
        in
        fmul Td2534 a3
      in
      fsub a Td2535
    in
    let Td2538 : FLOAT =
      let Td2537 : FLOAT =
        float 0.008332824
      in
      fmul Td2537 a5
    in
    fadd Td2536 Td2538
  in
  let Td2541 : FLOAT =
    let Td2540 : FLOAT =
      float 0.00019587841
    in
    fmul Td2540 a7
  in
  fsub Td2539 Td2541
in
letrec kernel_cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a4 : FLOAT =
    fmul a2 a2
  in
  let a6 : FLOAT =
    fmul a4 a2
  in
  let Td2531 : FLOAT =
    let Td2528 : FLOAT =
      let Td2525 : FLOAT =
        float 1.
      in
      let Td2527 : FLOAT =
        let Td2526 : FLOAT =
          float 0.5
        in
        fmul Td2526 a2
      in
      fsub Td2525 Td2527
    in
    let Td2530 : FLOAT =
      let Td2529 : FLOAT =
        float 0.04166368
      in
      fmul Td2529 a4
    in
    fadd Td2528 Td2530
  in
  let Td2533 : FLOAT =
    let Td2532 : FLOAT =
      float 0.0013695068
    in
    fmul Td2532 a6
  in
  fsub Td2531 Td2533
in
letrec sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let v : Array of FLOAT =
    let Ti2489 : INT =
      int 3
    in
    extfunapp
      create_float_array
      Ti2489
      a
  in
  let Tu13 : UNIT =
    let Td2490 : FLOAT =
      float 0.
    in
    if a <. Td2490
      let Ti2491 : INT =
        int 0
      in
      let Td2492 : FLOAT =
        fneg a
      in
      v.(Ti2491) <- Td2492
      unit ()
  in
  let Tu12 : UNIT =
    app
      reduction_2pi
      v
  in
  let Tu11 : UNIT =
    let Td2493 : FLOAT =
      float 3.14159265359
    in
    let Td2495 : FLOAT =
      let Ti2494 : INT =
        int 0
      in
      v.(Ti2494)
    in
    if Td2493 <. Td2495
      let Tu9 : UNIT =
        let Ti2496 : INT =
          int 0
        in
        let Td2500 : FLOAT =
          let Td2498 : FLOAT =
            let Ti2497 : INT =
              int 0
            in
            v.(Ti2497)
          in
          let Td2499 : FLOAT =
            float 3.14159265359
          in
          fsub Td2498 Td2499
        in
        v.(Ti2496) <- Td2500
      in
      let Ti2501 : INT =
        int 2
      in
      let Td2504 : FLOAT =
        let Td2503 : FLOAT =
          let Ti2502 : INT =
            int 2
          in
          v.(Ti2502)
        in
        fneg Td2503
      in
      v.(Ti2501) <- Td2504
      unit ()
  in
  let Tu10 : UNIT =
    let Td2505 : FLOAT =
      float 1.57079632679
    in
    let Td2507 : FLOAT =
      let Ti2506 : INT =
        int 0
      in
      v.(Ti2506)
    in
    if Td2505 <. Td2507
      let Ti2508 : INT =
        int 0
      in
      let Td2512 : FLOAT =
        let Td2509 : FLOAT =
          float 3.14159265359
        in
        let Td2511 : FLOAT =
          let Ti2510 : INT =
            int 0
          in
          v.(Ti2510)
        in
        fsub Td2509 Td2511
      in
      v.(Ti2508) <- Td2512
      unit ()
  in
  let x : FLOAT =
    let Td2513 : FLOAT =
      float 0.785398163397
    in
    let Td2515 : FLOAT =
      let Ti2514 : INT =
        int 0
      in
      v.(Ti2514)
    in
    if Td2513 <. Td2515
      let Td2519 : FLOAT =
        let Td2516 : FLOAT =
          float 1.57079632679
        in
        let Td2518 : FLOAT =
          let Ti2517 : INT =
            int 0
          in
          v.(Ti2517)
        in
        fsub Td2516 Td2518
      in
      app
        kernel_cos
        Td2519
      let Td2521 : FLOAT =
        let Ti2520 : INT =
          int 0
        in
        v.(Ti2520)
      in
      app
        kernel_sin
        Td2521
  in
  let Td2523 : FLOAT =
    let Ti2522 : INT =
      int 2
    in
    v.(Ti2522)
  in
  let Td2524 : FLOAT =
    float 0.
  in
  if Td2523 <. Td2524
    fneg x
    x
in
letrec cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a : FLOAT =
    let Td2453 : FLOAT =
      float 0.
    in
    if a <. Td2453
      fneg a
      a
  in
  let v : Array of FLOAT =
    let Ti2454 : INT =
      int 3
    in
    extfunapp
      create_float_array
      Ti2454
      a
  in
  let Tu18 : UNIT =
    app
      reduction_2pi
      v
  in
  let Tu17 : UNIT =
    let Td2455 : FLOAT =
      float 3.14159265359
    in
    let Td2457 : FLOAT =
      let Ti2456 : INT =
        int 0
      in
      v.(Ti2456)
    in
    if Td2455 <. Td2457
      let Tu14 : UNIT =
        let Ti2458 : INT =
          int 0
        in
        let Td2462 : FLOAT =
          let Td2460 : FLOAT =
            let Ti2459 : INT =
              int 0
            in
            v.(Ti2459)
          in
          let Td2461 : FLOAT =
            float 3.14159265359
          in
          fsub Td2460 Td2461
        in
        v.(Ti2458) <- Td2462
      in
      let Ti2463 : INT =
        int 2
      in
      let Td2464 : FLOAT =
        float -1.
      in
      v.(Ti2463) <- Td2464
      unit ()
  in
  let Tu16 : UNIT =
    let Td2465 : FLOAT =
      float 1.57079632679
    in
    let Td2467 : FLOAT =
      let Ti2466 : INT =
        int 0
      in
      v.(Ti2466)
    in
    if Td2465 <. Td2467
      let Tu15 : UNIT =
        let Ti2468 : INT =
          int 0
        in
        let Td2472 : FLOAT =
          let Td2469 : FLOAT =
            float 3.14159265359
          in
          let Td2471 : FLOAT =
            let Ti2470 : INT =
              int 0
            in
            v.(Ti2470)
          in
          fsub Td2469 Td2471
        in
        v.(Ti2468) <- Td2472
      in
      let Ti2473 : INT =
        int 2
      in
      let Td2476 : FLOAT =
        let Td2475 : FLOAT =
          let Ti2474 : INT =
            int 2
          in
          v.(Ti2474)
        in
        fneg Td2475
      in
      v.(Ti2473) <- Td2476
      unit ()
  in
  let x : FLOAT =
    let Td2478 : FLOAT =
      let Ti2477 : INT =
        int 0
      in
      v.(Ti2477)
    in
    let Td2479 : FLOAT =
      float 0.785398163397
    in
    if Td2478 <. Td2479
      let Td2481 : FLOAT =
        let Ti2480 : INT =
          int 0
        in
        v.(Ti2480)
      in
      app
        kernel_cos
        Td2481
      let Td2485 : FLOAT =
        let Td2482 : FLOAT =
          float 1.57079632679
        in
        let Td2484 : FLOAT =
          let Ti2483 : INT =
            int 0
          in
          v.(Ti2483)
        in
        fsub Td2482 Td2484
      in
      app
        kernel_sin
        Td2485
  in
  let Td2487 : FLOAT =
    let Ti2486 : INT =
      int 2
    in
    v.(Ti2486)
  in
  let Td2488 : FLOAT =
    float 0.
  in
  if Td2487 <. Td2488
    fneg x
    x
in
letrec sqrt : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2443 : FLOAT =
    float 0.
  in
  if Td2443 <. x
    let t : FLOAT =
      unknown sqrt_init x
    in
    let t : FLOAT =
      let Td2445 : FLOAT =
        let Td2444 : FLOAT =
          fmul t t
        in
        fadd Td2444 x
      in
      let Td2446 : FLOAT =
        fadd t t
      in
      fdiv Td2445 Td2446
    in
    let t : FLOAT =
      let Td2448 : FLOAT =
        let Td2447 : FLOAT =
          fmul t t
        in
        fadd Td2447 x
      in
      let Td2449 : FLOAT =
        fadd t t
      in
      fdiv Td2448 Td2449
    in
    let t : FLOAT =
      let Td2451 : FLOAT =
        let Td2450 : FLOAT =
          fmul t t
        in
        fadd Td2450 x
      in
      let Td2452 : FLOAT =
        fadd t t
      in
      fdiv Td2451 Td2452
    in
    t
    float 0.
in
letrec kernel_atan : (FLOAT -> FLOAT) =
variables : (a1 : FLOAT)
  let a2 : FLOAT =
    fmul a1 a1
  in
  let a3 : FLOAT =
    fmul a2 a1
  in
  let a5 : FLOAT =
    fmul a2 a3
  in
  let a7 : FLOAT =
    fmul a2 a5
  in
  let a9 : FLOAT =
    fmul a2 a7
  in
  let a11 : FLOAT =
    fmul a2 a9
  in
  let a13 : FLOAT =
    fmul a2 a11
  in
  let Td2440 : FLOAT =
    let Td2437 : FLOAT =
      let Td2434 : FLOAT =
        let Td2431 : FLOAT =
          let Td2428 : FLOAT =
            let Td2427 : FLOAT =
              let Td2426 : FLOAT =
                float 0.3333333
              in
              fmul Td2426 a3
            in
            fsub a1 Td2427
          in
          let Td2430 : FLOAT =
            let Td2429 : FLOAT =
              float 0.2
            in
            fmul Td2429 a5
          in
          fadd Td2428 Td2430
        in
        let Td2433 : FLOAT =
          let Td2432 : FLOAT =
            float 0.142857142
          in
          fmul Td2432 a7
        in
        fsub Td2431 Td2433
      in
      let Td2436 : FLOAT =
        let Td2435 : FLOAT =
          float 0.111111104
        in
        fmul Td2435 a9
      in
      fadd Td2434 Td2436
    in
    let Td2439 : FLOAT =
      let Td2438 : FLOAT =
        float 0.08976446
      in
      fmul Td2438 a11
    in
    fsub Td2437 Td2439
  in
  let Td2442 : FLOAT =
    let Td2441 : FLOAT =
      float 0.060035485
    in
    fmul Td2441 a13
  in
  fadd Td2440 Td2442
in
letrec atan : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2410 : FLOAT =
      float 0.
    in
    if Td2410 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Ti2411 : INT =
      int 0
    in
    if flag == Ti2411
      fneg a
      a
  in
  let b : FLOAT =
    let Td2412 : FLOAT =
      float 0.4375
    in
    if a <. Td2412
      app
        kernel_atan
        a
      let Td2413 : FLOAT =
        float 2.4375
      in
      if a <. Td2413
        let Td2414 : FLOAT =
          float 0.785398163397
        in
        let Td2420 : FLOAT =
          let Td2419 : FLOAT =
            let Td2416 : FLOAT =
              let Td2415 : FLOAT =
                float 1.
              in
              fsub a Td2415
            in
            let Td2418 : FLOAT =
              let Td2417 : FLOAT =
                float 1.
              in
              fadd a Td2417
            in
            fdiv Td2416 Td2418
          in
          app
            kernel_atan
            Td2419
        in
        fadd Td2414 Td2420
        let Td2421 : FLOAT =
          float 1.57079632679
        in
        let Td2424 : FLOAT =
          let Td2423 : FLOAT =
            let Td2422 : FLOAT =
              float 1.
            in
            fdiv Td2422 a
          in
          app
            kernel_atan
            Td2423
        in
        fsub Td2421 Td2424
  in
  let Ti2425 : INT =
    int 0
  in
  if flag == Ti2425
    fneg b
    b
in
letrec floor : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let a : FLOAT =
    let Ti2408 : INT =
      ftoi x
    in
    itof Ti2408
  in
  if x <. a
    let Td2409 : FLOAT =
      float 1.
    in
    fsub a Td2409
    a
in
letrec fabs : (FLOAT -> FLOAT) =
variables : (f : FLOAT)
  let Td2407 : FLOAT =
    float 0.
  in
  if f <. Td2407
    fneg f
    f
in
letrec fhalf : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2406 : FLOAT =
    float 0.5
  in
  fmul x Td2406
in
letrec fsqr : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fmul x x
in
letrec fneg : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fneg x
in
letrec fless : (FLOAT -> (FLOAT -> BOOL)) =
variables : (a : FLOAT), (b : FLOAT)
  if a <. b
    int 1
    int 0
in
letrec abs_float : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  app
    fabs
    x
in
letrec fispos : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2405 : FLOAT =
    float 0.
  in
  if Td2405 <. x
    int 1
    int 0
in
letrec fisneg : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2404 : FLOAT =
    float 0.
  in
  if x <. Td2404
    int 1
    int 0
in
let n_objects : Array of INT =
  let Ti264 : INT =
    int 1
  in
  let Ti265 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti264
    Ti265
in
let objects : Array of (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
  let dummy : Array of FLOAT =
    let Ti266 : INT =
      int 0
    in
    let Td267 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti266
      Td267
  in
  let Ti268 : INT =
    int 60
  in
  let Tt274 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * INT * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    let Ti269 : INT =
      int 0
    in
    let Ti270 : INT =
      int 0
    in
    let Ti271 : INT =
      int 0
    in
    let Ti272 : INT =
      int 0
    in
    let Ti273 : INT =
      int 0
    in
    Tuple
      Ti269
      Ti270
      Ti271
      Ti272
      dummy
      dummy
      Ti273
      dummy
      dummy
      dummy
      dummy
  in
  extfunapp
    create_array
    Ti268
    Tt274
in
let screen : Array of FLOAT =
  let Ti275 : INT =
    int 3
  in
  let Td276 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti275
    Td276
in
let viewpoint : Array of FLOAT =
  let Ti277 : INT =
    int 3
  in
  let Td278 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti277
    Td278
in
let light : Array of FLOAT =
  let Ti279 : INT =
    int 3
  in
  let Td280 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti279
    Td280
in
let beam : Array of FLOAT =
  let Ti281 : INT =
    int 1
  in
  let Td282 : FLOAT =
    float 255.
  in
  extfunapp
    create_float_array
    Ti281
    Td282
in
let and_net : Array of Array of INT =
  let Ti283 : INT =
    int 50
  in
  let Ta287 : Array of INT =
    let Ti284 : INT =
      int 1
    in
    let Ti286 : INT =
      let Ti285 : INT =
        int 1
      in
      neg Ti285
    in
    extfunapp
      create_array
      Ti284
      Ti286
  in
  extfunapp
    create_array
    Ti283
    Ta287
in
let or_net : Array of Array of Array of INT =
  let Ti288 : INT =
    int 1
  in
  let Ta292 : Array of Array of INT =
    let Ti289 : INT =
      int 1
    in
    let Ta291 : Array of INT =
      let Ti290 : INT =
        int 0
      in
      and_net.(Ti290)
    in
    extfunapp
      create_array
      Ti289
      Ta291
  in
  extfunapp
    create_array
    Ti288
    Ta292
in
let solver_dist : Array of FLOAT =
  let Ti293 : INT =
    int 1
  in
  let Td294 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti293
    Td294
in
let intsec_rectside : Array of INT =
  let Ti295 : INT =
    int 1
  in
  let Ti296 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti295
    Ti296
in
let tmin : Array of FLOAT =
  let Ti297 : INT =
    int 1
  in
  let Td298 : FLOAT =
    float 1000000000.
  in
  extfunapp
    create_float_array
    Ti297
    Td298
in
let intersection_point : Array of FLOAT =
  let Ti299 : INT =
    int 3
  in
  let Td300 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti299
    Td300
in
let intersected_object_id : Array of INT =
  let Ti301 : INT =
    int 1
  in
  let Ti302 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti301
    Ti302
in
let nvector : Array of FLOAT =
  let Ti303 : INT =
    int 3
  in
  let Td304 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti303
    Td304
in
let texture_color : Array of FLOAT =
  let Ti305 : INT =
    int 3
  in
  let Td306 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti305
    Td306
in
let diffuse_ray : Array of FLOAT =
  let Ti307 : INT =
    int 3
  in
  let Td308 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti307
    Td308
in
let rgb : Array of FLOAT =
  let Ti309 : INT =
    int 3
  in
  let Td310 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti309
    Td310
in
let image_size : Array of INT =
  let Ti311 : INT =
    int 2
  in
  let Ti312 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti311
    Ti312
in
let image_center : Array of INT =
  let Ti313 : INT =
    int 2
  in
  let Ti314 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti313
    Ti314
in
let scan_pitch : Array of FLOAT =
  let Ti315 : INT =
    int 1
  in
  let Td316 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti315
    Td316
in
let startp : Array of FLOAT =
  let Ti317 : INT =
    int 3
  in
  let Td318 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti317
    Td318
in
let startp_fast : Array of FLOAT =
  let Ti319 : INT =
    int 3
  in
  let Td320 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti319
    Td320
in
let screenx_dir : Array of FLOAT =
  let Ti321 : INT =
    int 3
  in
  let Td322 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti321
    Td322
in
let screeny_dir : Array of FLOAT =
  let Ti323 : INT =
    int 3
  in
  let Td324 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti323
    Td324
in
let screenz_dir : Array of FLOAT =
  let Ti325 : INT =
    int 3
  in
  let Td326 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti325
    Td326
in
let ptrace_dirvec : Array of FLOAT =
  let Ti327 : INT =
    int 3
  in
  let Td328 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti327
    Td328
in
let dirvecs : Array of Array of (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf : Array of FLOAT =
    let Ti329 : INT =
      int 0
    in
    let Td330 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti329
      Td330
  in
  let dummyff : Array of Array of FLOAT =
    let Ti331 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti331
      dummyf
  in
  let dummy_vs : Array of (Array of FLOAT * Array of Array of FLOAT) =
    let Ti332 : INT =
      int 0
    in
    let Tt333 : (Array of FLOAT * Array of Array of FLOAT) =
      Tuple
        dummyf
        dummyff
    in
    extfunapp
      create_array
      Ti332
      Tt333
  in
  let Ti334 : INT =
    int 5
  in
  extfunapp
    create_array
    Ti334
    dummy_vs
in
let light_dirvec : (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf2 : Array of FLOAT =
    let Ti335 : INT =
      int 0
    in
    let Td336 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti335
      Td336
  in
  let v3 : Array of FLOAT =
    let Ti337 : INT =
      int 3
    in
    let Td338 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti337
      Td338
  in
  let consts : Array of Array of FLOAT =
    let Ti339 : INT =
      int 60
    in
    extfunapp
      create_array
      Ti339
      dummyf2
  in
  Tuple
    v3
    consts
in
let reflections : Array of (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
  let dummyf3 : Array of FLOAT =
    let Ti340 : INT =
      int 0
    in
    let Td341 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti340
      Td341
  in
  let dummyff3 : Array of Array of FLOAT =
    let Ti342 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti342
      dummyf3
  in
  let dummydv : (Array of FLOAT * Array of Array of FLOAT) =
    Tuple
      dummyf3
      dummyff3
  in
  let Ti343 : INT =
    int 180
  in
  let Tt346 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    let Ti344 : INT =
      int 0
    in
    let Td345 : FLOAT =
      float 0.
    in
    Tuple
      Ti344
      dummydv
      Td345
  in
  extfunapp
    create_array
    Ti343
    Tt346
in
let n_reflections : Array of INT =
  let Ti347 : INT =
    int 1
  in
  let Ti348 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti347
    Ti348
in
letrec xor : (BOOL -> (BOOL -> BOOL)) =
variables : (x : BOOL), (y : BOOL)
  let Ti2402 : INT =
    int 0
  in
  if x == Ti2402
    y
    let Ti2403 : INT =
      int 0
    in
    if y == Ti2403
      int 1
      int 0
in
letrec sgn : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  if x == 0.0 
    float 0.
    let Tb2400 : BOOL =
      app
        fispos
        x
    in
    let Ti2401 : INT =
      int 0
    in
    if Tb2400 == Ti2401
      float -1.
      float 1.
in
letrec fneg_cond : (BOOL -> (FLOAT -> FLOAT)) =
variables : (cond : BOOL), (x : FLOAT)
  let Ti2399 : INT =
    int 0
  in
  if cond == Ti2399
    app
      fneg
      x
    x
in
letrec add_mod5 : (INT -> (INT -> INT)) =
variables : (x : INT), (y : INT)
  let sum : INT =
    add x y
  in
  let Ti2397 : INT =
    int 5
  in
  if Ti2397 <= sum
    let Ti2398 : INT =
      int 5
    in
    sub sum Ti2398
    sum
in
letrec vecset : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))) =
variables : (v : Array of FLOAT), (x : FLOAT), (y : FLOAT), (z : FLOAT)
  let Tu20 : UNIT =
    let Ti2394 : INT =
      int 0
    in
    v.(Ti2394) <- x
  in
  let Tu19 : UNIT =
    let Ti2395 : INT =
      int 1
    in
    v.(Ti2395) <- y
  in
  let Ti2396 : INT =
    int 2
  in
  v.(Ti2396) <- z
in
letrec vecfill : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (v : Array of FLOAT), (elem : FLOAT)
  let Tu22 : UNIT =
    let Ti2391 : INT =
      int 0
    in
    v.(Ti2391) <- elem
  in
  let Tu21 : UNIT =
    let Ti2392 : INT =
      int 1
    in
    v.(Ti2392) <- elem
  in
  let Ti2393 : INT =
    int 2
  in
  v.(Ti2393) <- elem
in
letrec vecbzero : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2390 : FLOAT =
    float 0.
  in
  app
    vecfill
    v
    Td2390
in
letrec veccpy : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (src : Array of FLOAT)
  let Tu24 : UNIT =
    let Ti2381 : INT =
      int 0
    in
    let Td2383 : FLOAT =
      let Ti2382 : INT =
        int 0
      in
      src.(Ti2382)
    in
    dest.(Ti2381) <- Td2383
  in
  let Tu23 : UNIT =
    let Ti2384 : INT =
      int 1
    in
    let Td2386 : FLOAT =
      let Ti2385 : INT =
        int 1
      in
      src.(Ti2385)
    in
    dest.(Ti2384) <- Td2386
  in
  let Ti2387 : INT =
    int 2
  in
  let Td2389 : FLOAT =
    let Ti2388 : INT =
      int 2
    in
    src.(Ti2388)
  in
  dest.(Ti2387) <- Td2389
in
letrec vecdist2 : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (p : Array of FLOAT), (q : Array of FLOAT)
  let Td2374 : FLOAT =
    let Td2367 : FLOAT =
      let Td2366 : FLOAT =
        let Td2363 : FLOAT =
          let Ti2362 : INT =
            int 0
          in
          p.(Ti2362)
        in
        let Td2365 : FLOAT =
          let Ti2364 : INT =
            int 0
          in
          q.(Ti2364)
        in
        fsub Td2363 Td2365
      in
      app
        fsqr
        Td2366
    in
    let Td2373 : FLOAT =
      let Td2372 : FLOAT =
        let Td2369 : FLOAT =
          let Ti2368 : INT =
            int 1
          in
          p.(Ti2368)
        in
        let Td2371 : FLOAT =
          let Ti2370 : INT =
            int 1
          in
          q.(Ti2370)
        in
        fsub Td2369 Td2371
      in
      app
        fsqr
        Td2372
    in
    fadd Td2367 Td2373
  in
  let Td2380 : FLOAT =
    let Td2379 : FLOAT =
      let Td2376 : FLOAT =
        let Ti2375 : INT =
          int 2
        in
        p.(Ti2375)
      in
      let Td2378 : FLOAT =
        let Ti2377 : INT =
          int 2
        in
        q.(Ti2377)
      in
      fsub Td2376 Td2378
    in
    app
      fsqr
      Td2379
  in
  fadd Td2374 Td2380
in
letrec vecunit : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let il : FLOAT =
    let Td2337 : FLOAT =
      float 1.
    in
    let Td2349 : FLOAT =
      let Td2348 : FLOAT =
        let Td2344 : FLOAT =
          let Td2340 : FLOAT =
            let Td2339 : FLOAT =
              let Ti2338 : INT =
                int 0
              in
              v.(Ti2338)
            in
            app
              fsqr
              Td2339
          in
          let Td2343 : FLOAT =
            let Td2342 : FLOAT =
              let Ti2341 : INT =
                int 1
              in
              v.(Ti2341)
            in
            app
              fsqr
              Td2342
          in
          fadd Td2340 Td2343
        in
        let Td2347 : FLOAT =
          let Td2346 : FLOAT =
            let Ti2345 : INT =
              int 2
            in
            v.(Ti2345)
          in
          app
            fsqr
            Td2346
        in
        fadd Td2344 Td2347
      in
      app
        sqrt
        Td2348
    in
    fdiv Td2337 Td2349
  in
  let Tu26 : UNIT =
    let Ti2350 : INT =
      int 0
    in
    let Td2353 : FLOAT =
      let Td2352 : FLOAT =
        let Ti2351 : INT =
          int 0
        in
        v.(Ti2351)
      in
      fmul Td2352 il
    in
    v.(Ti2350) <- Td2353
  in
  let Tu25 : UNIT =
    let Ti2354 : INT =
      int 1
    in
    let Td2357 : FLOAT =
      let Td2356 : FLOAT =
        let Ti2355 : INT =
          int 1
        in
        v.(Ti2355)
      in
      fmul Td2356 il
    in
    v.(Ti2354) <- Td2357
  in
  let Ti2358 : INT =
    int 2
  in
  let Td2361 : FLOAT =
    let Td2360 : FLOAT =
      let Ti2359 : INT =
        int 2
      in
      v.(Ti2359)
    in
    fmul Td2360 il
  in
  v.(Ti2358) <- Td2361
in
letrec vecunit_sgn : (Array of FLOAT -> (BOOL -> UNIT)) =
variables : (v : Array of FLOAT), (inv : BOOL)
  let l : FLOAT =
    let Td2321 : FLOAT =
      let Td2317 : FLOAT =
        let Td2313 : FLOAT =
          let Td2312 : FLOAT =
            let Ti2311 : INT =
              int 0
            in
            v.(Ti2311)
          in
          app
            fsqr
            Td2312
        in
        let Td2316 : FLOAT =
          let Td2315 : FLOAT =
            let Ti2314 : INT =
              int 1
            in
            v.(Ti2314)
          in
          app
            fsqr
            Td2315
        in
        fadd Td2313 Td2316
      in
      let Td2320 : FLOAT =
        let Td2319 : FLOAT =
          let Ti2318 : INT =
            int 2
          in
          v.(Ti2318)
        in
        app
          fsqr
          Td2319
      in
      fadd Td2317 Td2320
    in
    app
      sqrt
      Td2321
  in
  let il : FLOAT =
    if l == 0.0 
      float 1.
      let Ti2322 : INT =
        int 0
      in
      if inv == Ti2322
        let Td2323 : FLOAT =
          float 1.
        in
        fdiv Td2323 l
        let Td2324 : FLOAT =
          float -1.
        in
        fdiv Td2324 l
  in
  let Tu28 : UNIT =
    let Ti2325 : INT =
      int 0
    in
    let Td2328 : FLOAT =
      let Td2327 : FLOAT =
        let Ti2326 : INT =
          int 0
        in
        v.(Ti2326)
      in
      fmul Td2327 il
    in
    v.(Ti2325) <- Td2328
  in
  let Tu27 : UNIT =
    let Ti2329 : INT =
      int 1
    in
    let Td2332 : FLOAT =
      let Td2331 : FLOAT =
        let Ti2330 : INT =
          int 1
        in
        v.(Ti2330)
      in
      fmul Td2331 il
    in
    v.(Ti2329) <- Td2332
  in
  let Ti2333 : INT =
    int 2
  in
  let Td2336 : FLOAT =
    let Td2335 : FLOAT =
      let Ti2334 : INT =
        int 2
      in
      v.(Ti2334)
    in
    fmul Td2335 il
  in
  v.(Ti2333) <- Td2336
in
letrec veciprod : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (v : Array of FLOAT), (w : Array of FLOAT)
  let Td2305 : FLOAT =
    let Td2299 : FLOAT =
      let Td2296 : FLOAT =
        let Ti2295 : INT =
          int 0
        in
        v.(Ti2295)
      in
      let Td2298 : FLOAT =
        let Ti2297 : INT =
          int 0
        in
        w.(Ti2297)
      in
      fmul Td2296 Td2298
    in
    let Td2304 : FLOAT =
      let Td2301 : FLOAT =
        let Ti2300 : INT =
          int 1
        in
        v.(Ti2300)
      in
      let Td2303 : FLOAT =
        let Ti2302 : INT =
          int 1
        in
        w.(Ti2302)
      in
      fmul Td2301 Td2303
    in
    fadd Td2299 Td2304
  in
  let Td2310 : FLOAT =
    let Td2307 : FLOAT =
      let Ti2306 : INT =
        int 2
      in
      v.(Ti2306)
    in
    let Td2309 : FLOAT =
      let Ti2308 : INT =
        int 2
      in
      w.(Ti2308)
    in
    fmul Td2307 Td2309
  in
  fadd Td2305 Td2310
in
letrec veciprod2 : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (v : Array of FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let Td2291 : FLOAT =
    let Td2287 : FLOAT =
      let Td2286 : FLOAT =
        let Ti2285 : INT =
          int 0
        in
        v.(Ti2285)
      in
      fmul Td2286 w0
    in
    let Td2290 : FLOAT =
      let Td2289 : FLOAT =
        let Ti2288 : INT =
          int 1
        in
        v.(Ti2288)
      in
      fmul Td2289 w1
    in
    fadd Td2287 Td2290
  in
  let Td2294 : FLOAT =
    let Td2293 : FLOAT =
      let Ti2292 : INT =
        int 2
      in
      v.(Ti2292)
    in
    fmul Td2293 w2
  in
  fadd Td2291 Td2294
in
letrec vecaccum : (Array of FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (scale : FLOAT), (v : Array of FLOAT)
  let Tu30 : UNIT =
    let Ti2264 : INT =
      int 0
    in
    let Td2270 : FLOAT =
      let Td2266 : FLOAT =
        let Ti2265 : INT =
          int 0
        in
        dest.(Ti2265)
      in
      let Td2269 : FLOAT =
        let Td2268 : FLOAT =
          let Ti2267 : INT =
            int 0
          in
          v.(Ti2267)
        in
        fmul scale Td2268
      in
      fadd Td2266 Td2269
    in
    dest.(Ti2264) <- Td2270
  in
  let Tu29 : UNIT =
    let Ti2271 : INT =
      int 1
    in
    let Td2277 : FLOAT =
      let Td2273 : FLOAT =
        let Ti2272 : INT =
          int 1
        in
        dest.(Ti2272)
      in
      let Td2276 : FLOAT =
        let Td2275 : FLOAT =
          let Ti2274 : INT =
            int 1
          in
          v.(Ti2274)
        in
        fmul scale Td2275
      in
      fadd Td2273 Td2276
    in
    dest.(Ti2271) <- Td2277
  in
  let Ti2278 : INT =
    int 2
  in
  let Td2284 : FLOAT =
    let Td2280 : FLOAT =
      let Ti2279 : INT =
        int 2
      in
      dest.(Ti2279)
    in
    let Td2283 : FLOAT =
      let Td2282 : FLOAT =
        let Ti2281 : INT =
          int 2
        in
        v.(Ti2281)
      in
      fmul scale Td2282
    in
    fadd Td2280 Td2283
  in
  dest.(Ti2278) <- Td2284
in
letrec vecadd : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu32 : UNIT =
    let Ti2246 : INT =
      int 0
    in
    let Td2251 : FLOAT =
      let Td2248 : FLOAT =
        let Ti2247 : INT =
          int 0
        in
        dest.(Ti2247)
      in
      let Td2250 : FLOAT =
        let Ti2249 : INT =
          int 0
        in
        v.(Ti2249)
      in
      fadd Td2248 Td2250
    in
    dest.(Ti2246) <- Td2251
  in
  let Tu31 : UNIT =
    let Ti2252 : INT =
      int 1
    in
    let Td2257 : FLOAT =
      let Td2254 : FLOAT =
        let Ti2253 : INT =
          int 1
        in
        dest.(Ti2253)
      in
      let Td2256 : FLOAT =
        let Ti2255 : INT =
          int 1
        in
        v.(Ti2255)
      in
      fadd Td2254 Td2256
    in
    dest.(Ti2252) <- Td2257
  in
  let Ti2258 : INT =
    int 2
  in
  let Td2263 : FLOAT =
    let Td2260 : FLOAT =
      let Ti2259 : INT =
        int 2
      in
      dest.(Ti2259)
    in
    let Td2262 : FLOAT =
      let Ti2261 : INT =
        int 2
      in
      v.(Ti2261)
    in
    fadd Td2260 Td2262
  in
  dest.(Ti2258) <- Td2263
in
letrec vecmul : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu34 : UNIT =
    let Ti2228 : INT =
      int 0
    in
    let Td2233 : FLOAT =
      let Td2230 : FLOAT =
        let Ti2229 : INT =
          int 0
        in
        dest.(Ti2229)
      in
      let Td2232 : FLOAT =
        let Ti2231 : INT =
          int 0
        in
        v.(Ti2231)
      in
      fmul Td2230 Td2232
    in
    dest.(Ti2228) <- Td2233
  in
  let Tu33 : UNIT =
    let Ti2234 : INT =
      int 1
    in
    let Td2239 : FLOAT =
      let Td2236 : FLOAT =
        let Ti2235 : INT =
          int 1
        in
        dest.(Ti2235)
      in
      let Td2238 : FLOAT =
        let Ti2237 : INT =
          int 1
        in
        v.(Ti2237)
      in
      fmul Td2236 Td2238
    in
    dest.(Ti2234) <- Td2239
  in
  let Ti2240 : INT =
    int 2
  in
  let Td2245 : FLOAT =
    let Td2242 : FLOAT =
      let Ti2241 : INT =
        int 2
      in
      dest.(Ti2241)
    in
    let Td2244 : FLOAT =
      let Ti2243 : INT =
        int 2
      in
      v.(Ti2243)
    in
    fmul Td2242 Td2244
  in
  dest.(Ti2240) <- Td2245
in
letrec vecscale : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (scale : FLOAT)
  let Tu36 : UNIT =
    let Ti2216 : INT =
      int 0
    in
    let Td2219 : FLOAT =
      let Td2218 : FLOAT =
        let Ti2217 : INT =
          int 0
        in
        dest.(Ti2217)
      in
      fmul Td2218 scale
    in
    dest.(Ti2216) <- Td2219
  in
  let Tu35 : UNIT =
    let Ti2220 : INT =
      int 1
    in
    let Td2223 : FLOAT =
      let Td2222 : FLOAT =
        let Ti2221 : INT =
          int 1
        in
        dest.(Ti2221)
      in
      fmul Td2222 scale
    in
    dest.(Ti2220) <- Td2223
  in
  let Ti2224 : INT =
    int 2
  in
  let Td2227 : FLOAT =
    let Td2226 : FLOAT =
      let Ti2225 : INT =
        int 2
      in
      dest.(Ti2225)
    in
    fmul Td2226 scale
  in
  dest.(Ti2224) <- Td2227
in
letrec vecaccumv : (Array of FLOAT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT), (w : Array of FLOAT)
  let Tu38 : UNIT =
    let Ti2189 : INT =
      int 0
    in
    let Td2197 : FLOAT =
      let Td2191 : FLOAT =
        let Ti2190 : INT =
          int 0
        in
        dest.(Ti2190)
      in
      let Td2196 : FLOAT =
        let Td2193 : FLOAT =
          let Ti2192 : INT =
            int 0
          in
          v.(Ti2192)
        in
        let Td2195 : FLOAT =
          let Ti2194 : INT =
            int 0
          in
          w.(Ti2194)
        in
        fmul Td2193 Td2195
      in
      fadd Td2191 Td2196
    in
    dest.(Ti2189) <- Td2197
  in
  let Tu37 : UNIT =
    let Ti2198 : INT =
      int 1
    in
    let Td2206 : FLOAT =
      let Td2200 : FLOAT =
        let Ti2199 : INT =
          int 1
        in
        dest.(Ti2199)
      in
      let Td2205 : FLOAT =
        let Td2202 : FLOAT =
          let Ti2201 : INT =
            int 1
          in
          v.(Ti2201)
        in
        let Td2204 : FLOAT =
          let Ti2203 : INT =
            int 1
          in
          w.(Ti2203)
        in
        fmul Td2202 Td2204
      in
      fadd Td2200 Td2205
    in
    dest.(Ti2198) <- Td2206
  in
  let Ti2207 : INT =
    int 2
  in
  let Td2215 : FLOAT =
    let Td2209 : FLOAT =
      let Ti2208 : INT =
        int 2
      in
      dest.(Ti2208)
    in
    let Td2214 : FLOAT =
      let Td2211 : FLOAT =
        let Ti2210 : INT =
          int 2
        in
        v.(Ti2210)
      in
      let Td2213 : FLOAT =
        let Ti2212 : INT =
          int 2
        in
        w.(Ti2212)
      in
      fmul Td2211 Td2213
    in
    fadd Td2209 Td2214
  in
  dest.(Ti2207) <- Td2215
in
letrec o_texturetype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (m_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_tex
in
letrec o_form : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (m_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_shape
in
letrec o_reflectiontype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_surface
in
letrec o_isinvert : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> BOOL) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (m_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_invert
in
letrec o_isrot : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (m_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_isrot
in
letrec o_param_a : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2188 : INT =
      int 0
    in
    m_abc.(Ti2188)
in
letrec o_param_b : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2187 : INT =
      int 1
    in
    m_abc.(Ti2187)
in
letrec o_param_c : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2186 : INT =
      int 2
    in
    m_abc.(Ti2186)
in
letrec o_param_abc : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_abc
in
letrec o_param_x : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2185 : INT =
      int 0
    in
    m_xyz.(Ti2185)
in
letrec o_param_y : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2184 : INT =
      int 1
    in
    m_xyz.(Ti2184)
in
letrec o_param_z : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2183 : INT =
      int 2
    in
    m_xyz.(Ti2183)
in
letrec o_diffuse : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2182 : INT =
      int 0
    in
    m_surfparams.(Ti2182)
in
letrec o_hilight : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2181 : INT =
      int 1
    in
    m_surfparams.(Ti2181)
in
letrec o_color_red : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2180 : INT =
      int 0
    in
    m_color.(Ti2180)
in
letrec o_color_green : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2179 : INT =
      int 1
    in
    m_color.(Ti2179)
in
letrec o_color_blue : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2178 : INT =
      int 2
    in
    m_color.(Ti2178)
in
letrec o_param_r1 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2177 : INT =
      int 0
    in
    m_rot123.(Ti2177)
in
letrec o_param_r2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2176 : INT =
      int 1
    in
    m_rot123.(Ti2176)
in
letrec o_param_r3 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2175 : INT =
      int 2
    in
    m_rot123.(Ti2175)
in
letrec o_param_ctbl : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (m_ctbl : Array of FLOAT)
    m
  in
    m_ctbl
in
letrec p_rgb : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (m_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_rgb
in
letrec p_intersection_points : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (m_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_isect_ps
in
letrec p_surface_ids : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (m_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_sids
in
letrec p_calc_diffuse : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of BOOL) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (m_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_cdif
in
letrec p_energy : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (m_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_engy
in
letrec p_received_ray_20percent : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (m_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_r20p
in
letrec p_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2174 : INT =
      int 0
    in
    m_gid.(Ti2174)
in
letrec p_set_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (id : INT)
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2173 : INT =
      int 0
    in
    m_gid.(Ti2173) <- id
in
letrec p_nvectors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (m_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_nvectors
in
letrec d_vec : ((Array of FLOAT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (m_vec : Array of FLOAT), (xm_const : Array of Array of FLOAT)
    d
  in
    m_vec
in
letrec d_const : ((Array of FLOAT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (dm_vec : Array of FLOAT), (m_const : Array of Array of FLOAT)
    d
  in
    m_const
in
letrec r_surface_id : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> INT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (m_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_sid
in
letrec r_dvec : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (m_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_dvec
in
letrec r_bright : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> FLOAT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (m_br : FLOAT)
    r
  in
    m_br
in
letrec rad : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2172 : FLOAT =
    float 0.017453293
  in
  fmul x Td2172
in
letrec read_screen_settings : (UNIT -> UNIT) =
variables : (Tu39 : UNIT)
  let Tu53 : UNIT =
    let Ti2117 : INT =
      int 0
    in
    let Td2119 : FLOAT =
      let Tu2118 : UNIT =
        unit ()
      in
      unknown inflt Tu2118
    in
    screen.(Ti2117) <- Td2119
  in
  let Tu52 : UNIT =
    let Ti2120 : INT =
      int 1
    in
    let Td2122 : FLOAT =
      let Tu2121 : UNIT =
        unit ()
      in
      unknown inflt Tu2121
    in
    screen.(Ti2120) <- Td2122
  in
  let Tu51 : UNIT =
    let Ti2123 : INT =
      int 2
    in
    let Td2125 : FLOAT =
      let Tu2124 : UNIT =
        unit ()
      in
      unknown inflt Tu2124
    in
    screen.(Ti2123) <- Td2125
  in
  let v1 : FLOAT =
    let Td2127 : FLOAT =
      let Tu2126 : UNIT =
        unit ()
      in
      unknown inflt Tu2126
    in
    app
      rad
      Td2127
  in
  let cos_v1 : FLOAT =
    app
      cos
      v1
  in
  let sin_v1 : FLOAT =
    app
      sin
      v1
  in
  let v2 : FLOAT =
    let Td2129 : FLOAT =
      let Tu2128 : UNIT =
        unit ()
      in
      unknown inflt Tu2128
    in
    app
      rad
      Td2129
  in
  let cos_v2 : FLOAT =
    app
      cos
      v2
  in
  let sin_v2 : FLOAT =
    app
      sin
      v2
  in
  let Tu50 : UNIT =
    let Ti2130 : INT =
      int 0
    in
    let Td2133 : FLOAT =
      let Td2131 : FLOAT =
        fmul cos_v1 sin_v2
      in
      let Td2132 : FLOAT =
        float 200.
      in
      fmul Td2131 Td2132
    in
    screenz_dir.(Ti2130) <- Td2133
  in
  let Tu49 : UNIT =
    let Ti2134 : INT =
      int 1
    in
    let Td2136 : FLOAT =
      let Td2135 : FLOAT =
        float -200.
      in
      fmul sin_v1 Td2135
    in
    screenz_dir.(Ti2134) <- Td2136
  in
  let Tu48 : UNIT =
    let Ti2137 : INT =
      int 2
    in
    let Td2140 : FLOAT =
      let Td2138 : FLOAT =
        fmul cos_v1 cos_v2
      in
      let Td2139 : FLOAT =
        float 200.
      in
      fmul Td2138 Td2139
    in
    screenz_dir.(Ti2137) <- Td2140
  in
  let Tu47 : UNIT =
    let Ti2141 : INT =
      int 0
    in
    screenx_dir.(Ti2141) <- cos_v2
  in
  let Tu46 : UNIT =
    let Ti2142 : INT =
      int 1
    in
    let Td2143 : FLOAT =
      float 0.
    in
    screenx_dir.(Ti2142) <- Td2143
  in
  let Tu45 : UNIT =
    let Ti2144 : INT =
      int 2
    in
    let Td2145 : FLOAT =
      app
        fneg
        sin_v2
    in
    screenx_dir.(Ti2144) <- Td2145
  in
  let Tu44 : UNIT =
    let Ti2146 : INT =
      int 0
    in
    let Td2148 : FLOAT =
      let Td2147 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2147 sin_v2
    in
    screeny_dir.(Ti2146) <- Td2148
  in
  let Tu43 : UNIT =
    let Ti2149 : INT =
      int 1
    in
    let Td2150 : FLOAT =
      app
        fneg
        cos_v1
    in
    screeny_dir.(Ti2149) <- Td2150
  in
  let Tu42 : UNIT =
    let Ti2151 : INT =
      int 2
    in
    let Td2153 : FLOAT =
      let Td2152 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2152 cos_v2
    in
    screeny_dir.(Ti2151) <- Td2153
  in
  let Tu41 : UNIT =
    let Ti2154 : INT =
      int 0
    in
    let Td2159 : FLOAT =
      let Td2156 : FLOAT =
        let Ti2155 : INT =
          int 0
        in
        screen.(Ti2155)
      in
      let Td2158 : FLOAT =
        let Ti2157 : INT =
          int 0
        in
        screenz_dir.(Ti2157)
      in
      fsub Td2156 Td2158
    in
    viewpoint.(Ti2154) <- Td2159
  in
  let Tu40 : UNIT =
    let Ti2160 : INT =
      int 1
    in
    let Td2165 : FLOAT =
      let Td2162 : FLOAT =
        let Ti2161 : INT =
          int 1
        in
        screen.(Ti2161)
      in
      let Td2164 : FLOAT =
        let Ti2163 : INT =
          int 1
        in
        screenz_dir.(Ti2163)
      in
      fsub Td2162 Td2164
    in
    viewpoint.(Ti2160) <- Td2165
  in
  let Ti2166 : INT =
    int 2
  in
  let Td2171 : FLOAT =
    let Td2168 : FLOAT =
      let Ti2167 : INT =
        int 2
      in
      screen.(Ti2167)
    in
    let Td2170 : FLOAT =
      let Ti2169 : INT =
        int 2
      in
      screenz_dir.(Ti2169)
    in
    fsub Td2168 Td2170
  in
  viewpoint.(Ti2166) <- Td2171
in
letrec read_light : (UNIT -> UNIT) =
variables : (Tu54 : UNIT)
  let nl : INT =
    let Tu2103 : UNIT =
      unit ()
    in
    unknown inint Tu2103
  in
  let l1 : FLOAT =
    let Td2105 : FLOAT =
      let Tu2104 : UNIT =
        unit ()
      in
      unknown inflt Tu2104
    in
    app
      rad
      Td2105
  in
  let sl1 : FLOAT =
    app
      sin
      l1
  in
  let Tu57 : UNIT =
    let Ti2106 : INT =
      int 1
    in
    let Td2107 : FLOAT =
      app
        fneg
        sl1
    in
    light.(Ti2106) <- Td2107
  in
  let l2 : FLOAT =
    let Td2109 : FLOAT =
      let Tu2108 : UNIT =
        unit ()
      in
      unknown inflt Tu2108
    in
    app
      rad
      Td2109
  in
  let cl1 : FLOAT =
    app
      cos
      l1
  in
  let sl2 : FLOAT =
    app
      sin
      l2
  in
  let Tu56 : UNIT =
    let Ti2110 : INT =
      int 0
    in
    let Td2111 : FLOAT =
      fmul cl1 sl2
    in
    light.(Ti2110) <- Td2111
  in
  let cl2 : FLOAT =
    app
      cos
      l2
  in
  let Tu55 : UNIT =
    let Ti2112 : INT =
      int 2
    in
    let Td2113 : FLOAT =
      fmul cl1 cl2
    in
    light.(Ti2112) <- Td2113
  in
  let Ti2114 : INT =
    int 0
  in
  let Td2116 : FLOAT =
    let Tu2115 : UNIT =
      unit ()
    in
    unknown inflt Tu2115
  in
  beam.(Ti2114) <- Td2116
in
letrec rotate_quadratic_matrix : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (abc : Array of FLOAT), (rot : Array of FLOAT)
  let cos_x : FLOAT =
    let Td2017 : FLOAT =
      let Ti2016 : INT =
        int 0
      in
      rot.(Ti2016)
    in
    app
      cos
      Td2017
  in
  let sin_x : FLOAT =
    let Td2019 : FLOAT =
      let Ti2018 : INT =
        int 0
      in
      rot.(Ti2018)
    in
    app
      sin
      Td2019
  in
  let cos_y : FLOAT =
    let Td2021 : FLOAT =
      let Ti2020 : INT =
        int 1
      in
      rot.(Ti2020)
    in
    app
      cos
      Td2021
  in
  let sin_y : FLOAT =
    let Td2023 : FLOAT =
      let Ti2022 : INT =
        int 1
      in
      rot.(Ti2022)
    in
    app
      sin
      Td2023
  in
  let cos_z : FLOAT =
    let Td2025 : FLOAT =
      let Ti2024 : INT =
        int 2
      in
      rot.(Ti2024)
    in
    app
      cos
      Td2025
  in
  let sin_z : FLOAT =
    let Td2027 : FLOAT =
      let Ti2026 : INT =
        int 2
      in
      rot.(Ti2026)
    in
    app
      sin
      Td2027
  in
  let m00 : FLOAT =
    fmul cos_y cos_z
  in
  let m01 : FLOAT =
    let Td2029 : FLOAT =
      let Td2028 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2028 cos_z
    in
    let Td2030 : FLOAT =
      fmul cos_x sin_z
    in
    fsub Td2029 Td2030
  in
  let m02 : FLOAT =
    let Td2032 : FLOAT =
      let Td2031 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2031 cos_z
    in
    let Td2033 : FLOAT =
      fmul sin_x sin_z
    in
    fadd Td2032 Td2033
  in
  let m10 : FLOAT =
    fmul cos_y sin_z
  in
  let m11 : FLOAT =
    let Td2035 : FLOAT =
      let Td2034 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2034 sin_z
    in
    let Td2036 : FLOAT =
      fmul cos_x cos_z
    in
    fadd Td2035 Td2036
  in
  let m12 : FLOAT =
    let Td2038 : FLOAT =
      let Td2037 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2037 sin_z
    in
    let Td2039 : FLOAT =
      fmul sin_x cos_z
    in
    fsub Td2038 Td2039
  in
  let m20 : FLOAT =
    app
      fneg
      sin_y
  in
  let m21 : FLOAT =
    fmul sin_x cos_y
  in
  let m22 : FLOAT =
    fmul cos_x cos_y
  in
  let ao : FLOAT =
    let Ti2040 : INT =
      int 0
    in
    abc.(Ti2040)
  in
  let bo : FLOAT =
    let Ti2041 : INT =
      int 1
    in
    abc.(Ti2041)
  in
  let co : FLOAT =
    let Ti2042 : INT =
      int 2
    in
    abc.(Ti2042)
  in
  let Tu62 : UNIT =
    let Ti2043 : INT =
      int 0
    in
    let Td2051 : FLOAT =
      let Td2048 : FLOAT =
        let Td2045 : FLOAT =
          let Td2044 : FLOAT =
            app
              fsqr
              m00
          in
          fmul ao Td2044
        in
        let Td2047 : FLOAT =
          let Td2046 : FLOAT =
            app
              fsqr
              m10
          in
          fmul bo Td2046
        in
        fadd Td2045 Td2047
      in
      let Td2050 : FLOAT =
        let Td2049 : FLOAT =
          app
            fsqr
            m20
        in
        fmul co Td2049
      in
      fadd Td2048 Td2050
    in
    abc.(Ti2043) <- Td2051
  in
  let Tu61 : UNIT =
    let Ti2052 : INT =
      int 1
    in
    let Td2060 : FLOAT =
      let Td2057 : FLOAT =
        let Td2054 : FLOAT =
          let Td2053 : FLOAT =
            app
              fsqr
              m01
          in
          fmul ao Td2053
        in
        let Td2056 : FLOAT =
          let Td2055 : FLOAT =
            app
              fsqr
              m11
          in
          fmul bo Td2055
        in
        fadd Td2054 Td2056
      in
      let Td2059 : FLOAT =
        let Td2058 : FLOAT =
          app
            fsqr
            m21
        in
        fmul co Td2058
      in
      fadd Td2057 Td2059
    in
    abc.(Ti2052) <- Td2060
  in
  let Tu60 : UNIT =
    let Ti2061 : INT =
      int 2
    in
    let Td2069 : FLOAT =
      let Td2066 : FLOAT =
        let Td2063 : FLOAT =
          let Td2062 : FLOAT =
            app
              fsqr
              m02
          in
          fmul ao Td2062
        in
        let Td2065 : FLOAT =
          let Td2064 : FLOAT =
            app
              fsqr
              m12
          in
          fmul bo Td2064
        in
        fadd Td2063 Td2065
      in
      let Td2068 : FLOAT =
        let Td2067 : FLOAT =
          app
            fsqr
            m22
        in
        fmul co Td2067
      in
      fadd Td2066 Td2068
    in
    abc.(Ti2061) <- Td2069
  in
  let Tu59 : UNIT =
    let Ti2070 : INT =
      int 0
    in
    let Td2080 : FLOAT =
      let Td2071 : FLOAT =
        float 2.
      in
      let Td2079 : FLOAT =
        let Td2076 : FLOAT =
          let Td2073 : FLOAT =
            let Td2072 : FLOAT =
              fmul ao m01
            in
            fmul Td2072 m02
          in
          let Td2075 : FLOAT =
            let Td2074 : FLOAT =
              fmul bo m11
            in
            fmul Td2074 m12
          in
          fadd Td2073 Td2075
        in
        let Td2078 : FLOAT =
          let Td2077 : FLOAT =
            fmul co m21
          in
          fmul Td2077 m22
        in
        fadd Td2076 Td2078
      in
      fmul Td2071 Td2079
    in
    rot.(Ti2070) <- Td2080
  in
  let Tu58 : UNIT =
    let Ti2081 : INT =
      int 1
    in
    let Td2091 : FLOAT =
      let Td2082 : FLOAT =
        float 2.
      in
      let Td2090 : FLOAT =
        let Td2087 : FLOAT =
          let Td2084 : FLOAT =
            let Td2083 : FLOAT =
              fmul ao m00
            in
            fmul Td2083 m02
          in
          let Td2086 : FLOAT =
            let Td2085 : FLOAT =
              fmul bo m10
            in
            fmul Td2085 m12
          in
          fadd Td2084 Td2086
        in
        let Td2089 : FLOAT =
          let Td2088 : FLOAT =
            fmul co m20
          in
          fmul Td2088 m22
        in
        fadd Td2087 Td2089
      in
      fmul Td2082 Td2090
    in
    rot.(Ti2081) <- Td2091
  in
  let Ti2092 : INT =
    int 2
  in
  let Td2102 : FLOAT =
    let Td2093 : FLOAT =
      float 2.
    in
    let Td2101 : FLOAT =
      let Td2098 : FLOAT =
        let Td2095 : FLOAT =
          let Td2094 : FLOAT =
            fmul ao m00
          in
          fmul Td2094 m01
        in
        let Td2097 : FLOAT =
          let Td2096 : FLOAT =
            fmul bo m10
          in
          fmul Td2096 m11
        in
        fadd Td2095 Td2097
      in
      let Td2100 : FLOAT =
        let Td2099 : FLOAT =
          fmul co m20
        in
        fmul Td2099 m21
      in
      fadd Td2098 Td2100
    in
    fmul Td2093 Td2101
  in
  rot.(Ti2092) <- Td2102
in
letrec read_nth_object : (INT -> BOOL) =
variables : (n : INT)
  let texture : INT =
    let Tu1929 : UNIT =
      unit ()
    in
    unknown inint Tu1929
  in
  let Ti1931 : INT =
    let Ti1930 : INT =
      int 1
    in
    neg Ti1930
  in
  if texture == Ti1931
    int 0
    let form : INT =
      let Tu1932 : UNIT =
        unit ()
      in
      unknown inint Tu1932
    in
    let refltype : INT =
      let Tu1933 : UNIT =
        unit ()
      in
      unknown inint Tu1933
    in
    let isrot_p : INT =
      let Tu1934 : UNIT =
        unit ()
      in
      unknown inint Tu1934
    in
    let abc : Array of FLOAT =
      let Ti1935 : INT =
        int 3
      in
      let Td1936 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1935
        Td1936
    in
    let Tu81 : UNIT =
      let Ti1937 : INT =
        int 0
      in
      let Td1939 : FLOAT =
        let Tu1938 : UNIT =
          unit ()
        in
        unknown inflt Tu1938
      in
      abc.(Ti1937) <- Td1939
    in
    let Tu80 : UNIT =
      let Ti1940 : INT =
        int 1
      in
      let Td1942 : FLOAT =
        let Tu1941 : UNIT =
          unit ()
        in
        unknown inflt Tu1941
      in
      abc.(Ti1940) <- Td1942
    in
    let Tu79 : UNIT =
      let Ti1943 : INT =
        int 2
      in
      let Td1945 : FLOAT =
        let Tu1944 : UNIT =
          unit ()
        in
        unknown inflt Tu1944
      in
      abc.(Ti1943) <- Td1945
    in
    let xyz : Array of FLOAT =
      let Ti1946 : INT =
        int 3
      in
      let Td1947 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1946
        Td1947
    in
    let Tu78 : UNIT =
      let Ti1948 : INT =
        int 0
      in
      let Td1950 : FLOAT =
        let Tu1949 : UNIT =
          unit ()
        in
        unknown inflt Tu1949
      in
      xyz.(Ti1948) <- Td1950
    in
    let Tu77 : UNIT =
      let Ti1951 : INT =
        int 1
      in
      let Td1953 : FLOAT =
        let Tu1952 : UNIT =
          unit ()
        in
        unknown inflt Tu1952
      in
      xyz.(Ti1951) <- Td1953
    in
    let Tu76 : UNIT =
      let Ti1954 : INT =
        int 2
      in
      let Td1956 : FLOAT =
        let Tu1955 : UNIT =
          unit ()
        in
        unknown inflt Tu1955
      in
      xyz.(Ti1954) <- Td1956
    in
    let m_invert : BOOL =
      let Td1958 : FLOAT =
        let Tu1957 : UNIT =
          unit ()
        in
        unknown inflt Tu1957
      in
      app
        fisneg
        Td1958
    in
    let reflparam : Array of FLOAT =
      let Ti1959 : INT =
        int 2
      in
      let Td1960 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1959
        Td1960
    in
    let Tu75 : UNIT =
      let Ti1961 : INT =
        int 0
      in
      let Td1963 : FLOAT =
        let Tu1962 : UNIT =
          unit ()
        in
        unknown inflt Tu1962
      in
      reflparam.(Ti1961) <- Td1963
    in
    let Tu74 : UNIT =
      let Ti1964 : INT =
        int 1
      in
      let Td1966 : FLOAT =
        let Tu1965 : UNIT =
          unit ()
        in
        unknown inflt Tu1965
      in
      reflparam.(Ti1964) <- Td1966
    in
    let color : Array of FLOAT =
      let Ti1967 : INT =
        int 3
      in
      let Td1968 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1967
        Td1968
    in
    let Tu73 : UNIT =
      let Ti1969 : INT =
        int 0
      in
      let Td1971 : FLOAT =
        let Tu1970 : UNIT =
          unit ()
        in
        unknown inflt Tu1970
      in
      color.(Ti1969) <- Td1971
    in
    let Tu72 : UNIT =
      let Ti1972 : INT =
        int 1
      in
      let Td1974 : FLOAT =
        let Tu1973 : UNIT =
          unit ()
        in
        unknown inflt Tu1973
      in
      color.(Ti1972) <- Td1974
    in
    let Tu71 : UNIT =
      let Ti1975 : INT =
        int 2
      in
      let Td1977 : FLOAT =
        let Tu1976 : UNIT =
          unit ()
        in
        unknown inflt Tu1976
      in
      color.(Ti1975) <- Td1977
    in
    let rotation : Array of FLOAT =
      let Ti1978 : INT =
        int 3
      in
      let Td1979 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1978
        Td1979
    in
    let Tu70 : UNIT =
      let Ti1980 : INT =
        int 0
      in
      if isrot_p == Ti1980
        unit ()
        let Tu64 : UNIT =
          let Ti1981 : INT =
            int 0
          in
          let Td1984 : FLOAT =
            let Td1983 : FLOAT =
              let Tu1982 : UNIT =
                unit ()
              in
              unknown inflt Tu1982
            in
            app
              rad
              Td1983
          in
          rotation.(Ti1981) <- Td1984
        in
        let Tu63 : UNIT =
          let Ti1985 : INT =
            int 1
          in
          let Td1988 : FLOAT =
            let Td1987 : FLOAT =
              let Tu1986 : UNIT =
                unit ()
              in
              unknown inflt Tu1986
            in
            app
              rad
              Td1987
          in
          rotation.(Ti1985) <- Td1988
        in
        let Ti1989 : INT =
          int 2
        in
        let Td1992 : FLOAT =
          let Td1991 : FLOAT =
            let Tu1990 : UNIT =
              unit ()
            in
            unknown inflt Tu1990
          in
          app
            rad
            Td1991
        in
        rotation.(Ti1989) <- Td1992
    in
    let m_invert2 : BOOL =
      let Ti1993 : INT =
        int 2
      in
      if form == Ti1993
        int 1
        m_invert
    in
    let ctbl : Array of FLOAT =
      let Ti1994 : INT =
        int 4
      in
      let Td1995 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1994
        Td1995
    in
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      Tuple
        texture
        form
        refltype
        isrot_p
        abc
        xyz
        m_invert2
        reflparam
        color
        rotation
        ctbl
    in
    let Tu69 : UNIT =
      objects.(n) <- obj
    in
    let Tu68 : UNIT =
      let Ti1996 : INT =
        int 3
      in
      if form == Ti1996
        let a : FLOAT =
          let Ti1997 : INT =
            int 0
          in
          abc.(Ti1997)
        in
        let Tu66 : UNIT =
          let Ti1998 : INT =
            int 0
          in
          let Td2001 : FLOAT =
            if a == 0.0 
              float 0.
              let Td1999 : FLOAT =
                app
                  sgn
                  a
              in
              let Td2000 : FLOAT =
                app
                  fsqr
                  a
              in
              fdiv Td1999 Td2000
          in
          abc.(Ti1998) <- Td2001
        in
        let b : FLOAT =
          let Ti2002 : INT =
            int 1
          in
          abc.(Ti2002)
        in
        let Tu65 : UNIT =
          let Ti2003 : INT =
            int 1
          in
          let Td2006 : FLOAT =
            if b == 0.0 
              float 0.
              let Td2004 : FLOAT =
                app
                  sgn
                  b
              in
              let Td2005 : FLOAT =
                app
                  fsqr
                  b
              in
              fdiv Td2004 Td2005
          in
          abc.(Ti2003) <- Td2006
        in
        let c : FLOAT =
          let Ti2007 : INT =
            int 2
          in
          abc.(Ti2007)
        in
        let Ti2008 : INT =
          int 2
        in
        let Td2011 : FLOAT =
          if c == 0.0 
            float 0.
            let Td2009 : FLOAT =
              app
                sgn
                c
            in
            let Td2010 : FLOAT =
              app
                fsqr
                c
            in
            fdiv Td2009 Td2010
        in
        abc.(Ti2008) <- Td2011
        let Ti2012 : INT =
          int 2
        in
        if form == Ti2012
          let Ti2014 : INT =
            let Ti2013 : INT =
              int 0
            in
            if m_invert == Ti2013
              int 1
              int 0
          in
          app
            vecunit_sgn
            abc
            Ti2014
          unit ()
    in
    let Tu67 : UNIT =
      let Ti2015 : INT =
        int 0
      in
      if isrot_p == Ti2015
        unit ()
        app
          rotate_quadratic_matrix
          abc
          rotation
    in
    int 1
in
letrec read_object : (INT -> UNIT) =
variables : (n : INT)
  let Ti1923 : INT =
    int 60
  in
  if Ti1923 <= n
    unit ()
    let Tb1924 : BOOL =
      app
        read_nth_object
        n
    in
    let Ti1925 : INT =
      int 0
    in
    if Tb1924 == Ti1925
      let Ti1926 : INT =
        int 0
      in
      n_objects.(Ti1926) <- n
      let Ti1928 : INT =
        let Ti1927 : INT =
          int 1
        in
        add n Ti1927
      in
      app
        read_object
        Ti1928
in
letrec read_all_object : (UNIT -> UNIT) =
variables : (Tu82 : UNIT)
  let Ti1922 : INT =
    int 0
  in
  app
    read_object
    Ti1922
in
letrec read_net_item : (INT -> Array of INT) =
variables : (length : INT)
  let item : INT =
    let Tu1913 : UNIT =
      unit ()
    in
    unknown inint Tu1913
  in
  let Ti1915 : INT =
    let Ti1914 : INT =
      int 1
    in
    neg Ti1914
  in
  if item == Ti1915
    let Ti1917 : INT =
      let Ti1916 : INT =
        int 1
      in
      add length Ti1916
    in
    let Ti1919 : INT =
      let Ti1918 : INT =
        int 1
      in
      neg Ti1918
    in
    extfunapp
      create_array
      Ti1917
      Ti1919
    let v : Array of INT =
      let Ti1921 : INT =
        let Ti1920 : INT =
          int 1
        in
        add length Ti1920
      in
      app
        read_net_item
        Ti1921
    in
    let Tu83 : UNIT =
      v.(length) <- item
    in
    v
in
letrec read_or_network : (INT -> Array of Array of INT) =
variables : (length : INT)
  let net : Array of INT =
    let Ti1904 : INT =
      int 0
    in
    app
      read_net_item
      Ti1904
  in
  let Ti1906 : INT =
    let Ti1905 : INT =
      int 0
    in
    net.(Ti1905)
  in
  let Ti1908 : INT =
    let Ti1907 : INT =
      int 1
    in
    neg Ti1907
  in
  if Ti1906 == Ti1908
    let Ti1910 : INT =
      let Ti1909 : INT =
        int 1
      in
      add length Ti1909
    in
    extfunapp
      create_array
      Ti1910
      net
    let v : Array of Array of INT =
      let Ti1912 : INT =
        let Ti1911 : INT =
          int 1
        in
        add length Ti1911
      in
      app
        read_or_network
        Ti1912
    in
    let Tu84 : UNIT =
      v.(length) <- net
    in
    v
in
letrec read_and_network : (INT -> UNIT) =
variables : (n : INT)
  let net : Array of INT =
    let Ti1897 : INT =
      int 0
    in
    app
      read_net_item
      Ti1897
  in
  let Ti1899 : INT =
    let Ti1898 : INT =
      int 0
    in
    net.(Ti1898)
  in
  let Ti1901 : INT =
    let Ti1900 : INT =
      int 1
    in
    neg Ti1900
  in
  if Ti1899 == Ti1901
    unit ()
    let Tu85 : UNIT =
      and_net.(n) <- net
    in
    let Ti1903 : INT =
      let Ti1902 : INT =
        int 1
      in
      add n Ti1902
    in
    app
      read_and_network
      Ti1903
in
letrec read_parameter : (UNIT -> UNIT) =
variables : (Tu86 : UNIT)
  let Tu90 : UNIT =
    let Tu1890 : UNIT =
      unit ()
    in
    app
      read_screen_settings
      Tu1890
  in
  let Tu89 : UNIT =
    let Tu1891 : UNIT =
      unit ()
    in
    app
      read_light
      Tu1891
  in
  let Tu88 : UNIT =
    let Tu1892 : UNIT =
      unit ()
    in
    app
      read_all_object
      Tu1892
  in
  let Tu87 : UNIT =
    let Ti1893 : INT =
      int 0
    in
    app
      read_and_network
      Ti1893
  in
  let Ti1894 : INT =
    int 0
  in
  let Ta1896 : Array of Array of INT =
    let Ti1895 : INT =
      int 0
    in
    app
      read_or_network
      Ti1895
  in
  or_net.(Ti1894) <- Ta1896
in
letrec solver_rect_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> (INT -> BOOL)))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT), (i0 : INT), (i1 : INT), (i2 : INT)
  let Td1867 : FLOAT =
    dirvec.(i0)
  in
  if Td1867 == 0.0 
    int 0
    let abc : Array of FLOAT =
      app
        o_param_abc
        m
    in
    let d : FLOAT =
      let Tb1871 : BOOL =
        let Tb1868 : BOOL =
          app
            o_isinvert
            m
        in
        let Tb1870 : BOOL =
          let Td1869 : FLOAT =
            dirvec.(i0)
          in
          app
            fisneg
            Td1869
        in
        app
          xor
          Tb1868
          Tb1870
      in
      let Td1872 : FLOAT =
        abc.(i0)
      in
      app
        fneg_cond
        Tb1871
        Td1872
    in
    let d2 : FLOAT =
      let Td1873 : FLOAT =
        fsub d b0
      in
      let Td1874 : FLOAT =
        dirvec.(i0)
      in
      fdiv Td1873 Td1874
    in
    let Tb1880 : BOOL =
      let Td1878 : FLOAT =
        let Td1877 : FLOAT =
          let Td1876 : FLOAT =
            let Td1875 : FLOAT =
              dirvec.(i1)
            in
            fmul d2 Td1875
          in
          fadd Td1876 b1
        in
        app
          fabs
          Td1877
      in
      let Td1879 : FLOAT =
        abc.(i1)
      in
      app
        fless
        Td1878
        Td1879
    in
    let Ti1881 : INT =
      int 0
    in
    if Tb1880 == Ti1881
      int 0
      let Tb1887 : BOOL =
        let Td1885 : FLOAT =
          let Td1884 : FLOAT =
            let Td1883 : FLOAT =
              let Td1882 : FLOAT =
                dirvec.(i2)
              in
              fmul d2 Td1882
            in
            fadd Td1883 b2
          in
          app
            fabs
            Td1884
        in
        let Td1886 : FLOAT =
          abc.(i2)
        in
        app
          fless
          Td1885
          Td1886
      in
      let Ti1888 : INT =
        int 0
      in
      if Tb1887 == Ti1888
        int 0
        let Tu91 : UNIT =
          let Ti1889 : INT =
            int 0
          in
          solver_dist.(Ti1889) <- d2
        in
        int 1
in
letrec solver_rect : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1855 : BOOL =
    let Ti1852 : INT =
      int 0
    in
    let Ti1853 : INT =
      int 1
    in
    let Ti1854 : INT =
      int 2
    in
    app
      solver_rect_surface
      m
      dirvec
      b0
      b1
      b2
      Ti1852
      Ti1853
      Ti1854
  in
  let Ti1856 : INT =
    int 0
  in
  if Tb1855 == Ti1856
    let Tb1860 : BOOL =
      let Ti1857 : INT =
        int 1
      in
      let Ti1858 : INT =
        int 2
      in
      let Ti1859 : INT =
        int 0
      in
      app
        solver_rect_surface
        m
        dirvec
        b1
        b2
        b0
        Ti1857
        Ti1858
        Ti1859
    in
    let Ti1861 : INT =
      int 0
    in
    if Tb1860 == Ti1861
      let Tb1865 : BOOL =
        let Ti1862 : INT =
          int 2
        in
        let Ti1863 : INT =
          int 0
        in
        let Ti1864 : INT =
          int 1
        in
        app
          solver_rect_surface
          m
          dirvec
          b2
          b0
          b1
          Ti1862
          Ti1863
          Ti1864
      in
      let Ti1866 : INT =
        int 0
      in
      if Tb1865 == Ti1866
        int 0
        int 3
      int 2
    int 1
in
letrec solver_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let abc : Array of FLOAT =
    app
      o_param_abc
      m
  in
  let d : FLOAT =
    app
      veciprod
      dirvec
      abc
  in
  let Tb1846 : BOOL =
    app
      fispos
      d
  in
  let Ti1847 : INT =
    int 0
  in
  if Tb1846 == Ti1847
    int 0
    let Tu92 : UNIT =
      let Ti1848 : INT =
        int 0
      in
      let Td1851 : FLOAT =
        let Td1850 : FLOAT =
          let Td1849 : FLOAT =
            app
              veciprod2
              abc
              b0
              b1
              b2
          in
          app
            fneg
            Td1849
        in
        fdiv Td1850 d
      in
      solver_dist.(Ti1848) <- Td1851
    in
    int 1
in
letrec quadratic : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let diag_part : FLOAT =
    let Td1829 : FLOAT =
      let Td1825 : FLOAT =
        let Td1823 : FLOAT =
          app
            fsqr
            v0
        in
        let Td1824 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1823 Td1824
      in
      let Td1828 : FLOAT =
        let Td1826 : FLOAT =
          app
            fsqr
            v1
        in
        let Td1827 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1826 Td1827
      in
      fadd Td1825 Td1828
    in
    let Td1832 : FLOAT =
      let Td1830 : FLOAT =
        app
          fsqr
          v2
      in
      let Td1831 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1830 Td1831
    in
    fadd Td1829 Td1832
  in
  let Ti1833 : INT =
    app
      o_isrot
      m
  in
  let Ti1834 : INT =
    int 0
  in
  if Ti1833 == Ti1834
    diag_part
    let Td1842 : FLOAT =
      let Td1838 : FLOAT =
        let Td1837 : FLOAT =
          let Td1835 : FLOAT =
            fmul v1 v2
          in
          let Td1836 : FLOAT =
            app
              o_param_r1
              m
          in
          fmul Td1835 Td1836
        in
        fadd diag_part Td1837
      in
      let Td1841 : FLOAT =
        let Td1839 : FLOAT =
          fmul v2 v0
        in
        let Td1840 : FLOAT =
          app
            o_param_r2
            m
        in
        fmul Td1839 Td1840
      in
      fadd Td1838 Td1841
    in
    let Td1845 : FLOAT =
      let Td1843 : FLOAT =
        fmul v0 v1
      in
      let Td1844 : FLOAT =
        app
          o_param_r3
          m
      in
      fmul Td1843 Td1844
    in
    fadd Td1842 Td1845
in
letrec bilinear : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let diag_part : FLOAT =
    let Td1799 : FLOAT =
      let Td1795 : FLOAT =
        let Td1793 : FLOAT =
          fmul v0 w0
        in
        let Td1794 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1793 Td1794
      in
      let Td1798 : FLOAT =
        let Td1796 : FLOAT =
          fmul v1 w1
        in
        let Td1797 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1796 Td1797
      in
      fadd Td1795 Td1798
    in
    let Td1802 : FLOAT =
      let Td1800 : FLOAT =
        fmul v2 w2
      in
      let Td1801 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1800 Td1801
    in
    fadd Td1799 Td1802
  in
  let Ti1803 : INT =
    app
      o_isrot
      m
  in
  let Ti1804 : INT =
    int 0
  in
  if Ti1803 == Ti1804
    diag_part
    let Td1822 : FLOAT =
      let Td1821 : FLOAT =
        let Td1815 : FLOAT =
          let Td1809 : FLOAT =
            let Td1807 : FLOAT =
              let Td1805 : FLOAT =
                fmul v2 w1
              in
              let Td1806 : FLOAT =
                fmul v1 w2
              in
              fadd Td1805 Td1806
            in
            let Td1808 : FLOAT =
              app
                o_param_r1
                m
            in
            fmul Td1807 Td1808
          in
          let Td1814 : FLOAT =
            let Td1812 : FLOAT =
              let Td1810 : FLOAT =
                fmul v0 w2
              in
              let Td1811 : FLOAT =
                fmul v2 w0
              in
              fadd Td1810 Td1811
            in
            let Td1813 : FLOAT =
              app
                o_param_r2
                m
            in
            fmul Td1812 Td1813
          in
          fadd Td1809 Td1814
        in
        let Td1820 : FLOAT =
          let Td1818 : FLOAT =
            let Td1816 : FLOAT =
              fmul v0 w1
            in
            let Td1817 : FLOAT =
              fmul v1 w0
            in
            fadd Td1816 Td1817
          in
          let Td1819 : FLOAT =
            app
              o_param_r3
              m
          in
          fmul Td1818 Td1819
        in
        fadd Td1815 Td1820
      in
      app
        fhalf
        Td1821
    in
    fadd diag_part Td1822
in
letrec solver_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Td1770 : FLOAT =
      let Ti1769 : INT =
        int 0
      in
      dirvec.(Ti1769)
    in
    let Td1772 : FLOAT =
      let Ti1771 : INT =
        int 1
      in
      dirvec.(Ti1771)
    in
    let Td1774 : FLOAT =
      let Ti1773 : INT =
        int 2
      in
      dirvec.(Ti1773)
    in
    app
      quadratic
      m
      Td1770
      Td1772
      Td1774
  in
  if aa == 0.0 
    int 0
    let bb : FLOAT =
      let Td1776 : FLOAT =
        let Ti1775 : INT =
          int 0
        in
        dirvec.(Ti1775)
      in
      let Td1778 : FLOAT =
        let Ti1777 : INT =
          int 1
        in
        dirvec.(Ti1777)
      in
      let Td1780 : FLOAT =
        let Ti1779 : INT =
          int 2
        in
        dirvec.(Ti1779)
      in
      app
        bilinear
        m
        Td1776
        Td1778
        Td1780
        b0
        b1
        b2
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1781 : INT =
        app
          o_form
          m
      in
      let Ti1782 : INT =
        int 3
      in
      if Ti1781 == Ti1782
        let Td1783 : FLOAT =
          float 1.
        in
        fsub cc0 Td1783
        cc0
    in
    let d : FLOAT =
      let Td1784 : FLOAT =
        app
          fsqr
          bb
      in
      let Td1785 : FLOAT =
        fmul aa cc
      in
      fsub Td1784 Td1785
    in
    let Tb1786 : BOOL =
      app
        fispos
        d
    in
    let Ti1787 : INT =
      int 0
    in
    if Tb1786 == Ti1787
      int 0
      let sd : FLOAT =
        app
          sqrt
          d
      in
      let t1 : FLOAT =
        let Tb1788 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1789 : INT =
          int 0
        in
        if Tb1788 == Ti1789
          app
            fneg
            sd
          sd
      in
      let Tu93 : UNIT =
        let Ti1790 : INT =
          int 0
        in
        let Td1792 : FLOAT =
          let Td1791 : FLOAT =
            fsub t1 bb
          in
          fdiv Td1791 aa
        in
        solver_dist.(Ti1790) <- Td1792
      in
      int 1
in
letrec solver : (INT -> (Array of FLOAT -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : Array of FLOAT), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1759 : FLOAT =
      let Ti1758 : INT =
        int 0
      in
      org.(Ti1758)
    in
    let Td1760 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1759 Td1760
  in
  let b1 : FLOAT =
    let Td1762 : FLOAT =
      let Ti1761 : INT =
        int 1
      in
      org.(Ti1761)
    in
    let Td1763 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1762 Td1763
  in
  let b2 : FLOAT =
    let Td1765 : FLOAT =
      let Ti1764 : INT =
        int 2
      in
      org.(Ti1764)
    in
    let Td1766 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1765 Td1766
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1767 : INT =
    int 1
  in
  if m_shape == Ti1767
    app
      solver_rect
      m
      dirvec
      b0
      b1
      b2
    let Ti1768 : INT =
      int 2
    in
    if m_shape == Ti1768
      app
        solver_surface
        m
        dirvec
        b0
        b1
        b2
      app
        solver_second
        m
        dirvec
        b0
        b1
        b2
in
letrec solver_rect_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v : Array of FLOAT), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let d0 : FLOAT =
    let Td1682 : FLOAT =
      let Td1681 : FLOAT =
        let Ti1680 : INT =
          int 0
        in
        dconst.(Ti1680)
      in
      fsub Td1681 b0
    in
    let Td1684 : FLOAT =
      let Ti1683 : INT =
        int 1
      in
      dconst.(Ti1683)
    in
    fmul Td1682 Td1684
  in
  let Ti1703 : INT =
    let Tb1691 : BOOL =
      let Td1689 : FLOAT =
        let Td1688 : FLOAT =
          let Td1687 : FLOAT =
            let Td1686 : FLOAT =
              let Ti1685 : INT =
                int 1
              in
              v.(Ti1685)
            in
            fmul d0 Td1686
          in
          fadd Td1687 b1
        in
        app
          fabs
          Td1688
      in
      let Td1690 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fless
        Td1689
        Td1690
    in
    let Ti1692 : INT =
      int 0
    in
    if Tb1691 == Ti1692
      int 0
      let Tb1699 : BOOL =
        let Td1697 : FLOAT =
          let Td1696 : FLOAT =
            let Td1695 : FLOAT =
              let Td1694 : FLOAT =
                let Ti1693 : INT =
                  int 2
                in
                v.(Ti1693)
              in
              fmul d0 Td1694
            in
            fadd Td1695 b2
          in
          app
            fabs
            Td1696
        in
        let Td1698 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1697
          Td1698
      in
      let Ti1700 : INT =
        int 0
      in
      if Tb1699 == Ti1700
        int 0
        let Td1702 : FLOAT =
          let Ti1701 : INT =
            int 1
          in
          dconst.(Ti1701)
        in
        if Td1702 == 0.0 
          int 0
          int 1
  in
  let Ti1704 : INT =
    int 0
  in
  if Ti1703 == Ti1704
    let d1 : FLOAT =
      let Td1707 : FLOAT =
        let Td1706 : FLOAT =
          let Ti1705 : INT =
            int 2
          in
          dconst.(Ti1705)
        in
        fsub Td1706 b1
      in
      let Td1709 : FLOAT =
        let Ti1708 : INT =
          int 3
        in
        dconst.(Ti1708)
      in
      fmul Td1707 Td1709
    in
    let Ti1728 : INT =
      let Tb1716 : BOOL =
        let Td1714 : FLOAT =
          let Td1713 : FLOAT =
            let Td1712 : FLOAT =
              let Td1711 : FLOAT =
                let Ti1710 : INT =
                  int 0
                in
                v.(Ti1710)
              in
              fmul d1 Td1711
            in
            fadd Td1712 b0
          in
          app
            fabs
            Td1713
        in
        let Td1715 : FLOAT =
          app
            o_param_a
            m
        in
        app
          fless
          Td1714
          Td1715
      in
      let Ti1717 : INT =
        int 0
      in
      if Tb1716 == Ti1717
        int 0
        let Tb1724 : BOOL =
          let Td1722 : FLOAT =
            let Td1721 : FLOAT =
              let Td1720 : FLOAT =
                let Td1719 : FLOAT =
                  let Ti1718 : INT =
                    int 2
                  in
                  v.(Ti1718)
                in
                fmul d1 Td1719
              in
              fadd Td1720 b2
            in
            app
              fabs
              Td1721
          in
          let Td1723 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fless
            Td1722
            Td1723
        in
        let Ti1725 : INT =
          int 0
        in
        if Tb1724 == Ti1725
          int 0
          let Td1727 : FLOAT =
            let Ti1726 : INT =
              int 3
            in
            dconst.(Ti1726)
          in
          if Td1727 == 0.0 
            int 0
            int 1
    in
    let Ti1729 : INT =
      int 0
    in
    if Ti1728 == Ti1729
      let d2 : FLOAT =
        let Td1732 : FLOAT =
          let Td1731 : FLOAT =
            let Ti1730 : INT =
              int 4
            in
            dconst.(Ti1730)
          in
          fsub Td1731 b2
        in
        let Td1734 : FLOAT =
          let Ti1733 : INT =
            int 5
          in
          dconst.(Ti1733)
        in
        fmul Td1732 Td1734
      in
      let Ti1753 : INT =
        let Tb1741 : BOOL =
          let Td1739 : FLOAT =
            let Td1738 : FLOAT =
              let Td1737 : FLOAT =
                let Td1736 : FLOAT =
                  let Ti1735 : INT =
                    int 0
                  in
                  v.(Ti1735)
                in
                fmul d2 Td1736
              in
              fadd Td1737 b0
            in
            app
              fabs
              Td1738
          in
          let Td1740 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fless
            Td1739
            Td1740
        in
        let Ti1742 : INT =
          int 0
        in
        if Tb1741 == Ti1742
          int 0
          let Tb1749 : BOOL =
            let Td1747 : FLOAT =
              let Td1746 : FLOAT =
                let Td1745 : FLOAT =
                  let Td1744 : FLOAT =
                    let Ti1743 : INT =
                      int 1
                    in
                    v.(Ti1743)
                  in
                  fmul d2 Td1744
                in
                fadd Td1745 b1
              in
              app
                fabs
                Td1746
            in
            let Td1748 : FLOAT =
              app
                o_param_b
                m
            in
            app
              fless
              Td1747
              Td1748
          in
          let Ti1750 : INT =
            int 0
          in
          if Tb1749 == Ti1750
            int 0
            let Td1752 : FLOAT =
              let Ti1751 : INT =
                int 5
              in
              dconst.(Ti1751)
            in
            if Td1752 == 0.0 
              int 0
              int 1
      in
      let Ti1754 : INT =
        int 0
      in
      if Ti1753 == Ti1754
        int 0
        let Tu96 : UNIT =
          let Ti1755 : INT =
            int 0
          in
          solver_dist.(Ti1755) <- d2
        in
        int 3
      let Tu95 : UNIT =
        let Ti1756 : INT =
          int 0
        in
        solver_dist.(Ti1756) <- d1
      in
      int 2
    let Tu94 : UNIT =
      let Ti1757 : INT =
        int 0
      in
      solver_dist.(Ti1757) <- d0
    in
    int 1
in
letrec solver_surface_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1666 : BOOL =
    let Td1665 : FLOAT =
      let Ti1664 : INT =
        int 0
      in
      dconst.(Ti1664)
    in
    app
      fisneg
      Td1665
  in
  let Ti1667 : INT =
    int 0
  in
  if Tb1666 == Ti1667
    int 0
    let Tu97 : UNIT =
      let Ti1668 : INT =
        int 0
      in
      let Td1679 : FLOAT =
        let Td1675 : FLOAT =
          let Td1671 : FLOAT =
            let Td1670 : FLOAT =
              let Ti1669 : INT =
                int 1
              in
              dconst.(Ti1669)
            in
            fmul Td1670 b0
          in
          let Td1674 : FLOAT =
            let Td1673 : FLOAT =
              let Ti1672 : INT =
                int 2
              in
              dconst.(Ti1672)
            in
            fmul Td1673 b1
          in
          fadd Td1671 Td1674
        in
        let Td1678 : FLOAT =
          let Td1677 : FLOAT =
            let Ti1676 : INT =
              int 3
            in
            dconst.(Ti1676)
          in
          fmul Td1677 b2
        in
        fadd Td1675 Td1678
      in
      solver_dist.(Ti1668) <- Td1679
    in
    int 1
in
letrec solver_second_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1632 : INT =
      int 0
    in
    dconst.(Ti1632)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1639 : FLOAT =
        let Td1635 : FLOAT =
          let Td1634 : FLOAT =
            let Ti1633 : INT =
              int 1
            in
            dconst.(Ti1633)
          in
          fmul Td1634 b0
        in
        let Td1638 : FLOAT =
          let Td1637 : FLOAT =
            let Ti1636 : INT =
              int 2
            in
            dconst.(Ti1636)
          in
          fmul Td1637 b1
        in
        fadd Td1635 Td1638
      in
      let Td1642 : FLOAT =
        let Td1641 : FLOAT =
          let Ti1640 : INT =
            int 3
          in
          dconst.(Ti1640)
        in
        fmul Td1641 b2
      in
      fadd Td1639 Td1642
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1643 : INT =
        app
          o_form
          m
      in
      let Ti1644 : INT =
        int 3
      in
      if Ti1643 == Ti1644
        let Td1645 : FLOAT =
          float 1.
        in
        fsub cc0 Td1645
        cc0
    in
    let d : FLOAT =
      let Td1646 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1647 : FLOAT =
        fmul aa cc
      in
      fsub Td1646 Td1647
    in
    let Tb1648 : BOOL =
      app
        fispos
        d
    in
    let Ti1649 : INT =
      int 0
    in
    if Tb1648 == Ti1649
      int 0
      let Tu98 : UNIT =
        let Tb1650 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1651 : INT =
          int 0
        in
        if Tb1650 == Ti1651
          let Ti1652 : INT =
            int 0
          in
          let Td1657 : FLOAT =
            let Td1654 : FLOAT =
              let Td1653 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1653
            in
            let Td1656 : FLOAT =
              let Ti1655 : INT =
                int 4
              in
              dconst.(Ti1655)
            in
            fmul Td1654 Td1656
          in
          solver_dist.(Ti1652) <- Td1657
          let Ti1658 : INT =
            int 0
          in
          let Td1663 : FLOAT =
            let Td1660 : FLOAT =
              let Td1659 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1659
            in
            let Td1662 : FLOAT =
              let Ti1661 : INT =
                int 4
              in
              dconst.(Ti1661)
            in
            fmul Td1660 Td1662
          in
          solver_dist.(Ti1658) <- Td1663
      in
      int 1
in
letrec solver_fast : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1621 : FLOAT =
      let Ti1620 : INT =
        int 0
      in
      org.(Ti1620)
    in
    let Td1622 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1621 Td1622
  in
  let b1 : FLOAT =
    let Td1624 : FLOAT =
      let Ti1623 : INT =
        int 1
      in
      org.(Ti1623)
    in
    let Td1625 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1624 Td1625
  in
  let b2 : FLOAT =
    let Td1627 : FLOAT =
      let Ti1626 : INT =
        int 2
      in
      org.(Ti1626)
    in
    let Td1628 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1627 Td1628
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1629 : INT =
    int 1
  in
  if m_shape == Ti1629
    let Ta1630 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1630
      dconst
      b0
      b1
      b2
    let Ti1631 : INT =
      int 2
    in
    if m_shape == Ti1631
      app
        solver_surface_fast
        m
        dconst
        b0
        b1
        b2
      app
        solver_second_fast
        m
        dconst
        b0
        b1
        b2
in
letrec solver_surface_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1612 : BOOL =
    let Td1611 : FLOAT =
      let Ti1610 : INT =
        int 0
      in
      dconst.(Ti1610)
    in
    app
      fisneg
      Td1611
  in
  let Ti1613 : INT =
    int 0
  in
  if Tb1612 == Ti1613
    int 0
    let Tu99 : UNIT =
      let Ti1614 : INT =
        int 0
      in
      let Td1619 : FLOAT =
        let Td1616 : FLOAT =
          let Ti1615 : INT =
            int 0
          in
          dconst.(Ti1615)
        in
        let Td1618 : FLOAT =
          let Ti1617 : INT =
            int 3
          in
          sconst.(Ti1617)
        in
        fmul Td1616 Td1618
      in
      solver_dist.(Ti1614) <- Td1619
    in
    int 1
in
letrec solver_second_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1580 : INT =
      int 0
    in
    dconst.(Ti1580)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1587 : FLOAT =
        let Td1583 : FLOAT =
          let Td1582 : FLOAT =
            let Ti1581 : INT =
              int 1
            in
            dconst.(Ti1581)
          in
          fmul Td1582 b0
        in
        let Td1586 : FLOAT =
          let Td1585 : FLOAT =
            let Ti1584 : INT =
              int 2
            in
            dconst.(Ti1584)
          in
          fmul Td1585 b1
        in
        fadd Td1583 Td1586
      in
      let Td1590 : FLOAT =
        let Td1589 : FLOAT =
          let Ti1588 : INT =
            int 3
          in
          dconst.(Ti1588)
        in
        fmul Td1589 b2
      in
      fadd Td1587 Td1590
    in
    let cc : FLOAT =
      let Ti1591 : INT =
        int 3
      in
      sconst.(Ti1591)
    in
    let d : FLOAT =
      let Td1592 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1593 : FLOAT =
        fmul aa cc
      in
      fsub Td1592 Td1593
    in
    let Tb1594 : BOOL =
      app
        fispos
        d
    in
    let Ti1595 : INT =
      int 0
    in
    if Tb1594 == Ti1595
      int 0
      let Tu100 : UNIT =
        let Tb1596 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1597 : INT =
          int 0
        in
        if Tb1596 == Ti1597
          let Ti1598 : INT =
            int 0
          in
          let Td1603 : FLOAT =
            let Td1600 : FLOAT =
              let Td1599 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1599
            in
            let Td1602 : FLOAT =
              let Ti1601 : INT =
                int 4
              in
              dconst.(Ti1601)
            in
            fmul Td1600 Td1602
          in
          solver_dist.(Ti1598) <- Td1603
          let Ti1604 : INT =
            int 0
          in
          let Td1609 : FLOAT =
            let Td1606 : FLOAT =
              let Td1605 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1605
            in
            let Td1608 : FLOAT =
              let Ti1607 : INT =
                int 4
              in
              dconst.(Ti1607)
            in
            fmul Td1606 Td1608
          in
          solver_dist.(Ti1604) <- Td1609
      in
      int 1
in
letrec solver_fast2 : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> INT)) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let sconst : Array of FLOAT =
    app
      o_param_ctbl
      m
  in
  let b0 : FLOAT =
    let Ti1574 : INT =
      int 0
    in
    sconst.(Ti1574)
  in
  let b1 : FLOAT =
    let Ti1575 : INT =
      int 1
    in
    sconst.(Ti1575)
  in
  let b2 : FLOAT =
    let Ti1576 : INT =
      int 2
    in
    sconst.(Ti1576)
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1577 : INT =
    int 1
  in
  if m_shape == Ti1577
    let Ta1578 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1578
      dconst
      b0
      b1
      b2
    let Ti1579 : INT =
      int 2
    in
    if m_shape == Ti1579
      app
        solver_surface_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
      app
        solver_second_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
in
letrec setup_rect_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1521 : INT =
      int 6
    in
    let Td1522 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1521
      Td1522
  in
  let Tu106 : UNIT =
    let Td1524 : FLOAT =
      let Ti1523 : INT =
        int 0
      in
      vec.(Ti1523)
    in
    if Td1524 == 0.0 
      let Ti1525 : INT =
        int 1
      in
      let Td1526 : FLOAT =
        float 0.
      in
      const.(Ti1525) <- Td1526
      let Tu101 : UNIT =
        let Ti1527 : INT =
          int 0
        in
        let Td1534 : FLOAT =
          let Tb1532 : BOOL =
            let Tb1528 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1531 : BOOL =
              let Td1530 : FLOAT =
                let Ti1529 : INT =
                  int 0
                in
                vec.(Ti1529)
              in
              app
                fisneg
                Td1530
            in
            app
              xor
              Tb1528
              Tb1531
          in
          let Td1533 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fneg_cond
            Tb1532
            Td1533
        in
        const.(Ti1527) <- Td1534
      in
      let Ti1535 : INT =
        int 1
      in
      let Td1539 : FLOAT =
        let Td1536 : FLOAT =
          float 1.
        in
        let Td1538 : FLOAT =
          let Ti1537 : INT =
            int 0
          in
          vec.(Ti1537)
        in
        fdiv Td1536 Td1538
      in
      const.(Ti1535) <- Td1539
  in
  let Tu105 : UNIT =
    let Td1541 : FLOAT =
      let Ti1540 : INT =
        int 1
      in
      vec.(Ti1540)
    in
    if Td1541 == 0.0 
      let Ti1542 : INT =
        int 3
      in
      let Td1543 : FLOAT =
        float 0.
      in
      const.(Ti1542) <- Td1543
      let Tu102 : UNIT =
        let Ti1544 : INT =
          int 2
        in
        let Td1551 : FLOAT =
          let Tb1549 : BOOL =
            let Tb1545 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1548 : BOOL =
              let Td1547 : FLOAT =
                let Ti1546 : INT =
                  int 1
                in
                vec.(Ti1546)
              in
              app
                fisneg
                Td1547
            in
            app
              xor
              Tb1545
              Tb1548
          in
          let Td1550 : FLOAT =
            app
              o_param_b
              m
          in
          app
            fneg_cond
            Tb1549
            Td1550
        in
        const.(Ti1544) <- Td1551
      in
      let Ti1552 : INT =
        int 3
      in
      let Td1556 : FLOAT =
        let Td1553 : FLOAT =
          float 1.
        in
        let Td1555 : FLOAT =
          let Ti1554 : INT =
            int 1
          in
          vec.(Ti1554)
        in
        fdiv Td1553 Td1555
      in
      const.(Ti1552) <- Td1556
  in
  let Tu104 : UNIT =
    let Td1558 : FLOAT =
      let Ti1557 : INT =
        int 2
      in
      vec.(Ti1557)
    in
    if Td1558 == 0.0 
      let Ti1559 : INT =
        int 5
      in
      let Td1560 : FLOAT =
        float 0.
      in
      const.(Ti1559) <- Td1560
      let Tu103 : UNIT =
        let Ti1561 : INT =
          int 4
        in
        let Td1568 : FLOAT =
          let Tb1566 : BOOL =
            let Tb1562 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1565 : BOOL =
              let Td1564 : FLOAT =
                let Ti1563 : INT =
                  int 2
                in
                vec.(Ti1563)
              in
              app
                fisneg
                Td1564
            in
            app
              xor
              Tb1562
              Tb1565
          in
          let Td1567 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fneg_cond
            Tb1566
            Td1567
        in
        const.(Ti1561) <- Td1568
      in
      let Ti1569 : INT =
        int 5
      in
      let Td1573 : FLOAT =
        let Td1570 : FLOAT =
          float 1.
        in
        let Td1572 : FLOAT =
          let Ti1571 : INT =
            int 2
          in
          vec.(Ti1571)
        in
        fdiv Td1570 Td1572
      in
      const.(Ti1569) <- Td1573
  in
  const
in
letrec setup_surface_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1487 : INT =
      int 4
    in
    let Td1488 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1487
      Td1488
  in
  let d : FLOAT =
    let Td1497 : FLOAT =
      let Td1492 : FLOAT =
        let Td1490 : FLOAT =
          let Ti1489 : INT =
            int 0
          in
          vec.(Ti1489)
        in
        let Td1491 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1490 Td1491
      in
      let Td1496 : FLOAT =
        let Td1494 : FLOAT =
          let Ti1493 : INT =
            int 1
          in
          vec.(Ti1493)
        in
        let Td1495 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1494 Td1495
      in
      fadd Td1492 Td1496
    in
    let Td1501 : FLOAT =
      let Td1499 : FLOAT =
        let Ti1498 : INT =
          int 2
        in
        vec.(Ti1498)
      in
      let Td1500 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1499 Td1500
    in
    fadd Td1497 Td1501
  in
  let Tu110 : UNIT =
    let Tb1502 : BOOL =
      app
        fispos
        d
    in
    let Ti1503 : INT =
      int 0
    in
    if Tb1502 == Ti1503
      let Ti1504 : INT =
        int 0
      in
      let Td1505 : FLOAT =
        float 0.
      in
      const.(Ti1504) <- Td1505
      let Tu109 : UNIT =
        let Ti1506 : INT =
          int 0
        in
        let Td1508 : FLOAT =
          let Td1507 : FLOAT =
            float -1.
          in
          fdiv Td1507 d
        in
        const.(Ti1506) <- Td1508
      in
      let Tu108 : UNIT =
        let Ti1509 : INT =
          int 1
        in
        let Td1512 : FLOAT =
          let Td1511 : FLOAT =
            let Td1510 : FLOAT =
              app
                o_param_a
                m
            in
            fdiv Td1510 d
          in
          app
            fneg
            Td1511
        in
        const.(Ti1509) <- Td1512
      in
      let Tu107 : UNIT =
        let Ti1513 : INT =
          int 2
        in
        let Td1516 : FLOAT =
          let Td1515 : FLOAT =
            let Td1514 : FLOAT =
              app
                o_param_b
                m
            in
            fdiv Td1514 d
          in
          app
            fneg
            Td1515
        in
        const.(Ti1513) <- Td1516
      in
      let Ti1517 : INT =
        int 3
      in
      let Td1520 : FLOAT =
        let Td1519 : FLOAT =
          let Td1518 : FLOAT =
            app
              o_param_c
              m
          in
          fdiv Td1518 d
        in
        app
          fneg
          Td1519
      in
      const.(Ti1517) <- Td1520
  in
  const
in
letrec setup_second_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (v : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1422 : INT =
      int 5
    in
    let Td1423 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1422
      Td1423
  in
  let aa : FLOAT =
    let Td1425 : FLOAT =
      let Ti1424 : INT =
        int 0
      in
      v.(Ti1424)
    in
    let Td1427 : FLOAT =
      let Ti1426 : INT =
        int 1
      in
      v.(Ti1426)
    in
    let Td1429 : FLOAT =
      let Ti1428 : INT =
        int 2
      in
      v.(Ti1428)
    in
    app
      quadratic
      m
      Td1425
      Td1427
      Td1429
  in
  let c1 : FLOAT =
    let Td1433 : FLOAT =
      let Td1431 : FLOAT =
        let Ti1430 : INT =
          int 0
        in
        v.(Ti1430)
      in
      let Td1432 : FLOAT =
        app
          o_param_a
          m
      in
      fmul Td1431 Td1432
    in
    app
      fneg
      Td1433
  in
  let c2 : FLOAT =
    let Td1437 : FLOAT =
      let Td1435 : FLOAT =
        let Ti1434 : INT =
          int 1
        in
        v.(Ti1434)
      in
      let Td1436 : FLOAT =
        app
          o_param_b
          m
      in
      fmul Td1435 Td1436
    in
    app
      fneg
      Td1437
  in
  let c3 : FLOAT =
    let Td1441 : FLOAT =
      let Td1439 : FLOAT =
        let Ti1438 : INT =
          int 2
        in
        v.(Ti1438)
      in
      let Td1440 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1439 Td1440
    in
    app
      fneg
      Td1441
  in
  let Tu117 : UNIT =
    let Ti1442 : INT =
      int 0
    in
    const.(Ti1442) <- aa
  in
  let Tu116 : UNIT =
    let Ti1443 : INT =
      app
        o_isrot
        m
    in
    let Ti1444 : INT =
      int 0
    in
    if Ti1443 == Ti1444
      let Tu114 : UNIT =
        let Ti1445 : INT =
          int 1
        in
        const.(Ti1445) <- c1
      in
      let Tu113 : UNIT =
        let Ti1446 : INT =
          int 2
        in
        const.(Ti1446) <- c2
      in
      let Ti1447 : INT =
        int 3
      in
      const.(Ti1447) <- c3
      let Tu112 : UNIT =
        let Ti1448 : INT =
          int 1
        in
        let Td1459 : FLOAT =
          let Td1458 : FLOAT =
            let Td1457 : FLOAT =
              let Td1452 : FLOAT =
                let Td1450 : FLOAT =
                  let Ti1449 : INT =
                    int 2
                  in
                  v.(Ti1449)
                in
                let Td1451 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul Td1450 Td1451
              in
              let Td1456 : FLOAT =
                let Td1454 : FLOAT =
                  let Ti1453 : INT =
                    int 1
                  in
                  v.(Ti1453)
                in
                let Td1455 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1454 Td1455
              in
              fadd Td1452 Td1456
            in
            app
              fhalf
              Td1457
          in
          fsub c1 Td1458
        in
        const.(Ti1448) <- Td1459
      in
      let Tu111 : UNIT =
        let Ti1460 : INT =
          int 2
        in
        let Td1471 : FLOAT =
          let Td1470 : FLOAT =
            let Td1469 : FLOAT =
              let Td1464 : FLOAT =
                let Td1462 : FLOAT =
                  let Ti1461 : INT =
                    int 2
                  in
                  v.(Ti1461)
                in
                let Td1463 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul Td1462 Td1463
              in
              let Td1468 : FLOAT =
                let Td1466 : FLOAT =
                  let Ti1465 : INT =
                    int 0
                  in
                  v.(Ti1465)
                in
                let Td1467 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1466 Td1467
              in
              fadd Td1464 Td1468
            in
            app
              fhalf
              Td1469
          in
          fsub c2 Td1470
        in
        const.(Ti1460) <- Td1471
      in
      let Ti1472 : INT =
        int 3
      in
      let Td1483 : FLOAT =
        let Td1482 : FLOAT =
          let Td1481 : FLOAT =
            let Td1476 : FLOAT =
              let Td1474 : FLOAT =
                let Ti1473 : INT =
                  int 1
                in
                v.(Ti1473)
              in
              let Td1475 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul Td1474 Td1475
            in
            let Td1480 : FLOAT =
              let Td1478 : FLOAT =
                let Ti1477 : INT =
                  int 0
                in
                v.(Ti1477)
              in
              let Td1479 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul Td1478 Td1479
            in
            fadd Td1476 Td1480
          in
          app
            fhalf
            Td1481
        in
        fsub c3 Td1482
      in
      const.(Ti1472) <- Td1483
  in
  let Tu115 : UNIT =
    if aa == 0.0 
      unit ()
      let Ti1484 : INT =
        int 4
      in
      let Td1486 : FLOAT =
        let Td1485 : FLOAT =
          float 1.
        in
        fdiv Td1485 aa
      in
      const.(Ti1484) <- Td1486
  in
  const
in
letrec iter_setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti1414 : INT =
    int 0
  in
  if Ti1414 <= index
    let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let dconst : Array of Array of FLOAT =
      app
        d_const
        dirvec
    in
    let v : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    let m_shape : INT =
      app
        o_form
        m
    in
    let Tu118 : UNIT =
      let Ti1415 : INT =
        int 1
      in
      if m_shape == Ti1415
        let Ta1416 : Array of FLOAT =
          app
            setup_rect_table
            v
            m
        in
        dconst.(index) <- Ta1416
        let Ti1417 : INT =
          int 2
        in
        if m_shape == Ti1417
          let Ta1418 : Array of FLOAT =
            app
              setup_surface_table
              v
              m
          in
          dconst.(index) <- Ta1418
          let Ta1419 : Array of FLOAT =
            app
              setup_second_table
              v
              m
          in
          dconst.(index) <- Ta1419
    in
    let Ti1421 : INT =
      let Ti1420 : INT =
        int 1
      in
      sub index Ti1420
    in
    app
      iter_setup_dirvec_constants
      dirvec
      Ti1421
    unit ()
in
letrec setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> UNIT) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Ti1413 : INT =
    let Ti1411 : INT =
      let Ti1410 : INT =
        int 0
      in
      n_objects.(Ti1410)
    in
    let Ti1412 : INT =
      int 1
    in
    sub Ti1411 Ti1412
  in
  app
    iter_setup_dirvec_constants
    dirvec
    Ti1413
in
letrec setup_startp_constants : (Array of FLOAT -> (INT -> UNIT)) =
variables : (p : Array of FLOAT), (index : INT)
  let Ti1371 : INT =
    int 0
  in
  if Ti1371 <= index
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let sconst : Array of FLOAT =
      app
        o_param_ctbl
        obj
    in
    let m_shape : INT =
      app
        o_form
        obj
    in
    let Tu122 : UNIT =
      let Ti1372 : INT =
        int 0
      in
      let Td1376 : FLOAT =
        let Td1374 : FLOAT =
          let Ti1373 : INT =
            int 0
          in
          p.(Ti1373)
        in
        let Td1375 : FLOAT =
          app
            o_param_x
            obj
        in
        fsub Td1374 Td1375
      in
      sconst.(Ti1372) <- Td1376
    in
    let Tu121 : UNIT =
      let Ti1377 : INT =
        int 1
      in
      let Td1381 : FLOAT =
        let Td1379 : FLOAT =
          let Ti1378 : INT =
            int 1
          in
          p.(Ti1378)
        in
        let Td1380 : FLOAT =
          app
            o_param_y
            obj
        in
        fsub Td1379 Td1380
      in
      sconst.(Ti1377) <- Td1381
    in
    let Tu120 : UNIT =
      let Ti1382 : INT =
        int 2
      in
      let Td1386 : FLOAT =
        let Td1384 : FLOAT =
          let Ti1383 : INT =
            int 2
          in
          p.(Ti1383)
        in
        let Td1385 : FLOAT =
          app
            o_param_z
            obj
        in
        fsub Td1384 Td1385
      in
      sconst.(Ti1382) <- Td1386
    in
    let Tu119 : UNIT =
      let Ti1387 : INT =
        int 2
      in
      if m_shape == Ti1387
        let Ti1388 : INT =
          int 3
        in
        let Td1396 : FLOAT =
          let Ta1389 : Array of FLOAT =
            app
              o_param_abc
              obj
          in
          let Td1391 : FLOAT =
            let Ti1390 : INT =
              int 0
            in
            sconst.(Ti1390)
          in
          let Td1393 : FLOAT =
            let Ti1392 : INT =
              int 1
            in
            sconst.(Ti1392)
          in
          let Td1395 : FLOAT =
            let Ti1394 : INT =
              int 2
            in
            sconst.(Ti1394)
          in
          app
            veciprod2
            Ta1389
            Td1391
            Td1393
            Td1395
        in
        sconst.(Ti1388) <- Td1396
        let Ti1397 : INT =
          int 2
        in
        if m_shape <= Ti1397
          unit ()
          let cc0 : FLOAT =
            let Td1399 : FLOAT =
              let Ti1398 : INT =
                int 0
              in
              sconst.(Ti1398)
            in
            let Td1401 : FLOAT =
              let Ti1400 : INT =
                int 1
              in
              sconst.(Ti1400)
            in
            let Td1403 : FLOAT =
              let Ti1402 : INT =
                int 2
              in
              sconst.(Ti1402)
            in
            app
              quadratic
              obj
              Td1399
              Td1401
              Td1403
          in
          let Ti1404 : INT =
            int 3
          in
          let Td1407 : FLOAT =
            let Ti1405 : INT =
              int 3
            in
            if m_shape == Ti1405
              let Td1406 : FLOAT =
                float 1.
              in
              fsub cc0 Td1406
              cc0
          in
          sconst.(Ti1404) <- Td1407
    in
    let Ti1409 : INT =
      let Ti1408 : INT =
        int 1
      in
      sub index Ti1408
    in
    app
      setup_startp_constants
      p
      Ti1409
    unit ()
in
letrec setup_startp : (Array of FLOAT -> UNIT) =
variables : (p : Array of FLOAT)
  let Tu123 : UNIT =
    app
      veccpy
      startp_fast
      p
  in
  let Ti1370 : INT =
    let Ti1368 : INT =
      let Ti1367 : INT =
        int 0
      in
      n_objects.(Ti1367)
    in
    let Ti1369 : INT =
      int 1
    in
    sub Ti1368 Ti1369
  in
  app
    setup_startp_constants
    p
    Ti1370
in
letrec is_rect_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let Ti1363 : INT =
    let Tb1355 : BOOL =
      let Td1353 : FLOAT =
        app
          fabs
          p0
      in
      let Td1354 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fless
        Td1353
        Td1354
    in
    let Ti1356 : INT =
      int 0
    in
    if Tb1355 == Ti1356
      int 0
      let Tb1359 : BOOL =
        let Td1357 : FLOAT =
          app
            fabs
            p1
        in
        let Td1358 : FLOAT =
          app
            o_param_b
            m
        in
        app
          fless
          Td1357
          Td1358
      in
      let Ti1360 : INT =
        int 0
      in
      if Tb1359 == Ti1360
        int 0
        let Td1361 : FLOAT =
          app
            fabs
            p2
        in
        let Td1362 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1361
          Td1362
  in
  let Ti1364 : INT =
    int 0
  in
  if Ti1363 == Ti1364
    let Tb1365 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1366 : INT =
      int 0
    in
    if Tb1365 == Ti1366
      int 1
      int 0
    app
      o_isinvert
      m
in
letrec is_plane_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    let Ta1348 : Array of FLOAT =
      app
        o_param_abc
        m
    in
    app
      veciprod2
      Ta1348
      p0
      p1
      p2
  in
  let Tb1351 : BOOL =
    let Tb1349 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1350 : BOOL =
      app
        fisneg
        w
    in
    app
      xor
      Tb1349
      Tb1350
  in
  let Ti1352 : INT =
    int 0
  in
  if Tb1351 == Ti1352
    int 1
    int 0
in
letrec is_second_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    app
      quadratic
      m
      p0
      p1
      p2
  in
  let w2 : FLOAT =
    let Ti1341 : INT =
      app
        o_form
        m
    in
    let Ti1342 : INT =
      int 3
    in
    if Ti1341 == Ti1342
      let Td1343 : FLOAT =
        float 1.
      in
      fsub w Td1343
      w
  in
  let Tb1346 : BOOL =
    let Tb1344 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1345 : BOOL =
      app
        fisneg
        w2
    in
    app
      xor
      Tb1344
      Tb1345
  in
  let Ti1347 : INT =
    int 0
  in
  if Tb1346 == Ti1347
    int 1
    int 0
in
letrec is_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let p0 : FLOAT =
    let Td1336 : FLOAT =
      app
        o_param_x
        m
    in
    fsub q0 Td1336
  in
  let p1 : FLOAT =
    let Td1337 : FLOAT =
      app
        o_param_y
        m
    in
    fsub q1 Td1337
  in
  let p2 : FLOAT =
    let Td1338 : FLOAT =
      app
        o_param_z
        m
    in
    fsub q2 Td1338
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1339 : INT =
    int 1
  in
  if m_shape == Ti1339
    app
      is_rect_outside
      m
      p0
      p1
      p2
    let Ti1340 : INT =
      int 2
    in
    if m_shape == Ti1340
      app
        is_plane_outside
        m
        p0
        p1
        p2
      app
        is_second_outside
        m
        p0
        p1
        p2
in
letrec check_all_inside : (INT -> (Array of INT -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL))))) =
variables : (ofs : INT), (iand : Array of INT), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let head : INT =
    iand.(ofs)
  in
  let Ti1330 : INT =
    let Ti1329 : INT =
      int 1
    in
    neg Ti1329
  in
  if head == Ti1330
    int 1
    let Tb1332 : BOOL =
      let Tt1331 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(head)
      in
      app
        is_outside
        Tt1331
        q0
        q1
        q2
    in
    let Ti1333 : INT =
      int 0
    in
    if Tb1332 == Ti1333
      let Ti1335 : INT =
        let Ti1334 : INT =
          int 1
        in
        add ofs Ti1334
      in
      app
        check_all_inside
        Ti1335
        iand
        q0
        q1
        q2
      int 0
in
letrec shadow_check_and_group : (INT -> (Array of INT -> BOOL)) =
variables : (iand_ofs : INT), (and_group : Array of INT)
  let Ti1295 : INT =
    and_group.(iand_ofs)
  in
  let Ti1297 : INT =
    let Ti1296 : INT =
      int 1
    in
    neg Ti1296
  in
  if Ti1295 == Ti1297
    int 0
    let obj : INT =
      and_group.(iand_ofs)
    in
    let t0 : INT =
      app
        solver_fast
        obj
        light_dirvec
        intersection_point
    in
    let t0p : FLOAT =
      let Ti1298 : INT =
        int 0
      in
      solver_dist.(Ti1298)
    in
    let Ti1301 : INT =
      let Ti1299 : INT =
        int 0
      in
      if t0 == Ti1299
        int 0
        let Td1300 : FLOAT =
          float -0.2
        in
        app
          fless
          t0p
          Td1300
    in
    let Ti1302 : INT =
      int 0
    in
    if Ti1301 == Ti1302
      let Tb1304 : BOOL =
        let Tt1303 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(obj)
        in
        app
          o_isinvert
          Tt1303
      in
      let Ti1305 : INT =
        int 0
      in
      if Tb1304 == Ti1305
        int 0
        let Ti1307 : INT =
          let Ti1306 : INT =
            int 1
          in
          add iand_ofs Ti1306
        in
        app
          shadow_check_and_group
          Ti1307
          and_group
      let t : FLOAT =
        let Td1308 : FLOAT =
          float 0.01
        in
        fadd t0p Td1308
      in
      let q0 : FLOAT =
        let Td1311 : FLOAT =
          let Td1310 : FLOAT =
            let Ti1309 : INT =
              int 0
            in
            light.(Ti1309)
          in
          fmul Td1310 t
        in
        let Td1313 : FLOAT =
          let Ti1312 : INT =
            int 0
          in
          intersection_point.(Ti1312)
        in
        fadd Td1311 Td1313
      in
      let q1 : FLOAT =
        let Td1316 : FLOAT =
          let Td1315 : FLOAT =
            let Ti1314 : INT =
              int 1
            in
            light.(Ti1314)
          in
          fmul Td1315 t
        in
        let Td1318 : FLOAT =
          let Ti1317 : INT =
            int 1
          in
          intersection_point.(Ti1317)
        in
        fadd Td1316 Td1318
      in
      let q2 : FLOAT =
        let Td1321 : FLOAT =
          let Td1320 : FLOAT =
            let Ti1319 : INT =
              int 2
            in
            light.(Ti1319)
          in
          fmul Td1320 t
        in
        let Td1323 : FLOAT =
          let Ti1322 : INT =
            int 2
          in
          intersection_point.(Ti1322)
        in
        fadd Td1321 Td1323
      in
      let Tb1325 : BOOL =
        let Ti1324 : INT =
          int 0
        in
        app
          check_all_inside
          Ti1324
          and_group
          q0
          q1
          q2
      in
      let Ti1326 : INT =
        int 0
      in
      if Tb1325 == Ti1326
        let Ti1328 : INT =
          let Ti1327 : INT =
            int 1
          in
          add iand_ofs Ti1327
        in
        app
          shadow_check_and_group
          Ti1328
          and_group
        int 1
in
letrec shadow_check_one_or_group : (INT -> (Array of INT -> BOOL)) =
variables : (ofs : INT), (or_group : Array of INT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1290 : INT =
    let Ti1289 : INT =
      int 1
    in
    neg Ti1289
  in
  if head == Ti1290
    int 0
    let and_group : Array of INT =
      and_net.(head)
    in
    let shadow_p : BOOL =
      let Ti1291 : INT =
        int 0
      in
      app
        shadow_check_and_group
        Ti1291
        and_group
    in
    let Ti1292 : INT =
      int 0
    in
    if shadow_p == Ti1292
      let Ti1294 : INT =
        let Ti1293 : INT =
          int 1
        in
        add ofs Ti1293
      in
      app
        shadow_check_one_or_group
        Ti1294
        or_group
      int 1
in
letrec shadow_check_one_or_matrix : (INT -> (Array of Array of INT -> BOOL)) =
variables : (ofs : INT), (or_matrix : Array of Array of INT)
  let head : Array of INT =
    or_matrix.(ofs)
  in
  let range_primitive : INT =
    let Ti1267 : INT =
      int 0
    in
    head.(Ti1267)
  in
  let Ti1269 : INT =
    let Ti1268 : INT =
      int 1
    in
    neg Ti1268
  in
  if range_primitive == Ti1269
    int 0
    let Ti1280 : INT =
      let Ti1270 : INT =
        int 99
      in
      if range_primitive == Ti1270
        int 1
        let t : INT =
          app
            solver_fast
            range_primitive
            light_dirvec
            intersection_point
        in
        let Ti1271 : INT =
          int 0
        in
        if t == Ti1271
          int 0
          let Tb1275 : BOOL =
            let Td1273 : FLOAT =
              let Ti1272 : INT =
                int 0
              in
              solver_dist.(Ti1272)
            in
            let Td1274 : FLOAT =
              float -0.1
            in
            app
              fless
              Td1273
              Td1274
          in
          let Ti1276 : INT =
            int 0
          in
          if Tb1275 == Ti1276
            int 0
            let Tb1278 : BOOL =
              let Ti1277 : INT =
                int 1
              in
              app
                shadow_check_one_or_group
                Ti1277
                head
            in
            let Ti1279 : INT =
              int 0
            in
            if Tb1278 == Ti1279
              int 0
              int 1
    in
    let Ti1281 : INT =
      int 0
    in
    if Ti1280 == Ti1281
      let Ti1283 : INT =
        let Ti1282 : INT =
          int 1
        in
        add ofs Ti1282
      in
      app
        shadow_check_one_or_matrix
        Ti1283
        or_matrix
      let Tb1285 : BOOL =
        let Ti1284 : INT =
          int 1
        in
        app
          shadow_check_one_or_group
          Ti1284
          head
      in
      let Ti1286 : INT =
        int 0
      in
      if Tb1285 == Ti1286
        let Ti1288 : INT =
          let Ti1287 : INT =
            int 1
          in
          add ofs Ti1287
        in
        app
          shadow_check_one_or_matrix
          Ti1288
          or_matrix
        int 1
in
letrec solve_each_element : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : Array of FLOAT)
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1228 : INT =
    let Ti1227 : INT =
      int 1
    in
    neg Ti1227
  in
  if iobj == Ti1228
    unit ()
    let t0 : INT =
      app
        solver
        iobj
        dirvec
        startp
    in
    let Ti1229 : INT =
      int 0
    in
    if t0 == Ti1229
      let Tb1231 : BOOL =
        let Tt1230 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1230
      in
      let Ti1232 : INT =
        int 0
      in
      if Tb1231 == Ti1232
        unit ()
        let Ti1234 : INT =
          let Ti1233 : INT =
            int 1
          in
          add iand_ofs Ti1233
        in
        app
          solve_each_element
          Ti1234
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1235 : INT =
          int 0
        in
        solver_dist.(Ti1235)
      in
      let Tu127 : UNIT =
        let Tb1237 : BOOL =
          let Td1236 : FLOAT =
            float 0.
          in
          app
            fless
            Td1236
            t0p
        in
        let Ti1238 : INT =
          int 0
        in
        if Tb1237 == Ti1238
          unit ()
          let Tb1241 : BOOL =
            let Td1240 : FLOAT =
              let Ti1239 : INT =
                int 0
              in
              tmin.(Ti1239)
            in
            app
              fless
              t0p
              Td1240
          in
          let Ti1242 : INT =
            int 0
          in
          if Tb1241 == Ti1242
            unit ()
            let t : FLOAT =
              let Td1243 : FLOAT =
                float 0.01
              in
              fadd t0p Td1243
            in
            let q0 : FLOAT =
              let Td1246 : FLOAT =
                let Td1245 : FLOAT =
                  let Ti1244 : INT =
                    int 0
                  in
                  dirvec.(Ti1244)
                in
                fmul Td1245 t
              in
              let Td1248 : FLOAT =
                let Ti1247 : INT =
                  int 0
                in
                startp.(Ti1247)
              in
              fadd Td1246 Td1248
            in
            let q1 : FLOAT =
              let Td1251 : FLOAT =
                let Td1250 : FLOAT =
                  let Ti1249 : INT =
                    int 1
                  in
                  dirvec.(Ti1249)
                in
                fmul Td1250 t
              in
              let Td1253 : FLOAT =
                let Ti1252 : INT =
                  int 1
                in
                startp.(Ti1252)
              in
              fadd Td1251 Td1253
            in
            let q2 : FLOAT =
              let Td1256 : FLOAT =
                let Td1255 : FLOAT =
                  let Ti1254 : INT =
                    int 2
                  in
                  dirvec.(Ti1254)
                in
                fmul Td1255 t
              in
              let Td1258 : FLOAT =
                let Ti1257 : INT =
                  int 2
                in
                startp.(Ti1257)
              in
              fadd Td1256 Td1258
            in
            let Tb1260 : BOOL =
              let Ti1259 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1259
                and_group
                q0
                q1
                q2
            in
            let Ti1261 : INT =
              int 0
            in
            if Tb1260 == Ti1261
              unit ()
              let Tu126 : UNIT =
                let Ti1262 : INT =
                  int 0
                in
                tmin.(Ti1262) <- t
              in
              let Tu125 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu124 : UNIT =
                let Ti1263 : INT =
                  int 0
                in
                intersected_object_id.(Ti1263) <- iobj
              in
              let Ti1264 : INT =
                int 0
              in
              intsec_rectside.(Ti1264) <- t0
      in
      let Ti1266 : INT =
        let Ti1265 : INT =
          int 1
        in
        add iand_ofs Ti1265
      in
      app
        solve_each_element
        Ti1266
        and_group
        dirvec
in
letrec solve_one_or_network : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : Array of FLOAT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1223 : INT =
    let Ti1222 : INT =
      int 1
    in
    neg Ti1222
  in
  if head == Ti1223
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu128 : UNIT =
      let Ti1224 : INT =
        int 0
      in
      app
        solve_each_element
        Ti1224
        and_group
        dirvec
    in
    let Ti1226 : INT =
      let Ti1225 : INT =
        int 1
      in
      add ofs Ti1225
    in
    app
      solve_one_or_network
      Ti1226
      or_group
      dirvec
in
letrec trace_or_matrix : (INT -> (Array of Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : Array of FLOAT)
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1208 : INT =
      int 0
    in
    head.(Ti1208)
  in
  let Ti1210 : INT =
    let Ti1209 : INT =
      int 1
    in
    neg Ti1209
  in
  if range_primitive == Ti1210
    unit ()
    let Tu129 : UNIT =
      let Ti1211 : INT =
        int 99
      in
      if range_primitive == Ti1211
        let Ti1212 : INT =
          int 1
        in
        app
          solve_one_or_network
          Ti1212
          head
          dirvec
        let t : INT =
          app
            solver
            range_primitive
            dirvec
            startp
        in
        let Ti1213 : INT =
          int 0
        in
        if t == Ti1213
          unit ()
          let tp : FLOAT =
            let Ti1214 : INT =
              int 0
            in
            solver_dist.(Ti1214)
          in
          let Tb1217 : BOOL =
            let Td1216 : FLOAT =
              let Ti1215 : INT =
                int 0
              in
              tmin.(Ti1215)
            in
            app
              fless
              tp
              Td1216
          in
          let Ti1218 : INT =
            int 0
          in
          if Tb1217 == Ti1218
            unit ()
            let Ti1219 : INT =
              int 1
            in
            app
              solve_one_or_network
              Ti1219
              head
              dirvec
    in
    let Ti1221 : INT =
      let Ti1220 : INT =
        int 1
      in
      add ofs Ti1220
    in
    app
      trace_or_matrix
      Ti1221
      or_network
      dirvec
in
letrec judge_intersection : (Array of FLOAT -> BOOL) =
variables : (dirvec : Array of FLOAT)
  let Tu131 : UNIT =
    let Ti1198 : INT =
      int 0
    in
    let Td1199 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1198) <- Td1199
  in
  let Tu130 : UNIT =
    let Ti1200 : INT =
      int 0
    in
    let Ta1202 : Array of Array of INT =
      let Ti1201 : INT =
        int 0
      in
      or_net.(Ti1201)
    in
    app
      trace_or_matrix
      Ti1200
      Ta1202
      dirvec
  in
  let t : FLOAT =
    let Ti1203 : INT =
      int 0
    in
    tmin.(Ti1203)
  in
  let Tb1205 : BOOL =
    let Td1204 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1204
      t
  in
  let Ti1206 : INT =
    int 0
  in
  if Tb1205 == Ti1206
    int 0
    let Td1207 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1207
in
letrec solve_each_element_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let vec : Array of FLOAT =
    app
      d_vec
      dirvec
  in
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1159 : INT =
    let Ti1158 : INT =
      int 1
    in
    neg Ti1158
  in
  if iobj == Ti1159
    unit ()
    let t0 : INT =
      app
        solver_fast2
        iobj
        dirvec
    in
    let Ti1160 : INT =
      int 0
    in
    if t0 == Ti1160
      let Tb1162 : BOOL =
        let Tt1161 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1161
      in
      let Ti1163 : INT =
        int 0
      in
      if Tb1162 == Ti1163
        unit ()
        let Ti1165 : INT =
          let Ti1164 : INT =
            int 1
          in
          add iand_ofs Ti1164
        in
        app
          solve_each_element_fast
          Ti1165
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1166 : INT =
          int 0
        in
        solver_dist.(Ti1166)
      in
      let Tu135 : UNIT =
        let Tb1168 : BOOL =
          let Td1167 : FLOAT =
            float 0.
          in
          app
            fless
            Td1167
            t0p
        in
        let Ti1169 : INT =
          int 0
        in
        if Tb1168 == Ti1169
          unit ()
          let Tb1172 : BOOL =
            let Td1171 : FLOAT =
              let Ti1170 : INT =
                int 0
              in
              tmin.(Ti1170)
            in
            app
              fless
              t0p
              Td1171
          in
          let Ti1173 : INT =
            int 0
          in
          if Tb1172 == Ti1173
            unit ()
            let t : FLOAT =
              let Td1174 : FLOAT =
                float 0.01
              in
              fadd t0p Td1174
            in
            let q0 : FLOAT =
              let Td1177 : FLOAT =
                let Td1176 : FLOAT =
                  let Ti1175 : INT =
                    int 0
                  in
                  vec.(Ti1175)
                in
                fmul Td1176 t
              in
              let Td1179 : FLOAT =
                let Ti1178 : INT =
                  int 0
                in
                startp_fast.(Ti1178)
              in
              fadd Td1177 Td1179
            in
            let q1 : FLOAT =
              let Td1182 : FLOAT =
                let Td1181 : FLOAT =
                  let Ti1180 : INT =
                    int 1
                  in
                  vec.(Ti1180)
                in
                fmul Td1181 t
              in
              let Td1184 : FLOAT =
                let Ti1183 : INT =
                  int 1
                in
                startp_fast.(Ti1183)
              in
              fadd Td1182 Td1184
            in
            let q2 : FLOAT =
              let Td1187 : FLOAT =
                let Td1186 : FLOAT =
                  let Ti1185 : INT =
                    int 2
                  in
                  vec.(Ti1185)
                in
                fmul Td1186 t
              in
              let Td1189 : FLOAT =
                let Ti1188 : INT =
                  int 2
                in
                startp_fast.(Ti1188)
              in
              fadd Td1187 Td1189
            in
            let Tb1191 : BOOL =
              let Ti1190 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1190
                and_group
                q0
                q1
                q2
            in
            let Ti1192 : INT =
              int 0
            in
            if Tb1191 == Ti1192
              unit ()
              let Tu134 : UNIT =
                let Ti1193 : INT =
                  int 0
                in
                tmin.(Ti1193) <- t
              in
              let Tu133 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu132 : UNIT =
                let Ti1194 : INT =
                  int 0
                in
                intersected_object_id.(Ti1194) <- iobj
              in
              let Ti1195 : INT =
                int 0
              in
              intsec_rectside.(Ti1195) <- t0
      in
      let Ti1197 : INT =
        let Ti1196 : INT =
          int 1
        in
        add iand_ofs Ti1196
      in
      app
        solve_each_element_fast
        Ti1197
        and_group
        dirvec
in
letrec solve_one_or_network_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : INT =
    or_group.(ofs)
  in
  let Ti1154 : INT =
    let Ti1153 : INT =
      int 1
    in
    neg Ti1153
  in
  if head == Ti1154
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu136 : UNIT =
      let Ti1155 : INT =
        int 0
      in
      app
        solve_each_element_fast
        Ti1155
        and_group
        dirvec
    in
    let Ti1157 : INT =
      let Ti1156 : INT =
        int 1
      in
      add ofs Ti1156
    in
    app
      solve_one_or_network_fast
      Ti1157
      or_group
      dirvec
in
letrec trace_or_matrix_fast : (INT -> (Array of Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1139 : INT =
      int 0
    in
    head.(Ti1139)
  in
  let Ti1141 : INT =
    let Ti1140 : INT =
      int 1
    in
    neg Ti1140
  in
  if range_primitive == Ti1141
    unit ()
    let Tu137 : UNIT =
      let Ti1142 : INT =
        int 99
      in
      if range_primitive == Ti1142
        let Ti1143 : INT =
          int 1
        in
        app
          solve_one_or_network_fast
          Ti1143
          head
          dirvec
        let t : INT =
          app
            solver_fast2
            range_primitive
            dirvec
        in
        let Ti1144 : INT =
          int 0
        in
        if t == Ti1144
          unit ()
          let tp : FLOAT =
            let Ti1145 : INT =
              int 0
            in
            solver_dist.(Ti1145)
          in
          let Tb1148 : BOOL =
            let Td1147 : FLOAT =
              let Ti1146 : INT =
                int 0
              in
              tmin.(Ti1146)
            in
            app
              fless
              tp
              Td1147
          in
          let Ti1149 : INT =
            int 0
          in
          if Tb1148 == Ti1149
            unit ()
            let Ti1150 : INT =
              int 1
            in
            app
              solve_one_or_network_fast
              Ti1150
              head
              dirvec
    in
    let Ti1152 : INT =
      let Ti1151 : INT =
        int 1
      in
      add ofs Ti1151
    in
    app
      trace_or_matrix_fast
      Ti1152
      or_network
      dirvec
in
letrec judge_intersection_fast : ((Array of FLOAT * Array of Array of FLOAT) -> BOOL) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Tu139 : UNIT =
    let Ti1129 : INT =
      int 0
    in
    let Td1130 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1129) <- Td1130
  in
  let Tu138 : UNIT =
    let Ti1131 : INT =
      int 0
    in
    let Ta1133 : Array of Array of INT =
      let Ti1132 : INT =
        int 0
      in
      or_net.(Ti1132)
    in
    app
      trace_or_matrix_fast
      Ti1131
      Ta1133
      dirvec
  in
  let t : FLOAT =
    let Ti1134 : INT =
      int 0
    in
    tmin.(Ti1134)
  in
  let Tb1136 : BOOL =
    let Td1135 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1135
      t
  in
  let Ti1137 : INT =
    int 0
  in
  if Tb1136 == Ti1137
    int 0
    let Td1138 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1138
in
letrec get_nvector_rect : (Array of FLOAT -> UNIT) =
variables : (dirvec : Array of FLOAT)
  let rectside : INT =
    let Ti1121 : INT =
      int 0
    in
    intsec_rectside.(Ti1121)
  in
  let Tu140 : UNIT =
    app
      vecbzero
      nvector
  in
  let Ti1123 : INT =
    let Ti1122 : INT =
      int 1
    in
    sub rectside Ti1122
  in
  let Td1128 : FLOAT =
    let Td1127 : FLOAT =
      let Td1126 : FLOAT =
        let Ti1125 : INT =
          let Ti1124 : INT =
            int 1
          in
          sub rectside Ti1124
        in
        dirvec.(Ti1125)
      in
      app
        sgn
        Td1126
    in
    app
      fneg
      Td1127
  in
  nvector.(Ti1123) <- Td1128
in
letrec get_nvector_plane : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let Tu142 : UNIT =
    let Ti1112 : INT =
      int 0
    in
    let Td1114 : FLOAT =
      let Td1113 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fneg
        Td1113
    in
    nvector.(Ti1112) <- Td1114
  in
  let Tu141 : UNIT =
    let Ti1115 : INT =
      int 1
    in
    let Td1117 : FLOAT =
      let Td1116 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fneg
        Td1116
    in
    nvector.(Ti1115) <- Td1117
  in
  let Ti1118 : INT =
    int 2
  in
  let Td1120 : FLOAT =
    let Td1119 : FLOAT =
      app
        o_param_c
        m
    in
    app
      fneg
      Td1119
  in
  nvector.(Ti1118) <- Td1120
in
letrec get_nvector_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let p0 : FLOAT =
    let Td1071 : FLOAT =
      let Ti1070 : INT =
        int 0
      in
      intersection_point.(Ti1070)
    in
    let Td1072 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1071 Td1072
  in
  let p1 : FLOAT =
    let Td1074 : FLOAT =
      let Ti1073 : INT =
        int 1
      in
      intersection_point.(Ti1073)
    in
    let Td1075 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1074 Td1075
  in
  let p2 : FLOAT =
    let Td1077 : FLOAT =
      let Ti1076 : INT =
        int 2
      in
      intersection_point.(Ti1076)
    in
    let Td1078 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1077 Td1078
  in
  let d0 : FLOAT =
    let Td1079 : FLOAT =
      app
        o_param_a
        m
    in
    fmul p0 Td1079
  in
  let d1 : FLOAT =
    let Td1080 : FLOAT =
      app
        o_param_b
        m
    in
    fmul p1 Td1080
  in
  let d2 : FLOAT =
    let Td1081 : FLOAT =
      app
        o_param_c
        m
    in
    fmul p2 Td1081
  in
  let Tu147 : UNIT =
    let Ti1082 : INT =
      app
        o_isrot
        m
    in
    let Ti1083 : INT =
      int 0
    in
    if Ti1082 == Ti1083
      let Tu144 : UNIT =
        let Ti1084 : INT =
          int 0
        in
        nvector.(Ti1084) <- d0
      in
      let Tu143 : UNIT =
        let Ti1085 : INT =
          int 1
        in
        nvector.(Ti1085) <- d1
      in
      let Ti1086 : INT =
        int 2
      in
      nvector.(Ti1086) <- d2
      let Tu146 : UNIT =
        let Ti1087 : INT =
          int 0
        in
        let Td1094 : FLOAT =
          let Td1093 : FLOAT =
            let Td1092 : FLOAT =
              let Td1089 : FLOAT =
                let Td1088 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p1 Td1088
              in
              let Td1091 : FLOAT =
                let Td1090 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul p2 Td1090
              in
              fadd Td1089 Td1091
            in
            app
              fhalf
              Td1092
          in
          fadd d0 Td1093
        in
        nvector.(Ti1087) <- Td1094
      in
      let Tu145 : UNIT =
        let Ti1095 : INT =
          int 1
        in
        let Td1102 : FLOAT =
          let Td1101 : FLOAT =
            let Td1100 : FLOAT =
              let Td1097 : FLOAT =
                let Td1096 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p0 Td1096
              in
              let Td1099 : FLOAT =
                let Td1098 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul p2 Td1098
              in
              fadd Td1097 Td1099
            in
            app
              fhalf
              Td1100
          in
          fadd d1 Td1101
        in
        nvector.(Ti1095) <- Td1102
      in
      let Ti1103 : INT =
        int 2
      in
      let Td1110 : FLOAT =
        let Td1109 : FLOAT =
          let Td1108 : FLOAT =
            let Td1105 : FLOAT =
              let Td1104 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul p0 Td1104
            in
            let Td1107 : FLOAT =
              let Td1106 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul p1 Td1106
            in
            fadd Td1105 Td1107
          in
          app
            fhalf
            Td1108
        in
        fadd d2 Td1109
      in
      nvector.(Ti1103) <- Td1110
  in
  let Tb1111 : BOOL =
    app
      o_isinvert
      m
  in
  app
    vecunit_sgn
    nvector
    Tb1111
in
letrec get_nvector : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT)
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1068 : INT =
    int 1
  in
  if m_shape == Ti1068
    app
      get_nvector_rect
      dirvec
    let Ti1069 : INT =
      int 2
    in
    if m_shape == Ti1069
      app
        get_nvector_plane
        m
      app
        get_nvector_second
        m
in
letrec utexture : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p : Array of FLOAT)
  let m_tex : INT =
    app
      o_texturetype
      m
  in
  let Tu152 : UNIT =
    let Ti944 : INT =
      int 0
    in
    let Td945 : FLOAT =
      app
        o_color_red
        m
    in
    texture_color.(Ti944) <- Td945
  in
  let Tu151 : UNIT =
    let Ti946 : INT =
      int 1
    in
    let Td947 : FLOAT =
      app
        o_color_green
        m
    in
    texture_color.(Ti946) <- Td947
  in
  let Tu150 : UNIT =
    let Ti948 : INT =
      int 2
    in
    let Td949 : FLOAT =
      app
        o_color_blue
        m
    in
    texture_color.(Ti948) <- Td949
  in
  let Ti950 : INT =
    int 1
  in
  if m_tex == Ti950
    let w1 : FLOAT =
      let Td952 : FLOAT =
        let Ti951 : INT =
          int 0
        in
        p.(Ti951)
      in
      let Td953 : FLOAT =
        app
          o_param_x
          m
      in
      fsub Td952 Td953
    in
    let flag1 : BOOL =
      let d1 : FLOAT =
        let Td956 : FLOAT =
          let Td955 : FLOAT =
            let Td954 : FLOAT =
              float 0.05
            in
            fmul w1 Td954
          in
          app
            floor
            Td955
        in
        let Td957 : FLOAT =
          float 20.
        in
        fmul Td956 Td957
      in
      let Td958 : FLOAT =
        fsub w1 d1
      in
      let Td959 : FLOAT =
        float 10.
      in
      app
        fless
        Td958
        Td959
    in
    let w3 : FLOAT =
      let Td961 : FLOAT =
        let Ti960 : INT =
          int 2
        in
        p.(Ti960)
      in
      let Td962 : FLOAT =
        app
          o_param_z
          m
      in
      fsub Td961 Td962
    in
    let flag2 : BOOL =
      let d2 : FLOAT =
        let Td965 : FLOAT =
          let Td964 : FLOAT =
            let Td963 : FLOAT =
              float 0.05
            in
            fmul w3 Td963
          in
          app
            floor
            Td964
        in
        let Td966 : FLOAT =
          float 20.
        in
        fmul Td965 Td966
      in
      let Td967 : FLOAT =
        fsub w3 d2
      in
      let Td968 : FLOAT =
        float 10.
      in
      app
        fless
        Td967
        Td968
    in
    let Ti969 : INT =
      int 1
    in
    let Td973 : FLOAT =
      let Ti970 : INT =
        int 0
      in
      if flag1 == Ti970
        let Ti971 : INT =
          int 0
        in
        if flag2 == Ti971
          float 255.
          float 0.
        let Ti972 : INT =
          int 0
        in
        if flag2 == Ti972
          float 0.
          float 255.
    in
    texture_color.(Ti969) <- Td973
    let Ti974 : INT =
      int 2
    in
    if m_tex == Ti974
      let w2 : FLOAT =
        let Td979 : FLOAT =
          let Td978 : FLOAT =
            let Td976 : FLOAT =
              let Ti975 : INT =
                int 1
              in
              p.(Ti975)
            in
            let Td977 : FLOAT =
              float 0.25
            in
            fmul Td976 Td977
          in
          app
            sin
            Td978
        in
        app
          fsqr
          Td979
      in
      let Tu148 : UNIT =
        let Ti980 : INT =
          int 0
        in
        let Td982 : FLOAT =
          let Td981 : FLOAT =
            float 255.
          in
          fmul Td981 w2
        in
        texture_color.(Ti980) <- Td982
      in
      let Ti983 : INT =
        int 1
      in
      let Td987 : FLOAT =
        let Td984 : FLOAT =
          float 255.
        in
        let Td986 : FLOAT =
          let Td985 : FLOAT =
            float 1.
          in
          fsub Td985 w2
        in
        fmul Td984 Td986
      in
      texture_color.(Ti983) <- Td987
      let Ti988 : INT =
        int 3
      in
      if m_tex == Ti988
        let w1 : FLOAT =
          let Td990 : FLOAT =
            let Ti989 : INT =
              int 0
            in
            p.(Ti989)
          in
          let Td991 : FLOAT =
            app
              o_param_x
              m
          in
          fsub Td990 Td991
        in
        let w3 : FLOAT =
          let Td993 : FLOAT =
            let Ti992 : INT =
              int 2
            in
            p.(Ti992)
          in
          let Td994 : FLOAT =
            app
              o_param_z
              m
          in
          fsub Td993 Td994
        in
        let w2 : FLOAT =
          let Td998 : FLOAT =
            let Td997 : FLOAT =
              let Td995 : FLOAT =
                app
                  fsqr
                  w1
              in
              let Td996 : FLOAT =
                app
                  fsqr
                  w3
              in
              fadd Td995 Td996
            in
            app
              sqrt
              Td997
          in
          let Td999 : FLOAT =
            float 10.
          in
          fdiv Td998 Td999
        in
        let w4 : FLOAT =
          let Td1001 : FLOAT =
            let Td1000 : FLOAT =
              app
                floor
                w2
            in
            fsub w2 Td1000
          in
          let Td1002 : FLOAT =
            float 3.1415927
          in
          fmul Td1001 Td1002
        in
        let cws : FLOAT =
          let Td1003 : FLOAT =
            app
              cos
              w4
          in
          app
            fsqr
            Td1003
        in
        let Tu149 : UNIT =
          let Ti1004 : INT =
            int 1
          in
          let Td1006 : FLOAT =
            let Td1005 : FLOAT =
              float 255.
            in
            fmul cws Td1005
          in
          texture_color.(Ti1004) <- Td1006
        in
        let Ti1007 : INT =
          int 2
        in
        let Td1011 : FLOAT =
          let Td1009 : FLOAT =
            let Td1008 : FLOAT =
              float 1.
            in
            fsub Td1008 cws
          in
          let Td1010 : FLOAT =
            float 255.
          in
          fmul Td1009 Td1010
        in
        texture_color.(Ti1007) <- Td1011
        let Ti1012 : INT =
          int 4
        in
        if m_tex == Ti1012
          let w1 : FLOAT =
            let Td1016 : FLOAT =
              let Td1014 : FLOAT =
                let Ti1013 : INT =
                  int 0
                in
                p.(Ti1013)
              in
              let Td1015 : FLOAT =
                app
                  o_param_x
                  m
              in
              fsub Td1014 Td1015
            in
            let Td1018 : FLOAT =
              let Td1017 : FLOAT =
                app
                  o_param_a
                  m
              in
              app
                sqrt
                Td1017
            in
            fmul Td1016 Td1018
          in
          let w3 : FLOAT =
            let Td1022 : FLOAT =
              let Td1020 : FLOAT =
                let Ti1019 : INT =
                  int 2
                in
                p.(Ti1019)
              in
              let Td1021 : FLOAT =
                app
                  o_param_z
                  m
              in
              fsub Td1020 Td1021
            in
            let Td1024 : FLOAT =
              let Td1023 : FLOAT =
                app
                  o_param_c
                  m
              in
              app
                sqrt
                Td1023
            in
            fmul Td1022 Td1024
          in
          let w4 : FLOAT =
            let Td1025 : FLOAT =
              app
                fsqr
                w1
            in
            let Td1026 : FLOAT =
              app
                fsqr
                w3
            in
            fadd Td1025 Td1026
          in
          let w7 : FLOAT =
            let Tb1029 : BOOL =
              let Td1027 : FLOAT =
                app
                  fabs
                  w1
              in
              let Td1028 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1027
                Td1028
            in
            let Ti1030 : INT =
              int 0
            in
            if Tb1029 == Ti1030
              let w5 : FLOAT =
                let Td1031 : FLOAT =
                  fdiv w3 w1
                in
                app
                  fabs
                  Td1031
              in
              let Td1034 : FLOAT =
                let Td1032 : FLOAT =
                  app
                    atan
                    w5
                in
                let Td1033 : FLOAT =
                  float 30.
                in
                fmul Td1032 Td1033
              in
              let Td1035 : FLOAT =
                float 3.1415927
              in
              fdiv Td1034 Td1035
              float 15.
          in
          let w9 : FLOAT =
            let Td1036 : FLOAT =
              app
                floor
                w7
            in
            fsub w7 Td1036
          in
          let w2 : FLOAT =
            let Td1040 : FLOAT =
              let Td1038 : FLOAT =
                let Ti1037 : INT =
                  int 1
                in
                p.(Ti1037)
              in
              let Td1039 : FLOAT =
                app
                  o_param_y
                  m
              in
              fsub Td1038 Td1039
            in
            let Td1042 : FLOAT =
              let Td1041 : FLOAT =
                app
                  o_param_b
                  m
              in
              app
                sqrt
                Td1041
            in
            fmul Td1040 Td1042
          in
          let w8 : FLOAT =
            let Tb1045 : BOOL =
              let Td1043 : FLOAT =
                app
                  fabs
                  w4
              in
              let Td1044 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1043
                Td1044
            in
            let Ti1046 : INT =
              int 0
            in
            if Tb1045 == Ti1046
              let w6 : FLOAT =
                let Td1047 : FLOAT =
                  fdiv w2 w4
                in
                app
                  fabs
                  Td1047
              in
              let Td1050 : FLOAT =
                let Td1048 : FLOAT =
                  app
                    atan
                    w6
                in
                let Td1049 : FLOAT =
                  float 30.
                in
                fmul Td1048 Td1049
              in
              let Td1051 : FLOAT =
                float 3.1415927
              in
              fdiv Td1050 Td1051
              float 15.
          in
          let w10 : FLOAT =
            let Td1052 : FLOAT =
              app
                floor
                w8
            in
            fsub w8 Td1052
          in
          let w11 : FLOAT =
            let Td1057 : FLOAT =
              let Td1053 : FLOAT =
                float 0.15
              in
              let Td1056 : FLOAT =
                let Td1055 : FLOAT =
                  let Td1054 : FLOAT =
                    float 0.5
                  in
                  fsub Td1054 w9
                in
                app
                  fsqr
                  Td1055
              in
              fsub Td1053 Td1056
            in
            let Td1060 : FLOAT =
              let Td1059 : FLOAT =
                let Td1058 : FLOAT =
                  float 0.5
                in
                fsub Td1058 w10
              in
              app
                fsqr
                Td1059
            in
            fsub Td1057 Td1060
          in
          let w12 : FLOAT =
            let Tb1061 : BOOL =
              app
                fisneg
                w11
            in
            let Ti1062 : INT =
              int 0
            in
            if Tb1061 == Ti1062
              w11
              float 0.
          in
          let Ti1063 : INT =
            int 2
          in
          let Td1067 : FLOAT =
            let Td1065 : FLOAT =
              let Td1064 : FLOAT =
                float 255.
              in
              fmul Td1064 w12
            in
            let Td1066 : FLOAT =
              float 0.3
            in
            fdiv Td1065 Td1066
          in
          texture_color.(Ti1063) <- Td1067
          unit ()
in
letrec add_light : (FLOAT -> (FLOAT -> (FLOAT -> UNIT))) =
variables : (bright : FLOAT), (hilight : FLOAT), (hilight_scale : FLOAT)
  let Tu155 : UNIT =
    let Tb926 : BOOL =
      app
        fispos
        bright
    in
    let Ti927 : INT =
      int 0
    in
    if Tb926 == Ti927
      unit ()
      app
        vecaccum
        rgb
        bright
        texture_color
  in
  let Tb928 : BOOL =
    app
      fispos
      hilight
  in
  let Ti929 : INT =
    int 0
  in
  if Tb928 == Ti929
    unit ()
    let ihl : FLOAT =
      let Td931 : FLOAT =
        let Td930 : FLOAT =
          app
            fsqr
            hilight
        in
        app
          fsqr
          Td930
      in
      fmul Td931 hilight_scale
    in
    let Tu154 : UNIT =
      let Ti932 : INT =
        int 0
      in
      let Td935 : FLOAT =
        let Td934 : FLOAT =
          let Ti933 : INT =
            int 0
          in
          rgb.(Ti933)
        in
        fadd Td934 ihl
      in
      rgb.(Ti932) <- Td935
    in
    let Tu153 : UNIT =
      let Ti936 : INT =
        int 1
      in
      let Td939 : FLOAT =
        let Td938 : FLOAT =
          let Ti937 : INT =
            int 1
          in
          rgb.(Ti937)
        in
        fadd Td938 ihl
      in
      rgb.(Ti936) <- Td939
    in
    let Ti940 : INT =
      int 2
    in
    let Td943 : FLOAT =
      let Td942 : FLOAT =
        let Ti941 : INT =
          int 2
        in
        rgb.(Ti941)
      in
      fadd Td942 ihl
    in
    rgb.(Ti940) <- Td943
in
letrec trace_reflections : (INT -> (FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT)))) =
variables : (index : INT), (diffuse : FLOAT), (hilight_scale : FLOAT), (dirvec : Array of FLOAT)
  let Ti906 : INT =
    int 0
  in
  if Ti906 <= index
    let rinfo : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
      reflections.(index)
    in
    let dvec : (Array of FLOAT * Array of Array of FLOAT) =
      app
        r_dvec
        rinfo
    in
    let Tu156 : UNIT =
      let Tb907 : BOOL =
        app
          judge_intersection_fast
          dvec
      in
      let Ti908 : INT =
        int 0
      in
      if Tb907 == Ti908
        unit ()
        let surface_id : INT =
          let Ti911 : INT =
            let Ti910 : INT =
              let Ti909 : INT =
                int 0
              in
              intersected_object_id.(Ti909)
            in
            mul Ti910 4
          in
          let Ti913 : INT =
            let Ti912 : INT =
              int 0
            in
            intsec_rectside.(Ti912)
          in
          add Ti911 Ti913
        in
        let Ti914 : INT =
          app
            r_surface_id
            rinfo
        in
        if surface_id == Ti914
          let Tb918 : BOOL =
            let Ti915 : INT =
              int 0
            in
            let Ta917 : Array of Array of INT =
              let Ti916 : INT =
                int 0
              in
              or_net.(Ti916)
            in
            app
              shadow_check_one_or_matrix
              Ti915
              Ta917
          in
          let Ti919 : INT =
            int 0
          in
          if Tb918 == Ti919
            let p : FLOAT =
              let Ta920 : Array of FLOAT =
                app
                  d_vec
                  dvec
              in
              app
                veciprod
                nvector
                Ta920
            in
            let scale : FLOAT =
              app
                r_bright
                rinfo
            in
            let bright : FLOAT =
              let Td921 : FLOAT =
                fmul scale diffuse
              in
              fmul Td921 p
            in
            let hilight : FLOAT =
              let Td923 : FLOAT =
                let Ta922 : Array of FLOAT =
                  app
                    d_vec
                    dvec
                in
                app
                  veciprod
                  dirvec
                  Ta922
              in
              fmul scale Td923
            in
            app
              add_light
              bright
              hilight
              hilight_scale
            unit ()
          unit ()
    in
    let Ti925 : INT =
      let Ti924 : INT =
        int 1
      in
      sub index Ti924
    in
    app
      trace_reflections
      Ti925
      diffuse
      hilight_scale
      dirvec
    unit ()
in
letrec trace_ray : (INT -> (FLOAT -> (Array of FLOAT -> ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (FLOAT -> UNIT))))) =
variables : (nref : INT), (energy : FLOAT), (dirvec : Array of FLOAT), (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (dist : FLOAT)
  let Ti828 : INT =
    int 4
  in
  if nref <= Ti828
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Tb829 : BOOL =
      app
        judge_intersection
        dirvec
    in
    let Ti830 : INT =
      int 0
    in
    if Tb829 == Ti830
      let Tu173 : UNIT =
        let Ti832 : INT =
          let Ti831 : INT =
            int 1
          in
          neg Ti831
        in
        surface_ids.(nref) <- Ti832
      in
      let Ti833 : INT =
        int 0
      in
      if nref == Ti833
        unit ()
        let hl : FLOAT =
          let Td834 : FLOAT =
            app
              veciprod
              dirvec
              light
          in
          app
            fneg
            Td834
        in
        let Tb835 : BOOL =
          app
            fispos
            hl
        in
        let Ti836 : INT =
          int 0
        in
        if Tb835 == Ti836
          unit ()
          let ihl : FLOAT =
            let Td839 : FLOAT =
              let Td838 : FLOAT =
                let Td837 : FLOAT =
                  app
                    fsqr
                    hl
                in
                fmul Td837 hl
              in
              fmul Td838 energy
            in
            let Td841 : FLOAT =
              let Ti840 : INT =
                int 0
              in
              beam.(Ti840)
            in
            fmul Td839 Td841
          in
          let Tu172 : UNIT =
            let Ti842 : INT =
              int 0
            in
            let Td845 : FLOAT =
              let Td844 : FLOAT =
                let Ti843 : INT =
                  int 0
                in
                rgb.(Ti843)
              in
              fadd Td844 ihl
            in
            rgb.(Ti842) <- Td845
          in
          let Tu171 : UNIT =
            let Ti846 : INT =
              int 1
            in
            let Td849 : FLOAT =
              let Td848 : FLOAT =
                let Ti847 : INT =
                  int 1
                in
                rgb.(Ti847)
              in
              fadd Td848 ihl
            in
            rgb.(Ti846) <- Td849
          in
          let Ti850 : INT =
            int 2
          in
          let Td853 : FLOAT =
            let Td852 : FLOAT =
              let Ti851 : INT =
                int 2
              in
              rgb.(Ti851)
            in
            fadd Td852 ihl
          in
          rgb.(Ti850) <- Td853
      let obj_id : INT =
        let Ti854 : INT =
          int 0
        in
        intersected_object_id.(Ti854)
      in
      let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(obj_id)
      in
      let m_surface : INT =
        app
          o_reflectiontype
          obj
      in
      let diffuse : FLOAT =
        let Td855 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td855 energy
      in
      let Tu170 : UNIT =
        app
          get_nvector
          obj
          dirvec
      in
      let Tu169 : UNIT =
        app
          veccpy
          startp
          intersection_point
      in
      let Tu168 : UNIT =
        app
          utexture
          obj
          intersection_point
      in
      let Tu167 : UNIT =
        let Ti859 : INT =
          let Ti856 : INT =
            mul obj_id 4
          in
          let Ti858 : INT =
            let Ti857 : INT =
              int 0
            in
            intsec_rectside.(Ti857)
          in
          add Ti856 Ti858
        in
        surface_ids.(nref) <- Ti859
      in
      let intersection_points : Array of Array of FLOAT =
        app
          p_intersection_points
          pixel
      in
      let Tu166 : UNIT =
        let Ta860 : Array of FLOAT =
          intersection_points.(nref)
        in
        app
          veccpy
          Ta860
          intersection_point
      in
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu165 : UNIT =
        let Tb863 : BOOL =
          let Td861 : FLOAT =
            app
              o_diffuse
              obj
          in
          let Td862 : FLOAT =
            float 0.5
          in
          app
            fless
            Td861
            Td862
        in
        let Ti864 : INT =
          int 0
        in
        if Tb863 == Ti864
          let Tu159 : UNIT =
            let Ti865 : INT =
              int 1
            in
            calc_diffuse.(nref) <- Ti865
          in
          let energya : Array of Array of FLOAT =
            app
              p_energy
              pixel
          in
          let Tu158 : UNIT =
            let Ta866 : Array of FLOAT =
              energya.(nref)
            in
            app
              veccpy
              Ta866
              texture_color
          in
          let Tu157 : UNIT =
            let Ta867 : Array of FLOAT =
              energya.(nref)
            in
            let Td871 : FLOAT =
              let Td870 : FLOAT =
                let Td868 : FLOAT =
                  float 1.
                in
                let Td869 : FLOAT =
                  float 256.
                in
                fdiv Td868 Td869
              in
              fmul Td870 diffuse
            in
            app
              vecscale
              Ta867
              Td871
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let Ta872 : Array of FLOAT =
            nvectors.(nref)
          in
          app
            veccpy
            Ta872
            nvector
          let Ti873 : INT =
            int 0
          in
          calc_diffuse.(nref) <- Ti873
      in
      let w : FLOAT =
        let Td874 : FLOAT =
          float -2.
        in
        let Td875 : FLOAT =
          app
            veciprod
            dirvec
            nvector
        in
        fmul Td874 Td875
      in
      let Tu164 : UNIT =
        app
          vecaccum
          dirvec
          w
          nvector
      in
      let hilight_scale : FLOAT =
        let Td876 : FLOAT =
          app
            o_hilight
            obj
        in
        fmul energy Td876
      in
      let Tu163 : UNIT =
        let Tb880 : BOOL =
          let Ti877 : INT =
            int 0
          in
          let Ta879 : Array of Array of INT =
            let Ti878 : INT =
              int 0
            in
            or_net.(Ti878)
          in
          app
            shadow_check_one_or_matrix
            Ti877
            Ta879
        in
        let Ti881 : INT =
          int 0
        in
        if Tb880 == Ti881
          let bright : FLOAT =
            let Td883 : FLOAT =
              let Td882 : FLOAT =
                app
                  veciprod
                  nvector
                  light
              in
              app
                fneg
                Td882
            in
            fmul Td883 diffuse
          in
          let hilight : FLOAT =
            let Td884 : FLOAT =
              app
                veciprod
                dirvec
                light
            in
            app
              fneg
              Td884
          in
          app
            add_light
            bright
            hilight
            hilight_scale
          unit ()
      in
      let Tu162 : UNIT =
        app
          setup_startp
          intersection_point
      in
      let Tu161 : UNIT =
        let Ti888 : INT =
          let Ti886 : INT =
            let Ti885 : INT =
              int 0
            in
            n_reflections.(Ti885)
          in
          let Ti887 : INT =
            int 1
          in
          sub Ti886 Ti887
        in
        app
          trace_reflections
          Ti888
          diffuse
          hilight_scale
          dirvec
      in
      let Tb890 : BOOL =
        let Td889 : FLOAT =
          float 0.1
        in
        app
          fless
          Td889
          energy
      in
      let Ti891 : INT =
        int 0
      in
      if Tb890 == Ti891
        unit ()
        let Tu160 : UNIT =
          let Ti892 : INT =
            int 4
          in
          if Ti892 <= nref
            unit ()
            let Ti894 : INT =
              let Ti893 : INT =
                int 1
              in
              add nref Ti893
            in
            let Ti896 : INT =
              let Ti895 : INT =
                int 1
              in
              neg Ti895
            in
            surface_ids.(Ti894) <- Ti896
        in
        let Ti897 : INT =
          int 2
        in
        if m_surface == Ti897
          let energy2 : FLOAT =
            let Td900 : FLOAT =
              let Td898 : FLOAT =
                float 1.
              in
              let Td899 : FLOAT =
                app
                  o_diffuse
                  obj
              in
              fsub Td898 Td899
            in
            fmul energy Td900
          in
          let Ti902 : INT =
            let Ti901 : INT =
              int 1
            in
            add nref Ti901
          in
          let Td905 : FLOAT =
            let Td904 : FLOAT =
              let Ti903 : INT =
                int 0
              in
              tmin.(Ti903)
            in
            fadd dist Td904
          in
          app
            trace_ray
            Ti902
            energy2
            dirvec
            pixel
            Td905
          unit ()
    unit ()
in
letrec trace_diffuse_ray : ((Array of FLOAT * Array of Array of FLOAT) -> (FLOAT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (energy : FLOAT)
  let Tb812 : BOOL =
    app
      judge_intersection_fast
      dirvec
  in
  let Ti813 : INT =
    int 0
  in
  if Tb812 == Ti813
    unit ()
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      let Ti815 : INT =
        let Ti814 : INT =
          int 0
        in
        intersected_object_id.(Ti814)
      in
      objects.(Ti815)
    in
    let Tu175 : UNIT =
      let Ta816 : Array of FLOAT =
        app
          d_vec
          dirvec
      in
      app
        get_nvector
        obj
        Ta816
    in
    let Tu174 : UNIT =
      app
        utexture
        obj
        intersection_point
    in
    let Tb820 : BOOL =
      let Ti817 : INT =
        int 0
      in
      let Ta819 : Array of Array of INT =
        let Ti818 : INT =
          int 0
        in
        or_net.(Ti818)
      in
      app
        shadow_check_one_or_matrix
        Ti817
        Ta819
    in
    let Ti821 : INT =
      int 0
    in
    if Tb820 == Ti821
      let br : FLOAT =
        let Td822 : FLOAT =
          app
            veciprod
            nvector
            light
        in
        app
          fneg
          Td822
      in
      let bright : FLOAT =
        let Tb823 : BOOL =
          app
            fispos
            br
        in
        let Ti824 : INT =
          int 0
        in
        if Tb823 == Ti824
          float 0.
          br
      in
      let Td827 : FLOAT =
        let Td825 : FLOAT =
          fmul energy bright
        in
        let Td826 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td825 Td826
      in
      app
        vecaccum
        diffuse_ray
        Td827
        texture_color
      unit ()
in
letrec iter_trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (INT -> UNIT)))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT), (index : INT)
  let Ti797 : INT =
    int 0
  in
  if Ti797 <= index
    let p : FLOAT =
      let Ta799 : Array of FLOAT =
        let Tt798 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        app
          d_vec
          Tt798
      in
      app
        veciprod
        Ta799
        nvector
    in
    let Tu176 : UNIT =
      let Tb800 : BOOL =
        app
          fisneg
          p
      in
      let Ti801 : INT =
        int 0
      in
      if Tb800 == Ti801
        let Tt802 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        let Td804 : FLOAT =
          let Td803 : FLOAT =
            float 150.
          in
          fdiv p Td803
        in
        app
          trace_diffuse_ray
          Tt802
          Td804
        let Tt807 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti806 : INT =
            let Ti805 : INT =
              int 1
            in
            add index Ti805
          in
          dirvec_group.(Ti806)
        in
        let Td809 : FLOAT =
          let Td808 : FLOAT =
            float -150.
          in
          fdiv p Td808
        in
        app
          trace_diffuse_ray
          Tt807
          Td809
    in
    let Ti811 : INT =
      let Ti810 : INT =
        int 2
      in
      sub index Ti810
    in
    app
      iter_trace_diffuse_rays
      dirvec_group
      nvector
      org
      Ti811
    unit ()
in
letrec trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu177 : UNIT =
    app
      setup_startp
      org
  in
  let Ti796 : INT =
    int 118
  in
  app
    iter_trace_diffuse_rays
    dirvec_group
    nvector
    org
    Ti796
in
letrec trace_diffuse_ray_80percent : (INT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (group_id : INT), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu181 : UNIT =
    let Ti781 : INT =
      int 0
    in
    if group_id == Ti781
      unit ()
      let Ta783 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti782 : INT =
          int 0
        in
        dirvecs.(Ti782)
      in
      app
        trace_diffuse_rays
        Ta783
        nvector
        org
  in
  let Tu180 : UNIT =
    let Ti784 : INT =
      int 1
    in
    if group_id == Ti784
      unit ()
      let Ta786 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti785 : INT =
          int 1
        in
        dirvecs.(Ti785)
      in
      app
        trace_diffuse_rays
        Ta786
        nvector
        org
  in
  let Tu179 : UNIT =
    let Ti787 : INT =
      int 2
    in
    if group_id == Ti787
      unit ()
      let Ta789 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti788 : INT =
          int 2
        in
        dirvecs.(Ti788)
      in
      app
        trace_diffuse_rays
        Ta789
        nvector
        org
  in
  let Tu178 : UNIT =
    let Ti790 : INT =
      int 3
    in
    if group_id == Ti790
      unit ()
      let Ta792 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti791 : INT =
          int 3
        in
        dirvecs.(Ti791)
      in
      app
        trace_diffuse_rays
        Ta792
        nvector
        org
  in
  let Ti793 : INT =
    int 4
  in
  if group_id == Ti793
    unit ()
    let Ta795 : Array of (Array of FLOAT * Array of Array of FLOAT) =
      let Ti794 : INT =
        int 4
      in
      dirvecs.(Ti794)
    in
    app
      trace_diffuse_rays
      Ta795
      nvector
      org
in
letrec calc_diffuse_using_1point : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let ray20p : Array of Array of FLOAT =
    app
      p_received_ray_20percent
      pixel
  in
  let nvectors : Array of Array of FLOAT =
    app
      p_nvectors
      pixel
  in
  let intersection_points : Array of Array of FLOAT =
    app
      p_intersection_points
      pixel
  in
  let energya : Array of Array of FLOAT =
    app
      p_energy
      pixel
  in
  let Tu183 : UNIT =
    let Ta776 : Array of FLOAT =
      ray20p.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta776
  in
  let Tu182 : UNIT =
    let Ti777 : INT =
      app
        p_group_id
        pixel
    in
    let Ta778 : Array of FLOAT =
      nvectors.(nref)
    in
    let Ta779 : Array of FLOAT =
      intersection_points.(nref)
    in
    app
      trace_diffuse_ray_80percent
      Ti777
      Ta778
      Ta779
  in
  let Ta780 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta780
    diffuse_ray
in
letrec calc_diffuse_using_5points : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let r_up : Array of Array of FLOAT =
    let Tt760 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      p_received_ray_20percent
      Tt760
  in
  let r_left : Array of Array of FLOAT =
    let Tt763 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti762 : INT =
        let Ti761 : INT =
          int 1
        in
        sub x Ti761
      in
      cur.(Ti762)
    in
    app
      p_received_ray_20percent
      Tt763
  in
  let r_center : Array of Array of FLOAT =
    let Tt764 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_received_ray_20percent
      Tt764
  in
  let r_right : Array of Array of FLOAT =
    let Tt767 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti766 : INT =
        let Ti765 : INT =
          int 1
        in
        add x Ti765
      in
      cur.(Ti766)
    in
    app
      p_received_ray_20percent
      Tt767
  in
  let r_down : Array of Array of FLOAT =
    let Tt768 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      next.(x)
    in
    app
      p_received_ray_20percent
      Tt768
  in
  let Tu188 : UNIT =
    let Ta769 : Array of FLOAT =
      r_up.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta769
  in
  let Tu187 : UNIT =
    let Ta770 : Array of FLOAT =
      r_left.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta770
  in
  let Tu186 : UNIT =
    let Ta771 : Array of FLOAT =
      r_center.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta771
  in
  let Tu185 : UNIT =
    let Ta772 : Array of FLOAT =
      r_right.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta772
  in
  let Tu184 : UNIT =
    let Ta773 : Array of FLOAT =
      r_down.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta773
  in
  let energya : Array of Array of FLOAT =
    let Tt774 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_energy
      Tt774
  in
  let Ta775 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta775
    diffuse_ray
in
letrec do_without_neighbors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti753 : INT =
    int 4
  in
  if nref <= Ti753
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Ti754 : INT =
      int 0
    in
    let Ti755 : INT =
      surface_ids.(nref)
    in
    if Ti754 <= Ti755
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu189 : UNIT =
        let Tb756 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti757 : INT =
          int 0
        in
        if Tb756 == Ti757
          unit ()
          app
            calc_diffuse_using_1point
            pixel
            nref
      in
      let Ti759 : INT =
        let Ti758 : INT =
          int 1
        in
        add nref Ti758
      in
      app
        do_without_neighbors
        pixel
        Ti759
      unit ()
    unit ()
in
letrec neighbors_exist : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> BOOL))) =
variables : (x : INT), (y : INT), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti744 : INT =
    let Ti743 : INT =
      int 1
    in
    image_size.(Ti743)
  in
  let Ti746 : INT =
    let Ti745 : INT =
      int 1
    in
    add y Ti745
  in
  if Ti744 <= Ti746
    int 0
    let Ti747 : INT =
      int 0
    in
    if y <= Ti747
      int 0
      let Ti749 : INT =
        let Ti748 : INT =
          int 0
        in
        image_size.(Ti748)
      in
      let Ti751 : INT =
        let Ti750 : INT =
          int 1
        in
        add x Ti750
      in
      if Ti749 <= Ti751
        int 0
        let Ti752 : INT =
          int 0
        in
        if x <= Ti752
          int 0
          int 1
in
letrec get_surface_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> INT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (index : INT)
  let surface_ids : Array of INT =
    app
      p_surface_ids
      pixel
  in
  surface_ids.(index)
in
letrec neighbors_are_available : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> BOOL))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let sid_center : INT =
    let Tt730 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      get_surface_id
      Tt730
      nref
  in
  let Ti732 : INT =
    let Tt731 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      get_surface_id
      Tt731
      nref
  in
  if Ti732 == sid_center
    let Ti734 : INT =
      let Tt733 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        next.(x)
      in
      app
        get_surface_id
        Tt733
        nref
    in
    if Ti734 == sid_center
      let Ti738 : INT =
        let Tt737 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          let Ti736 : INT =
            let Ti735 : INT =
              int 1
            in
            sub x Ti735
          in
          cur.(Ti736)
        in
        app
          get_surface_id
          Tt737
          nref
      in
      if Ti738 == sid_center
        let Ti742 : INT =
          let Tt741 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
            let Ti740 : INT =
              let Ti739 : INT =
                int 1
              in
              add x Ti739
            in
            cur.(Ti740)
          in
          app
            get_surface_id
            Tt741
            nref
        in
        if Ti742 == sid_center
          int 1
          int 0
        int 0
      int 0
    int 0
in
letrec try_exploit_neighbors : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    cur.(x)
  in
  let Ti720 : INT =
    int 4
  in
  if nref <= Ti720
    let Ti721 : INT =
      int 0
    in
    let Ti722 : INT =
      app
        get_surface_id
        pixel
        nref
    in
    if Ti721 <= Ti722
      let Tb723 : BOOL =
        app
          neighbors_are_available
          x
          prev
          cur
          next
          nref
      in
      let Ti724 : INT =
        int 0
      in
      if Tb723 == Ti724
        let Tt725 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          do_without_neighbors
          Tt725
          nref
        let calc_diffuse : Array of BOOL =
          app
            p_calc_diffuse
            pixel
        in
        let Tu190 : UNIT =
          let Tb726 : BOOL =
            calc_diffuse.(nref)
          in
          let Ti727 : INT =
            int 0
          in
          if Tb726 == Ti727
            unit ()
            app
              calc_diffuse_using_5points
              x
              prev
              cur
              next
              nref
        in
        let Ti729 : INT =
          let Ti728 : INT =
            int 1
          in
          add nref Ti728
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti729
      unit ()
    unit ()
in
letrec write_ppm_header : (UNIT -> UNIT) =
variables : (Tu191 : UNIT)
  let Tu199 : UNIT =
    let Ti707 : INT =
      int 80
    in
    out Ti707 0
  in
  let Tu198 : UNIT =
    let Ti710 : INT =
      let Ti708 : INT =
        int 48
      in
      let Ti709 : INT =
        int 6
      in
      add Ti708 Ti709
    in
    out Ti710 0
  in
  let Tu197 : UNIT =
    let Ti711 : INT =
      int 10
    in
    out Ti711 0
  in
  let Tu196 : UNIT =
    let Ti713 : INT =
      let Ti712 : INT =
        int 0
      in
      image_size.(Ti712)
    in
    app
      print_int
      Ti713
  in
  let Tu195 : UNIT =
    let Ti714 : INT =
      int 32
    in
    out Ti714 0
  in
  let Tu194 : UNIT =
    let Ti716 : INT =
      let Ti715 : INT =
        int 1
      in
      image_size.(Ti715)
    in
    app
      print_int
      Ti716
  in
  let Tu193 : UNIT =
    let Ti717 : INT =
      int 32
    in
    out Ti717 0
  in
  let Tu192 : UNIT =
    let Ti718 : INT =
      int 255
    in
    app
      print_int
      Ti718
  in
  let Ti719 : INT =
    int 10
  in
  out Ti719 0
in
letrec write_rgb_element : (FLOAT -> UNIT) =
variables : (x : FLOAT)
  let ix : INT =
    ftoi x
  in
  let elem : INT =
    let Ti705 : INT =
      int 255
    in
    if ix <= Ti705
      let Ti706 : INT =
        int 0
      in
      if Ti706 <= ix
        ix
        int 0
      int 255
  in
  out elem 0
in
letrec write_rgb : (UNIT -> UNIT) =
variables : (Tu200 : UNIT)
  let Tu202 : UNIT =
    let Td700 : FLOAT =
      let Ti699 : INT =
        int 0
      in
      rgb.(Ti699)
    in
    app
      write_rgb_element
      Td700
  in
  let Tu201 : UNIT =
    let Td702 : FLOAT =
      let Ti701 : INT =
        int 1
      in
      rgb.(Ti701)
    in
    app
      write_rgb_element
      Td702
  in
  let Td704 : FLOAT =
    let Ti703 : INT =
      int 2
    in
    rgb.(Ti703)
  in
  app
    write_rgb_element
    Td704
in
letrec pretrace_diffuse_rays : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti689 : INT =
    int 4
  in
  if nref <= Ti689
    let sid : INT =
      app
        get_surface_id
        pixel
        nref
    in
    let Ti690 : INT =
      int 0
    in
    if Ti690 <= sid
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu205 : UNIT =
        let Tb691 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti692 : INT =
          int 0
        in
        if Tb691 == Ti692
          unit ()
          let group_id : INT =
            app
              p_group_id
              pixel
          in
          let Tu204 : UNIT =
            app
              vecbzero
              diffuse_ray
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let intersection_points : Array of Array of FLOAT =
            app
              p_intersection_points
              pixel
          in
          let Tu203 : UNIT =
            let Ta693 : Array of (Array of FLOAT * Array of Array of FLOAT) =
              dirvecs.(group_id)
            in
            let Ta694 : Array of FLOAT =
              nvectors.(nref)
            in
            let Ta695 : Array of FLOAT =
              intersection_points.(nref)
            in
            app
              trace_diffuse_rays
              Ta693
              Ta694
              Ta695
          in
          let ray20p : Array of Array of FLOAT =
            app
              p_received_ray_20percent
              pixel
          in
          let Ta696 : Array of FLOAT =
            ray20p.(nref)
          in
          app
            veccpy
            Ta696
            diffuse_ray
      in
      let Ti698 : INT =
        let Ti697 : INT =
          int 1
        in
        add nref Ti697
      in
      app
        pretrace_diffuse_rays
        pixel
        Ti698
      unit ()
    unit ()
in
letrec pretrace_pixels : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (x : INT), (group_id : INT), (lc0 : FLOAT), (lc1 : FLOAT), (lc2 : FLOAT)
  let Ti653 : INT =
    int 0
  in
  if Ti653 <= x
    let xdisp : FLOAT =
      let Td655 : FLOAT =
        let Ti654 : INT =
          int 0
        in
        scan_pitch.(Ti654)
      in
      let Td659 : FLOAT =
        let Ti658 : INT =
          let Ti657 : INT =
            let Ti656 : INT =
              int 0
            in
            image_center.(Ti656)
          in
          sub x Ti657
        in
        itof Ti658
      in
      fmul Td655 Td659
    in
    let Tu215 : UNIT =
      let Ti660 : INT =
        int 0
      in
      let Td664 : FLOAT =
        let Td663 : FLOAT =
          let Td662 : FLOAT =
            let Ti661 : INT =
              int 0
            in
            screenx_dir.(Ti661)
          in
          fmul xdisp Td662
        in
        fadd Td663 lc0
      in
      ptrace_dirvec.(Ti660) <- Td664
    in
    let Tu214 : UNIT =
      let Ti665 : INT =
        int 1
      in
      let Td669 : FLOAT =
        let Td668 : FLOAT =
          let Td667 : FLOAT =
            let Ti666 : INT =
              int 1
            in
            screenx_dir.(Ti666)
          in
          fmul xdisp Td667
        in
        fadd Td668 lc1
      in
      ptrace_dirvec.(Ti665) <- Td669
    in
    let Tu213 : UNIT =
      let Ti670 : INT =
        int 2
      in
      let Td674 : FLOAT =
        let Td673 : FLOAT =
          let Td672 : FLOAT =
            let Ti671 : INT =
              int 2
            in
            screenx_dir.(Ti671)
          in
          fmul xdisp Td672
        in
        fadd Td673 lc2
      in
      ptrace_dirvec.(Ti670) <- Td674
    in
    let Tu212 : UNIT =
      let Ti675 : INT =
        int 0
      in
      app
        vecunit_sgn
        ptrace_dirvec
        Ti675
    in
    let Tu211 : UNIT =
      app
        vecbzero
        rgb
    in
    let Tu210 : UNIT =
      app
        veccpy
        startp
        viewpoint
    in
    let Tu209 : UNIT =
      let Ti676 : INT =
        int 0
      in
      let Td677 : FLOAT =
        float 1.
      in
      let Tt678 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Td679 : FLOAT =
        float 0.
      in
      app
        trace_ray
        Ti676
        Td677
        ptrace_dirvec
        Tt678
        Td679
    in
    let Tu208 : UNIT =
      let Ta681 : Array of FLOAT =
        let Tt680 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          line.(x)
        in
        app
          p_rgb
          Tt680
      in
      app
        veccpy
        Ta681
        rgb
    in
    let Tu207 : UNIT =
      let Tt682 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      app
        p_set_group_id
        Tt682
        group_id
    in
    let Tu206 : UNIT =
      let Tt683 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Ti684 : INT =
        int 0
      in
      app
        pretrace_diffuse_rays
        Tt683
        Ti684
    in
    let Ti686 : INT =
      let Ti685 : INT =
        int 1
      in
      sub x Ti685
    in
    let Ti688 : INT =
      let Ti687 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti687
    in
    app
      pretrace_pixels
      line
      Ti686
      Ti688
      lc0
      lc1
      lc2
    unit ()
in
letrec pretrace_line : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> UNIT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (y : INT), (group_id : INT)
  let ydisp : FLOAT =
    let Td629 : FLOAT =
      let Ti628 : INT =
        int 0
      in
      scan_pitch.(Ti628)
    in
    let Td633 : FLOAT =
      let Ti632 : INT =
        let Ti631 : INT =
          let Ti630 : INT =
            int 1
          in
          image_center.(Ti630)
        in
        sub y Ti631
      in
      itof Ti632
    in
    fmul Td629 Td633
  in
  let lc0 : FLOAT =
    let Td636 : FLOAT =
      let Td635 : FLOAT =
        let Ti634 : INT =
          int 0
        in
        screeny_dir.(Ti634)
      in
      fmul ydisp Td635
    in
    let Td638 : FLOAT =
      let Ti637 : INT =
        int 0
      in
      screenz_dir.(Ti637)
    in
    fadd Td636 Td638
  in
  let lc1 : FLOAT =
    let Td641 : FLOAT =
      let Td640 : FLOAT =
        let Ti639 : INT =
          int 1
        in
        screeny_dir.(Ti639)
      in
      fmul ydisp Td640
    in
    let Td643 : FLOAT =
      let Ti642 : INT =
        int 1
      in
      screenz_dir.(Ti642)
    in
    fadd Td641 Td643
  in
  let lc2 : FLOAT =
    let Td646 : FLOAT =
      let Td645 : FLOAT =
        let Ti644 : INT =
          int 2
        in
        screeny_dir.(Ti644)
      in
      fmul ydisp Td645
    in
    let Td648 : FLOAT =
      let Ti647 : INT =
        int 2
      in
      screenz_dir.(Ti647)
    in
    fadd Td646 Td648
  in
  let Ti652 : INT =
    let Ti650 : INT =
      let Ti649 : INT =
        int 0
      in
      image_size.(Ti649)
    in
    let Ti651 : INT =
      int 1
    in
    sub Ti650 Ti651
  in
  app
    pretrace_pixels
    line
    Ti652
    group_id
    lc0
    lc1
    lc2
in
letrec scan_pixel : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> UNIT))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti617 : INT =
    let Ti616 : INT =
      int 0
    in
    image_size.(Ti616)
  in
  if Ti617 <= x
    unit ()
    let Tu218 : UNIT =
      let Ta619 : Array of FLOAT =
        let Tt618 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          p_rgb
          Tt618
      in
      app
        veccpy
        rgb
        Ta619
    in
    let Tu217 : UNIT =
      let Tb620 : BOOL =
        app
          neighbors_exist
          x
          y
          next
      in
      let Ti621 : INT =
        int 0
      in
      if Tb620 == Ti621
        let Tt622 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        let Ti623 : INT =
          int 0
        in
        app
          do_without_neighbors
          Tt622
          Ti623
        let Ti624 : INT =
          int 0
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti624
    in
    let Tu216 : UNIT =
      let Tu625 : UNIT =
        unit ()
      in
      app
        write_rgb
        Tu625
    in
    let Ti627 : INT =
      let Ti626 : INT =
        int 1
      in
      add x Ti626
    in
    app
      scan_pixel
      Ti627
      y
      prev
      cur
      next
in
letrec scan_line : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (group_id : INT)
  let Ti604 : INT =
    let Ti603 : INT =
      int 1
    in
    image_size.(Ti603)
  in
  if Ti604 <= y
    unit ()
    let Tu220 : UNIT =
      let Ti608 : INT =
        let Ti606 : INT =
          let Ti605 : INT =
            int 1
          in
          image_size.(Ti605)
        in
        let Ti607 : INT =
          int 1
        in
        sub Ti606 Ti607
      in
      if Ti608 <= y
        unit ()
        let Ti610 : INT =
          let Ti609 : INT =
            int 1
          in
          add y Ti609
        in
        app
          pretrace_line
          next
          Ti610
          group_id
    in
    let Tu219 : UNIT =
      let Ti611 : INT =
        int 0
      in
      app
        scan_pixel
        Ti611
        y
        prev
        cur
        next
    in
    let Ti613 : INT =
      let Ti612 : INT =
        int 1
      in
      add y Ti612
    in
    let Ti615 : INT =
      let Ti614 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti614
    in
    app
      scan_line
      Ti613
      cur
      next
      prev
      Ti615
in
letrec create_float5x3array : (UNIT -> Array of Array of FLOAT) =
variables : (Tu221 : UNIT)
  let vec : Array of FLOAT =
    let Ti584 : INT =
      int 3
    in
    let Td585 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti584
      Td585
  in
  let array : Array of Array of FLOAT =
    let Ti586 : INT =
      int 5
    in
    extfunapp
      create_array
      Ti586
      vec
  in
  let Tu225 : UNIT =
    let Ti587 : INT =
      int 1
    in
    let Ta590 : Array of FLOAT =
      let Ti588 : INT =
        int 3
      in
      let Td589 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti588
        Td589
    in
    array.(Ti587) <- Ta590
  in
  let Tu224 : UNIT =
    let Ti591 : INT =
      int 2
    in
    let Ta594 : Array of FLOAT =
      let Ti592 : INT =
        int 3
      in
      let Td593 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti592
        Td593
    in
    array.(Ti591) <- Ta594
  in
  let Tu223 : UNIT =
    let Ti595 : INT =
      int 3
    in
    let Ta598 : Array of FLOAT =
      let Ti596 : INT =
        int 3
      in
      let Td597 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti596
        Td597
    in
    array.(Ti595) <- Ta598
  in
  let Tu222 : UNIT =
    let Ti599 : INT =
      int 4
    in
    let Ta602 : Array of FLOAT =
      let Ti600 : INT =
        int 3
      in
      let Td601 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti600
        Td601
    in
    array.(Ti599) <- Ta602
  in
  array
in
letrec create_pixel : (UNIT -> (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu226 : UNIT)
  let m_rgb : Array of FLOAT =
    let Ti572 : INT =
      int 3
    in
    let Td573 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti572
      Td573
  in
  let m_isect_ps : Array of Array of FLOAT =
    let Tu574 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu574
  in
  let m_sids : Array of INT =
    let Ti575 : INT =
      int 5
    in
    let Ti576 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti575
      Ti576
  in
  let m_cdif : Array of BOOL =
    let Ti577 : INT =
      int 5
    in
    let Ti578 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti577
      Ti578
  in
  let m_engy : Array of Array of FLOAT =
    let Tu579 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu579
  in
  let m_r20p : Array of Array of FLOAT =
    let Tu580 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu580
  in
  let m_gid : Array of INT =
    let Ti581 : INT =
      int 1
    in
    let Ti582 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti581
      Ti582
  in
  let m_nvectors : Array of Array of FLOAT =
    let Tu583 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu583
  in
  Tuple
    m_rgb
    m_isect_ps
    m_sids
    m_cdif
    m_engy
    m_r20p
    m_gid
    m_nvectors
in
letrec init_line_elements : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (n : INT)
  let Ti567 : INT =
    int 0
  in
  if Ti567 <= n
    let Tu227 : UNIT =
      let Tt569 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        let Tu568 : UNIT =
          unit ()
        in
        app
          create_pixel
          Tu568
      in
      line.(n) <- Tt569
    in
    let Ti571 : INT =
      let Ti570 : INT =
        int 1
      in
      sub n Ti570
    in
    app
      init_line_elements
      line
      Ti571
    line
in
letrec create_pixelline : (UNIT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu228 : UNIT)
  let line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Ti560 : INT =
      let Ti559 : INT =
        int 0
      in
      image_size.(Ti559)
    in
    let Tt562 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Tu561 : UNIT =
        unit ()
      in
      app
        create_pixel
        Tu561
    in
    extfunapp
      create_array
      Ti560
      Tt562
  in
  let Ti566 : INT =
    let Ti564 : INT =
      let Ti563 : INT =
        int 0
      in
      image_size.(Ti563)
    in
    let Ti565 : INT =
      int 2
    in
    sub Ti564 Ti565
  in
  app
    init_line_elements
    line
    Ti566
in
letrec tan : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td557 : FLOAT =
    app
      sin
      x
  in
  let Td558 : FLOAT =
    app
      cos
      x
  in
  fdiv Td557 Td558
in
letrec adjust_position : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (h : FLOAT), (ratio : FLOAT)
  let l : FLOAT =
    let Td554 : FLOAT =
      let Td552 : FLOAT =
        fmul h h
      in
      let Td553 : FLOAT =
        float 0.1
      in
      fadd Td552 Td553
    in
    app
      sqrt
      Td554
  in
  let tan_h : FLOAT =
    let Td555 : FLOAT =
      float 1.
    in
    fdiv Td555 l
  in
  let theta_h : FLOAT =
    app
      atan
      tan_h
  in
  let tan_m : FLOAT =
    let Td556 : FLOAT =
      fmul theta_h ratio
    in
    app
      tan
      Td556
  in
  fmul tan_m l
in
letrec calc_dirvec : (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> UNIT))))))) =
variables : (icount : INT), (x : FLOAT), (y : FLOAT), (rx : FLOAT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti511 : INT =
    int 5
  in
  if Ti511 <= icount
    let l : FLOAT =
      let Td516 : FLOAT =
        let Td514 : FLOAT =
          let Td512 : FLOAT =
            app
              fsqr
              x
          in
          let Td513 : FLOAT =
            app
              fsqr
              y
          in
          fadd Td512 Td513
        in
        let Td515 : FLOAT =
          float 1.
        in
        fadd Td514 Td515
      in
      app
        sqrt
        Td516
    in
    let vx : FLOAT =
      fdiv x l
    in
    let vy : FLOAT =
      fdiv y l
    in
    let vz : FLOAT =
      let Td517 : FLOAT =
        float 1.
      in
      fdiv Td517 l
    in
    let dgroup : Array of (Array of FLOAT * Array of Array of FLOAT) =
      dirvecs.(group_id)
    in
    let Tu233 : UNIT =
      let Ta519 : Array of FLOAT =
        let Tt518 : (Array of FLOAT * Array of Array of FLOAT) =
          dgroup.(index)
        in
        app
          d_vec
          Tt518
      in
      app
        vecset
        Ta519
        vx
        vy
        vz
    in
    let Tu232 : UNIT =
      let Ta523 : Array of FLOAT =
        let Tt522 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti521 : INT =
            let Ti520 : INT =
              int 40
            in
            add index Ti520
          in
          dgroup.(Ti521)
        in
        app
          d_vec
          Tt522
      in
      let Td524 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta523
        vx
        vz
        Td524
    in
    let Tu231 : UNIT =
      let Ta528 : Array of FLOAT =
        let Tt527 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti526 : INT =
            let Ti525 : INT =
              int 80
            in
            add index Ti525
          in
          dgroup.(Ti526)
        in
        app
          d_vec
          Tt527
      in
      let Td529 : FLOAT =
        app
          fneg
          vx
      in
      let Td530 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta528
        vz
        Td529
        Td530
    in
    let Tu230 : UNIT =
      let Ta534 : Array of FLOAT =
        let Tt533 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti532 : INT =
            let Ti531 : INT =
              int 1
            in
            add index Ti531
          in
          dgroup.(Ti532)
        in
        app
          d_vec
          Tt533
      in
      let Td535 : FLOAT =
        app
          fneg
          vx
      in
      let Td536 : FLOAT =
        app
          fneg
          vy
      in
      let Td537 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta534
        Td535
        Td536
        Td537
    in
    let Tu229 : UNIT =
      let Ta541 : Array of FLOAT =
        let Tt540 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti539 : INT =
            let Ti538 : INT =
              int 41
            in
            add index Ti538
          in
          dgroup.(Ti539)
        in
        app
          d_vec
          Tt540
      in
      let Td542 : FLOAT =
        app
          fneg
          vx
      in
      let Td543 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta541
        Td542
        Td543
        vy
    in
    let Ta547 : Array of FLOAT =
      let Tt546 : (Array of FLOAT * Array of Array of FLOAT) =
        let Ti545 : INT =
          let Ti544 : INT =
            int 81
          in
          add index Ti544
        in
        dgroup.(Ti545)
      in
      app
        d_vec
        Tt546
    in
    let Td548 : FLOAT =
      app
        fneg
        vz
    in
    app
      vecset
      Ta547
      Td548
      vx
      vy
    let x2 : FLOAT =
      app
        adjust_position
        y
        rx
    in
    let Ti550 : INT =
      let Ti549 : INT =
        int 1
      in
      add icount Ti549
    in
    let Td551 : FLOAT =
      app
        adjust_position
        x2
        ry
    in
    app
      calc_dirvec
      Ti550
      x2
      Td551
      rx
      ry
      group_id
      index
in
letrec calc_dirvecs : (INT -> (FLOAT -> (INT -> (INT -> UNIT)))) =
variables : (col : INT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti490 : INT =
    int 0
  in
  if Ti490 <= col
    let rx : FLOAT =
      let Td493 : FLOAT =
        let Td491 : FLOAT =
          itof col
        in
        let Td492 : FLOAT =
          float 0.2
        in
        fmul Td491 Td492
      in
      let Td494 : FLOAT =
        float 0.9
      in
      fsub Td493 Td494
    in
    let Tu235 : UNIT =
      let Ti495 : INT =
        int 0
      in
      let Td496 : FLOAT =
        float 0.
      in
      let Td497 : FLOAT =
        float 0.
      in
      app
        calc_dirvec
        Ti495
        Td496
        Td497
        rx
        ry
        group_id
        index
    in
    let rx2 : FLOAT =
      let Td500 : FLOAT =
        let Td498 : FLOAT =
          itof col
        in
        let Td499 : FLOAT =
          float 0.2
        in
        fmul Td498 Td499
      in
      let Td501 : FLOAT =
        float 0.1
      in
      fadd Td500 Td501
    in
    let Tu234 : UNIT =
      let Ti502 : INT =
        int 0
      in
      let Td503 : FLOAT =
        float 0.
      in
      let Td504 : FLOAT =
        float 0.
      in
      let Ti506 : INT =
        let Ti505 : INT =
          int 2
        in
        add index Ti505
      in
      app
        calc_dirvec
        Ti502
        Td503
        Td504
        rx2
        ry
        group_id
        Ti506
    in
    let Ti508 : INT =
      let Ti507 : INT =
        int 1
      in
      sub col Ti507
    in
    let Ti510 : INT =
      let Ti509 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti509
    in
    app
      calc_dirvecs
      Ti508
      ry
      Ti510
      index
    unit ()
in
letrec calc_dirvec_rows : (INT -> (INT -> (INT -> UNIT))) =
variables : (row : INT), (group_id : INT), (index : INT)
  let Ti478 : INT =
    int 0
  in
  if Ti478 <= row
    let ry : FLOAT =
      let Td481 : FLOAT =
        let Td479 : FLOAT =
          itof row
        in
        let Td480 : FLOAT =
          float 0.2
        in
        fmul Td479 Td480
      in
      let Td482 : FLOAT =
        float 0.9
      in
      fsub Td481 Td482
    in
    let Tu236 : UNIT =
      let Ti483 : INT =
        int 4
      in
      app
        calc_dirvecs
        Ti483
        ry
        group_id
        index
    in
    let Ti485 : INT =
      let Ti484 : INT =
        int 1
      in
      sub row Ti484
    in
    let Ti487 : INT =
      let Ti486 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti486
    in
    let Ti489 : INT =
      let Ti488 : INT =
        int 4
      in
      add index Ti488
    in
    app
      calc_dirvec_rows
      Ti485
      Ti487
      Ti489
    unit ()
in
letrec create_dirvec : (UNIT -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (Tu237 : UNIT)
  let v3 : Array of FLOAT =
    let Ti474 : INT =
      int 3
    in
    let Td475 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti474
      Td475
  in
  let consts : Array of Array of FLOAT =
    let Ti477 : INT =
      let Ti476 : INT =
        int 0
      in
      n_objects.(Ti476)
    in
    extfunapp
      create_array
      Ti477
      v3
  in
  Tuple
    v3
    consts
in
letrec create_dirvec_elements : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (d : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti469 : INT =
    int 0
  in
  if Ti469 <= index
    let Tu238 : UNIT =
      let Tt471 : (Array of FLOAT * Array of Array of FLOAT) =
        let Tu470 : UNIT =
          unit ()
        in
        app
          create_dirvec
          Tu470
      in
      d.(index) <- Tt471
    in
    let Ti473 : INT =
      let Ti472 : INT =
        int 1
      in
      sub index Ti472
    in
    app
      create_dirvec_elements
      d
      Ti473
    unit ()
in
letrec create_dirvecs : (INT -> UNIT) =
variables : (index : INT)
  let Ti460 : INT =
    int 0
  in
  if Ti460 <= index
    let Tu240 : UNIT =
      let Ta464 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti461 : INT =
          int 120
        in
        let Tt463 : (Array of FLOAT * Array of Array of FLOAT) =
          let Tu462 : UNIT =
            unit ()
          in
          app
            create_dirvec
            Tu462
        in
        extfunapp
          create_array
          Ti461
          Tt463
      in
      dirvecs.(index) <- Ta464
    in
    let Tu239 : UNIT =
      let Ta465 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti466 : INT =
        int 118
      in
      app
        create_dirvec_elements
        Ta465
        Ti466
    in
    let Ti468 : INT =
      let Ti467 : INT =
        int 1
      in
      sub index Ti467
    in
    app
      create_dirvecs
      Ti468
    unit ()
in
letrec init_dirvec_constants : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (vecset : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti456 : INT =
    int 0
  in
  if Ti456 <= index
    let Tu241 : UNIT =
      let Tt457 : (Array of FLOAT * Array of Array of FLOAT) =
        vecset.(index)
      in
      app
        setup_dirvec_constants
        Tt457
    in
    let Ti459 : INT =
      let Ti458 : INT =
        int 1
      in
      sub index Ti458
    in
    app
      init_dirvec_constants
      vecset
      Ti459
    unit ()
in
letrec init_vecset_constants : (INT -> UNIT) =
variables : (index : INT)
  let Ti451 : INT =
    int 0
  in
  if Ti451 <= index
    let Tu242 : UNIT =
      let Ta452 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti453 : INT =
        int 119
      in
      app
        init_dirvec_constants
        Ta452
        Ti453
    in
    let Ti455 : INT =
      let Ti454 : INT =
        int 1
      in
      sub index Ti454
    in
    app
      init_vecset_constants
      Ti455
    unit ()
in
letrec init_dirvecs : (UNIT -> UNIT) =
variables : (Tu243 : UNIT)
  let Tu245 : UNIT =
    let Ti446 : INT =
      int 4
    in
    app
      create_dirvecs
      Ti446
  in
  let Tu244 : UNIT =
    let Ti447 : INT =
      int 9
    in
    let Ti448 : INT =
      int 0
    in
    let Ti449 : INT =
      int 0
    in
    app
      calc_dirvec_rows
      Ti447
      Ti448
      Ti449
  in
  let Ti450 : INT =
    int 4
  in
  app
    init_vecset_constants
    Ti450
in
letrec add_reflection : (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (index : INT), (surface_id : INT), (bright : FLOAT), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let dvec : (Array of FLOAT * Array of Array of FLOAT) =
    let Tu443 : UNIT =
      unit ()
    in
    app
      create_dirvec
      Tu443
  in
  let Tu247 : UNIT =
    let Ta444 : Array of FLOAT =
      app
        d_vec
        dvec
    in
    app
      vecset
      Ta444
      v0
      v1
      v2
  in
  let Tu246 : UNIT =
    app
      setup_dirvec_constants
      dvec
  in
  let Tt445 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    Tuple
      surface_id
      dvec
      bright
  in
  reflections.(index) <- Tt445
in
letrec setup_rect_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    mul obj_id 4
  in
  let nr : INT =
    let Ti415 : INT =
      int 0
    in
    n_reflections.(Ti415)
  in
  let br : FLOAT =
    let Td416 : FLOAT =
      float 1.
    in
    let Td417 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td416 Td417
  in
  let n0 : FLOAT =
    let Td419 : FLOAT =
      let Ti418 : INT =
        int 0
      in
      light.(Ti418)
    in
    app
      fneg
      Td419
  in
  let n1 : FLOAT =
    let Td421 : FLOAT =
      let Ti420 : INT =
        int 1
      in
      light.(Ti420)
    in
    app
      fneg
      Td421
  in
  let n2 : FLOAT =
    let Td423 : FLOAT =
      let Ti422 : INT =
        int 2
      in
      light.(Ti422)
    in
    app
      fneg
      Td423
  in
  let Tu250 : UNIT =
    let Ti425 : INT =
      let Ti424 : INT =
        int 1
      in
      add sid Ti424
    in
    let Td427 : FLOAT =
      let Ti426 : INT =
        int 0
      in
      light.(Ti426)
    in
    app
      add_reflection
      nr
      Ti425
      br
      Td427
      n1
      n2
  in
  let Tu249 : UNIT =
    let Ti429 : INT =
      let Ti428 : INT =
        int 1
      in
      add nr Ti428
    in
    let Ti431 : INT =
      let Ti430 : INT =
        int 2
      in
      add sid Ti430
    in
    let Td433 : FLOAT =
      let Ti432 : INT =
        int 1
      in
      light.(Ti432)
    in
    app
      add_reflection
      Ti429
      Ti431
      br
      n0
      Td433
      n2
  in
  let Tu248 : UNIT =
    let Ti435 : INT =
      let Ti434 : INT =
        int 2
      in
      add nr Ti434
    in
    let Ti437 : INT =
      let Ti436 : INT =
        int 3
      in
      add sid Ti436
    in
    let Td439 : FLOAT =
      let Ti438 : INT =
        int 2
      in
      light.(Ti438)
    in
    app
      add_reflection
      Ti435
      Ti437
      br
      n0
      n1
      Td439
  in
  let Ti440 : INT =
    int 0
  in
  let Ti442 : INT =
    let Ti441 : INT =
      int 3
    in
    add nr Ti441
  in
  n_reflections.(Ti440) <- Ti442
in
letrec setup_surface_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    let Ti385 : INT =
      mul obj_id 4
    in
    let Ti386 : INT =
      int 1
    in
    add Ti385 Ti386
  in
  let nr : INT =
    let Ti387 : INT =
      int 0
    in
    n_reflections.(Ti387)
  in
  let br : FLOAT =
    let Td388 : FLOAT =
      float 1.
    in
    let Td389 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td388 Td389
  in
  let p : FLOAT =
    let Ta390 : Array of FLOAT =
      app
        o_param_abc
        obj
    in
    app
      veciprod
      light
      Ta390
  in
  let Tu251 : UNIT =
    let Td397 : FLOAT =
      let Td394 : FLOAT =
        let Td393 : FLOAT =
          let Td391 : FLOAT =
            float 2.
          in
          let Td392 : FLOAT =
            app
              o_param_a
              obj
          in
          fmul Td391 Td392
        in
        fmul Td393 p
      in
      let Td396 : FLOAT =
        let Ti395 : INT =
          int 0
        in
        light.(Ti395)
      in
      fsub Td394 Td396
    in
    let Td404 : FLOAT =
      let Td401 : FLOAT =
        let Td400 : FLOAT =
          let Td398 : FLOAT =
            float 2.
          in
          let Td399 : FLOAT =
            app
              o_param_b
              obj
          in
          fmul Td398 Td399
        in
        fmul Td400 p
      in
      let Td403 : FLOAT =
        let Ti402 : INT =
          int 1
        in
        light.(Ti402)
      in
      fsub Td401 Td403
    in
    let Td411 : FLOAT =
      let Td408 : FLOAT =
        let Td407 : FLOAT =
          let Td405 : FLOAT =
            float 2.
          in
          let Td406 : FLOAT =
            app
              o_param_c
              obj
          in
          fmul Td405 Td406
        in
        fmul Td407 p
      in
      let Td410 : FLOAT =
        let Ti409 : INT =
          int 2
        in
        light.(Ti409)
      in
      fsub Td408 Td410
    in
    app
      add_reflection
      nr
      sid
      br
      Td397
      Td404
      Td411
  in
  let Ti412 : INT =
    int 0
  in
  let Ti414 : INT =
    let Ti413 : INT =
      int 1
    in
    add nr Ti413
  in
  n_reflections.(Ti412) <- Ti414
in
letrec setup_reflections : (INT -> UNIT) =
variables : (obj_id : INT)
  let Ti376 : INT =
    int 0
  in
  if Ti376 <= obj_id
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(obj_id)
    in
    let Ti377 : INT =
      app
        o_reflectiontype
        obj
    in
    let Ti378 : INT =
      int 2
    in
    if Ti377 == Ti378
      let Tb381 : BOOL =
        let Td379 : FLOAT =
          app
            o_diffuse
            obj
        in
        let Td380 : FLOAT =
          float 1.
        in
        app
          fless
          Td379
          Td380
      in
      let Ti382 : INT =
        int 0
      in
      if Tb381 == Ti382
        unit ()
        let m_shape : INT =
          app
            o_form
            obj
        in
        let Ti383 : INT =
          int 1
        in
        if m_shape == Ti383
          app
            setup_rect_reflection
            obj_id
            obj
          let Ti384 : INT =
            int 2
          in
          if m_shape == Ti384
            app
              setup_surface_reflection
              obj_id
              obj
            unit ()
      unit ()
    unit ()
in
letrec rt : (INT -> (INT -> UNIT)) =
variables : (size_x : INT), (size_y : INT)
  let Tu263 : UNIT =
    let Ti351 : INT =
      int 0
    in
    image_size.(Ti351) <- size_x
  in
  let Tu262 : UNIT =
    let Ti352 : INT =
      int 1
    in
    image_size.(Ti352) <- size_y
  in
  let Tu261 : UNIT =
    let Ti353 : INT =
      int 0
    in
    let Ti354 : INT =
      div size_x 2
    in
    image_center.(Ti353) <- Ti354
  in
  let Tu260 : UNIT =
    let Ti355 : INT =
      int 1
    in
    let Ti356 : INT =
      div size_y 2
    in
    image_center.(Ti355) <- Ti356
  in
  let Tu259 : UNIT =
    let Ti357 : INT =
      int 0
    in
    let Td360 : FLOAT =
      let Td358 : FLOAT =
        float 128.
      in
      let Td359 : FLOAT =
        itof size_x
      in
      fdiv Td358 Td359
    in
    scan_pitch.(Ti357) <- Td360
  in
  let prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu361 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu361
  in
  let cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu362 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu362
  in
  let next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu363 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu363
  in
  let Tu258 : UNIT =
    let Tu364 : UNIT =
      unit ()
    in
    app
      read_parameter
      Tu364
  in
  let Tu257 : UNIT =
    let Tu365 : UNIT =
      unit ()
    in
    app
      write_ppm_header
      Tu365
  in
  let Tu256 : UNIT =
    let Tu366 : UNIT =
      unit ()
    in
    app
      init_dirvecs
      Tu366
  in
  let Tu255 : UNIT =
    let Ta367 : Array of FLOAT =
      app
        d_vec
        light_dirvec
    in
    app
      veccpy
      Ta367
      light
  in
  let Tu254 : UNIT =
    app
      setup_dirvec_constants
      light_dirvec
  in
  let Tu253 : UNIT =
    let Ti371 : INT =
      let Ti369 : INT =
        let Ti368 : INT =
          int 0
        in
        n_objects.(Ti368)
      in
      let Ti370 : INT =
        int 1
      in
      sub Ti369 Ti370
    in
    app
      setup_reflections
      Ti371
  in
  let Tu252 : UNIT =
    let Ti372 : INT =
      int 0
    in
    let Ti373 : INT =
      int 0
    in
    app
      pretrace_line
      cur
      Ti372
      Ti373
  in
  let Ti374 : INT =
    int 0
  in
  let Ti375 : INT =
    int 2
  in
  app
    scan_line
    Ti374
    prev
    cur
    next
    Ti375
in
let Ti349 : INT =
  int 128
in
let Ti350 : INT =
  int 128
in
app
  rt
  Ti349
  Ti350
