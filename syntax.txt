----- syntax.print -----
LETREC print_int (VAR of )
  (n : VAR of )
  LET n (VAR of )
    IF
      NOT
        LE
          INT 0
          VAR n
      LET Tu1 (UNIT)
        OUT
          INT 45        0
      NEG
        VAR n
      VAR n
  IF
    NOT
      LE
        INT 10
        VAR n
    OUT
      VAR n    48
    LET m (VAR of )
      DIVIDE BY 10
        VAR n
    LET Tu2 (UNIT)
      APP
        VAR print_int
        VAR m
    OUT
      SUB
        VAR n
        MULTIPLE 10
          VAR m    48
LETREC print_char (VAR of )
  (c : VAR of )
  OUT
    VAR c  0
LETREC reduction_2pi_sub1 (VAR of )
  (a : VAR of ), (p : VAR of )
  IF
    FLt
      VAR a
      VAR p
    VAR p
    APP
      VAR reduction_2pi_sub1
      VAR a
      FADD
        VAR p
        VAR p
LETREC reduction_2pi_sub2 (VAR of )
  (a : VAR of ), (p : VAR of )
  IF
    FLt
      FLOAT 6.28318530718
      VAR a
    LET a (VAR of )
      IF
        FLt
          VAR p
          VAR a
        FSUB
          VAR a
          VAR p
        FADD
          VAR a
          FLOAT 0.
    LET p (VAR of )
      FDIV
        VAR p
        FLOAT 2.
    APP
      VAR reduction_2pi_sub2
      VAR a
      VAR p
    FADD
      VAR a
      FLOAT 0.
LETREC reduction_2pi (VAR of )
  (a : VAR of )
  LET p (VAR of )
    FLOAT 6.28318530718
  LET p (VAR of )
    APP
      VAR reduction_2pi_sub1
      VAR a
      VAR p
  APP
    VAR reduction_2pi_sub2
    VAR a
    VAR p
LETREC kernel_sin (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a
  LET a5 (VAR of )
    FMUL
      VAR a3
      VAR a2
  LET a7 (VAR of )
    FMUL
      VAR a5
      VAR a2
  FADD
    FSUB
      FADD
        NEG
          FMUL
            FLOAT 0.000198411698413
            VAR a7
        FMUL
          FLOAT 0.0083333333333
          VAR a5
      FMUL
        FLOAT 0.166666666667
        VAR a3
    VAR a
LETREC kernel_cos (VAR of )
  (a : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a
      VAR a
  LET a4 (VAR of )
    FMUL
      VAR a2
      VAR a2
  LET a6 (VAR of )
    FMUL
      VAR a4
      VAR a2
  FADD
    FSUB
      FADD
        NEG
          FMUL
            FLOAT 0.00138888888889
            VAR a6
        FMUL
          FLOAT 0.0416666666667
          VAR a4
      FMUL
        FLOAT 0.5
        VAR a2
    FLOAT 1.
LETREC sin (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      FADD
        VAR a
        FLOAT 0.
  LET a (VAR of )
    APP
      VAR reduction_2pi
      VAR a
  (a : VAR of ), (flag : VAR of )
    IF
      FLt
        FLOAT 3.14159265359
        VAR a
      TUPLE
        FSUB
          VAR a
          FLOAT 3.14159265359
        NOT
          VAR flag
      TUPLE
        FADD
          VAR a
          FLOAT 0.
        VAR flag
    LET a (VAR of )
      IF
        FLt
          FLOAT 1.57079632679
          VAR a
        FSUB
          FLOAT 3.14159265359
          VAR a
        FADD
          VAR a
          FLOAT 0.
    LET a (VAR of )
      IF
        FLt
          VAR a
          FLOAT 0.785398163397
        APP
          VAR kernel_cos
          FSUB
            FLOAT 1.57079632679
            VAR a
        APP
          VAR kernel_sin
          VAR a
    IF
      VAR flag
      FADD
        VAR a
        FLOAT 0.
      NEG
        VAR a
LETREC cos (VAR of )
  (a : VAR of )
  LET a (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.
      NEG
        VAR a
      FADD
        VAR a
        FLOAT 0.
  LET a (VAR of )
    APP
      VAR reduction_2pi
      VAR a
  (a : VAR of ), (flag : VAR of )
    IF
      FLt
        FLOAT 3.14159265359
        VAR a
      TUPLE
        FSUB
          VAR a
          FLOAT 3.14159265359
        BOOL false
      TUPLE
        VAR a
        BOOL true
    (a : VAR of ), (flag : VAR of )
      IF
        FLt
          FLOAT 1.57079632679
          VAR a
        TUPLE
          FSUB
            FLOAT 3.14159265359
            VAR a
          NOT
            VAR flag
        TUPLE
          FADD
            VAR a
            FLOAT 0.
          VAR flag
      LET a (VAR of )
        IF
          FLt
            FLOAT 0.785398163397
            VAR a
          APP
            VAR kernel_cos
            VAR a
          APP
            VAR kernel_sin
            FSUB
              FLOAT 1.57079632679
              VAR a
      IF
        VAR flag
        FADD
          VAR a
          FLOAT 0.
        NEG
          VAR a
LETREC sqrt (VAR of )
  (x : VAR of )
  LETREC inner (VAR of )
    (t : VAR of ), (i : VAR of )
    IF
      EQ
        VAR i
        INT 0
      VAR t
      APP
        VAR inner
        FDIV
          FADD
            FMUL
              VAR t
              VAR t
            VAR x
          FMUL
            FLOAT 2.
            VAR t
        SUB
          VAR i
          INT 1
  APP
    VAR inner
    UNKNOWN APP      sqrt_init
      VAR x
    INT 5
LETREC kernel_atan (VAR of )
  (a1 : VAR of )
  LET a2 (VAR of )
    FMUL
      VAR a1
      VAR a1
  LET a3 (VAR of )
    FMUL
      VAR a2
      VAR a1
  LET a5 (VAR of )
    FMUL
      VAR a2
      VAR a3
  LET a7 (VAR of )
    FMUL
      VAR a2
      VAR a5
  LET a9 (VAR of )
    FMUL
      VAR a2
      VAR a7
  LET a11 (VAR of )
    FMUL
      VAR a2
      VAR a9
  LET a13 (VAR of )
    FMUL
      VAR a2
      VAR a11
  FADD
    FSUB
      FADD
        FSUB
          FADD
            FSUB
              VAR a1
              FMUL
                FLOAT 0.3333333
                VAR a3
            FMUL
              FLOAT 0.2
              VAR a5
          FMUL
            FLOAT 0.142857142
            VAR a7
        FMUL
          FLOAT 0.111111104
          VAR a9
      FMUL
        FLOAT 0.08976446
        VAR a11
    FMUL
      FLOAT 0.060035485
      VAR a13
LETREC atan (VAR of )
  (a : VAR of )
  LET flag (VAR of )
    FLt
      FLOAT 0.
      VAR a
  LET a (VAR of )
    IF
      VAR flag
      FADD
        VAR a
        FLOAT 0.
      NEG
        VAR a
  LET b (VAR of )
    IF
      FLt
        VAR a
        FLOAT 0.4375
      APP
        VAR kernel_atan
        VAR a
      FADD
        IF
          FLt
            VAR a
            FLOAT 2.4375
          FADD
            FLOAT 0.785398163397
            APP
              VAR kernel_atan
              FDIV
                FSUB
                  VAR a
                  FLOAT 1.
                FADD
                  VAR a
                  FLOAT 1.
          FSUB
            FLOAT 1.57079632679
            APP
              VAR kernel_atan
              FDIV
                FLOAT 1.
                VAR a
        FLOAT 0.
  IF
    VAR flag
    FADD
      FLOAT 0.
      VAR b
    NEG
      VAR b
LETREC floor (VAR of )
  (x : VAR of )
  LET a (VAR of )
    int_to_float
      float_to_int
        VAR x
  IF
    FLt
      VAR x
      VAR a
    FSUB
      VAR a
      FLOAT 1.
    VAR a
LETREC fabs (VAR of )
  (f : VAR of )
  IF
    FLt
      VAR f
      FLOAT 0.
    NEG
      VAR f
    VAR f
LETREC fhalf (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.5
LETREC fsqr (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    VAR x
LETREC fneg (VAR of )
  (x : VAR of )
  NEG
    VAR x
LETREC fless (VAR of )
  (a : VAR of ), (b : VAR of )
  FLt
    VAR a
    VAR b
LETREC abs_float (VAR of )
  (x : VAR of )
  APP
    VAR fabs
    VAR x
LETREC fispos (VAR of )
  (x : VAR of )
  FLt
    FLOAT 0.
    VAR x
LETREC fisneg (VAR of )
  (x : VAR of )
  FLt
    VAR x
    FLOAT 0.
LET n_objects (VAR of )
  ARRAY
    INT 1
    INT 0
LET objects (VAR of )
  LET dummy (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  ARRAY
    INT 60
    TUPLE
      INT 0
      INT 0
      INT 0
      INT 0
      VAR dummy
      VAR dummy
      BOOL false
      VAR dummy
      VAR dummy
      VAR dummy
      VAR dummy
LET screen (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET viewpoint (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET light (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET beam (VAR of )
  ARRAY
    INT 1
    FLOAT 255.
LET and_net (VAR of )
  ARRAY
    INT 50
    ARRAY
      INT 1
      NEG
        INT 1
LET or_net (VAR of )
  ARRAY
    INT 1
    ARRAY
      INT 1
      GET
        VAR and_net
        INT 0
LET solver_dist (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET intsec_rectside (VAR of )
  ARRAY
    INT 1
    INT 0
LET tmin (VAR of )
  ARRAY
    INT 1
    FLOAT 1000000000.
LET intersection_point (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET intersected_object_id (VAR of )
  ARRAY
    INT 1
    INT 0
LET nvector (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET texture_color (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET diffuse_ray (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET rgb (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET image_size (VAR of )
  ARRAY
    INT 2
    INT 0
LET image_center (VAR of )
  ARRAY
    INT 2
    INT 0
LET scan_pitch (VAR of )
  ARRAY
    INT 1
    FLOAT 0.
LET startp (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET startp_fast (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenx_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screeny_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET screenz_dir (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET ptrace_dirvec (VAR of )
  ARRAY
    INT 3
    FLOAT 0.
LET dirvecs (VAR of )
  LET dummyf (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff (VAR of )
    ARRAY
      INT 0
      VAR dummyf
  LET dummy_vs (VAR of )
    ARRAY
      INT 0
      TUPLE
        VAR dummyf
        VAR dummyff
  ARRAY
    INT 5
    VAR dummy_vs
LET light_dirvec (VAR of )
  LET dummyf2 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      INT 60
      VAR dummyf2
  TUPLE
    VAR v3
    VAR consts
LET reflections (VAR of )
  LET dummyf3 (VAR of )
    ARRAY
      INT 0
      FLOAT 0.
  LET dummyff3 (VAR of )
    ARRAY
      INT 0
      VAR dummyf3
  LET dummydv (VAR of )
    TUPLE
      VAR dummyf3
      VAR dummyff3
  ARRAY
    INT 180
    TUPLE
      INT 0
      VAR dummydv
      FLOAT 0.
LET n_reflections (VAR of )
  ARRAY
    INT 1
    INT 0
LETREC xor (VAR of )
  (x : VAR of ), (y : VAR of )
  IF
    VAR x
    NOT
      VAR y
    VAR y
LETREC sgn (VAR of )
  (x : VAR of )
  IF
    FZero?
      VAR x
    FLOAT 0.
    IF
      APP
        VAR fispos
        VAR x
      FLOAT 1.
      FLOAT -1.
LETREC fneg_cond (VAR of )
  (cond : VAR of ), (x : VAR of )
  IF
    VAR cond
    VAR x
    APP
      VAR fneg
      VAR x
LETREC add_mod5 (VAR of )
  (x : VAR of ), (y : VAR of )
  LET sum (VAR of )
    ADD
      VAR x
      VAR y
  IF
    LE
      INT 5
      VAR sum
    SUB
      VAR sum
      INT 5
    VAR sum
LETREC vecset (VAR of )
  (v : VAR of ), (x : VAR of ), (y : VAR of ), (z : VAR of )
  LET Tu4 (UNIT)
    PUT
      VAR v
      INT 0
      VAR x
  LET Tu3 (UNIT)
    PUT
      VAR v
      INT 1
      VAR y
  PUT
    VAR v
    INT 2
    VAR z
LETREC vecfill (VAR of )
  (v : VAR of ), (elem : VAR of )
  LET Tu6 (UNIT)
    PUT
      VAR v
      INT 0
      VAR elem
  LET Tu5 (UNIT)
    PUT
      VAR v
      INT 1
      VAR elem
  PUT
    VAR v
    INT 2
    VAR elem
LETREC vecbzero (VAR of )
  (v : VAR of )
  APP
    VAR vecfill
    VAR v
    FLOAT 0.
LETREC veccpy (VAR of )
  (dest : VAR of ), (src : VAR of )
  LET Tu8 (UNIT)
    PUT
      VAR dest
      INT 0
      GET
        VAR src
        INT 0
  LET Tu7 (UNIT)
    PUT
      VAR dest
      INT 1
      GET
        VAR src
        INT 1
  PUT
    VAR dest
    INT 2
    GET
      VAR src
      INT 2
LETREC vecdist2 (VAR of )
  (p : VAR of ), (q : VAR of )
  FADD
    FADD
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 0
          GET
            VAR q
            INT 0
      APP
        VAR fsqr
        FSUB
          GET
            VAR p
            INT 1
          GET
            VAR q
            INT 1
    APP
      VAR fsqr
      FSUB
        GET
          VAR p
          INT 2
        GET
          VAR q
          INT 2
LETREC vecunit (VAR of )
  (v : VAR of )
  LET il (VAR of )
    FDIV
      FLOAT 1.
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              GET
                VAR v
                INT 0
            APP
              VAR fsqr
              GET
                VAR v
                INT 1
          APP
            VAR fsqr
            GET
              VAR v
              INT 2
  LET Tu10 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu9 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC vecunit_sgn (VAR of )
  (v : VAR of ), (inv : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FADD
          APP
            VAR fsqr
            GET
              VAR v
              INT 0
          APP
            VAR fsqr
            GET
              VAR v
              INT 1
        APP
          VAR fsqr
          GET
            VAR v
            INT 2
  LET il (VAR of )
    IF
      FZero?
        VAR l
      FLOAT 1.
      IF
        VAR inv
        FDIV
          FLOAT -1.
          VAR l
        FDIV
          FLOAT 1.
          VAR l
  LET Tu12 (UNIT)
    PUT
      VAR v
      INT 0
      FMUL
        GET
          VAR v
          INT 0
        VAR il
  LET Tu11 (UNIT)
    PUT
      VAR v
      INT 1
      FMUL
        GET
          VAR v
          INT 1
        VAR il
  PUT
    VAR v
    INT 2
    FMUL
      GET
        VAR v
        INT 2
      VAR il
LETREC veciprod (VAR of )
  (v : VAR of ), (w : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        GET
          VAR w
          INT 0
      FMUL
        GET
          VAR v
          INT 1
        GET
          VAR w
          INT 1
    FMUL
      GET
        VAR v
        INT 2
      GET
        VAR w
        INT 2
LETREC veciprod2 (VAR of )
  (v : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  FADD
    FADD
      FMUL
        GET
          VAR v
          INT 0
        VAR w0
      FMUL
        GET
          VAR v
          INT 1
        VAR w1
    FMUL
      GET
        VAR v
        INT 2
      VAR w2
LETREC vecaccum (VAR of )
  (dest : VAR of ), (scale : VAR of ), (v : VAR of )
  LET Tu14 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          VAR scale
          GET
            VAR v
            INT 0
  LET Tu13 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          VAR scale
          GET
            VAR v
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        VAR scale
        GET
          VAR v
          INT 2
LETREC vecadd (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu16 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu15 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecmul (VAR of )
  (dest : VAR of ), (v : VAR of )
  LET Tu18 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        GET
          VAR v
          INT 0
  LET Tu17 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        GET
          VAR v
          INT 1
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      GET
        VAR v
        INT 2
LETREC vecscale (VAR of )
  (dest : VAR of ), (scale : VAR of )
  LET Tu20 (UNIT)
    PUT
      VAR dest
      INT 0
      FMUL
        GET
          VAR dest
          INT 0
        VAR scale
  LET Tu19 (UNIT)
    PUT
      VAR dest
      INT 1
      FMUL
        GET
          VAR dest
          INT 1
        VAR scale
  PUT
    VAR dest
    INT 2
    FMUL
      GET
        VAR dest
        INT 2
      VAR scale
LETREC vecaccumv (VAR of )
  (dest : VAR of ), (v : VAR of ), (w : VAR of )
  LET Tu22 (UNIT)
    PUT
      VAR dest
      INT 0
      FADD
        GET
          VAR dest
          INT 0
        FMUL
          GET
            VAR v
            INT 0
          GET
            VAR w
            INT 0
  LET Tu21 (UNIT)
    PUT
      VAR dest
      INT 1
      FADD
        GET
          VAR dest
          INT 1
        FMUL
          GET
            VAR v
            INT 1
          GET
            VAR w
            INT 1
  PUT
    VAR dest
    INT 2
    FADD
      GET
        VAR dest
        INT 2
      FMUL
        GET
          VAR v
          INT 2
        GET
          VAR w
          INT 2
LETREC o_texturetype (VAR of )
  (m : VAR of )
  (m_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_tex
LETREC o_form (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (m_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_shape
LETREC o_reflectiontype (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_surface
LETREC o_isinvert (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (m_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_invert
LETREC o_isrot (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (m_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_isrot
LETREC o_param_a (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 0
LETREC o_param_b (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 1
LETREC o_param_c (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_abc
      INT 2
LETREC o_param_abc (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (m_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    VAR m_abc
LETREC o_param_x (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 0
LETREC o_param_y (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 1
LETREC o_param_z (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (m_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_xyz
      INT 2
LETREC o_diffuse (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 0
LETREC o_hilight (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (m_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_surfparams
      INT 1
LETREC o_color_red (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 0
LETREC o_color_green (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 1
LETREC o_color_blue (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (m_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (m_color : VAR of ), (xm_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_color
      INT 2
LETREC o_param_r1 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 0
LETREC o_param_r2 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 1
LETREC o_param_r3 (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (m_rot123 : VAR of ), (xm_ctbl : VAR of )
    VAR m
    GET
      VAR m_rot123
      INT 2
LETREC o_param_ctbl (VAR of )
  (m : VAR of )
  (xm_tex : VAR of ), (xm_shape : VAR of ), (xm_surface : VAR of ), (xm_isrot : VAR of ), (xm_abc : VAR of ), (xm_xyz : VAR of ), (xm_invert : VAR of ), (xm_surfparams : VAR of ), (xm_color : VAR of ), (xm_rot123 : VAR of ), (m_ctbl : VAR of )
    VAR m
    VAR m_ctbl
LETREC p_rgb (VAR of )
  (pixel : VAR of )
  (m_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_rgb
LETREC p_intersection_points (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (m_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_isect_ps
LETREC p_surface_ids (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (m_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_sids
LETREC p_calc_diffuse (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (m_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_cdif
LETREC p_energy (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (m_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_engy
LETREC p_received_ray_20percent (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (m_r20p : VAR of ), (xm_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    VAR m_r20p
LETREC p_group_id (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    GET
      VAR m_gid
      INT 0
LETREC p_set_group_id (VAR of )
  (pixel : VAR of ), (id : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (m_gid : VAR of ), (xm_nvectors : VAR of )
    VAR pixel
    PUT
      VAR m_gid
      INT 0
      VAR id
LETREC p_nvectors (VAR of )
  (pixel : VAR of )
  (xm_rgb : VAR of ), (xm_isect_ps : VAR of ), (xm_sids : VAR of ), (xm_cdif : VAR of ), (xm_engy : VAR of ), (xm_r20p : VAR of ), (xm_gid : VAR of ), (m_nvectors : VAR of )
    VAR pixel
    VAR m_nvectors
LETREC d_vec (VAR of )
  (d : VAR of )
  (m_vec : VAR of ), (xm_const : VAR of )
    VAR d
    VAR m_vec
LETREC d_const (VAR of )
  (d : VAR of )
  (dm_vec : VAR of ), (m_const : VAR of )
    VAR d
    VAR m_const
LETREC r_surface_id (VAR of )
  (r : VAR of )
  (m_sid : VAR of ), (xm_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_sid
LETREC r_dvec (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (m_dvec : VAR of ), (xm_br : VAR of )
    VAR r
    VAR m_dvec
LETREC r_bright (VAR of )
  (r : VAR of )
  (xm_sid : VAR of ), (xm_dvec : VAR of ), (m_br : VAR of )
    VAR r
    VAR m_br
LETREC rad (VAR of )
  (x : VAR of )
  FMUL
    VAR x
    FLOAT 0.017453293
LETREC read_screen_settings (VAR of )
  (Tu23 : VAR of )
  LET Tu37 (UNIT)
    PUT
      VAR screen
      INT 0
      UNKNOWN APP        inflt
        UNIT
  LET Tu36 (UNIT)
    PUT
      VAR screen
      INT 1
      UNKNOWN APP        inflt
        UNIT
  LET Tu35 (UNIT)
    PUT
      VAR screen
      INT 2
      UNKNOWN APP        inflt
        UNIT
  LET v1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v1 (VAR of )
    APP
      VAR cos
      VAR v1
  LET sin_v1 (VAR of )
    APP
      VAR sin
      VAR v1
  LET v2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cos_v2 (VAR of )
    APP
      VAR cos
      VAR v2
  LET sin_v2 (VAR of )
    APP
      VAR sin
      VAR v2
  LET Tu34 (UNIT)
    PUT
      VAR screenz_dir
      INT 0
      FMUL
        FMUL
          VAR cos_v1
          VAR sin_v2
        FLOAT 200.
  LET Tu33 (UNIT)
    PUT
      VAR screenz_dir
      INT 1
      FMUL
        VAR sin_v1
        FLOAT -200.
  LET Tu32 (UNIT)
    PUT
      VAR screenz_dir
      INT 2
      FMUL
        FMUL
          VAR cos_v1
          VAR cos_v2
        FLOAT 200.
  LET Tu31 (UNIT)
    PUT
      VAR screenx_dir
      INT 0
      VAR cos_v2
  LET Tu30 (UNIT)
    PUT
      VAR screenx_dir
      INT 1
      FLOAT 0.
  LET Tu29 (UNIT)
    PUT
      VAR screenx_dir
      INT 2
      APP
        VAR fneg
        VAR sin_v2
  LET Tu28 (UNIT)
    PUT
      VAR screeny_dir
      INT 0
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR sin_v2
  LET Tu27 (UNIT)
    PUT
      VAR screeny_dir
      INT 1
      APP
        VAR fneg
        VAR cos_v1
  LET Tu26 (UNIT)
    PUT
      VAR screeny_dir
      INT 2
      FMUL
        APP
          VAR fneg
          VAR sin_v1
        VAR cos_v2
  LET Tu25 (UNIT)
    PUT
      VAR viewpoint
      INT 0
      FSUB
        GET
          VAR screen
          INT 0
        GET
          VAR screenz_dir
          INT 0
  LET Tu24 (UNIT)
    PUT
      VAR viewpoint
      INT 1
      FSUB
        GET
          VAR screen
          INT 1
        GET
          VAR screenz_dir
          INT 1
  PUT
    VAR viewpoint
    INT 2
    FSUB
      GET
        VAR screen
        INT 2
      GET
        VAR screenz_dir
        INT 2
LETREC read_light (VAR of )
  (Tu38 : VAR of )
  LET nl (VAR of )
    UNKNOWN APP      inint
      UNIT
  LET l1 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET sl1 (VAR of )
    APP
      VAR sin
      VAR l1
  LET Tu41 (UNIT)
    PUT
      VAR light
      INT 1
      APP
        VAR fneg
        VAR sl1
  LET l2 (VAR of )
    APP
      VAR rad
      UNKNOWN APP        inflt
        UNIT
  LET cl1 (VAR of )
    APP
      VAR cos
      VAR l1
  LET sl2 (VAR of )
    APP
      VAR sin
      VAR l2
  LET Tu40 (UNIT)
    PUT
      VAR light
      INT 0
      FMUL
        VAR cl1
        VAR sl2
  LET cl2 (VAR of )
    APP
      VAR cos
      VAR l2
  LET Tu39 (UNIT)
    PUT
      VAR light
      INT 2
      FMUL
        VAR cl1
        VAR cl2
  PUT
    VAR beam
    INT 0
    UNKNOWN APP      inflt
      UNIT
LETREC rotate_quadratic_matrix (VAR of )
  (abc : VAR of ), (rot : VAR of )
  LET cos_x (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 0
  LET sin_x (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 0
  LET cos_y (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 1
  LET sin_y (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 1
  LET cos_z (VAR of )
    APP
      VAR cos
      GET
        VAR rot
        INT 2
  LET sin_z (VAR of )
    APP
      VAR sin
      GET
        VAR rot
        INT 2
  LET m00 (VAR of )
    FMUL
      VAR cos_y
      VAR cos_z
  LET m01 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR cos_x
        VAR sin_z
  LET m02 (VAR of )
    FADD
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR cos_z
      FMUL
        VAR sin_x
        VAR sin_z
  LET m10 (VAR of )
    FMUL
      VAR cos_y
      VAR sin_z
  LET m11 (VAR of )
    FADD
      FMUL
        FMUL
          VAR sin_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR cos_x
        VAR cos_z
  LET m12 (VAR of )
    FSUB
      FMUL
        FMUL
          VAR cos_x
          VAR sin_y
        VAR sin_z
      FMUL
        VAR sin_x
        VAR cos_z
  LET m20 (VAR of )
    APP
      VAR fneg
      VAR sin_y
  LET m21 (VAR of )
    FMUL
      VAR sin_x
      VAR cos_y
  LET m22 (VAR of )
    FMUL
      VAR cos_x
      VAR cos_y
  LET ao (VAR of )
    GET
      VAR abc
      INT 0
  LET bo (VAR of )
    GET
      VAR abc
      INT 1
  LET co (VAR of )
    GET
      VAR abc
      INT 2
  LET Tu46 (UNIT)
    PUT
      VAR abc
      INT 0
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m00
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m10
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m20
  LET Tu45 (UNIT)
    PUT
      VAR abc
      INT 1
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m01
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m11
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m21
  LET Tu44 (UNIT)
    PUT
      VAR abc
      INT 2
      FADD
        FADD
          FMUL
            VAR ao
            APP
              VAR fsqr
              VAR m02
          FMUL
            VAR bo
            APP
              VAR fsqr
              VAR m12
        FMUL
          VAR co
          APP
            VAR fsqr
            VAR m22
  LET Tu43 (UNIT)
    PUT
      VAR rot
      INT 0
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m01
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m11
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m21
            VAR m22
  LET Tu42 (UNIT)
    PUT
      VAR rot
      INT 1
      FMUL
        FLOAT 2.
        FADD
          FADD
            FMUL
              FMUL
                VAR ao
                VAR m00
              VAR m02
            FMUL
              FMUL
                VAR bo
                VAR m10
              VAR m12
          FMUL
            FMUL
              VAR co
              VAR m20
            VAR m22
  PUT
    VAR rot
    INT 2
    FMUL
      FLOAT 2.
      FADD
        FADD
          FMUL
            FMUL
              VAR ao
              VAR m00
            VAR m01
          FMUL
            FMUL
              VAR bo
              VAR m10
            VAR m11
        FMUL
          FMUL
            VAR co
            VAR m20
          VAR m21
LETREC read_nth_object (VAR of )
  (n : VAR of )
  LET texture (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    NOT
      EQ
        VAR texture
        NEG
          INT 1
    LET form (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET refltype (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET isrot_p (VAR of )
      UNKNOWN APP        inint
        UNIT
    LET abc (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu65 (UNIT)
      PUT
        VAR abc
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu64 (UNIT)
      PUT
        VAR abc
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu63 (UNIT)
      PUT
        VAR abc
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET xyz (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu62 (UNIT)
      PUT
        VAR xyz
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu61 (UNIT)
      PUT
        VAR xyz
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu60 (UNIT)
      PUT
        VAR xyz
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET m_invert (VAR of )
      APP
        VAR fisneg
        UNKNOWN APP          inflt
          UNIT
    LET reflparam (VAR of )
      ARRAY
        INT 2
        FLOAT 0.
    LET Tu59 (UNIT)
      PUT
        VAR reflparam
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu58 (UNIT)
      PUT
        VAR reflparam
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET color (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu57 (UNIT)
      PUT
        VAR color
        INT 0
        UNKNOWN APP          inflt
          UNIT
    LET Tu56 (UNIT)
      PUT
        VAR color
        INT 1
        UNKNOWN APP          inflt
          UNIT
    LET Tu55 (UNIT)
      PUT
        VAR color
        INT 2
        UNKNOWN APP          inflt
          UNIT
    LET rotation (VAR of )
      ARRAY
        INT 3
        FLOAT 0.
    LET Tu54 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        LET Tu48 (UNIT)
          PUT
            VAR rotation
            INT 0
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        LET Tu47 (UNIT)
          PUT
            VAR rotation
            INT 1
            APP
              VAR rad
              UNKNOWN APP                inflt
                UNIT
        PUT
          VAR rotation
          INT 2
          APP
            VAR rad
            UNKNOWN APP              inflt
              UNIT
        UNIT
    LET m_invert2 (VAR of )
      IF
        EQ
          VAR form
          INT 2
        BOOL true
        VAR m_invert
    LET ctbl (VAR of )
      ARRAY
        INT 4
        FLOAT 0.
    LET obj (VAR of )
      TUPLE
        VAR texture
        VAR form
        VAR refltype
        VAR isrot_p
        VAR abc
        VAR xyz
        VAR m_invert2
        VAR reflparam
        VAR color
        VAR rotation
        VAR ctbl
    LET Tu53 (UNIT)
      PUT
        VAR objects
        VAR n
        VAR obj
    LET Tu52 (UNIT)
      IF
        EQ
          VAR form
          INT 3
        LET a (VAR of )
          GET
            VAR abc
            INT 0
        LET Tu50 (UNIT)
          PUT
            VAR abc
            INT 0
            IF
              FZero?
                VAR a
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR a
                APP
                  VAR fsqr
                  VAR a
        LET b (VAR of )
          GET
            VAR abc
            INT 1
        LET Tu49 (UNIT)
          PUT
            VAR abc
            INT 1
            IF
              FZero?
                VAR b
              FLOAT 0.
              FDIV
                APP
                  VAR sgn
                  VAR b
                APP
                  VAR fsqr
                  VAR b
        LET c (VAR of )
          GET
            VAR abc
            INT 2
        PUT
          VAR abc
          INT 2
          IF
            FZero?
              VAR c
            FLOAT 0.
            FDIV
              APP
                VAR sgn
                VAR c
              APP
                VAR fsqr
                VAR c
        IF
          EQ
            VAR form
            INT 2
          APP
            VAR vecunit_sgn
            VAR abc
            NOT
              VAR m_invert
          UNIT
    LET Tu51 (UNIT)
      IF
        NOT
          EQ
            VAR isrot_p
            INT 0
        APP
          VAR rotate_quadratic_matrix
          VAR abc
          VAR rotation
        UNIT
    BOOL true
    BOOL false
LETREC read_object (VAR of )
  (n : VAR of )
  IF
    NOT
      LE
        INT 60
        VAR n
    IF
      APP
        VAR read_nth_object
        VAR n
      APP
        VAR read_object
        ADD
          VAR n
          INT 1
      PUT
        VAR n_objects
        INT 0
        VAR n
    UNIT
LETREC read_all_object (VAR of )
  (Tu66 : VAR of )
  APP
    VAR read_object
    INT 0
LETREC read_net_item (VAR of )
  (length : VAR of )
  LET item (VAR of )
    UNKNOWN APP      inint
      UNIT
  IF
    EQ
      VAR item
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      NEG
        INT 1
    LET v (VAR of )
      APP
        VAR read_net_item
        ADD
          VAR length
          INT 1
    LET Tu67 (UNIT)
      PUT
        VAR v
        VAR length
        VAR item
    VAR v
LETREC read_or_network (VAR of )
  (length : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    ARRAY
      ADD
        VAR length
        INT 1
      VAR net
    LET v (VAR of )
      APP
        VAR read_or_network
        ADD
          VAR length
          INT 1
    LET Tu68 (UNIT)
      PUT
        VAR v
        VAR length
        VAR net
    VAR v
LETREC read_and_network (VAR of )
  (n : VAR of )
  LET net (VAR of )
    APP
      VAR read_net_item
      INT 0
  IF
    EQ
      GET
        VAR net
        INT 0
      NEG
        INT 1
    UNIT
    LET Tu69 (UNIT)
      PUT
        VAR and_net
        VAR n
        VAR net
    APP
      VAR read_and_network
      ADD
        VAR n
        INT 1
LETREC read_parameter (VAR of )
  (Tu70 : VAR of )
  LET Tu74 (UNIT)
    APP
      VAR read_screen_settings
      UNIT
  LET Tu73 (UNIT)
    APP
      VAR read_light
      UNIT
  LET Tu72 (UNIT)
    APP
      VAR read_all_object
      UNIT
  LET Tu71 (UNIT)
    APP
      VAR read_and_network
      INT 0
  PUT
    VAR or_net
    INT 0
    APP
      VAR read_or_network
      INT 0
LETREC solver_rect_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of ), (i0 : VAR of ), (i1 : VAR of ), (i2 : VAR of )
  IF
    FZero?
      GET
        VAR dirvec
        VAR i0
    BOOL false
    LET abc (VAR of )
      APP
        VAR o_param_abc
        VAR m
    LET d (VAR of )
      APP
        VAR fneg_cond
        APP
          VAR xor
          APP
            VAR o_isinvert
            VAR m
          APP
            VAR fisneg
            GET
              VAR dirvec
              VAR i0
        GET
          VAR abc
          VAR i0
    LET d2 (VAR of )
      FDIV
        FSUB
          VAR d
          VAR b0
        GET
          VAR dirvec
          VAR i0
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d2
              GET
                VAR dirvec
                VAR i1
            VAR b1
        GET
          VAR abc
          VAR i1
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d2
                GET
                  VAR dirvec
                  VAR i2
              VAR b2
          GET
            VAR abc
            VAR i2
        LET Tu75 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        BOOL true
        BOOL false
      BOOL false
LETREC solver_rect (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR solver_rect_surface
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
      INT 0
      INT 1
      INT 2
    INT 1
    IF
      APP
        VAR solver_rect_surface
        VAR m
        VAR dirvec
        VAR b1
        VAR b2
        VAR b0
        INT 1
        INT 2
        INT 0
      INT 2
      IF
        APP
          VAR solver_rect_surface
          VAR m
          VAR dirvec
          VAR b2
          VAR b0
          VAR b1
          INT 2
          INT 0
          INT 1
        INT 3
        INT 0
LETREC solver_surface (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET abc (VAR of )
    APP
      VAR o_param_abc
      VAR m
  LET d (VAR of )
    APP
      VAR veciprod
      VAR dirvec
      VAR abc
  IF
    APP
      VAR fispos
      VAR d
    LET Tu76 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FDIV
          APP
            VAR fneg
            APP
              VAR veciprod2
              VAR abc
              VAR b0
              VAR b1
              VAR b2
          VAR d
    INT 1
    INT 0
LETREC quadratic (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          APP
            VAR fsqr
            VAR v0
          APP
            VAR o_param_a
            VAR m
        FMUL
          APP
            VAR fsqr
            VAR v1
          APP
            VAR o_param_b
            VAR m
      FMUL
        APP
          VAR fsqr
          VAR v2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      FADD
        FADD
          VAR diag_part
          FMUL
            FMUL
              VAR v1
              VAR v2
            APP
              VAR o_param_r1
              VAR m
        FMUL
          FMUL
            VAR v2
            VAR v0
          APP
            VAR o_param_r2
            VAR m
      FMUL
        FMUL
          VAR v0
          VAR v1
        APP
          VAR o_param_r3
          VAR m
LETREC bilinear (VAR of )
  (m : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of ), (w0 : VAR of ), (w1 : VAR of ), (w2 : VAR of )
  LET diag_part (VAR of )
    FADD
      FADD
        FMUL
          FMUL
            VAR v0
            VAR w0
          APP
            VAR o_param_a
            VAR m
        FMUL
          FMUL
            VAR v1
            VAR w1
          APP
            VAR o_param_b
            VAR m
      FMUL
        FMUL
          VAR v2
          VAR w2
        APP
          VAR o_param_c
          VAR m
  IF
    EQ
      APP
        VAR o_isrot
        VAR m
      INT 0
    VAR diag_part
    FADD
      VAR diag_part
      APP
        VAR fhalf
        FADD
          FADD
            FMUL
              FADD
                FMUL
                  VAR v2
                  VAR w1
                FMUL
                  VAR v1
                  VAR w2
              APP
                VAR o_param_r1
                VAR m
            FMUL
              FADD
                FMUL
                  VAR v0
                  VAR w2
                FMUL
                  VAR v2
                  VAR w0
              APP
                VAR o_param_r2
                VAR m
          FMUL
            FADD
              FMUL
                VAR v0
                VAR w1
              FMUL
                VAR v1
                VAR w0
            APP
              VAR o_param_r3
              VAR m
LETREC solver_second (VAR of )
  (m : VAR of ), (dirvec : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR dirvec
        INT 0
      GET
        VAR dirvec
        INT 1
      GET
        VAR dirvec
        INT 2
  IF
    FZero?
      VAR aa
    INT 0
    LET bb (VAR of )
      APP
        VAR bilinear
        VAR m
        GET
          VAR dirvec
          INT 0
        GET
          VAR dirvec
          INT 1
        GET
          VAR dirvec
          INT 2
        VAR b0
        VAR b1
        VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET sd (VAR of )
        APP
          VAR sqrt
          VAR d
      LET t1 (VAR of )
        IF
          APP
            VAR o_isinvert
            VAR m
          VAR sd
          APP
            VAR fneg
            VAR sd
      LET Tu77 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          FDIV
            FSUB
              VAR t1
              VAR bb
            VAR aa
      INT 1
      INT 0
LETREC solver (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect
      VAR m
      VAR dirvec
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second
        VAR m
        VAR dirvec
        VAR b0
        VAR b1
        VAR b2
LETREC solver_rect_fast (VAR of )
  (m : VAR of ), (v : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET d0 (VAR of )
    FMUL
      FSUB
        GET
          VAR dconst
          INT 0
        VAR b0
      GET
        VAR dconst
        INT 1
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          FADD
            FMUL
              VAR d0
              GET
                VAR v
                INT 1
            VAR b1
        APP
          VAR o_param_b
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d0
                GET
                  VAR v
                  INT 2
              VAR b2
          APP
            VAR o_param_c
            VAR m
        NOT
          FZero?
            GET
              VAR dconst
              INT 1
        BOOL false
      BOOL false
    LET Tu78 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        VAR d0
    INT 1
    LET d1 (VAR of )
      FMUL
        FSUB
          GET
            VAR dconst
            INT 2
          VAR b1
        GET
          VAR dconst
          INT 3
    IF
      IF
        APP
          VAR fless
          APP
            VAR fabs
            FADD
              FMUL
                VAR d1
                GET
                  VAR v
                  INT 0
              VAR b0
          APP
            VAR o_param_a
            VAR m
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d1
                  GET
                    VAR v
                    INT 2
                VAR b2
            APP
              VAR o_param_c
              VAR m
          NOT
            FZero?
              GET
                VAR dconst
                INT 3
          BOOL false
        BOOL false
      LET Tu79 (UNIT)
        PUT
          VAR solver_dist
          INT 0
          VAR d1
      INT 2
      LET d2 (VAR of )
        FMUL
          FSUB
            GET
              VAR dconst
              INT 4
            VAR b2
          GET
            VAR dconst
            INT 5
      IF
        IF
          APP
            VAR fless
            APP
              VAR fabs
              FADD
                FMUL
                  VAR d2
                  GET
                    VAR v
                    INT 0
                VAR b0
            APP
              VAR o_param_a
              VAR m
          IF
            APP
              VAR fless
              APP
                VAR fabs
                FADD
                  FMUL
                    VAR d2
                    GET
                      VAR v
                      INT 1
                  VAR b1
              APP
                VAR o_param_b
                VAR m
            NOT
              FZero?
                GET
                  VAR dconst
                  INT 5
            BOOL false
          BOOL false
        LET Tu80 (UNIT)
          PUT
            VAR solver_dist
            INT 0
            VAR d2
        INT 3
        INT 0
LETREC solver_surface_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu81 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FADD
          FADD
            FMUL
              GET
                VAR dconst
                INT 1
              VAR b0
            FMUL
              GET
                VAR dconst
                INT 2
              VAR b1
          FMUL
            GET
              VAR dconst
              INT 3
            VAR b2
    INT 1
    INT 0
LETREC solver_second_fast (VAR of )
  (m : VAR of ), (dconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc0 (VAR of )
      APP
        VAR quadratic
        VAR m
        VAR b0
        VAR b1
        VAR b2
    LET cc (VAR of )
      IF
        EQ
          APP
            VAR o_form
            VAR m
          INT 3
        FSUB
          VAR cc0
          FLOAT 1.
        VAR cc0
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu82 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast (VAR of )
  (index : VAR of ), (dirvec : VAR of ), (org : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET b0 (VAR of )
    FSUB
      GET
        VAR org
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET b1 (VAR of )
    FSUB
      GET
        VAR org
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET b2 (VAR of )
    FSUB
      GET
        VAR org
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast
        VAR m
        VAR dconst
        VAR b0
        VAR b1
        VAR b2
LETREC solver_surface_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  IF
    APP
      VAR fisneg
      GET
        VAR dconst
        INT 0
    LET Tu83 (UNIT)
      PUT
        VAR solver_dist
        INT 0
        FMUL
          GET
            VAR dconst
            INT 0
          GET
            VAR sconst
            INT 3
    INT 1
    INT 0
LETREC solver_second_fast2 (VAR of )
  (m : VAR of ), (dconst : VAR of ), (sconst : VAR of ), (b0 : VAR of ), (b1 : VAR of ), (b2 : VAR of )
  LET aa (VAR of )
    GET
      VAR dconst
      INT 0
  IF
    FZero?
      VAR aa
    INT 0
    LET neg_bb (VAR of )
      FADD
        FADD
          FMUL
            GET
              VAR dconst
              INT 1
            VAR b0
          FMUL
            GET
              VAR dconst
              INT 2
            VAR b1
        FMUL
          GET
            VAR dconst
            INT 3
          VAR b2
    LET cc (VAR of )
      GET
        VAR sconst
        INT 3
    LET d (VAR of )
      FSUB
        APP
          VAR fsqr
          VAR neg_bb
        FMUL
          VAR aa
          VAR cc
    IF
      APP
        VAR fispos
        VAR d
      LET Tu84 (UNIT)
        IF
          APP
            VAR o_isinvert
            VAR m
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FADD
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
          PUT
            VAR solver_dist
            INT 0
            FMUL
              FSUB
                VAR neg_bb
                APP
                  VAR sqrt
                  VAR d
              GET
                VAR dconst
                INT 4
      INT 1
      INT 0
LETREC solver_fast2 (VAR of )
  (index : VAR of ), (dirvec : VAR of )
  LET m (VAR of )
    GET
      VAR objects
      VAR index
  LET sconst (VAR of )
    APP
      VAR o_param_ctbl
      VAR m
  LET b0 (VAR of )
    GET
      VAR sconst
      INT 0
  LET b1 (VAR of )
    GET
      VAR sconst
      INT 1
  LET b2 (VAR of )
    GET
      VAR sconst
      INT 2
  LET dconsts (VAR of )
    APP
      VAR d_const
      VAR dirvec
  LET dconst (VAR of )
    GET
      VAR dconsts
      VAR index
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR solver_rect_fast
      VAR m
      APP
        VAR d_vec
        VAR dirvec
      VAR dconst
      VAR b0
      VAR b1
      VAR b2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR solver_surface_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
      APP
        VAR solver_second_fast2
        VAR m
        VAR dconst
        VAR sconst
        VAR b0
        VAR b1
        VAR b2
LETREC setup_rect_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 6
      FLOAT 0.
  LET Tu90 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 0
      PUT
        VAR const
        INT 1
        FLOAT 0.
      LET Tu85 (UNIT)
        PUT
          VAR const
          INT 0
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 0
            APP
              VAR o_param_a
              VAR m
      PUT
        VAR const
        INT 1
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 0
  LET Tu89 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 1
      PUT
        VAR const
        INT 3
        FLOAT 0.
      LET Tu86 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 1
            APP
              VAR o_param_b
              VAR m
      PUT
        VAR const
        INT 3
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 1
  LET Tu88 (UNIT)
    IF
      FZero?
        GET
          VAR vec
          INT 2
      PUT
        VAR const
        INT 5
        FLOAT 0.
      LET Tu87 (UNIT)
        PUT
          VAR const
          INT 4
          APP
            VAR fneg_cond
            APP
              VAR xor
              APP
                VAR o_isinvert
                VAR m
              APP
                VAR fisneg
                GET
                  VAR vec
                  INT 2
            APP
              VAR o_param_c
              VAR m
      PUT
        VAR const
        INT 5
        FDIV
          FLOAT 1.
          GET
            VAR vec
            INT 2
  VAR const
LETREC setup_surface_table (VAR of )
  (vec : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 4
      FLOAT 0.
  LET d (VAR of )
    FADD
      FADD
        FMUL
          GET
            VAR vec
            INT 0
          APP
            VAR o_param_a
            VAR m
        FMUL
          GET
            VAR vec
            INT 1
          APP
            VAR o_param_b
            VAR m
      FMUL
        GET
          VAR vec
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu94 (UNIT)
    IF
      APP
        VAR fispos
        VAR d
      LET Tu93 (UNIT)
        PUT
          VAR const
          INT 0
          FDIV
            FLOAT -1.
            VAR d
      LET Tu92 (UNIT)
        PUT
          VAR const
          INT 1
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_a
                VAR m
              VAR d
      LET Tu91 (UNIT)
        PUT
          VAR const
          INT 2
          APP
            VAR fneg
            FDIV
              APP
                VAR o_param_b
                VAR m
              VAR d
      PUT
        VAR const
        INT 3
        APP
          VAR fneg
          FDIV
            APP
              VAR o_param_c
              VAR m
            VAR d
      PUT
        VAR const
        INT 0
        FLOAT 0.
  VAR const
LETREC setup_second_table (VAR of )
  (v : VAR of ), (m : VAR of )
  LET const (VAR of )
    ARRAY
      INT 5
      FLOAT 0.
  LET aa (VAR of )
    APP
      VAR quadratic
      VAR m
      GET
        VAR v
        INT 0
      GET
        VAR v
        INT 1
      GET
        VAR v
        INT 2
  LET c1 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 0
        APP
          VAR o_param_a
          VAR m
  LET c2 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 1
        APP
          VAR o_param_b
          VAR m
  LET c3 (VAR of )
    APP
      VAR fneg
      FMUL
        GET
          VAR v
          INT 2
        APP
          VAR o_param_c
          VAR m
  LET Tu101 (UNIT)
    PUT
      VAR const
      INT 0
      VAR aa
  LET Tu100 (UNIT)
    IF
      NOT
        EQ
          APP
            VAR o_isrot
            VAR m
          INT 0
      LET Tu96 (UNIT)
        PUT
          VAR const
          INT 1
          FSUB
            VAR c1
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r2
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 1
                  APP
                    VAR o_param_r3
                    VAR m
      LET Tu95 (UNIT)
        PUT
          VAR const
          INT 2
          FSUB
            VAR c2
            APP
              VAR fhalf
              FADD
                FMUL
                  GET
                    VAR v
                    INT 2
                  APP
                    VAR o_param_r1
                    VAR m
                FMUL
                  GET
                    VAR v
                    INT 0
                  APP
                    VAR o_param_r3
                    VAR m
      PUT
        VAR const
        INT 3
        FSUB
          VAR c3
          APP
            VAR fhalf
            FADD
              FMUL
                GET
                  VAR v
                  INT 1
                APP
                  VAR o_param_r1
                  VAR m
              FMUL
                GET
                  VAR v
                  INT 0
                APP
                  VAR o_param_r2
                  VAR m
      LET Tu98 (UNIT)
        PUT
          VAR const
          INT 1
          VAR c1
      LET Tu97 (UNIT)
        PUT
          VAR const
          INT 2
          VAR c2
      PUT
        VAR const
        INT 3
        VAR c3
  LET Tu99 (UNIT)
    IF
      NOT
        FZero?
          VAR aa
      PUT
        VAR const
        INT 4
        FDIV
          FLOAT 1.
          VAR aa
      UNIT
  VAR const
LETREC iter_setup_dirvec_constants (VAR of )
  (dirvec : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET m (VAR of )
      GET
        VAR objects
        VAR index
    LET dconst (VAR of )
      APP
        VAR d_const
        VAR dirvec
    LET v (VAR of )
      APP
        VAR d_vec
        VAR dirvec
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR m
    LET Tu102 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 1
        PUT
          VAR dconst
          VAR index
          APP
            VAR setup_rect_table
            VAR v
            VAR m
        IF
          EQ
            VAR m_shape
            INT 2
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_surface_table
              VAR v
              VAR m
          PUT
            VAR dconst
            VAR index
            APP
              VAR setup_second_table
              VAR v
              VAR m
    APP
      VAR iter_setup_dirvec_constants
      VAR dirvec
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_dirvec_constants (VAR of )
  (dirvec : VAR of )
  APP
    VAR iter_setup_dirvec_constants
    VAR dirvec
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC setup_startp_constants (VAR of )
  (p : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET obj (VAR of )
      GET
        VAR objects
        VAR index
    LET sconst (VAR of )
      APP
        VAR o_param_ctbl
        VAR obj
    LET m_shape (VAR of )
      APP
        VAR o_form
        VAR obj
    LET Tu106 (UNIT)
      PUT
        VAR sconst
        INT 0
        FSUB
          GET
            VAR p
            INT 0
          APP
            VAR o_param_x
            VAR obj
    LET Tu105 (UNIT)
      PUT
        VAR sconst
        INT 1
        FSUB
          GET
            VAR p
            INT 1
          APP
            VAR o_param_y
            VAR obj
    LET Tu104 (UNIT)
      PUT
        VAR sconst
        INT 2
        FSUB
          GET
            VAR p
            INT 2
          APP
            VAR o_param_z
            VAR obj
    LET Tu103 (UNIT)
      IF
        EQ
          VAR m_shape
          INT 2
        PUT
          VAR sconst
          INT 3
          APP
            VAR veciprod2
            APP
              VAR o_param_abc
              VAR obj
            GET
              VAR sconst
              INT 0
            GET
              VAR sconst
              INT 1
            GET
              VAR sconst
              INT 2
        IF
          NOT
            LE
              VAR m_shape
              INT 2
          LET cc0 (VAR of )
            APP
              VAR quadratic
              VAR obj
              GET
                VAR sconst
                INT 0
              GET
                VAR sconst
                INT 1
              GET
                VAR sconst
                INT 2
          PUT
            VAR sconst
            INT 3
            IF
              EQ
                VAR m_shape
                INT 3
              FSUB
                VAR cc0
                FLOAT 1.
              VAR cc0
          UNIT
    APP
      VAR setup_startp_constants
      VAR p
      SUB
        VAR index
        INT 1
    UNIT
LETREC setup_startp (VAR of )
  (p : VAR of )
  LET Tu107 (UNIT)
    APP
      VAR veccpy
      VAR startp_fast
      VAR p
  APP
    VAR setup_startp_constants
    VAR p
    SUB
      GET
        VAR n_objects
        INT 0
      INT 1
LETREC is_rect_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  IF
    IF
      APP
        VAR fless
        APP
          VAR fabs
          VAR p0
        APP
          VAR o_param_a
          VAR m
      IF
        APP
          VAR fless
          APP
            VAR fabs
            VAR p1
          APP
            VAR o_param_b
            VAR m
        APP
          VAR fless
          APP
            VAR fabs
            VAR p2
          APP
            VAR o_param_c
            VAR m
        BOOL false
      BOOL false
    APP
      VAR o_isinvert
      VAR m
    NOT
      APP
        VAR o_isinvert
        VAR m
LETREC is_plane_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR veciprod2
      APP
        VAR o_param_abc
        VAR m
      VAR p0
      VAR p1
      VAR p2
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w
LETREC is_second_outside (VAR of )
  (m : VAR of ), (p0 : VAR of ), (p1 : VAR of ), (p2 : VAR of )
  LET w (VAR of )
    APP
      VAR quadratic
      VAR m
      VAR p0
      VAR p1
      VAR p2
  LET w2 (VAR of )
    IF
      EQ
        APP
          VAR o_form
          VAR m
        INT 3
      FSUB
        VAR w
        FLOAT 1.
      VAR w
  NOT
    APP
      VAR xor
      APP
        VAR o_isinvert
        VAR m
      APP
        VAR fisneg
        VAR w2
LETREC is_outside (VAR of )
  (m : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET p0 (VAR of )
    FSUB
      VAR q0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      VAR q1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      VAR q2
      APP
        VAR o_param_z
        VAR m
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR is_rect_outside
      VAR m
      VAR p0
      VAR p1
      VAR p2
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR is_plane_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
      APP
        VAR is_second_outside
        VAR m
        VAR p0
        VAR p1
        VAR p2
LETREC check_all_inside (VAR of )
  (ofs : VAR of ), (iand : VAR of ), (q0 : VAR of ), (q1 : VAR of ), (q2 : VAR of )
  LET head (VAR of )
    GET
      VAR iand
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL true
    IF
      APP
        VAR is_outside
        GET
          VAR objects
          VAR head
        VAR q0
        VAR q1
        VAR q2
      BOOL false
      APP
        VAR check_all_inside
        ADD
          VAR ofs
          INT 1
        VAR iand
        VAR q0
        VAR q1
        VAR q2
LETREC shadow_check_and_group (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of )
  IF
    EQ
      GET
        VAR and_group
        VAR iand_ofs
      NEG
        INT 1
    BOOL false
    LET obj (VAR of )
      GET
        VAR and_group
        VAR iand_ofs
    LET t0 (VAR of )
      APP
        VAR solver_fast
        VAR obj
        VAR light_dirvec
        VAR intersection_point
    LET t0p (VAR of )
      GET
        VAR solver_dist
        INT 0
    IF
      IF
        NOT
          EQ
            VAR t0
            INT 0
        APP
          VAR fless
          VAR t0p
          FLOAT -0.2
        BOOL false
      LET t (VAR of )
        FADD
          VAR t0p
          FLOAT 0.01
      LET q0 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 0
            VAR t
          GET
            VAR intersection_point
            INT 0
      LET q1 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 1
            VAR t
          GET
            VAR intersection_point
            INT 1
      LET q2 (VAR of )
        FADD
          FMUL
            GET
              VAR light
              INT 2
            VAR t
          GET
            VAR intersection_point
            INT 2
      IF
        APP
          VAR check_all_inside
          INT 0
          VAR and_group
          VAR q0
          VAR q1
          VAR q2
        BOOL true
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR obj
        APP
          VAR shadow_check_and_group
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
        BOOL false
LETREC shadow_check_one_or_group (VAR of )
  (ofs : VAR of ), (or_group : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    EQ
      VAR head
      NEG
        INT 1
    BOOL false
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET shadow_p (VAR of )
      APP
        VAR shadow_check_and_group
        INT 0
        VAR and_group
    IF
      VAR shadow_p
      BOOL true
      APP
        VAR shadow_check_one_or_group
        ADD
          VAR ofs
          INT 1
        VAR or_group
LETREC shadow_check_one_or_matrix (VAR of )
  (ofs : VAR of ), (or_matrix : VAR of )
  LET head (VAR of )
    GET
      VAR or_matrix
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    BOOL false
    IF
      IF
        EQ
          VAR range_primitive
          INT 99
        BOOL true
        LET t (VAR of )
          APP
            VAR solver_fast
            VAR range_primitive
            VAR light_dirvec
            VAR intersection_point
        IF
          NOT
            EQ
              VAR t
              INT 0
          IF
            APP
              VAR fless
              GET
                VAR solver_dist
                INT 0
              FLOAT -0.1
            IF
              APP
                VAR shadow_check_one_or_group
                INT 1
                VAR head
              BOOL true
              BOOL false
            BOOL false
          BOOL false
      IF
        APP
          VAR shadow_check_one_or_group
          INT 1
          VAR head
        BOOL true
        APP
          VAR shadow_check_one_or_matrix
          ADD
            VAR ofs
            INT 1
          VAR or_matrix
      APP
        VAR shadow_check_one_or_matrix
        ADD
          VAR ofs
          INT 1
        VAR or_matrix
LETREC solve_each_element (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver
        VAR iobj
        VAR dirvec
        VAR startp
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu111 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 0
                  VAR t
                GET
                  VAR startp
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 1
                  VAR t
                GET
                  VAR startp
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR dirvec
                    INT 2
                  VAR t
                GET
                  VAR startp
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu110 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu109 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu108 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu112 (UNIT)
      APP
        VAR solve_each_element
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu113 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver
            VAR range_primitive
            VAR dirvec
            VAR startp
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection (VAR of )
  (dirvec : VAR of )
  LET Tu115 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu114 (UNIT)
    APP
      VAR trace_or_matrix
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC solve_each_element_fast (VAR of )
  (iand_ofs : VAR of ), (and_group : VAR of ), (dirvec : VAR of )
  LET vec (VAR of )
    APP
      VAR d_vec
      VAR dirvec
  LET iobj (VAR of )
    GET
      VAR and_group
      VAR iand_ofs
  IF
    EQ
      VAR iobj
      NEG
        INT 1
    UNIT
    LET t0 (VAR of )
      APP
        VAR solver_fast2
        VAR iobj
        VAR dirvec
    IF
      NOT
        EQ
          VAR t0
          INT 0
      LET t0p (VAR of )
        GET
          VAR solver_dist
          INT 0
      LET Tu119 (UNIT)
        IF
          APP
            VAR fless
            FLOAT 0.
            VAR t0p
          IF
            APP
              VAR fless
              VAR t0p
              GET
                VAR tmin
                INT 0
            LET t (VAR of )
              FADD
                VAR t0p
                FLOAT 0.01
            LET q0 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 0
                  VAR t
                GET
                  VAR startp_fast
                  INT 0
            LET q1 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 1
                  VAR t
                GET
                  VAR startp_fast
                  INT 1
            LET q2 (VAR of )
              FADD
                FMUL
                  GET
                    VAR vec
                    INT 2
                  VAR t
                GET
                  VAR startp_fast
                  INT 2
            IF
              APP
                VAR check_all_inside
                INT 0
                VAR and_group
                VAR q0
                VAR q1
                VAR q2
              LET Tu118 (UNIT)
                PUT
                  VAR tmin
                  INT 0
                  VAR t
              LET Tu117 (UNIT)
                APP
                  VAR vecset
                  VAR intersection_point
                  VAR q0
                  VAR q1
                  VAR q2
              LET Tu116 (UNIT)
                PUT
                  VAR intersected_object_id
                  INT 0
                  VAR iobj
              PUT
                VAR intsec_rectside
                INT 0
                VAR t0
              UNIT
            UNIT
          UNIT
      APP
        VAR solve_each_element_fast
        ADD
          VAR iand_ofs
          INT 1
        VAR and_group
        VAR dirvec
      IF
        APP
          VAR o_isinvert
          GET
            VAR objects
            VAR iobj
        APP
          VAR solve_each_element_fast
          ADD
            VAR iand_ofs
            INT 1
          VAR and_group
          VAR dirvec
        UNIT
LETREC solve_one_or_network_fast (VAR of )
  (ofs : VAR of ), (or_group : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_group
      VAR ofs
  IF
    NOT
      EQ
        VAR head
        NEG
          INT 1
    LET and_group (VAR of )
      GET
        VAR and_net
        VAR head
    LET Tu120 (UNIT)
      APP
        VAR solve_each_element_fast
        INT 0
        VAR and_group
        VAR dirvec
    APP
      VAR solve_one_or_network_fast
      ADD
        VAR ofs
        INT 1
      VAR or_group
      VAR dirvec
    UNIT
LETREC trace_or_matrix_fast (VAR of )
  (ofs : VAR of ), (or_network : VAR of ), (dirvec : VAR of )
  LET head (VAR of )
    GET
      VAR or_network
      VAR ofs
  LET range_primitive (VAR of )
    GET
      VAR head
      INT 0
  IF
    EQ
      VAR range_primitive
      NEG
        INT 1
    UNIT
    LET Tu121 (UNIT)
      IF
        EQ
          VAR range_primitive
          INT 99
        APP
          VAR solve_one_or_network_fast
          INT 1
          VAR head
          VAR dirvec
        LET t (VAR of )
          APP
            VAR solver_fast2
            VAR range_primitive
            VAR dirvec
        IF
          NOT
            EQ
              VAR t
              INT 0
          LET tp (VAR of )
            GET
              VAR solver_dist
              INT 0
          IF
            APP
              VAR fless
              VAR tp
              GET
                VAR tmin
                INT 0
            APP
              VAR solve_one_or_network_fast
              INT 1
              VAR head
              VAR dirvec
            UNIT
          UNIT
    APP
      VAR trace_or_matrix_fast
      ADD
        VAR ofs
        INT 1
      VAR or_network
      VAR dirvec
LETREC judge_intersection_fast (VAR of )
  (dirvec : VAR of )
  LET Tu123 (UNIT)
    PUT
      VAR tmin
      INT 0
      FLOAT 1000000000.
  LET Tu122 (UNIT)
    APP
      VAR trace_or_matrix_fast
      INT 0
      GET
        VAR or_net
        INT 0
      VAR dirvec
  LET t (VAR of )
    GET
      VAR tmin
      INT 0
  IF
    APP
      VAR fless
      FLOAT -0.1
      VAR t
    APP
      VAR fless
      VAR t
      FLOAT 100000000.
    BOOL false
LETREC get_nvector_rect (VAR of )
  (dirvec : VAR of )
  LET rectside (VAR of )
    GET
      VAR intsec_rectside
      INT 0
  LET Tu124 (UNIT)
    APP
      VAR vecbzero
      VAR nvector
  PUT
    VAR nvector
    SUB
      VAR rectside
      INT 1
    APP
      VAR fneg
      APP
        VAR sgn
        GET
          VAR dirvec
          SUB
            VAR rectside
            INT 1
LETREC get_nvector_plane (VAR of )
  (m : VAR of )
  LET Tu126 (UNIT)
    PUT
      VAR nvector
      INT 0
      APP
        VAR fneg
        APP
          VAR o_param_a
          VAR m
  LET Tu125 (UNIT)
    PUT
      VAR nvector
      INT 1
      APP
        VAR fneg
        APP
          VAR o_param_b
          VAR m
  PUT
    VAR nvector
    INT 2
    APP
      VAR fneg
      APP
        VAR o_param_c
        VAR m
LETREC get_nvector_second (VAR of )
  (m : VAR of )
  LET p0 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 0
      APP
        VAR o_param_x
        VAR m
  LET p1 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 1
      APP
        VAR o_param_y
        VAR m
  LET p2 (VAR of )
    FSUB
      GET
        VAR intersection_point
        INT 2
      APP
        VAR o_param_z
        VAR m
  LET d0 (VAR of )
    FMUL
      VAR p0
      APP
        VAR o_param_a
        VAR m
  LET d1 (VAR of )
    FMUL
      VAR p1
      APP
        VAR o_param_b
        VAR m
  LET d2 (VAR of )
    FMUL
      VAR p2
      APP
        VAR o_param_c
        VAR m
  LET Tu131 (UNIT)
    IF
      EQ
        APP
          VAR o_isrot
          VAR m
        INT 0
      LET Tu128 (UNIT)
        PUT
          VAR nvector
          INT 0
          VAR d0
      LET Tu127 (UNIT)
        PUT
          VAR nvector
          INT 1
          VAR d1
      PUT
        VAR nvector
        INT 2
        VAR d2
      LET Tu130 (UNIT)
        PUT
          VAR nvector
          INT 0
          FADD
            VAR d0
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p1
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r2
                    VAR m
      LET Tu129 (UNIT)
        PUT
          VAR nvector
          INT 1
          FADD
            VAR d1
            APP
              VAR fhalf
              FADD
                FMUL
                  VAR p0
                  APP
                    VAR o_param_r3
                    VAR m
                FMUL
                  VAR p2
                  APP
                    VAR o_param_r1
                    VAR m
      PUT
        VAR nvector
        INT 2
        FADD
          VAR d2
          APP
            VAR fhalf
            FADD
              FMUL
                VAR p0
                APP
                  VAR o_param_r2
                  VAR m
              FMUL
                VAR p1
                APP
                  VAR o_param_r1
                  VAR m
  APP
    VAR vecunit_sgn
    VAR nvector
    APP
      VAR o_isinvert
      VAR m
LETREC get_nvector (VAR of )
  (m : VAR of ), (dirvec : VAR of )
  LET m_shape (VAR of )
    APP
      VAR o_form
      VAR m
  IF
    EQ
      VAR m_shape
      INT 1
    APP
      VAR get_nvector_rect
      VAR dirvec
    IF
      EQ
        VAR m_shape
        INT 2
      APP
        VAR get_nvector_plane
        VAR m
      APP
        VAR get_nvector_second
        VAR m
LETREC utexture (VAR of )
  (m : VAR of ), (p : VAR of )
  LET m_tex (VAR of )
    APP
      VAR o_texturetype
      VAR m
  LET Tu136 (UNIT)
    PUT
      VAR texture_color
      INT 0
      APP
        VAR o_color_red
        VAR m
  LET Tu135 (UNIT)
    PUT
      VAR texture_color
      INT 1
      APP
        VAR o_color_green
        VAR m
  LET Tu134 (UNIT)
    PUT
      VAR texture_color
      INT 2
      APP
        VAR o_color_blue
        VAR m
  IF
    EQ
      VAR m_tex
      INT 1
    LET w1 (VAR of )
      FSUB
        GET
          VAR p
          INT 0
        APP
          VAR o_param_x
          VAR m
    LET flag1 (VAR of )
      LET d1 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w1
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w1
          VAR d1
        FLOAT 10.
    LET w3 (VAR of )
      FSUB
        GET
          VAR p
          INT 2
        APP
          VAR o_param_z
          VAR m
    LET flag2 (VAR of )
      LET d2 (VAR of )
        FMUL
          APP
            VAR floor
            FMUL
              VAR w3
              FLOAT 0.05
          FLOAT 20.
      APP
        VAR fless
        FSUB
          VAR w3
          VAR d2
        FLOAT 10.
    PUT
      VAR texture_color
      INT 1
      IF
        VAR flag1
        IF
          VAR flag2
          FLOAT 255.
          FLOAT 0.
        IF
          VAR flag2
          FLOAT 0.
          FLOAT 255.
    IF
      EQ
        VAR m_tex
        INT 2
      LET w2 (VAR of )
        APP
          VAR fsqr
          APP
            VAR sin
            FMUL
              GET
                VAR p
                INT 1
              FLOAT 0.25
      LET Tu132 (UNIT)
        PUT
          VAR texture_color
          INT 0
          FMUL
            FLOAT 255.
            VAR w2
      PUT
        VAR texture_color
        INT 1
        FMUL
          FLOAT 255.
          FSUB
            FLOAT 1.
            VAR w2
      IF
        EQ
          VAR m_tex
          INT 3
        LET w1 (VAR of )
          FSUB
            GET
              VAR p
              INT 0
            APP
              VAR o_param_x
              VAR m
        LET w3 (VAR of )
          FSUB
            GET
              VAR p
              INT 2
            APP
              VAR o_param_z
              VAR m
        LET w2 (VAR of )
          FDIV
            APP
              VAR sqrt
              FADD
                APP
                  VAR fsqr
                  VAR w1
                APP
                  VAR fsqr
                  VAR w3
            FLOAT 10.
        LET w4 (VAR of )
          FMUL
            FSUB
              VAR w2
              APP
                VAR floor
                VAR w2
            FLOAT 3.1415927
        LET cws (VAR of )
          APP
            VAR fsqr
            APP
              VAR cos
              VAR w4
        LET Tu133 (UNIT)
          PUT
            VAR texture_color
            INT 1
            FMUL
              VAR cws
              FLOAT 255.
        PUT
          VAR texture_color
          INT 2
          FMUL
            FSUB
              FLOAT 1.
              VAR cws
            FLOAT 255.
        IF
          EQ
            VAR m_tex
            INT 4
          LET w1 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 0
                APP
                  VAR o_param_x
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_a
                  VAR m
          LET w3 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 2
                APP
                  VAR o_param_z
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_c
                  VAR m
          LET w4 (VAR of )
            FADD
              APP
                VAR fsqr
                VAR w1
              APP
                VAR fsqr
                VAR w3
          LET w7 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w1
                FLOAT 0.0001
              FLOAT 15.
              LET w5 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w3
                    VAR w1
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w5
                  FLOAT 30.
                FLOAT 3.1415927
          LET w9 (VAR of )
            FSUB
              VAR w7
              APP
                VAR floor
                VAR w7
          LET w2 (VAR of )
            FMUL
              FSUB
                GET
                  VAR p
                  INT 1
                APP
                  VAR o_param_y
                  VAR m
              APP
                VAR sqrt
                APP
                  VAR o_param_b
                  VAR m
          LET w8 (VAR of )
            IF
              APP
                VAR fless
                APP
                  VAR fabs
                  VAR w4
                FLOAT 0.0001
              FLOAT 15.
              LET w6 (VAR of )
                APP
                  VAR fabs
                  FDIV
                    VAR w2
                    VAR w4
              FDIV
                FMUL
                  APP
                    VAR atan
                    VAR w6
                  FLOAT 30.
                FLOAT 3.1415927
          LET w10 (VAR of )
            FSUB
              VAR w8
              APP
                VAR floor
                VAR w8
          LET w11 (VAR of )
            FSUB
              FSUB
                FLOAT 0.15
                APP
                  VAR fsqr
                  FSUB
                    FLOAT 0.5
                    VAR w9
              APP
                VAR fsqr
                FSUB
                  FLOAT 0.5
                  VAR w10
          LET w12 (VAR of )
            IF
              APP
                VAR fisneg
                VAR w11
              FLOAT 0.
              VAR w11
          PUT
            VAR texture_color
            INT 2
            FDIV
              FMUL
                FLOAT 255.
                VAR w12
              FLOAT 0.3
          UNIT
LETREC add_light (VAR of )
  (bright : VAR of ), (hilight : VAR of ), (hilight_scale : VAR of )
  LET Tu139 (UNIT)
    IF
      APP
        VAR fispos
        VAR bright
      APP
        VAR vecaccum
        VAR rgb
        VAR bright
        VAR texture_color
      UNIT
  IF
    APP
      VAR fispos
      VAR hilight
    LET ihl (VAR of )
      FMUL
        APP
          VAR fsqr
          APP
            VAR fsqr
            VAR hilight
        VAR hilight_scale
    LET Tu138 (UNIT)
      PUT
        VAR rgb
        INT 0
        FADD
          GET
            VAR rgb
            INT 0
          VAR ihl
    LET Tu137 (UNIT)
      PUT
        VAR rgb
        INT 1
        FADD
          GET
            VAR rgb
            INT 1
          VAR ihl
    PUT
      VAR rgb
      INT 2
      FADD
        GET
          VAR rgb
          INT 2
        VAR ihl
    UNIT
LETREC trace_reflections (VAR of )
  (index : VAR of ), (diffuse : VAR of ), (hilight_scale : VAR of ), (dirvec : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET rinfo (VAR of )
      GET
        VAR reflections
        VAR index
    LET dvec (VAR of )
      APP
        VAR r_dvec
        VAR rinfo
    LET Tu140 (UNIT)
      IF
        APP
          VAR judge_intersection_fast
          VAR dvec
        LET surface_id (VAR of )
          ADD
            MULTIPLE 4
              GET
                VAR intersected_object_id
                INT 0
            GET
              VAR intsec_rectside
              INT 0
        IF
          EQ
            VAR surface_id
            APP
              VAR r_surface_id
              VAR rinfo
          IF
            NOT
              APP
                VAR shadow_check_one_or_matrix
                INT 0
                GET
                  VAR or_net
                  INT 0
            LET p (VAR of )
              APP
                VAR veciprod
                VAR nvector
                APP
                  VAR d_vec
                  VAR dvec
            LET scale (VAR of )
              APP
                VAR r_bright
                VAR rinfo
            LET bright (VAR of )
              FMUL
                FMUL
                  VAR scale
                  VAR diffuse
                VAR p
            LET hilight (VAR of )
              FMUL
                VAR scale
                APP
                  VAR veciprod
                  VAR dirvec
                  APP
                    VAR d_vec
                    VAR dvec
            APP
              VAR add_light
              VAR bright
              VAR hilight
              VAR hilight_scale
            UNIT
          UNIT
        UNIT
    APP
      VAR trace_reflections
      SUB
        VAR index
        INT 1
      VAR diffuse
      VAR hilight_scale
      VAR dirvec
    UNIT
LETREC trace_ray (VAR of )
  (nref : VAR of ), (energy : VAR of ), (dirvec : VAR of ), (pixel : VAR of ), (dist : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      APP
        VAR judge_intersection
        VAR dirvec
      LET obj_id (VAR of )
        GET
          VAR intersected_object_id
          INT 0
      LET obj (VAR of )
        GET
          VAR objects
          VAR obj_id
      LET m_surface (VAR of )
        APP
          VAR o_reflectiontype
          VAR obj
      LET diffuse (VAR of )
        FMUL
          APP
            VAR o_diffuse
            VAR obj
          VAR energy
      LET Tu154 (UNIT)
        APP
          VAR get_nvector
          VAR obj
          VAR dirvec
      LET Tu153 (UNIT)
        APP
          VAR veccpy
          VAR startp
          VAR intersection_point
      LET Tu152 (UNIT)
        APP
          VAR utexture
          VAR obj
          VAR intersection_point
      LET Tu151 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          ADD
            MULTIPLE 4
              VAR obj_id
            GET
              VAR intsec_rectside
              INT 0
      LET intersection_points (VAR of )
        APP
          VAR p_intersection_points
          VAR pixel
      LET Tu150 (UNIT)
        APP
          VAR veccpy
          GET
            VAR intersection_points
            VAR nref
          VAR intersection_point
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu149 (UNIT)
        IF
          APP
            VAR fless
            APP
              VAR o_diffuse
              VAR obj
            FLOAT 0.5
          PUT
            VAR calc_diffuse
            VAR nref
            BOOL false
          LET Tu143 (UNIT)
            PUT
              VAR calc_diffuse
              VAR nref
              BOOL true
          LET energya (VAR of )
            APP
              VAR p_energy
              VAR pixel
          LET Tu142 (UNIT)
            APP
              VAR veccpy
              GET
                VAR energya
                VAR nref
              VAR texture_color
          LET Tu141 (UNIT)
            APP
              VAR vecscale
              GET
                VAR energya
                VAR nref
              FMUL
                FDIV
                  FLOAT 1.
                  FLOAT 256.
                VAR diffuse
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR nvectors
              VAR nref
            VAR nvector
      LET w (VAR of )
        FMUL
          FLOAT -2.
          APP
            VAR veciprod
            VAR dirvec
            VAR nvector
      LET Tu148 (UNIT)
        APP
          VAR vecaccum
          VAR dirvec
          VAR w
          VAR nvector
      LET hilight_scale (VAR of )
        FMUL
          VAR energy
          APP
            VAR o_hilight
            VAR obj
      LET Tu147 (UNIT)
        IF
          NOT
            APP
              VAR shadow_check_one_or_matrix
              INT 0
              GET
                VAR or_net
                INT 0
          LET bright (VAR of )
            FMUL
              APP
                VAR fneg
                APP
                  VAR veciprod
                  VAR nvector
                  VAR light
              VAR diffuse
          LET hilight (VAR of )
            APP
              VAR fneg
              APP
                VAR veciprod
                VAR dirvec
                VAR light
          APP
            VAR add_light
            VAR bright
            VAR hilight
            VAR hilight_scale
          UNIT
      LET Tu146 (UNIT)
        APP
          VAR setup_startp
          VAR intersection_point
      LET Tu145 (UNIT)
        APP
          VAR trace_reflections
          SUB
            GET
              VAR n_reflections
              INT 0
            INT 1
          VAR diffuse
          VAR hilight_scale
          VAR dirvec
      IF
        APP
          VAR fless
          FLOAT 0.1
          VAR energy
        LET Tu144 (UNIT)
          IF
            NOT
              LE
                INT 4
                VAR nref
            PUT
              VAR surface_ids
              ADD
                VAR nref
                INT 1
              NEG
                INT 1
            UNIT
        IF
          EQ
            VAR m_surface
            INT 2
          LET energy2 (VAR of )
            FMUL
              VAR energy
              FSUB
                FLOAT 1.
                APP
                  VAR o_diffuse
                  VAR obj
          APP
            VAR trace_ray
            ADD
              VAR nref
              INT 1
            VAR energy2
            VAR dirvec
            VAR pixel
            FADD
              VAR dist
              GET
                VAR tmin
                INT 0
          UNIT
        UNIT
      LET Tu157 (UNIT)
        PUT
          VAR surface_ids
          VAR nref
          NEG
            INT 1
      IF
        NOT
          EQ
            VAR nref
            INT 0
        LET hl (VAR of )
          APP
            VAR fneg
            APP
              VAR veciprod
              VAR dirvec
              VAR light
        IF
          APP
            VAR fispos
            VAR hl
          LET ihl (VAR of )
            FMUL
              FMUL
                FMUL
                  APP
                    VAR fsqr
                    VAR hl
                  VAR hl
                VAR energy
              GET
                VAR beam
                INT 0
          LET Tu156 (UNIT)
            PUT
              VAR rgb
              INT 0
              FADD
                GET
                  VAR rgb
                  INT 0
                VAR ihl
          LET Tu155 (UNIT)
            PUT
              VAR rgb
              INT 1
              FADD
                GET
                  VAR rgb
                  INT 1
                VAR ihl
          PUT
            VAR rgb
            INT 2
            FADD
              GET
                VAR rgb
                INT 2
              VAR ihl
          UNIT
        UNIT
    UNIT
LETREC trace_diffuse_ray (VAR of )
  (dirvec : VAR of ), (energy : VAR of )
  IF
    APP
      VAR judge_intersection_fast
      VAR dirvec
    LET obj (VAR of )
      GET
        VAR objects
        GET
          VAR intersected_object_id
          INT 0
    LET Tu159 (UNIT)
      APP
        VAR get_nvector
        VAR obj
        APP
          VAR d_vec
          VAR dirvec
    LET Tu158 (UNIT)
      APP
        VAR utexture
        VAR obj
        VAR intersection_point
    IF
      NOT
        APP
          VAR shadow_check_one_or_matrix
          INT 0
          GET
            VAR or_net
            INT 0
      LET br (VAR of )
        APP
          VAR fneg
          APP
            VAR veciprod
            VAR nvector
            VAR light
      LET bright (VAR of )
        IF
          APP
            VAR fispos
            VAR br
          VAR br
          FLOAT 0.
      APP
        VAR vecaccum
        VAR diffuse_ray
        FMUL
          FMUL
            VAR energy
            VAR bright
          APP
            VAR o_diffuse
            VAR obj
        VAR texture_color
      UNIT
    UNIT
LETREC iter_trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET p (VAR of )
      APP
        VAR veciprod
        APP
          VAR d_vec
          GET
            VAR dirvec_group
            VAR index
        VAR nvector
    LET Tu160 (UNIT)
      IF
        APP
          VAR fisneg
          VAR p
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            ADD
              VAR index
              INT 1
          FDIV
            VAR p
            FLOAT -150.
        APP
          VAR trace_diffuse_ray
          GET
            VAR dirvec_group
            VAR index
          FDIV
            VAR p
            FLOAT 150.
    APP
      VAR iter_trace_diffuse_rays
      VAR dirvec_group
      VAR nvector
      VAR org
      SUB
        VAR index
        INT 2
    UNIT
LETREC trace_diffuse_rays (VAR of )
  (dirvec_group : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu161 (UNIT)
    APP
      VAR setup_startp
      VAR org
  APP
    VAR iter_trace_diffuse_rays
    VAR dirvec_group
    VAR nvector
    VAR org
    INT 118
LETREC trace_diffuse_ray_80percent (VAR of )
  (group_id : VAR of ), (nvector : VAR of ), (org : VAR of )
  LET Tu165 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 0
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 0
        VAR nvector
        VAR org
      UNIT
  LET Tu164 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 1
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 1
        VAR nvector
        VAR org
      UNIT
  LET Tu163 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 2
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 2
        VAR nvector
        VAR org
      UNIT
  LET Tu162 (UNIT)
    IF
      NOT
        EQ
          VAR group_id
          INT 3
      APP
        VAR trace_diffuse_rays
        GET
          VAR dirvecs
          INT 3
        VAR nvector
        VAR org
      UNIT
  IF
    NOT
      EQ
        VAR group_id
        INT 4
    APP
      VAR trace_diffuse_rays
      GET
        VAR dirvecs
        INT 4
      VAR nvector
      VAR org
    UNIT
LETREC calc_diffuse_using_1point (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  LET ray20p (VAR of )
    APP
      VAR p_received_ray_20percent
      VAR pixel
  LET nvectors (VAR of )
    APP
      VAR p_nvectors
      VAR pixel
  LET intersection_points (VAR of )
    APP
      VAR p_intersection_points
      VAR pixel
  LET energya (VAR of )
    APP
      VAR p_energy
      VAR pixel
  LET Tu167 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR ray20p
        VAR nref
  LET Tu166 (UNIT)
    APP
      VAR trace_diffuse_ray_80percent
      APP
        VAR p_group_id
        VAR pixel
      GET
        VAR nvectors
        VAR nref
      GET
        VAR intersection_points
        VAR nref
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC calc_diffuse_using_5points (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET r_up (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR prev
        VAR x
  LET r_left (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        SUB
          VAR x
          INT 1
  LET r_center (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        VAR x
  LET r_right (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR cur
        ADD
          VAR x
          INT 1
  LET r_down (VAR of )
    APP
      VAR p_received_ray_20percent
      GET
        VAR next
        VAR x
  LET Tu172 (UNIT)
    APP
      VAR veccpy
      VAR diffuse_ray
      GET
        VAR r_up
        VAR nref
  LET Tu171 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_left
        VAR nref
  LET Tu170 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_center
        VAR nref
  LET Tu169 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_right
        VAR nref
  LET Tu168 (UNIT)
    APP
      VAR vecadd
      VAR diffuse_ray
      GET
        VAR r_down
        VAR nref
  LET energya (VAR of )
    APP
      VAR p_energy
      GET
        VAR cur
        VAR x
  APP
    VAR vecaccumv
    VAR rgb
    GET
      VAR energya
      VAR nref
    VAR diffuse_ray
LETREC do_without_neighbors (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET surface_ids (VAR of )
      APP
        VAR p_surface_ids
        VAR pixel
    IF
      LE
        INT 0
        GET
          VAR surface_ids
          VAR nref
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu173 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          APP
            VAR calc_diffuse_using_1point
            VAR pixel
            VAR nref
          UNIT
      APP
        VAR do_without_neighbors
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC neighbors_exist (VAR of )
  (x : VAR of ), (y : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        ADD
          VAR y
          INT 1
    IF
      NOT
        LE
          VAR y
          INT 0
      IF
        NOT
          LE
            GET
              VAR image_size
              INT 0
            ADD
              VAR x
              INT 1
        IF
          NOT
            LE
              VAR x
              INT 0
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC get_surface_id (VAR of )
  (pixel : VAR of ), (index : VAR of )
  LET surface_ids (VAR of )
    APP
      VAR p_surface_ids
      VAR pixel
  GET
    VAR surface_ids
    VAR index
LETREC neighbors_are_available (VAR of )
  (x : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET sid_center (VAR of )
    APP
      VAR get_surface_id
      GET
        VAR cur
        VAR x
      VAR nref
  IF
    EQ
      APP
        VAR get_surface_id
        GET
          VAR prev
          VAR x
        VAR nref
      VAR sid_center
    IF
      EQ
        APP
          VAR get_surface_id
          GET
            VAR next
            VAR x
          VAR nref
        VAR sid_center
      IF
        EQ
          APP
            VAR get_surface_id
            GET
              VAR cur
              SUB
                VAR x
                INT 1
            VAR nref
          VAR sid_center
        IF
          EQ
            APP
              VAR get_surface_id
              GET
                VAR cur
                ADD
                  VAR x
                  INT 1
              VAR nref
            VAR sid_center
          BOOL true
          BOOL false
        BOOL false
      BOOL false
    BOOL false
LETREC try_exploit_neighbors (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (nref : VAR of )
  LET pixel (VAR of )
    GET
      VAR cur
      VAR x
  IF
    LE
      VAR nref
      INT 4
    IF
      LE
        INT 0
        APP
          VAR get_surface_id
          VAR pixel
          VAR nref
      IF
        APP
          VAR neighbors_are_available
          VAR x
          VAR prev
          VAR cur
          VAR next
          VAR nref
        LET calc_diffuse (VAR of )
          APP
            VAR p_calc_diffuse
            VAR pixel
        LET Tu174 (UNIT)
          IF
            GET
              VAR calc_diffuse
              VAR nref
            APP
              VAR calc_diffuse_using_5points
              VAR x
              VAR prev
              VAR cur
              VAR next
              VAR nref
            UNIT
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          ADD
            VAR nref
            INT 1
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          VAR nref
      UNIT
    UNIT
LETREC write_ppm_header (VAR of )
  (Tu175 : VAR of )
  LET Tu183 (UNIT)
    APP
      VAR print_char
      INT 80
  LET Tu182 (UNIT)
    APP
      VAR print_char
      ADD
        INT 48
        INT 3
  LET Tu181 (UNIT)
    APP
      VAR print_char
      INT 10
  LET Tu180 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 0
  LET Tu179 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu178 (UNIT)
    APP
      VAR print_int
      GET
        VAR image_size
        INT 1
  LET Tu177 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu176 (UNIT)
    APP
      VAR print_int
      INT 255
  APP
    VAR print_char
    INT 10
LETREC write_rgb_element (VAR of )
  (x : VAR of )
  LET ix (VAR of )
    float_to_int
      VAR x
  LET elem (VAR of )
    IF
      NOT
        LE
          VAR ix
          INT 255
      INT 255
      IF
        NOT
          LE
            INT 0
            VAR ix
        INT 0
        VAR ix
  APP
    VAR print_int
    VAR elem
LETREC write_rgb (VAR of )
  (Tu184 : VAR of )
  LET Tu189 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 0
  LET Tu188 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu187 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 1
  LET Tu186 (UNIT)
    APP
      VAR print_char
      INT 32
  LET Tu185 (UNIT)
    APP
      VAR write_rgb_element
      GET
        VAR rgb
        INT 2
  APP
    VAR print_char
    INT 10
LETREC pretrace_diffuse_rays (VAR of )
  (pixel : VAR of ), (nref : VAR of )
  IF
    LE
      VAR nref
      INT 4
    LET sid (VAR of )
      APP
        VAR get_surface_id
        VAR pixel
        VAR nref
    IF
      LE
        INT 0
        VAR sid
      LET calc_diffuse (VAR of )
        APP
          VAR p_calc_diffuse
          VAR pixel
      LET Tu192 (UNIT)
        IF
          GET
            VAR calc_diffuse
            VAR nref
          LET group_id (VAR of )
            APP
              VAR p_group_id
              VAR pixel
          LET Tu191 (UNIT)
            APP
              VAR vecbzero
              VAR diffuse_ray
          LET nvectors (VAR of )
            APP
              VAR p_nvectors
              VAR pixel
          LET intersection_points (VAR of )
            APP
              VAR p_intersection_points
              VAR pixel
          LET Tu190 (UNIT)
            APP
              VAR trace_diffuse_rays
              GET
                VAR dirvecs
                VAR group_id
              GET
                VAR nvectors
                VAR nref
              GET
                VAR intersection_points
                VAR nref
          LET ray20p (VAR of )
            APP
              VAR p_received_ray_20percent
              VAR pixel
          APP
            VAR veccpy
            GET
              VAR ray20p
              VAR nref
            VAR diffuse_ray
          UNIT
      APP
        VAR pretrace_diffuse_rays
        VAR pixel
        ADD
          VAR nref
          INT 1
      UNIT
    UNIT
LETREC pretrace_pixels (VAR of )
  (line : VAR of ), (x : VAR of ), (group_id : VAR of ), (lc0 : VAR of ), (lc1 : VAR of ), (lc2 : VAR of )
  IF
    LE
      INT 0
      VAR x
    LET xdisp (VAR of )
      FMUL
        GET
          VAR scan_pitch
          INT 0
        int_to_float
          SUB
            VAR x
            GET
              VAR image_center
              INT 0
    LET Tu202 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 0
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 0
          VAR lc0
    LET Tu201 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 1
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 1
          VAR lc1
    LET Tu200 (UNIT)
      PUT
        VAR ptrace_dirvec
        INT 2
        FADD
          FMUL
            VAR xdisp
            GET
              VAR screenx_dir
              INT 2
          VAR lc2
    LET Tu199 (UNIT)
      APP
        VAR vecunit_sgn
        VAR ptrace_dirvec
        BOOL false
    LET Tu198 (UNIT)
      APP
        VAR vecbzero
        VAR rgb
    LET Tu197 (UNIT)
      APP
        VAR veccpy
        VAR startp
        VAR viewpoint
    LET Tu196 (UNIT)
      APP
        VAR trace_ray
        INT 0
        FLOAT 1.
        VAR ptrace_dirvec
        GET
          VAR line
          VAR x
        FLOAT 0.
    LET Tu195 (UNIT)
      APP
        VAR veccpy
        APP
          VAR p_rgb
          GET
            VAR line
            VAR x
        VAR rgb
    LET Tu194 (UNIT)
      APP
        VAR p_set_group_id
        GET
          VAR line
          VAR x
        VAR group_id
    LET Tu193 (UNIT)
      APP
        VAR pretrace_diffuse_rays
        GET
          VAR line
          VAR x
        INT 0
    APP
      VAR pretrace_pixels
      VAR line
      SUB
        VAR x
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR lc0
      VAR lc1
      VAR lc2
    UNIT
LETREC pretrace_line (VAR of )
  (line : VAR of ), (y : VAR of ), (group_id : VAR of )
  LET ydisp (VAR of )
    FMUL
      GET
        VAR scan_pitch
        INT 0
      int_to_float
        SUB
          VAR y
          GET
            VAR image_center
            INT 1
  LET lc0 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 0
      GET
        VAR screenz_dir
        INT 0
  LET lc1 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 1
      GET
        VAR screenz_dir
        INT 1
  LET lc2 (VAR of )
    FADD
      FMUL
        VAR ydisp
        GET
          VAR screeny_dir
          INT 2
      GET
        VAR screenz_dir
        INT 2
  APP
    VAR pretrace_pixels
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 1
    VAR group_id
    VAR lc0
    VAR lc1
    VAR lc2
LETREC scan_pixel (VAR of )
  (x : VAR of ), (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 0
        VAR x
    LET Tu205 (UNIT)
      APP
        VAR veccpy
        VAR rgb
        APP
          VAR p_rgb
          GET
            VAR cur
            VAR x
    LET Tu204 (UNIT)
      IF
        APP
          VAR neighbors_exist
          VAR x
          VAR y
          VAR next
        APP
          VAR try_exploit_neighbors
          VAR x
          VAR y
          VAR prev
          VAR cur
          VAR next
          INT 0
        APP
          VAR do_without_neighbors
          GET
            VAR cur
            VAR x
          INT 0
    LET Tu203 (UNIT)
      APP
        VAR write_rgb
        UNIT
    APP
      VAR scan_pixel
      ADD
        VAR x
        INT 1
      VAR y
      VAR prev
      VAR cur
      VAR next
    UNIT
LETREC scan_line (VAR of )
  (y : VAR of ), (prev : VAR of ), (cur : VAR of ), (next : VAR of ), (group_id : VAR of )
  IF
    NOT
      LE
        GET
          VAR image_size
          INT 1
        VAR y
    LET Tu207 (UNIT)
      IF
        NOT
          LE
            SUB
              GET
                VAR image_size
                INT 1
              INT 1
            VAR y
        APP
          VAR pretrace_line
          VAR next
          ADD
            VAR y
            INT 1
          VAR group_id
        UNIT
    LET Tu206 (UNIT)
      APP
        VAR scan_pixel
        INT 0
        VAR y
        VAR prev
        VAR cur
        VAR next
    APP
      VAR scan_line
      ADD
        VAR y
        INT 1
      VAR cur
      VAR next
      VAR prev
      APP
        VAR add_mod5
        VAR group_id
        INT 2
    UNIT
LETREC create_float5x3array (VAR of )
  (Tu208 : VAR of )
  LET vec (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET array (VAR of )
    ARRAY
      INT 5
      VAR vec
  LET Tu212 (UNIT)
    PUT
      VAR array
      INT 1
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu211 (UNIT)
    PUT
      VAR array
      INT 2
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu210 (UNIT)
    PUT
      VAR array
      INT 3
      ARRAY
        INT 3
        FLOAT 0.
  LET Tu209 (UNIT)
    PUT
      VAR array
      INT 4
      ARRAY
        INT 3
        FLOAT 0.
  VAR array
LETREC create_pixel (VAR of )
  (Tu213 : VAR of )
  LET m_rgb (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET m_isect_ps (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_sids (VAR of )
    ARRAY
      INT 5
      INT 0
  LET m_cdif (VAR of )
    ARRAY
      INT 5
      BOOL false
  LET m_engy (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_r20p (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  LET m_gid (VAR of )
    ARRAY
      INT 1
      INT 0
  LET m_nvectors (VAR of )
    APP
      VAR create_float5x3array
      UNIT
  TUPLE
    VAR m_rgb
    VAR m_isect_ps
    VAR m_sids
    VAR m_cdif
    VAR m_engy
    VAR m_r20p
    VAR m_gid
    VAR m_nvectors
LETREC init_line_elements (VAR of )
  (line : VAR of ), (n : VAR of )
  IF
    LE
      INT 0
      VAR n
    LET Tu214 (UNIT)
      PUT
        VAR line
        VAR n
        APP
          VAR create_pixel
          UNIT
    APP
      VAR init_line_elements
      VAR line
      SUB
        VAR n
        INT 1
    VAR line
LETREC create_pixelline (VAR of )
  (Tu215 : VAR of )
  LET line (VAR of )
    ARRAY
      GET
        VAR image_size
        INT 0
      APP
        VAR create_pixel
        UNIT
  APP
    VAR init_line_elements
    VAR line
    SUB
      GET
        VAR image_size
        INT 0
      INT 2
LETREC tan (VAR of )
  (x : VAR of )
  FDIV
    APP
      VAR sin
      VAR x
    APP
      VAR cos
      VAR x
LETREC adjust_position (VAR of )
  (h : VAR of ), (ratio : VAR of )
  LET l (VAR of )
    APP
      VAR sqrt
      FADD
        FMUL
          VAR h
          VAR h
        FLOAT 0.1
  LET tan_h (VAR of )
    FDIV
      FLOAT 1.
      VAR l
  LET theta_h (VAR of )
    APP
      VAR atan
      VAR tan_h
  LET tan_m (VAR of )
    APP
      VAR tan
      FMUL
        VAR theta_h
        VAR ratio
  FMUL
    VAR tan_m
    VAR l
LETREC calc_dirvec (VAR of )
  (icount : VAR of ), (x : VAR of ), (y : VAR of ), (rx : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 5
      VAR icount
    LET l (VAR of )
      APP
        VAR sqrt
        FADD
          FADD
            APP
              VAR fsqr
              VAR x
            APP
              VAR fsqr
              VAR y
          FLOAT 1.
    LET vx (VAR of )
      FDIV
        VAR x
        VAR l
    LET vy (VAR of )
      FDIV
        VAR y
        VAR l
    LET vz (VAR of )
      FDIV
        FLOAT 1.
        VAR l
    LET dgroup (VAR of )
      GET
        VAR dirvecs
        VAR group_id
    LET Tu220 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            VAR index
        VAR vx
        VAR vy
        VAR vz
    LET Tu219 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 40
        VAR vx
        VAR vz
        APP
          VAR fneg
          VAR vy
    LET Tu218 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 80
        VAR vz
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
    LET Tu217 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 1
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vy
        APP
          VAR fneg
          VAR vz
    LET Tu216 (UNIT)
      APP
        VAR vecset
        APP
          VAR d_vec
          GET
            VAR dgroup
            ADD
              VAR index
              INT 41
        APP
          VAR fneg
          VAR vx
        APP
          VAR fneg
          VAR vz
        VAR vy
    APP
      VAR vecset
      APP
        VAR d_vec
        GET
          VAR dgroup
          ADD
            VAR index
            INT 81
      APP
        VAR fneg
        VAR vz
      VAR vx
      VAR vy
    LET x2 (VAR of )
      APP
        VAR adjust_position
        VAR y
        VAR rx
    APP
      VAR calc_dirvec
      ADD
        VAR icount
        INT 1
      VAR x2
      APP
        VAR adjust_position
        VAR x2
        VAR ry
      VAR rx
      VAR ry
      VAR group_id
      VAR index
LETREC calc_dirvecs (VAR of )
  (col : VAR of ), (ry : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR col
    LET rx (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.9
    LET Tu222 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx
        VAR ry
        VAR group_id
        VAR index
    LET rx2 (VAR of )
      FADD
        FMUL
          int_to_float
            VAR col
          FLOAT 0.2
        FLOAT 0.1
    LET Tu221 (UNIT)
      APP
        VAR calc_dirvec
        INT 0
        FLOAT 0.
        FLOAT 0.
        VAR rx2
        VAR ry
        VAR group_id
        ADD
          VAR index
          INT 2
    APP
      VAR calc_dirvecs
      SUB
        VAR col
        INT 1
      VAR ry
      APP
        VAR add_mod5
        VAR group_id
        INT 1
      VAR index
    UNIT
LETREC calc_dirvec_rows (VAR of )
  (row : VAR of ), (group_id : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR row
    LET ry (VAR of )
      FSUB
        FMUL
          int_to_float
            VAR row
          FLOAT 0.2
        FLOAT 0.9
    LET Tu223 (UNIT)
      APP
        VAR calc_dirvecs
        INT 4
        VAR ry
        VAR group_id
        VAR index
    APP
      VAR calc_dirvec_rows
      SUB
        VAR row
        INT 1
      APP
        VAR add_mod5
        VAR group_id
        INT 2
      ADD
        VAR index
        INT 4
    UNIT
LETREC create_dirvec (VAR of )
  (Tu224 : VAR of )
  LET v3 (VAR of )
    ARRAY
      INT 3
      FLOAT 0.
  LET consts (VAR of )
    ARRAY
      GET
        VAR n_objects
        INT 0
      VAR v3
  TUPLE
    VAR v3
    VAR consts
LETREC create_dirvec_elements (VAR of )
  (d : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu225 (UNIT)
      PUT
        VAR d
        VAR index
        APP
          VAR create_dirvec
          UNIT
    APP
      VAR create_dirvec_elements
      VAR d
      SUB
        VAR index
        INT 1
    UNIT
LETREC create_dirvecs (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu227 (UNIT)
      PUT
        VAR dirvecs
        VAR index
        ARRAY
          INT 120
          APP
            VAR create_dirvec
            UNIT
    LET Tu226 (UNIT)
      APP
        VAR create_dirvec_elements
        GET
          VAR dirvecs
          VAR index
        INT 118
    APP
      VAR create_dirvecs
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvec_constants (VAR of )
  (vecset : VAR of ), (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu228 (UNIT)
      APP
        VAR setup_dirvec_constants
        GET
          VAR vecset
          VAR index
    APP
      VAR init_dirvec_constants
      VAR vecset
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_vecset_constants (VAR of )
  (index : VAR of )
  IF
    LE
      INT 0
      VAR index
    LET Tu229 (UNIT)
      APP
        VAR init_dirvec_constants
        GET
          VAR dirvecs
          VAR index
        INT 119
    APP
      VAR init_vecset_constants
      SUB
        VAR index
        INT 1
    UNIT
LETREC init_dirvecs (VAR of )
  (Tu230 : VAR of )
  LET Tu232 (UNIT)
    APP
      VAR create_dirvecs
      INT 4
  LET Tu231 (UNIT)
    APP
      VAR calc_dirvec_rows
      INT 9
      INT 0
      INT 0
  APP
    VAR init_vecset_constants
    INT 4
LETREC add_reflection (VAR of )
  (index : VAR of ), (surface_id : VAR of ), (bright : VAR of ), (v0 : VAR of ), (v1 : VAR of ), (v2 : VAR of )
  LET dvec (VAR of )
    APP
      VAR create_dirvec
      UNIT
  LET Tu234 (UNIT)
    APP
      VAR vecset
      APP
        VAR d_vec
        VAR dvec
      VAR v0
      VAR v1
      VAR v2
  LET Tu233 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR dvec
  PUT
    VAR reflections
    VAR index
    TUPLE
      VAR surface_id
      VAR dvec
      VAR bright
LETREC setup_rect_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    MULTIPLE 4
      VAR obj_id
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET n0 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 0
  LET n1 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 1
  LET n2 (VAR of )
    APP
      VAR fneg
      GET
        VAR light
        INT 2
  LET Tu237 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      ADD
        VAR sid
        INT 1
      VAR br
      GET
        VAR light
        INT 0
      VAR n1
      VAR n2
  LET Tu236 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 1
      ADD
        VAR sid
        INT 2
      VAR br
      VAR n0
      GET
        VAR light
        INT 1
      VAR n2
  LET Tu235 (UNIT)
    APP
      VAR add_reflection
      ADD
        VAR nr
        INT 2
      ADD
        VAR sid
        INT 3
      VAR br
      VAR n0
      VAR n1
      GET
        VAR light
        INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 3
LETREC setup_surface_reflection (VAR of )
  (obj_id : VAR of ), (obj : VAR of )
  LET sid (VAR of )
    ADD
      MULTIPLE 4
        VAR obj_id
      INT 1
  LET nr (VAR of )
    GET
      VAR n_reflections
      INT 0
  LET br (VAR of )
    FSUB
      FLOAT 1.
      APP
        VAR o_diffuse
        VAR obj
  LET p (VAR of )
    APP
      VAR veciprod
      VAR light
      APP
        VAR o_param_abc
        VAR obj
  LET Tu238 (UNIT)
    APP
      VAR add_reflection
      VAR nr
      VAR sid
      VAR br
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_a
              VAR obj
          VAR p
        GET
          VAR light
          INT 0
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_b
              VAR obj
          VAR p
        GET
          VAR light
          INT 1
      FSUB
        FMUL
          FMUL
            FLOAT 2.
            APP
              VAR o_param_c
              VAR obj
          VAR p
        GET
          VAR light
          INT 2
  PUT
    VAR n_reflections
    INT 0
    ADD
      VAR nr
      INT 1
LETREC setup_reflections (VAR of )
  (obj_id : VAR of )
  IF
    LE
      INT 0
      VAR obj_id
    LET obj (VAR of )
      GET
        VAR objects
        VAR obj_id
    IF
      EQ
        APP
          VAR o_reflectiontype
          VAR obj
        INT 2
      IF
        APP
          VAR fless
          APP
            VAR o_diffuse
            VAR obj
          FLOAT 1.
        LET m_shape (VAR of )
          APP
            VAR o_form
            VAR obj
        IF
          EQ
            VAR m_shape
            INT 1
          APP
            VAR setup_rect_reflection
            VAR obj_id
            VAR obj
          IF
            EQ
              VAR m_shape
              INT 2
            APP
              VAR setup_surface_reflection
              VAR obj_id
              VAR obj
            UNIT
        UNIT
      UNIT
    UNIT
LETREC rt (VAR of )
  (size_x : VAR of ), (size_y : VAR of )
  LET Tu250 (UNIT)
    PUT
      VAR image_size
      INT 0
      VAR size_x
  LET Tu249 (UNIT)
    PUT
      VAR image_size
      INT 1
      VAR size_y
  LET Tu248 (UNIT)
    PUT
      VAR image_center
      INT 0
      DIVIDE BY 2
        VAR size_x
  LET Tu247 (UNIT)
    PUT
      VAR image_center
      INT 1
      DIVIDE BY 2
        VAR size_y
  LET Tu246 (UNIT)
    PUT
      VAR scan_pitch
      INT 0
      FDIV
        FLOAT 128.
        int_to_float
          VAR size_x
  LET prev (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET cur (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET next (VAR of )
    APP
      VAR create_pixelline
      UNIT
  LET Tu245 (UNIT)
    APP
      VAR read_parameter
      UNIT
  LET Tu244 (UNIT)
    APP
      VAR write_ppm_header
      UNIT
  LET Tu243 (UNIT)
    APP
      VAR init_dirvecs
      UNIT
  LET Tu242 (UNIT)
    APP
      VAR veccpy
      APP
        VAR d_vec
        VAR light_dirvec
      VAR light
  LET Tu241 (UNIT)
    APP
      VAR setup_dirvec_constants
      VAR light_dirvec
  LET Tu240 (UNIT)
    APP
      VAR setup_reflections
      SUB
        GET
          VAR n_objects
          INT 0
        INT 1
  LET Tu239 (UNIT)
    APP
      VAR pretrace_line
      VAR cur
      INT 0
      INT 0
  APP
    VAR scan_line
    INT 0
    VAR prev
    VAR cur
    VAR next
    INT 2
APP
  VAR rt
  INT 512
  INT 512

----- kNormal.print -----
letrec print_int : (INT -> UNIT) =
variables : (n : INT)
  let n : INT =
    let Ti2511 : INT =
      int 0
    in
    if Ti2511 <= n
      n
      let Tu1 : UNIT =
        let Ti2512 : INT =
          int 45
        in
        out Ti2512 0
      in
      neg n
  in
  let Ti2513 : INT =
    int 10
  in
  if Ti2513 <= n
    let m : INT =
      div n 10
    in
    let Tu2 : UNIT =
      app
        print_int
        m
    in
    let Ti2515 : INT =
      let Ti2514 : INT =
        mul m 10
      in
      sub n Ti2514
    in
    out Ti2515 48
    out n 48
in
letrec print_char : (INT -> UNIT) =
variables : (c : INT)
  out c 0
in
letrec reduction_2pi_sub1 : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (a : FLOAT), (p : FLOAT)
  if a <. p
    p
    let Td2510 : FLOAT =
      fadd p p
    in
    app
      reduction_2pi_sub1
      a
      Td2510
in
letrec reduction_2pi_sub2 : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (a : FLOAT), (p : FLOAT)
  let Td2506 : FLOAT =
    float 6.28318530718
  in
  if Td2506 <. a
    let a : FLOAT =
      if p <. a
        fsub a p
        let Td2507 : FLOAT =
          float 0.
        in
        fadd a Td2507
    in
    let p : FLOAT =
      let Td2508 : FLOAT =
        float 2.
      in
      fdiv p Td2508
    in
    app
      reduction_2pi_sub2
      a
      p
    let Td2509 : FLOAT =
      float 0.
    in
    fadd a Td2509
in
letrec reduction_2pi : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let p : FLOAT =
    float 6.28318530718
  in
  let p : FLOAT =
    app
      reduction_2pi_sub1
      a
      p
  in
  app
    reduction_2pi_sub2
    a
    p
in
letrec kernel_sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a3 : FLOAT =
    fmul a2 a
  in
  let a5 : FLOAT =
    fmul a3 a2
  in
  let a7 : FLOAT =
    fmul a5 a2
  in
  let Td2505 : FLOAT =
    let Td2502 : FLOAT =
      let Td2499 : FLOAT =
        let Td2498 : FLOAT =
          let Td2497 : FLOAT =
            float 0.000198411698413
          in
          fmul Td2497 a7
        in
        fneg Td2498
      in
      let Td2501 : FLOAT =
        let Td2500 : FLOAT =
          float 0.0083333333333
        in
        fmul Td2500 a5
      in
      fadd Td2499 Td2501
    in
    let Td2504 : FLOAT =
      let Td2503 : FLOAT =
        float 0.166666666667
      in
      fmul Td2503 a3
    in
    fsub Td2502 Td2504
  in
  fadd Td2505 a
in
letrec kernel_cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a2 : FLOAT =
    fmul a a
  in
  let a4 : FLOAT =
    fmul a2 a2
  in
  let a6 : FLOAT =
    fmul a4 a2
  in
  let Td2495 : FLOAT =
    let Td2492 : FLOAT =
      let Td2489 : FLOAT =
        let Td2488 : FLOAT =
          let Td2487 : FLOAT =
            float 0.00138888888889
          in
          fmul Td2487 a6
        in
        fneg Td2488
      in
      let Td2491 : FLOAT =
        let Td2490 : FLOAT =
          float 0.0416666666667
        in
        fmul Td2490 a4
      in
      fadd Td2489 Td2491
    in
    let Td2494 : FLOAT =
      let Td2493 : FLOAT =
        float 0.5
      in
      fmul Td2493 a2
    in
    fsub Td2492 Td2494
  in
  let Td2496 : FLOAT =
    float 1.
  in
  fadd Td2495 Td2496
in
letrec sin : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2468 : FLOAT =
      float 0.
    in
    if Td2468 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Td2469 : FLOAT =
      float 0.
    in
    if a <. Td2469
      fneg a
      let Td2470 : FLOAT =
        float 0.
      in
      fadd a Td2470
  in
  let a : FLOAT =
    app
      reduction_2pi
      a
  in
  let Tt2478 : (FLOAT * INT) =
    let Td2471 : FLOAT =
      float 3.14159265359
    in
    if Td2471 <. a
      let Td2473 : FLOAT =
        let Td2472 : FLOAT =
          float 3.14159265359
        in
        fsub a Td2472
      in
      let Ti2475 : INT =
        let Ti2474 : INT =
          int 0
        in
        if flag == Ti2474
          int 1
          int 0
      in
      Tuple
        Td2473
        Ti2475
      let Td2477 : FLOAT =
        let Td2476 : FLOAT =
          float 0.
        in
        fadd a Td2476
      in
      Tuple
        Td2477
        flag
  in
  let tuple (a : FLOAT), (flag : BOOL)
    Tt2478
  in
    let a : FLOAT =
      let Td2479 : FLOAT =
        float 1.57079632679
      in
      if Td2479 <. a
        let Td2480 : FLOAT =
          float 3.14159265359
        in
        fsub Td2480 a
        let Td2481 : FLOAT =
          float 0.
        in
        fadd a Td2481
    in
    let a : FLOAT =
      let Td2482 : FLOAT =
        float 0.785398163397
      in
      if a <. Td2482
        let Td2484 : FLOAT =
          let Td2483 : FLOAT =
            float 1.57079632679
          in
          fsub Td2483 a
        in
        app
          kernel_cos
          Td2484
        app
          kernel_sin
          a
    in
    let Ti2485 : INT =
      int 0
    in
    if flag == Ti2485
      fneg a
      let Td2486 : FLOAT =
        float 0.
      in
      fadd a Td2486
in
letrec cos : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let a : FLOAT =
    let Td2447 : FLOAT =
      float 0.
    in
    if a <. Td2447
      fneg a
      let Td2448 : FLOAT =
        float 0.
      in
      fadd a Td2448
  in
  let a : FLOAT =
    app
      reduction_2pi
      a
  in
  let Tt2454 : (FLOAT * INT) =
    let Td2449 : FLOAT =
      float 3.14159265359
    in
    if Td2449 <. a
      let Td2451 : FLOAT =
        let Td2450 : FLOAT =
          float 3.14159265359
        in
        fsub a Td2450
      in
      let Ti2452 : INT =
        int 0
      in
      Tuple
        Td2451
        Ti2452
      let Ti2453 : INT =
        int 1
      in
      Tuple
        a
        Ti2453
  in
  let tuple (a : FLOAT), (flag : BOOL)
    Tt2454
  in
    let Tt2462 : (FLOAT * INT) =
      let Td2455 : FLOAT =
        float 1.57079632679
      in
      if Td2455 <. a
        let Td2457 : FLOAT =
          let Td2456 : FLOAT =
            float 3.14159265359
          in
          fsub Td2456 a
        in
        let Ti2459 : INT =
          let Ti2458 : INT =
            int 0
          in
          if flag == Ti2458
            int 1
            int 0
        in
        Tuple
          Td2457
          Ti2459
        let Td2461 : FLOAT =
          let Td2460 : FLOAT =
            float 0.
          in
          fadd a Td2460
        in
        Tuple
          Td2461
          flag
    in
    let tuple (a : FLOAT), (flag : BOOL)
      Tt2462
    in
      let a : FLOAT =
        let Td2463 : FLOAT =
          float 0.785398163397
        in
        if Td2463 <. a
          app
            kernel_cos
            a
          let Td2465 : FLOAT =
            let Td2464 : FLOAT =
              float 1.57079632679
            in
            fsub Td2464 a
          in
          app
            kernel_sin
            Td2465
      in
      let Ti2466 : INT =
        int 0
      in
      if flag == Ti2466
        fneg a
        let Td2467 : FLOAT =
          float 0.
        in
        fadd a Td2467
in
letrec sqrt : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  letrec inner : (FLOAT -> (INT -> FLOAT)) =
  variables : (t : FLOAT), (i : INT)
    let Ti2439 : INT =
      int 0
    in
    if i == Ti2439
      t
      let Td2444 : FLOAT =
        let Td2441 : FLOAT =
          let Td2440 : FLOAT =
            fmul t t
          in
          fadd Td2440 x
        in
        let Td2443 : FLOAT =
          let Td2442 : FLOAT =
            float 2.
          in
          fmul Td2442 t
        in
        fdiv Td2441 Td2443
      in
      let Ti2446 : INT =
        let Ti2445 : INT =
          int 1
        in
        sub i Ti2445
      in
      app
        inner
        Td2444
        Ti2446
  in
  let Td2437 : FLOAT =
    unknown sqrt_init x
  in
  let Ti2438 : INT =
    int 5
  in
  app
    inner
    Td2437
    Ti2438
in
letrec kernel_atan : (FLOAT -> FLOAT) =
variables : (a1 : FLOAT)
  let a2 : FLOAT =
    fmul a1 a1
  in
  let a3 : FLOAT =
    fmul a2 a1
  in
  let a5 : FLOAT =
    fmul a2 a3
  in
  let a7 : FLOAT =
    fmul a2 a5
  in
  let a9 : FLOAT =
    fmul a2 a7
  in
  let a11 : FLOAT =
    fmul a2 a9
  in
  let a13 : FLOAT =
    fmul a2 a11
  in
  let Td2434 : FLOAT =
    let Td2431 : FLOAT =
      let Td2428 : FLOAT =
        let Td2425 : FLOAT =
          let Td2422 : FLOAT =
            let Td2421 : FLOAT =
              let Td2420 : FLOAT =
                float 0.3333333
              in
              fmul Td2420 a3
            in
            fsub a1 Td2421
          in
          let Td2424 : FLOAT =
            let Td2423 : FLOAT =
              float 0.2
            in
            fmul Td2423 a5
          in
          fadd Td2422 Td2424
        in
        let Td2427 : FLOAT =
          let Td2426 : FLOAT =
            float 0.142857142
          in
          fmul Td2426 a7
        in
        fsub Td2425 Td2427
      in
      let Td2430 : FLOAT =
        let Td2429 : FLOAT =
          float 0.111111104
        in
        fmul Td2429 a9
      in
      fadd Td2428 Td2430
    in
    let Td2433 : FLOAT =
      let Td2432 : FLOAT =
        float 0.08976446
      in
      fmul Td2432 a11
    in
    fsub Td2431 Td2433
  in
  let Td2436 : FLOAT =
    let Td2435 : FLOAT =
      float 0.060035485
    in
    fmul Td2435 a13
  in
  fadd Td2434 Td2436
in
letrec atan : (FLOAT -> FLOAT) =
variables : (a : FLOAT)
  let flag : BOOL =
    let Td2400 : FLOAT =
      float 0.
    in
    if Td2400 <. a
      int 1
      int 0
  in
  let a : FLOAT =
    let Ti2401 : INT =
      int 0
    in
    if flag == Ti2401
      fneg a
      let Td2402 : FLOAT =
        float 0.
      in
      fadd a Td2402
  in
  let b : FLOAT =
    let Td2403 : FLOAT =
      float 0.4375
    in
    if a <. Td2403
      app
        kernel_atan
        a
      let Td2416 : FLOAT =
        let Td2404 : FLOAT =
          float 2.4375
        in
        if a <. Td2404
          let Td2405 : FLOAT =
            float 0.785398163397
          in
          let Td2411 : FLOAT =
            let Td2410 : FLOAT =
              let Td2407 : FLOAT =
                let Td2406 : FLOAT =
                  float 1.
                in
                fsub a Td2406
              in
              let Td2409 : FLOAT =
                let Td2408 : FLOAT =
                  float 1.
                in
                fadd a Td2408
              in
              fdiv Td2407 Td2409
            in
            app
              kernel_atan
              Td2410
          in
          fadd Td2405 Td2411
          let Td2412 : FLOAT =
            float 1.57079632679
          in
          let Td2415 : FLOAT =
            let Td2414 : FLOAT =
              let Td2413 : FLOAT =
                float 1.
              in
              fdiv Td2413 a
            in
            app
              kernel_atan
              Td2414
          in
          fsub Td2412 Td2415
      in
      let Td2417 : FLOAT =
        float 0.
      in
      fadd Td2416 Td2417
  in
  let Ti2418 : INT =
    int 0
  in
  if flag == Ti2418
    fneg b
    let Td2419 : FLOAT =
      float 0.
    in
    fadd Td2419 b
in
letrec floor : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let a : FLOAT =
    let Ti2398 : INT =
      ftoi x
    in
    itof Ti2398
  in
  if x <. a
    let Td2399 : FLOAT =
      float 1.
    in
    fsub a Td2399
    a
in
letrec fabs : (FLOAT -> FLOAT) =
variables : (f : FLOAT)
  let Td2397 : FLOAT =
    float 0.
  in
  if f <. Td2397
    fneg f
    f
in
letrec fhalf : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2396 : FLOAT =
    float 0.5
  in
  fmul x Td2396
in
letrec fsqr : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fmul x x
in
letrec fneg : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  fneg x
in
letrec fless : (FLOAT -> (FLOAT -> BOOL)) =
variables : (a : FLOAT), (b : FLOAT)
  if a <. b
    int 1
    int 0
in
letrec abs_float : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  app
    fabs
    x
in
letrec fispos : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2395 : FLOAT =
    float 0.
  in
  if Td2395 <. x
    int 1
    int 0
in
letrec fisneg : (FLOAT -> BOOL) =
variables : (x : FLOAT)
  let Td2394 : FLOAT =
    float 0.
  in
  if x <. Td2394
    int 1
    int 0
in
let n_objects : Array of INT =
  let Ti251 : INT =
    int 1
  in
  let Ti252 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti251
    Ti252
in
let objects : Array of (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
  let dummy : Array of FLOAT =
    let Ti253 : INT =
      int 0
    in
    let Td254 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti253
      Td254
  in
  let Ti255 : INT =
    int 60
  in
  let Tt261 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * INT * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    let Ti256 : INT =
      int 0
    in
    let Ti257 : INT =
      int 0
    in
    let Ti258 : INT =
      int 0
    in
    let Ti259 : INT =
      int 0
    in
    let Ti260 : INT =
      int 0
    in
    Tuple
      Ti256
      Ti257
      Ti258
      Ti259
      dummy
      dummy
      Ti260
      dummy
      dummy
      dummy
      dummy
  in
  extfunapp
    create_array
    Ti255
    Tt261
in
let screen : Array of FLOAT =
  let Ti262 : INT =
    int 3
  in
  let Td263 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti262
    Td263
in
let viewpoint : Array of FLOAT =
  let Ti264 : INT =
    int 3
  in
  let Td265 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti264
    Td265
in
let light : Array of FLOAT =
  let Ti266 : INT =
    int 3
  in
  let Td267 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti266
    Td267
in
let beam : Array of FLOAT =
  let Ti268 : INT =
    int 1
  in
  let Td269 : FLOAT =
    float 255.
  in
  extfunapp
    create_float_array
    Ti268
    Td269
in
let and_net : Array of Array of INT =
  let Ti270 : INT =
    int 50
  in
  let Ta274 : Array of INT =
    let Ti271 : INT =
      int 1
    in
    let Ti273 : INT =
      let Ti272 : INT =
        int 1
      in
      neg Ti272
    in
    extfunapp
      create_array
      Ti271
      Ti273
  in
  extfunapp
    create_array
    Ti270
    Ta274
in
let or_net : Array of Array of Array of INT =
  let Ti275 : INT =
    int 1
  in
  let Ta279 : Array of Array of INT =
    let Ti276 : INT =
      int 1
    in
    let Ta278 : Array of INT =
      let Ti277 : INT =
        int 0
      in
      and_net.(Ti277)
    in
    extfunapp
      create_array
      Ti276
      Ta278
  in
  extfunapp
    create_array
    Ti275
    Ta279
in
let solver_dist : Array of FLOAT =
  let Ti280 : INT =
    int 1
  in
  let Td281 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti280
    Td281
in
let intsec_rectside : Array of INT =
  let Ti282 : INT =
    int 1
  in
  let Ti283 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti282
    Ti283
in
let tmin : Array of FLOAT =
  let Ti284 : INT =
    int 1
  in
  let Td285 : FLOAT =
    float 1000000000.
  in
  extfunapp
    create_float_array
    Ti284
    Td285
in
let intersection_point : Array of FLOAT =
  let Ti286 : INT =
    int 3
  in
  let Td287 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti286
    Td287
in
let intersected_object_id : Array of INT =
  let Ti288 : INT =
    int 1
  in
  let Ti289 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti288
    Ti289
in
let nvector : Array of FLOAT =
  let Ti290 : INT =
    int 3
  in
  let Td291 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti290
    Td291
in
let texture_color : Array of FLOAT =
  let Ti292 : INT =
    int 3
  in
  let Td293 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti292
    Td293
in
let diffuse_ray : Array of FLOAT =
  let Ti294 : INT =
    int 3
  in
  let Td295 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti294
    Td295
in
let rgb : Array of FLOAT =
  let Ti296 : INT =
    int 3
  in
  let Td297 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti296
    Td297
in
let image_size : Array of INT =
  let Ti298 : INT =
    int 2
  in
  let Ti299 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti298
    Ti299
in
let image_center : Array of INT =
  let Ti300 : INT =
    int 2
  in
  let Ti301 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti300
    Ti301
in
let scan_pitch : Array of FLOAT =
  let Ti302 : INT =
    int 1
  in
  let Td303 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti302
    Td303
in
let startp : Array of FLOAT =
  let Ti304 : INT =
    int 3
  in
  let Td305 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti304
    Td305
in
let startp_fast : Array of FLOAT =
  let Ti306 : INT =
    int 3
  in
  let Td307 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti306
    Td307
in
let screenx_dir : Array of FLOAT =
  let Ti308 : INT =
    int 3
  in
  let Td309 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti308
    Td309
in
let screeny_dir : Array of FLOAT =
  let Ti310 : INT =
    int 3
  in
  let Td311 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti310
    Td311
in
let screenz_dir : Array of FLOAT =
  let Ti312 : INT =
    int 3
  in
  let Td313 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti312
    Td313
in
let ptrace_dirvec : Array of FLOAT =
  let Ti314 : INT =
    int 3
  in
  let Td315 : FLOAT =
    float 0.
  in
  extfunapp
    create_float_array
    Ti314
    Td315
in
let dirvecs : Array of Array of (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf : Array of FLOAT =
    let Ti316 : INT =
      int 0
    in
    let Td317 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti316
      Td317
  in
  let dummyff : Array of Array of FLOAT =
    let Ti318 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti318
      dummyf
  in
  let dummy_vs : Array of (Array of FLOAT * Array of Array of FLOAT) =
    let Ti319 : INT =
      int 0
    in
    let Tt320 : (Array of FLOAT * Array of Array of FLOAT) =
      Tuple
        dummyf
        dummyff
    in
    extfunapp
      create_array
      Ti319
      Tt320
  in
  let Ti321 : INT =
    int 5
  in
  extfunapp
    create_array
    Ti321
    dummy_vs
in
let light_dirvec : (Array of FLOAT * Array of Array of FLOAT) =
  let dummyf2 : Array of FLOAT =
    let Ti322 : INT =
      int 0
    in
    let Td323 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti322
      Td323
  in
  let v3 : Array of FLOAT =
    let Ti324 : INT =
      int 3
    in
    let Td325 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti324
      Td325
  in
  let consts : Array of Array of FLOAT =
    let Ti326 : INT =
      int 60
    in
    extfunapp
      create_array
      Ti326
      dummyf2
  in
  Tuple
    v3
    consts
in
let reflections : Array of (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
  let dummyf3 : Array of FLOAT =
    let Ti327 : INT =
      int 0
    in
    let Td328 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti327
      Td328
  in
  let dummyff3 : Array of Array of FLOAT =
    let Ti329 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti329
      dummyf3
  in
  let dummydv : (Array of FLOAT * Array of Array of FLOAT) =
    Tuple
      dummyf3
      dummyff3
  in
  let Ti330 : INT =
    int 180
  in
  let Tt333 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    let Ti331 : INT =
      int 0
    in
    let Td332 : FLOAT =
      float 0.
    in
    Tuple
      Ti331
      dummydv
      Td332
  in
  extfunapp
    create_array
    Ti330
    Tt333
in
let n_reflections : Array of INT =
  let Ti334 : INT =
    int 1
  in
  let Ti335 : INT =
    int 0
  in
  extfunapp
    create_array
    Ti334
    Ti335
in
letrec xor : (BOOL -> (BOOL -> BOOL)) =
variables : (x : BOOL), (y : BOOL)
  let Ti2392 : INT =
    int 0
  in
  if x == Ti2392
    y
    let Ti2393 : INT =
      int 0
    in
    if y == Ti2393
      int 1
      int 0
in
letrec sgn : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  if x == 0.0 
    float 0.
    let Tb2390 : BOOL =
      app
        fispos
        x
    in
    let Ti2391 : INT =
      int 0
    in
    if Tb2390 == Ti2391
      float -1.
      float 1.
in
letrec fneg_cond : (BOOL -> (FLOAT -> FLOAT)) =
variables : (cond : BOOL), (x : FLOAT)
  let Ti2389 : INT =
    int 0
  in
  if cond == Ti2389
    app
      fneg
      x
    x
in
letrec add_mod5 : (INT -> (INT -> INT)) =
variables : (x : INT), (y : INT)
  let sum : INT =
    add x y
  in
  let Ti2387 : INT =
    int 5
  in
  if Ti2387 <= sum
    let Ti2388 : INT =
      int 5
    in
    sub sum Ti2388
    sum
in
letrec vecset : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))) =
variables : (v : Array of FLOAT), (x : FLOAT), (y : FLOAT), (z : FLOAT)
  let Tu4 : UNIT =
    let Ti2384 : INT =
      int 0
    in
    v.(Ti2384) <- x
  in
  let Tu3 : UNIT =
    let Ti2385 : INT =
      int 1
    in
    v.(Ti2385) <- y
  in
  let Ti2386 : INT =
    int 2
  in
  v.(Ti2386) <- z
in
letrec vecfill : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (v : Array of FLOAT), (elem : FLOAT)
  let Tu6 : UNIT =
    let Ti2381 : INT =
      int 0
    in
    v.(Ti2381) <- elem
  in
  let Tu5 : UNIT =
    let Ti2382 : INT =
      int 1
    in
    v.(Ti2382) <- elem
  in
  let Ti2383 : INT =
    int 2
  in
  v.(Ti2383) <- elem
in
letrec vecbzero : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let Td2380 : FLOAT =
    float 0.
  in
  app
    vecfill
    v
    Td2380
in
letrec veccpy : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (src : Array of FLOAT)
  let Tu8 : UNIT =
    let Ti2371 : INT =
      int 0
    in
    let Td2373 : FLOAT =
      let Ti2372 : INT =
        int 0
      in
      src.(Ti2372)
    in
    dest.(Ti2371) <- Td2373
  in
  let Tu7 : UNIT =
    let Ti2374 : INT =
      int 1
    in
    let Td2376 : FLOAT =
      let Ti2375 : INT =
        int 1
      in
      src.(Ti2375)
    in
    dest.(Ti2374) <- Td2376
  in
  let Ti2377 : INT =
    int 2
  in
  let Td2379 : FLOAT =
    let Ti2378 : INT =
      int 2
    in
    src.(Ti2378)
  in
  dest.(Ti2377) <- Td2379
in
letrec vecdist2 : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (p : Array of FLOAT), (q : Array of FLOAT)
  let Td2364 : FLOAT =
    let Td2357 : FLOAT =
      let Td2356 : FLOAT =
        let Td2353 : FLOAT =
          let Ti2352 : INT =
            int 0
          in
          p.(Ti2352)
        in
        let Td2355 : FLOAT =
          let Ti2354 : INT =
            int 0
          in
          q.(Ti2354)
        in
        fsub Td2353 Td2355
      in
      app
        fsqr
        Td2356
    in
    let Td2363 : FLOAT =
      let Td2362 : FLOAT =
        let Td2359 : FLOAT =
          let Ti2358 : INT =
            int 1
          in
          p.(Ti2358)
        in
        let Td2361 : FLOAT =
          let Ti2360 : INT =
            int 1
          in
          q.(Ti2360)
        in
        fsub Td2359 Td2361
      in
      app
        fsqr
        Td2362
    in
    fadd Td2357 Td2363
  in
  let Td2370 : FLOAT =
    let Td2369 : FLOAT =
      let Td2366 : FLOAT =
        let Ti2365 : INT =
          int 2
        in
        p.(Ti2365)
      in
      let Td2368 : FLOAT =
        let Ti2367 : INT =
          int 2
        in
        q.(Ti2367)
      in
      fsub Td2366 Td2368
    in
    app
      fsqr
      Td2369
  in
  fadd Td2364 Td2370
in
letrec vecunit : (Array of FLOAT -> UNIT) =
variables : (v : Array of FLOAT)
  let il : FLOAT =
    let Td2327 : FLOAT =
      float 1.
    in
    let Td2339 : FLOAT =
      let Td2338 : FLOAT =
        let Td2334 : FLOAT =
          let Td2330 : FLOAT =
            let Td2329 : FLOAT =
              let Ti2328 : INT =
                int 0
              in
              v.(Ti2328)
            in
            app
              fsqr
              Td2329
          in
          let Td2333 : FLOAT =
            let Td2332 : FLOAT =
              let Ti2331 : INT =
                int 1
              in
              v.(Ti2331)
            in
            app
              fsqr
              Td2332
          in
          fadd Td2330 Td2333
        in
        let Td2337 : FLOAT =
          let Td2336 : FLOAT =
            let Ti2335 : INT =
              int 2
            in
            v.(Ti2335)
          in
          app
            fsqr
            Td2336
        in
        fadd Td2334 Td2337
      in
      app
        sqrt
        Td2338
    in
    fdiv Td2327 Td2339
  in
  let Tu10 : UNIT =
    let Ti2340 : INT =
      int 0
    in
    let Td2343 : FLOAT =
      let Td2342 : FLOAT =
        let Ti2341 : INT =
          int 0
        in
        v.(Ti2341)
      in
      fmul Td2342 il
    in
    v.(Ti2340) <- Td2343
  in
  let Tu9 : UNIT =
    let Ti2344 : INT =
      int 1
    in
    let Td2347 : FLOAT =
      let Td2346 : FLOAT =
        let Ti2345 : INT =
          int 1
        in
        v.(Ti2345)
      in
      fmul Td2346 il
    in
    v.(Ti2344) <- Td2347
  in
  let Ti2348 : INT =
    int 2
  in
  let Td2351 : FLOAT =
    let Td2350 : FLOAT =
      let Ti2349 : INT =
        int 2
      in
      v.(Ti2349)
    in
    fmul Td2350 il
  in
  v.(Ti2348) <- Td2351
in
letrec vecunit_sgn : (Array of FLOAT -> (BOOL -> UNIT)) =
variables : (v : Array of FLOAT), (inv : BOOL)
  let l : FLOAT =
    let Td2311 : FLOAT =
      let Td2307 : FLOAT =
        let Td2303 : FLOAT =
          let Td2302 : FLOAT =
            let Ti2301 : INT =
              int 0
            in
            v.(Ti2301)
          in
          app
            fsqr
            Td2302
        in
        let Td2306 : FLOAT =
          let Td2305 : FLOAT =
            let Ti2304 : INT =
              int 1
            in
            v.(Ti2304)
          in
          app
            fsqr
            Td2305
        in
        fadd Td2303 Td2306
      in
      let Td2310 : FLOAT =
        let Td2309 : FLOAT =
          let Ti2308 : INT =
            int 2
          in
          v.(Ti2308)
        in
        app
          fsqr
          Td2309
      in
      fadd Td2307 Td2310
    in
    app
      sqrt
      Td2311
  in
  let il : FLOAT =
    if l == 0.0 
      float 1.
      let Ti2312 : INT =
        int 0
      in
      if inv == Ti2312
        let Td2313 : FLOAT =
          float 1.
        in
        fdiv Td2313 l
        let Td2314 : FLOAT =
          float -1.
        in
        fdiv Td2314 l
  in
  let Tu12 : UNIT =
    let Ti2315 : INT =
      int 0
    in
    let Td2318 : FLOAT =
      let Td2317 : FLOAT =
        let Ti2316 : INT =
          int 0
        in
        v.(Ti2316)
      in
      fmul Td2317 il
    in
    v.(Ti2315) <- Td2318
  in
  let Tu11 : UNIT =
    let Ti2319 : INT =
      int 1
    in
    let Td2322 : FLOAT =
      let Td2321 : FLOAT =
        let Ti2320 : INT =
          int 1
        in
        v.(Ti2320)
      in
      fmul Td2321 il
    in
    v.(Ti2319) <- Td2322
  in
  let Ti2323 : INT =
    int 2
  in
  let Td2326 : FLOAT =
    let Td2325 : FLOAT =
      let Ti2324 : INT =
        int 2
      in
      v.(Ti2324)
    in
    fmul Td2325 il
  in
  v.(Ti2323) <- Td2326
in
letrec veciprod : (Array of FLOAT -> (Array of FLOAT -> FLOAT)) =
variables : (v : Array of FLOAT), (w : Array of FLOAT)
  let Td2295 : FLOAT =
    let Td2289 : FLOAT =
      let Td2286 : FLOAT =
        let Ti2285 : INT =
          int 0
        in
        v.(Ti2285)
      in
      let Td2288 : FLOAT =
        let Ti2287 : INT =
          int 0
        in
        w.(Ti2287)
      in
      fmul Td2286 Td2288
    in
    let Td2294 : FLOAT =
      let Td2291 : FLOAT =
        let Ti2290 : INT =
          int 1
        in
        v.(Ti2290)
      in
      let Td2293 : FLOAT =
        let Ti2292 : INT =
          int 1
        in
        w.(Ti2292)
      in
      fmul Td2291 Td2293
    in
    fadd Td2289 Td2294
  in
  let Td2300 : FLOAT =
    let Td2297 : FLOAT =
      let Ti2296 : INT =
        int 2
      in
      v.(Ti2296)
    in
    let Td2299 : FLOAT =
      let Ti2298 : INT =
        int 2
      in
      w.(Ti2298)
    in
    fmul Td2297 Td2299
  in
  fadd Td2295 Td2300
in
letrec veciprod2 : (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (v : Array of FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let Td2281 : FLOAT =
    let Td2277 : FLOAT =
      let Td2276 : FLOAT =
        let Ti2275 : INT =
          int 0
        in
        v.(Ti2275)
      in
      fmul Td2276 w0
    in
    let Td2280 : FLOAT =
      let Td2279 : FLOAT =
        let Ti2278 : INT =
          int 1
        in
        v.(Ti2278)
      in
      fmul Td2279 w1
    in
    fadd Td2277 Td2280
  in
  let Td2284 : FLOAT =
    let Td2283 : FLOAT =
      let Ti2282 : INT =
        int 2
      in
      v.(Ti2282)
    in
    fmul Td2283 w2
  in
  fadd Td2281 Td2284
in
letrec vecaccum : (Array of FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (scale : FLOAT), (v : Array of FLOAT)
  let Tu14 : UNIT =
    let Ti2254 : INT =
      int 0
    in
    let Td2260 : FLOAT =
      let Td2256 : FLOAT =
        let Ti2255 : INT =
          int 0
        in
        dest.(Ti2255)
      in
      let Td2259 : FLOAT =
        let Td2258 : FLOAT =
          let Ti2257 : INT =
            int 0
          in
          v.(Ti2257)
        in
        fmul scale Td2258
      in
      fadd Td2256 Td2259
    in
    dest.(Ti2254) <- Td2260
  in
  let Tu13 : UNIT =
    let Ti2261 : INT =
      int 1
    in
    let Td2267 : FLOAT =
      let Td2263 : FLOAT =
        let Ti2262 : INT =
          int 1
        in
        dest.(Ti2262)
      in
      let Td2266 : FLOAT =
        let Td2265 : FLOAT =
          let Ti2264 : INT =
            int 1
          in
          v.(Ti2264)
        in
        fmul scale Td2265
      in
      fadd Td2263 Td2266
    in
    dest.(Ti2261) <- Td2267
  in
  let Ti2268 : INT =
    int 2
  in
  let Td2274 : FLOAT =
    let Td2270 : FLOAT =
      let Ti2269 : INT =
        int 2
      in
      dest.(Ti2269)
    in
    let Td2273 : FLOAT =
      let Td2272 : FLOAT =
        let Ti2271 : INT =
          int 2
        in
        v.(Ti2271)
      in
      fmul scale Td2272
    in
    fadd Td2270 Td2273
  in
  dest.(Ti2268) <- Td2274
in
letrec vecadd : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu16 : UNIT =
    let Ti2236 : INT =
      int 0
    in
    let Td2241 : FLOAT =
      let Td2238 : FLOAT =
        let Ti2237 : INT =
          int 0
        in
        dest.(Ti2237)
      in
      let Td2240 : FLOAT =
        let Ti2239 : INT =
          int 0
        in
        v.(Ti2239)
      in
      fadd Td2238 Td2240
    in
    dest.(Ti2236) <- Td2241
  in
  let Tu15 : UNIT =
    let Ti2242 : INT =
      int 1
    in
    let Td2247 : FLOAT =
      let Td2244 : FLOAT =
        let Ti2243 : INT =
          int 1
        in
        dest.(Ti2243)
      in
      let Td2246 : FLOAT =
        let Ti2245 : INT =
          int 1
        in
        v.(Ti2245)
      in
      fadd Td2244 Td2246
    in
    dest.(Ti2242) <- Td2247
  in
  let Ti2248 : INT =
    int 2
  in
  let Td2253 : FLOAT =
    let Td2250 : FLOAT =
      let Ti2249 : INT =
        int 2
      in
      dest.(Ti2249)
    in
    let Td2252 : FLOAT =
      let Ti2251 : INT =
        int 2
      in
      v.(Ti2251)
    in
    fadd Td2250 Td2252
  in
  dest.(Ti2248) <- Td2253
in
letrec vecmul : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT)
  let Tu18 : UNIT =
    let Ti2218 : INT =
      int 0
    in
    let Td2223 : FLOAT =
      let Td2220 : FLOAT =
        let Ti2219 : INT =
          int 0
        in
        dest.(Ti2219)
      in
      let Td2222 : FLOAT =
        let Ti2221 : INT =
          int 0
        in
        v.(Ti2221)
      in
      fmul Td2220 Td2222
    in
    dest.(Ti2218) <- Td2223
  in
  let Tu17 : UNIT =
    let Ti2224 : INT =
      int 1
    in
    let Td2229 : FLOAT =
      let Td2226 : FLOAT =
        let Ti2225 : INT =
          int 1
        in
        dest.(Ti2225)
      in
      let Td2228 : FLOAT =
        let Ti2227 : INT =
          int 1
        in
        v.(Ti2227)
      in
      fmul Td2226 Td2228
    in
    dest.(Ti2224) <- Td2229
  in
  let Ti2230 : INT =
    int 2
  in
  let Td2235 : FLOAT =
    let Td2232 : FLOAT =
      let Ti2231 : INT =
        int 2
      in
      dest.(Ti2231)
    in
    let Td2234 : FLOAT =
      let Ti2233 : INT =
        int 2
      in
      v.(Ti2233)
    in
    fmul Td2232 Td2234
  in
  dest.(Ti2230) <- Td2235
in
letrec vecscale : (Array of FLOAT -> (FLOAT -> UNIT)) =
variables : (dest : Array of FLOAT), (scale : FLOAT)
  let Tu20 : UNIT =
    let Ti2206 : INT =
      int 0
    in
    let Td2209 : FLOAT =
      let Td2208 : FLOAT =
        let Ti2207 : INT =
          int 0
        in
        dest.(Ti2207)
      in
      fmul Td2208 scale
    in
    dest.(Ti2206) <- Td2209
  in
  let Tu19 : UNIT =
    let Ti2210 : INT =
      int 1
    in
    let Td2213 : FLOAT =
      let Td2212 : FLOAT =
        let Ti2211 : INT =
          int 1
        in
        dest.(Ti2211)
      in
      fmul Td2212 scale
    in
    dest.(Ti2210) <- Td2213
  in
  let Ti2214 : INT =
    int 2
  in
  let Td2217 : FLOAT =
    let Td2216 : FLOAT =
      let Ti2215 : INT =
        int 2
      in
      dest.(Ti2215)
    in
    fmul Td2216 scale
  in
  dest.(Ti2214) <- Td2217
in
letrec vecaccumv : (Array of FLOAT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dest : Array of FLOAT), (v : Array of FLOAT), (w : Array of FLOAT)
  let Tu22 : UNIT =
    let Ti2179 : INT =
      int 0
    in
    let Td2187 : FLOAT =
      let Td2181 : FLOAT =
        let Ti2180 : INT =
          int 0
        in
        dest.(Ti2180)
      in
      let Td2186 : FLOAT =
        let Td2183 : FLOAT =
          let Ti2182 : INT =
            int 0
          in
          v.(Ti2182)
        in
        let Td2185 : FLOAT =
          let Ti2184 : INT =
            int 0
          in
          w.(Ti2184)
        in
        fmul Td2183 Td2185
      in
      fadd Td2181 Td2186
    in
    dest.(Ti2179) <- Td2187
  in
  let Tu21 : UNIT =
    let Ti2188 : INT =
      int 1
    in
    let Td2196 : FLOAT =
      let Td2190 : FLOAT =
        let Ti2189 : INT =
          int 1
        in
        dest.(Ti2189)
      in
      let Td2195 : FLOAT =
        let Td2192 : FLOAT =
          let Ti2191 : INT =
            int 1
          in
          v.(Ti2191)
        in
        let Td2194 : FLOAT =
          let Ti2193 : INT =
            int 1
          in
          w.(Ti2193)
        in
        fmul Td2192 Td2194
      in
      fadd Td2190 Td2195
    in
    dest.(Ti2188) <- Td2196
  in
  let Ti2197 : INT =
    int 2
  in
  let Td2205 : FLOAT =
    let Td2199 : FLOAT =
      let Ti2198 : INT =
        int 2
      in
      dest.(Ti2198)
    in
    let Td2204 : FLOAT =
      let Td2201 : FLOAT =
        let Ti2200 : INT =
          int 2
        in
        v.(Ti2200)
      in
      let Td2203 : FLOAT =
        let Ti2202 : INT =
          int 2
        in
        w.(Ti2202)
      in
      fmul Td2201 Td2203
    in
    fadd Td2199 Td2204
  in
  dest.(Ti2197) <- Td2205
in
letrec o_texturetype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (m_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_tex
in
letrec o_form : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (m_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_shape
in
letrec o_reflectiontype : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_surface
in
letrec o_isinvert : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> BOOL) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (m_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_invert
in
letrec o_isrot : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> INT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (m_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_isrot
in
letrec o_param_a : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2178 : INT =
      int 0
    in
    m_abc.(Ti2178)
in
letrec o_param_b : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2177 : INT =
      int 1
    in
    m_abc.(Ti2177)
in
letrec o_param_c : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2176 : INT =
      int 2
    in
    m_abc.(Ti2176)
in
letrec o_param_abc : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (m_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    m_abc
in
letrec o_param_x : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2175 : INT =
      int 0
    in
    m_xyz.(Ti2175)
in
letrec o_param_y : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2174 : INT =
      int 1
    in
    m_xyz.(Ti2174)
in
letrec o_param_z : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (m_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2173 : INT =
      int 2
    in
    m_xyz.(Ti2173)
in
letrec o_diffuse : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2172 : INT =
      int 0
    in
    m_surfparams.(Ti2172)
in
letrec o_hilight : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (m_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2171 : INT =
      int 1
    in
    m_surfparams.(Ti2171)
in
letrec o_color_red : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2170 : INT =
      int 0
    in
    m_color.(Ti2170)
in
letrec o_color_green : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2169 : INT =
      int 1
    in
    m_color.(Ti2169)
in
letrec o_color_blue : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (m_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (m_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2168 : INT =
      int 2
    in
    m_color.(Ti2168)
in
letrec o_param_r1 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2167 : INT =
      int 0
    in
    m_rot123.(Ti2167)
in
letrec o_param_r2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2166 : INT =
      int 1
    in
    m_rot123.(Ti2166)
in
letrec o_param_r3 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (m_rot123 : Array of FLOAT), (xm_ctbl : Array of FLOAT)
    m
  in
    let Ti2165 : INT =
      int 2
    in
    m_rot123.(Ti2165)
in
letrec o_param_ctbl : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let tuple (xm_tex : INT), (xm_shape : INT), (xm_surface : INT), (xm_isrot : INT), (xm_abc : Array of FLOAT), (xm_xyz : Array of FLOAT), (xm_invert : BOOL), (xm_surfparams : Array of FLOAT), (xm_color : Array of FLOAT), (xm_rot123 : Array of FLOAT), (m_ctbl : Array of FLOAT)
    m
  in
    m_ctbl
in
letrec p_rgb : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (m_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_rgb
in
letrec p_intersection_points : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (m_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_isect_ps
in
letrec p_surface_ids : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (m_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_sids
in
letrec p_calc_diffuse : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of BOOL) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (m_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_cdif
in
letrec p_energy : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (m_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_engy
in
letrec p_received_ray_20percent : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (m_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_r20p
in
letrec p_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> INT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2164 : INT =
      int 0
    in
    m_gid.(Ti2164)
in
letrec p_set_group_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (id : INT)
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (m_gid : Array of INT), (xm_nvectors : Array of Array of FLOAT)
    pixel
  in
    let Ti2163 : INT =
      int 0
    in
    m_gid.(Ti2163) <- id
in
letrec p_nvectors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let tuple (xm_rgb : Array of FLOAT), (xm_isect_ps : Array of Array of FLOAT), (xm_sids : Array of INT), (xm_cdif : Array of BOOL), (xm_engy : Array of Array of FLOAT), (xm_r20p : Array of Array of FLOAT), (xm_gid : Array of INT), (m_nvectors : Array of Array of FLOAT)
    pixel
  in
    m_nvectors
in
letrec d_vec : ((Array of FLOAT * Array of Array of FLOAT) -> Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (m_vec : Array of FLOAT), (xm_const : Array of Array of FLOAT)
    d
  in
    m_vec
in
letrec d_const : ((Array of FLOAT * Array of Array of FLOAT) -> Array of Array of FLOAT) =
variables : (d : (Array of FLOAT * Array of Array of FLOAT))
  let tuple (dm_vec : Array of FLOAT), (m_const : Array of Array of FLOAT)
    d
  in
    m_const
in
letrec r_surface_id : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> INT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (m_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_sid
in
letrec r_dvec : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (m_dvec : (Array of FLOAT * Array of Array of FLOAT)), (xm_br : FLOAT)
    r
  in
    m_dvec
in
letrec r_bright : ((INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) -> FLOAT) =
variables : (r : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT))
  let tuple (xm_sid : INT), (xm_dvec : (Array of FLOAT * Array of Array of FLOAT)), (m_br : FLOAT)
    r
  in
    m_br
in
letrec rad : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td2162 : FLOAT =
    float 0.017453293
  in
  fmul x Td2162
in
letrec read_screen_settings : (UNIT -> UNIT) =
variables : (Tu23 : UNIT)
  let Tu37 : UNIT =
    let Ti2107 : INT =
      int 0
    in
    let Td2109 : FLOAT =
      let Tu2108 : UNIT =
        unit ()
      in
      unknown inflt Tu2108
    in
    screen.(Ti2107) <- Td2109
  in
  let Tu36 : UNIT =
    let Ti2110 : INT =
      int 1
    in
    let Td2112 : FLOAT =
      let Tu2111 : UNIT =
        unit ()
      in
      unknown inflt Tu2111
    in
    screen.(Ti2110) <- Td2112
  in
  let Tu35 : UNIT =
    let Ti2113 : INT =
      int 2
    in
    let Td2115 : FLOAT =
      let Tu2114 : UNIT =
        unit ()
      in
      unknown inflt Tu2114
    in
    screen.(Ti2113) <- Td2115
  in
  let v1 : FLOAT =
    let Td2117 : FLOAT =
      let Tu2116 : UNIT =
        unit ()
      in
      unknown inflt Tu2116
    in
    app
      rad
      Td2117
  in
  let cos_v1 : FLOAT =
    app
      cos
      v1
  in
  let sin_v1 : FLOAT =
    app
      sin
      v1
  in
  let v2 : FLOAT =
    let Td2119 : FLOAT =
      let Tu2118 : UNIT =
        unit ()
      in
      unknown inflt Tu2118
    in
    app
      rad
      Td2119
  in
  let cos_v2 : FLOAT =
    app
      cos
      v2
  in
  let sin_v2 : FLOAT =
    app
      sin
      v2
  in
  let Tu34 : UNIT =
    let Ti2120 : INT =
      int 0
    in
    let Td2123 : FLOAT =
      let Td2121 : FLOAT =
        fmul cos_v1 sin_v2
      in
      let Td2122 : FLOAT =
        float 200.
      in
      fmul Td2121 Td2122
    in
    screenz_dir.(Ti2120) <- Td2123
  in
  let Tu33 : UNIT =
    let Ti2124 : INT =
      int 1
    in
    let Td2126 : FLOAT =
      let Td2125 : FLOAT =
        float -200.
      in
      fmul sin_v1 Td2125
    in
    screenz_dir.(Ti2124) <- Td2126
  in
  let Tu32 : UNIT =
    let Ti2127 : INT =
      int 2
    in
    let Td2130 : FLOAT =
      let Td2128 : FLOAT =
        fmul cos_v1 cos_v2
      in
      let Td2129 : FLOAT =
        float 200.
      in
      fmul Td2128 Td2129
    in
    screenz_dir.(Ti2127) <- Td2130
  in
  let Tu31 : UNIT =
    let Ti2131 : INT =
      int 0
    in
    screenx_dir.(Ti2131) <- cos_v2
  in
  let Tu30 : UNIT =
    let Ti2132 : INT =
      int 1
    in
    let Td2133 : FLOAT =
      float 0.
    in
    screenx_dir.(Ti2132) <- Td2133
  in
  let Tu29 : UNIT =
    let Ti2134 : INT =
      int 2
    in
    let Td2135 : FLOAT =
      app
        fneg
        sin_v2
    in
    screenx_dir.(Ti2134) <- Td2135
  in
  let Tu28 : UNIT =
    let Ti2136 : INT =
      int 0
    in
    let Td2138 : FLOAT =
      let Td2137 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2137 sin_v2
    in
    screeny_dir.(Ti2136) <- Td2138
  in
  let Tu27 : UNIT =
    let Ti2139 : INT =
      int 1
    in
    let Td2140 : FLOAT =
      app
        fneg
        cos_v1
    in
    screeny_dir.(Ti2139) <- Td2140
  in
  let Tu26 : UNIT =
    let Ti2141 : INT =
      int 2
    in
    let Td2143 : FLOAT =
      let Td2142 : FLOAT =
        app
          fneg
          sin_v1
      in
      fmul Td2142 cos_v2
    in
    screeny_dir.(Ti2141) <- Td2143
  in
  let Tu25 : UNIT =
    let Ti2144 : INT =
      int 0
    in
    let Td2149 : FLOAT =
      let Td2146 : FLOAT =
        let Ti2145 : INT =
          int 0
        in
        screen.(Ti2145)
      in
      let Td2148 : FLOAT =
        let Ti2147 : INT =
          int 0
        in
        screenz_dir.(Ti2147)
      in
      fsub Td2146 Td2148
    in
    viewpoint.(Ti2144) <- Td2149
  in
  let Tu24 : UNIT =
    let Ti2150 : INT =
      int 1
    in
    let Td2155 : FLOAT =
      let Td2152 : FLOAT =
        let Ti2151 : INT =
          int 1
        in
        screen.(Ti2151)
      in
      let Td2154 : FLOAT =
        let Ti2153 : INT =
          int 1
        in
        screenz_dir.(Ti2153)
      in
      fsub Td2152 Td2154
    in
    viewpoint.(Ti2150) <- Td2155
  in
  let Ti2156 : INT =
    int 2
  in
  let Td2161 : FLOAT =
    let Td2158 : FLOAT =
      let Ti2157 : INT =
        int 2
      in
      screen.(Ti2157)
    in
    let Td2160 : FLOAT =
      let Ti2159 : INT =
        int 2
      in
      screenz_dir.(Ti2159)
    in
    fsub Td2158 Td2160
  in
  viewpoint.(Ti2156) <- Td2161
in
letrec read_light : (UNIT -> UNIT) =
variables : (Tu38 : UNIT)
  let nl : INT =
    let Tu2093 : UNIT =
      unit ()
    in
    unknown inint Tu2093
  in
  let l1 : FLOAT =
    let Td2095 : FLOAT =
      let Tu2094 : UNIT =
        unit ()
      in
      unknown inflt Tu2094
    in
    app
      rad
      Td2095
  in
  let sl1 : FLOAT =
    app
      sin
      l1
  in
  let Tu41 : UNIT =
    let Ti2096 : INT =
      int 1
    in
    let Td2097 : FLOAT =
      app
        fneg
        sl1
    in
    light.(Ti2096) <- Td2097
  in
  let l2 : FLOAT =
    let Td2099 : FLOAT =
      let Tu2098 : UNIT =
        unit ()
      in
      unknown inflt Tu2098
    in
    app
      rad
      Td2099
  in
  let cl1 : FLOAT =
    app
      cos
      l1
  in
  let sl2 : FLOAT =
    app
      sin
      l2
  in
  let Tu40 : UNIT =
    let Ti2100 : INT =
      int 0
    in
    let Td2101 : FLOAT =
      fmul cl1 sl2
    in
    light.(Ti2100) <- Td2101
  in
  let cl2 : FLOAT =
    app
      cos
      l2
  in
  let Tu39 : UNIT =
    let Ti2102 : INT =
      int 2
    in
    let Td2103 : FLOAT =
      fmul cl1 cl2
    in
    light.(Ti2102) <- Td2103
  in
  let Ti2104 : INT =
    int 0
  in
  let Td2106 : FLOAT =
    let Tu2105 : UNIT =
      unit ()
    in
    unknown inflt Tu2105
  in
  beam.(Ti2104) <- Td2106
in
letrec rotate_quadratic_matrix : (Array of FLOAT -> (Array of FLOAT -> UNIT)) =
variables : (abc : Array of FLOAT), (rot : Array of FLOAT)
  let cos_x : FLOAT =
    let Td2007 : FLOAT =
      let Ti2006 : INT =
        int 0
      in
      rot.(Ti2006)
    in
    app
      cos
      Td2007
  in
  let sin_x : FLOAT =
    let Td2009 : FLOAT =
      let Ti2008 : INT =
        int 0
      in
      rot.(Ti2008)
    in
    app
      sin
      Td2009
  in
  let cos_y : FLOAT =
    let Td2011 : FLOAT =
      let Ti2010 : INT =
        int 1
      in
      rot.(Ti2010)
    in
    app
      cos
      Td2011
  in
  let sin_y : FLOAT =
    let Td2013 : FLOAT =
      let Ti2012 : INT =
        int 1
      in
      rot.(Ti2012)
    in
    app
      sin
      Td2013
  in
  let cos_z : FLOAT =
    let Td2015 : FLOAT =
      let Ti2014 : INT =
        int 2
      in
      rot.(Ti2014)
    in
    app
      cos
      Td2015
  in
  let sin_z : FLOAT =
    let Td2017 : FLOAT =
      let Ti2016 : INT =
        int 2
      in
      rot.(Ti2016)
    in
    app
      sin
      Td2017
  in
  let m00 : FLOAT =
    fmul cos_y cos_z
  in
  let m01 : FLOAT =
    let Td2019 : FLOAT =
      let Td2018 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2018 cos_z
    in
    let Td2020 : FLOAT =
      fmul cos_x sin_z
    in
    fsub Td2019 Td2020
  in
  let m02 : FLOAT =
    let Td2022 : FLOAT =
      let Td2021 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2021 cos_z
    in
    let Td2023 : FLOAT =
      fmul sin_x sin_z
    in
    fadd Td2022 Td2023
  in
  let m10 : FLOAT =
    fmul cos_y sin_z
  in
  let m11 : FLOAT =
    let Td2025 : FLOAT =
      let Td2024 : FLOAT =
        fmul sin_x sin_y
      in
      fmul Td2024 sin_z
    in
    let Td2026 : FLOAT =
      fmul cos_x cos_z
    in
    fadd Td2025 Td2026
  in
  let m12 : FLOAT =
    let Td2028 : FLOAT =
      let Td2027 : FLOAT =
        fmul cos_x sin_y
      in
      fmul Td2027 sin_z
    in
    let Td2029 : FLOAT =
      fmul sin_x cos_z
    in
    fsub Td2028 Td2029
  in
  let m20 : FLOAT =
    app
      fneg
      sin_y
  in
  let m21 : FLOAT =
    fmul sin_x cos_y
  in
  let m22 : FLOAT =
    fmul cos_x cos_y
  in
  let ao : FLOAT =
    let Ti2030 : INT =
      int 0
    in
    abc.(Ti2030)
  in
  let bo : FLOAT =
    let Ti2031 : INT =
      int 1
    in
    abc.(Ti2031)
  in
  let co : FLOAT =
    let Ti2032 : INT =
      int 2
    in
    abc.(Ti2032)
  in
  let Tu46 : UNIT =
    let Ti2033 : INT =
      int 0
    in
    let Td2041 : FLOAT =
      let Td2038 : FLOAT =
        let Td2035 : FLOAT =
          let Td2034 : FLOAT =
            app
              fsqr
              m00
          in
          fmul ao Td2034
        in
        let Td2037 : FLOAT =
          let Td2036 : FLOAT =
            app
              fsqr
              m10
          in
          fmul bo Td2036
        in
        fadd Td2035 Td2037
      in
      let Td2040 : FLOAT =
        let Td2039 : FLOAT =
          app
            fsqr
            m20
        in
        fmul co Td2039
      in
      fadd Td2038 Td2040
    in
    abc.(Ti2033) <- Td2041
  in
  let Tu45 : UNIT =
    let Ti2042 : INT =
      int 1
    in
    let Td2050 : FLOAT =
      let Td2047 : FLOAT =
        let Td2044 : FLOAT =
          let Td2043 : FLOAT =
            app
              fsqr
              m01
          in
          fmul ao Td2043
        in
        let Td2046 : FLOAT =
          let Td2045 : FLOAT =
            app
              fsqr
              m11
          in
          fmul bo Td2045
        in
        fadd Td2044 Td2046
      in
      let Td2049 : FLOAT =
        let Td2048 : FLOAT =
          app
            fsqr
            m21
        in
        fmul co Td2048
      in
      fadd Td2047 Td2049
    in
    abc.(Ti2042) <- Td2050
  in
  let Tu44 : UNIT =
    let Ti2051 : INT =
      int 2
    in
    let Td2059 : FLOAT =
      let Td2056 : FLOAT =
        let Td2053 : FLOAT =
          let Td2052 : FLOAT =
            app
              fsqr
              m02
          in
          fmul ao Td2052
        in
        let Td2055 : FLOAT =
          let Td2054 : FLOAT =
            app
              fsqr
              m12
          in
          fmul bo Td2054
        in
        fadd Td2053 Td2055
      in
      let Td2058 : FLOAT =
        let Td2057 : FLOAT =
          app
            fsqr
            m22
        in
        fmul co Td2057
      in
      fadd Td2056 Td2058
    in
    abc.(Ti2051) <- Td2059
  in
  let Tu43 : UNIT =
    let Ti2060 : INT =
      int 0
    in
    let Td2070 : FLOAT =
      let Td2061 : FLOAT =
        float 2.
      in
      let Td2069 : FLOAT =
        let Td2066 : FLOAT =
          let Td2063 : FLOAT =
            let Td2062 : FLOAT =
              fmul ao m01
            in
            fmul Td2062 m02
          in
          let Td2065 : FLOAT =
            let Td2064 : FLOAT =
              fmul bo m11
            in
            fmul Td2064 m12
          in
          fadd Td2063 Td2065
        in
        let Td2068 : FLOAT =
          let Td2067 : FLOAT =
            fmul co m21
          in
          fmul Td2067 m22
        in
        fadd Td2066 Td2068
      in
      fmul Td2061 Td2069
    in
    rot.(Ti2060) <- Td2070
  in
  let Tu42 : UNIT =
    let Ti2071 : INT =
      int 1
    in
    let Td2081 : FLOAT =
      let Td2072 : FLOAT =
        float 2.
      in
      let Td2080 : FLOAT =
        let Td2077 : FLOAT =
          let Td2074 : FLOAT =
            let Td2073 : FLOAT =
              fmul ao m00
            in
            fmul Td2073 m02
          in
          let Td2076 : FLOAT =
            let Td2075 : FLOAT =
              fmul bo m10
            in
            fmul Td2075 m12
          in
          fadd Td2074 Td2076
        in
        let Td2079 : FLOAT =
          let Td2078 : FLOAT =
            fmul co m20
          in
          fmul Td2078 m22
        in
        fadd Td2077 Td2079
      in
      fmul Td2072 Td2080
    in
    rot.(Ti2071) <- Td2081
  in
  let Ti2082 : INT =
    int 2
  in
  let Td2092 : FLOAT =
    let Td2083 : FLOAT =
      float 2.
    in
    let Td2091 : FLOAT =
      let Td2088 : FLOAT =
        let Td2085 : FLOAT =
          let Td2084 : FLOAT =
            fmul ao m00
          in
          fmul Td2084 m01
        in
        let Td2087 : FLOAT =
          let Td2086 : FLOAT =
            fmul bo m10
          in
          fmul Td2086 m11
        in
        fadd Td2085 Td2087
      in
      let Td2090 : FLOAT =
        let Td2089 : FLOAT =
          fmul co m20
        in
        fmul Td2089 m21
      in
      fadd Td2088 Td2090
    in
    fmul Td2083 Td2091
  in
  rot.(Ti2082) <- Td2092
in
letrec read_nth_object : (INT -> BOOL) =
variables : (n : INT)
  let texture : INT =
    let Tu1919 : UNIT =
      unit ()
    in
    unknown inint Tu1919
  in
  let Ti1921 : INT =
    let Ti1920 : INT =
      int 1
    in
    neg Ti1920
  in
  if texture == Ti1921
    int 0
    let form : INT =
      let Tu1922 : UNIT =
        unit ()
      in
      unknown inint Tu1922
    in
    let refltype : INT =
      let Tu1923 : UNIT =
        unit ()
      in
      unknown inint Tu1923
    in
    let isrot_p : INT =
      let Tu1924 : UNIT =
        unit ()
      in
      unknown inint Tu1924
    in
    let abc : Array of FLOAT =
      let Ti1925 : INT =
        int 3
      in
      let Td1926 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1925
        Td1926
    in
    let Tu65 : UNIT =
      let Ti1927 : INT =
        int 0
      in
      let Td1929 : FLOAT =
        let Tu1928 : UNIT =
          unit ()
        in
        unknown inflt Tu1928
      in
      abc.(Ti1927) <- Td1929
    in
    let Tu64 : UNIT =
      let Ti1930 : INT =
        int 1
      in
      let Td1932 : FLOAT =
        let Tu1931 : UNIT =
          unit ()
        in
        unknown inflt Tu1931
      in
      abc.(Ti1930) <- Td1932
    in
    let Tu63 : UNIT =
      let Ti1933 : INT =
        int 2
      in
      let Td1935 : FLOAT =
        let Tu1934 : UNIT =
          unit ()
        in
        unknown inflt Tu1934
      in
      abc.(Ti1933) <- Td1935
    in
    let xyz : Array of FLOAT =
      let Ti1936 : INT =
        int 3
      in
      let Td1937 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1936
        Td1937
    in
    let Tu62 : UNIT =
      let Ti1938 : INT =
        int 0
      in
      let Td1940 : FLOAT =
        let Tu1939 : UNIT =
          unit ()
        in
        unknown inflt Tu1939
      in
      xyz.(Ti1938) <- Td1940
    in
    let Tu61 : UNIT =
      let Ti1941 : INT =
        int 1
      in
      let Td1943 : FLOAT =
        let Tu1942 : UNIT =
          unit ()
        in
        unknown inflt Tu1942
      in
      xyz.(Ti1941) <- Td1943
    in
    let Tu60 : UNIT =
      let Ti1944 : INT =
        int 2
      in
      let Td1946 : FLOAT =
        let Tu1945 : UNIT =
          unit ()
        in
        unknown inflt Tu1945
      in
      xyz.(Ti1944) <- Td1946
    in
    let m_invert : BOOL =
      let Td1948 : FLOAT =
        let Tu1947 : UNIT =
          unit ()
        in
        unknown inflt Tu1947
      in
      app
        fisneg
        Td1948
    in
    let reflparam : Array of FLOAT =
      let Ti1949 : INT =
        int 2
      in
      let Td1950 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1949
        Td1950
    in
    let Tu59 : UNIT =
      let Ti1951 : INT =
        int 0
      in
      let Td1953 : FLOAT =
        let Tu1952 : UNIT =
          unit ()
        in
        unknown inflt Tu1952
      in
      reflparam.(Ti1951) <- Td1953
    in
    let Tu58 : UNIT =
      let Ti1954 : INT =
        int 1
      in
      let Td1956 : FLOAT =
        let Tu1955 : UNIT =
          unit ()
        in
        unknown inflt Tu1955
      in
      reflparam.(Ti1954) <- Td1956
    in
    let color : Array of FLOAT =
      let Ti1957 : INT =
        int 3
      in
      let Td1958 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1957
        Td1958
    in
    let Tu57 : UNIT =
      let Ti1959 : INT =
        int 0
      in
      let Td1961 : FLOAT =
        let Tu1960 : UNIT =
          unit ()
        in
        unknown inflt Tu1960
      in
      color.(Ti1959) <- Td1961
    in
    let Tu56 : UNIT =
      let Ti1962 : INT =
        int 1
      in
      let Td1964 : FLOAT =
        let Tu1963 : UNIT =
          unit ()
        in
        unknown inflt Tu1963
      in
      color.(Ti1962) <- Td1964
    in
    let Tu55 : UNIT =
      let Ti1965 : INT =
        int 2
      in
      let Td1967 : FLOAT =
        let Tu1966 : UNIT =
          unit ()
        in
        unknown inflt Tu1966
      in
      color.(Ti1965) <- Td1967
    in
    let rotation : Array of FLOAT =
      let Ti1968 : INT =
        int 3
      in
      let Td1969 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1968
        Td1969
    in
    let Tu54 : UNIT =
      let Ti1970 : INT =
        int 0
      in
      if isrot_p == Ti1970
        unit ()
        let Tu48 : UNIT =
          let Ti1971 : INT =
            int 0
          in
          let Td1974 : FLOAT =
            let Td1973 : FLOAT =
              let Tu1972 : UNIT =
                unit ()
              in
              unknown inflt Tu1972
            in
            app
              rad
              Td1973
          in
          rotation.(Ti1971) <- Td1974
        in
        let Tu47 : UNIT =
          let Ti1975 : INT =
            int 1
          in
          let Td1978 : FLOAT =
            let Td1977 : FLOAT =
              let Tu1976 : UNIT =
                unit ()
              in
              unknown inflt Tu1976
            in
            app
              rad
              Td1977
          in
          rotation.(Ti1975) <- Td1978
        in
        let Ti1979 : INT =
          int 2
        in
        let Td1982 : FLOAT =
          let Td1981 : FLOAT =
            let Tu1980 : UNIT =
              unit ()
            in
            unknown inflt Tu1980
          in
          app
            rad
            Td1981
        in
        rotation.(Ti1979) <- Td1982
    in
    let m_invert2 : BOOL =
      let Ti1983 : INT =
        int 2
      in
      if form == Ti1983
        int 1
        m_invert
    in
    let ctbl : Array of FLOAT =
      let Ti1984 : INT =
        int 4
      in
      let Td1985 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti1984
        Td1985
    in
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      Tuple
        texture
        form
        refltype
        isrot_p
        abc
        xyz
        m_invert2
        reflparam
        color
        rotation
        ctbl
    in
    let Tu53 : UNIT =
      objects.(n) <- obj
    in
    let Tu52 : UNIT =
      let Ti1986 : INT =
        int 3
      in
      if form == Ti1986
        let a : FLOAT =
          let Ti1987 : INT =
            int 0
          in
          abc.(Ti1987)
        in
        let Tu50 : UNIT =
          let Ti1988 : INT =
            int 0
          in
          let Td1991 : FLOAT =
            if a == 0.0 
              float 0.
              let Td1989 : FLOAT =
                app
                  sgn
                  a
              in
              let Td1990 : FLOAT =
                app
                  fsqr
                  a
              in
              fdiv Td1989 Td1990
          in
          abc.(Ti1988) <- Td1991
        in
        let b : FLOAT =
          let Ti1992 : INT =
            int 1
          in
          abc.(Ti1992)
        in
        let Tu49 : UNIT =
          let Ti1993 : INT =
            int 1
          in
          let Td1996 : FLOAT =
            if b == 0.0 
              float 0.
              let Td1994 : FLOAT =
                app
                  sgn
                  b
              in
              let Td1995 : FLOAT =
                app
                  fsqr
                  b
              in
              fdiv Td1994 Td1995
          in
          abc.(Ti1993) <- Td1996
        in
        let c : FLOAT =
          let Ti1997 : INT =
            int 2
          in
          abc.(Ti1997)
        in
        let Ti1998 : INT =
          int 2
        in
        let Td2001 : FLOAT =
          if c == 0.0 
            float 0.
            let Td1999 : FLOAT =
              app
                sgn
                c
            in
            let Td2000 : FLOAT =
              app
                fsqr
                c
            in
            fdiv Td1999 Td2000
        in
        abc.(Ti1998) <- Td2001
        let Ti2002 : INT =
          int 2
        in
        if form == Ti2002
          let Ti2004 : INT =
            let Ti2003 : INT =
              int 0
            in
            if m_invert == Ti2003
              int 1
              int 0
          in
          app
            vecunit_sgn
            abc
            Ti2004
          unit ()
    in
    let Tu51 : UNIT =
      let Ti2005 : INT =
        int 0
      in
      if isrot_p == Ti2005
        unit ()
        app
          rotate_quadratic_matrix
          abc
          rotation
    in
    int 1
in
letrec read_object : (INT -> UNIT) =
variables : (n : INT)
  let Ti1913 : INT =
    int 60
  in
  if Ti1913 <= n
    unit ()
    let Tb1914 : BOOL =
      app
        read_nth_object
        n
    in
    let Ti1915 : INT =
      int 0
    in
    if Tb1914 == Ti1915
      let Ti1916 : INT =
        int 0
      in
      n_objects.(Ti1916) <- n
      let Ti1918 : INT =
        let Ti1917 : INT =
          int 1
        in
        add n Ti1917
      in
      app
        read_object
        Ti1918
in
letrec read_all_object : (UNIT -> UNIT) =
variables : (Tu66 : UNIT)
  let Ti1912 : INT =
    int 0
  in
  app
    read_object
    Ti1912
in
letrec read_net_item : (INT -> Array of INT) =
variables : (length : INT)
  let item : INT =
    let Tu1903 : UNIT =
      unit ()
    in
    unknown inint Tu1903
  in
  let Ti1905 : INT =
    let Ti1904 : INT =
      int 1
    in
    neg Ti1904
  in
  if item == Ti1905
    let Ti1907 : INT =
      let Ti1906 : INT =
        int 1
      in
      add length Ti1906
    in
    let Ti1909 : INT =
      let Ti1908 : INT =
        int 1
      in
      neg Ti1908
    in
    extfunapp
      create_array
      Ti1907
      Ti1909
    let v : Array of INT =
      let Ti1911 : INT =
        let Ti1910 : INT =
          int 1
        in
        add length Ti1910
      in
      app
        read_net_item
        Ti1911
    in
    let Tu67 : UNIT =
      v.(length) <- item
    in
    v
in
letrec read_or_network : (INT -> Array of Array of INT) =
variables : (length : INT)
  let net : Array of INT =
    let Ti1894 : INT =
      int 0
    in
    app
      read_net_item
      Ti1894
  in
  let Ti1896 : INT =
    let Ti1895 : INT =
      int 0
    in
    net.(Ti1895)
  in
  let Ti1898 : INT =
    let Ti1897 : INT =
      int 1
    in
    neg Ti1897
  in
  if Ti1896 == Ti1898
    let Ti1900 : INT =
      let Ti1899 : INT =
        int 1
      in
      add length Ti1899
    in
    extfunapp
      create_array
      Ti1900
      net
    let v : Array of Array of INT =
      let Ti1902 : INT =
        let Ti1901 : INT =
          int 1
        in
        add length Ti1901
      in
      app
        read_or_network
        Ti1902
    in
    let Tu68 : UNIT =
      v.(length) <- net
    in
    v
in
letrec read_and_network : (INT -> UNIT) =
variables : (n : INT)
  let net : Array of INT =
    let Ti1887 : INT =
      int 0
    in
    app
      read_net_item
      Ti1887
  in
  let Ti1889 : INT =
    let Ti1888 : INT =
      int 0
    in
    net.(Ti1888)
  in
  let Ti1891 : INT =
    let Ti1890 : INT =
      int 1
    in
    neg Ti1890
  in
  if Ti1889 == Ti1891
    unit ()
    let Tu69 : UNIT =
      and_net.(n) <- net
    in
    let Ti1893 : INT =
      let Ti1892 : INT =
        int 1
      in
      add n Ti1892
    in
    app
      read_and_network
      Ti1893
in
letrec read_parameter : (UNIT -> UNIT) =
variables : (Tu70 : UNIT)
  let Tu74 : UNIT =
    let Tu1880 : UNIT =
      unit ()
    in
    app
      read_screen_settings
      Tu1880
  in
  let Tu73 : UNIT =
    let Tu1881 : UNIT =
      unit ()
    in
    app
      read_light
      Tu1881
  in
  let Tu72 : UNIT =
    let Tu1882 : UNIT =
      unit ()
    in
    app
      read_all_object
      Tu1882
  in
  let Tu71 : UNIT =
    let Ti1883 : INT =
      int 0
    in
    app
      read_and_network
      Ti1883
  in
  let Ti1884 : INT =
    int 0
  in
  let Ta1886 : Array of Array of INT =
    let Ti1885 : INT =
      int 0
    in
    app
      read_or_network
      Ti1885
  in
  or_net.(Ti1884) <- Ta1886
in
letrec solver_rect_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> (INT -> BOOL)))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT), (i0 : INT), (i1 : INT), (i2 : INT)
  let Td1857 : FLOAT =
    dirvec.(i0)
  in
  if Td1857 == 0.0 
    int 0
    let abc : Array of FLOAT =
      app
        o_param_abc
        m
    in
    let d : FLOAT =
      let Tb1861 : BOOL =
        let Tb1858 : BOOL =
          app
            o_isinvert
            m
        in
        let Tb1860 : BOOL =
          let Td1859 : FLOAT =
            dirvec.(i0)
          in
          app
            fisneg
            Td1859
        in
        app
          xor
          Tb1858
          Tb1860
      in
      let Td1862 : FLOAT =
        abc.(i0)
      in
      app
        fneg_cond
        Tb1861
        Td1862
    in
    let d2 : FLOAT =
      let Td1863 : FLOAT =
        fsub d b0
      in
      let Td1864 : FLOAT =
        dirvec.(i0)
      in
      fdiv Td1863 Td1864
    in
    let Tb1870 : BOOL =
      let Td1868 : FLOAT =
        let Td1867 : FLOAT =
          let Td1866 : FLOAT =
            let Td1865 : FLOAT =
              dirvec.(i1)
            in
            fmul d2 Td1865
          in
          fadd Td1866 b1
        in
        app
          fabs
          Td1867
      in
      let Td1869 : FLOAT =
        abc.(i1)
      in
      app
        fless
        Td1868
        Td1869
    in
    let Ti1871 : INT =
      int 0
    in
    if Tb1870 == Ti1871
      int 0
      let Tb1877 : BOOL =
        let Td1875 : FLOAT =
          let Td1874 : FLOAT =
            let Td1873 : FLOAT =
              let Td1872 : FLOAT =
                dirvec.(i2)
              in
              fmul d2 Td1872
            in
            fadd Td1873 b2
          in
          app
            fabs
            Td1874
        in
        let Td1876 : FLOAT =
          abc.(i2)
        in
        app
          fless
          Td1875
          Td1876
      in
      let Ti1878 : INT =
        int 0
      in
      if Tb1877 == Ti1878
        int 0
        let Tu75 : UNIT =
          let Ti1879 : INT =
            int 0
          in
          solver_dist.(Ti1879) <- d2
        in
        int 1
in
letrec solver_rect : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1845 : BOOL =
    let Ti1842 : INT =
      int 0
    in
    let Ti1843 : INT =
      int 1
    in
    let Ti1844 : INT =
      int 2
    in
    app
      solver_rect_surface
      m
      dirvec
      b0
      b1
      b2
      Ti1842
      Ti1843
      Ti1844
  in
  let Ti1846 : INT =
    int 0
  in
  if Tb1845 == Ti1846
    let Tb1850 : BOOL =
      let Ti1847 : INT =
        int 1
      in
      let Ti1848 : INT =
        int 2
      in
      let Ti1849 : INT =
        int 0
      in
      app
        solver_rect_surface
        m
        dirvec
        b1
        b2
        b0
        Ti1847
        Ti1848
        Ti1849
    in
    let Ti1851 : INT =
      int 0
    in
    if Tb1850 == Ti1851
      let Tb1855 : BOOL =
        let Ti1852 : INT =
          int 2
        in
        let Ti1853 : INT =
          int 0
        in
        let Ti1854 : INT =
          int 1
        in
        app
          solver_rect_surface
          m
          dirvec
          b2
          b0
          b1
          Ti1852
          Ti1853
          Ti1854
      in
      let Ti1856 : INT =
        int 0
      in
      if Tb1855 == Ti1856
        int 0
        int 3
      int 2
    int 1
in
letrec solver_surface : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let abc : Array of FLOAT =
    app
      o_param_abc
      m
  in
  let d : FLOAT =
    app
      veciprod
      dirvec
      abc
  in
  let Tb1836 : BOOL =
    app
      fispos
      d
  in
  let Ti1837 : INT =
    int 0
  in
  if Tb1836 == Ti1837
    int 0
    let Tu76 : UNIT =
      let Ti1838 : INT =
        int 0
      in
      let Td1841 : FLOAT =
        let Td1840 : FLOAT =
          let Td1839 : FLOAT =
            app
              veciprod2
              abc
              b0
              b1
              b2
          in
          app
            fneg
            Td1839
        in
        fdiv Td1840 d
      in
      solver_dist.(Ti1838) <- Td1841
    in
    int 1
in
letrec quadratic : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let diag_part : FLOAT =
    let Td1819 : FLOAT =
      let Td1815 : FLOAT =
        let Td1813 : FLOAT =
          app
            fsqr
            v0
        in
        let Td1814 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1813 Td1814
      in
      let Td1818 : FLOAT =
        let Td1816 : FLOAT =
          app
            fsqr
            v1
        in
        let Td1817 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1816 Td1817
      in
      fadd Td1815 Td1818
    in
    let Td1822 : FLOAT =
      let Td1820 : FLOAT =
        app
          fsqr
          v2
      in
      let Td1821 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1820 Td1821
    in
    fadd Td1819 Td1822
  in
  let Ti1823 : INT =
    app
      o_isrot
      m
  in
  let Ti1824 : INT =
    int 0
  in
  if Ti1823 == Ti1824
    diag_part
    let Td1832 : FLOAT =
      let Td1828 : FLOAT =
        let Td1827 : FLOAT =
          let Td1825 : FLOAT =
            fmul v1 v2
          in
          let Td1826 : FLOAT =
            app
              o_param_r1
              m
          in
          fmul Td1825 Td1826
        in
        fadd diag_part Td1827
      in
      let Td1831 : FLOAT =
        let Td1829 : FLOAT =
          fmul v2 v0
        in
        let Td1830 : FLOAT =
          app
            o_param_r2
            m
        in
        fmul Td1829 Td1830
      in
      fadd Td1828 Td1831
    in
    let Td1835 : FLOAT =
      let Td1833 : FLOAT =
        fmul v0 v1
      in
      let Td1834 : FLOAT =
        app
          o_param_r3
          m
      in
      fmul Td1833 Td1834
    in
    fadd Td1832 Td1835
in
letrec bilinear : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> FLOAT))))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT), (w0 : FLOAT), (w1 : FLOAT), (w2 : FLOAT)
  let diag_part : FLOAT =
    let Td1789 : FLOAT =
      let Td1785 : FLOAT =
        let Td1783 : FLOAT =
          fmul v0 w0
        in
        let Td1784 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1783 Td1784
      in
      let Td1788 : FLOAT =
        let Td1786 : FLOAT =
          fmul v1 w1
        in
        let Td1787 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1786 Td1787
      in
      fadd Td1785 Td1788
    in
    let Td1792 : FLOAT =
      let Td1790 : FLOAT =
        fmul v2 w2
      in
      let Td1791 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1790 Td1791
    in
    fadd Td1789 Td1792
  in
  let Ti1793 : INT =
    app
      o_isrot
      m
  in
  let Ti1794 : INT =
    int 0
  in
  if Ti1793 == Ti1794
    diag_part
    let Td1812 : FLOAT =
      let Td1811 : FLOAT =
        let Td1805 : FLOAT =
          let Td1799 : FLOAT =
            let Td1797 : FLOAT =
              let Td1795 : FLOAT =
                fmul v2 w1
              in
              let Td1796 : FLOAT =
                fmul v1 w2
              in
              fadd Td1795 Td1796
            in
            let Td1798 : FLOAT =
              app
                o_param_r1
                m
            in
            fmul Td1797 Td1798
          in
          let Td1804 : FLOAT =
            let Td1802 : FLOAT =
              let Td1800 : FLOAT =
                fmul v0 w2
              in
              let Td1801 : FLOAT =
                fmul v2 w0
              in
              fadd Td1800 Td1801
            in
            let Td1803 : FLOAT =
              app
                o_param_r2
                m
            in
            fmul Td1802 Td1803
          in
          fadd Td1799 Td1804
        in
        let Td1810 : FLOAT =
          let Td1808 : FLOAT =
            let Td1806 : FLOAT =
              fmul v0 w1
            in
            let Td1807 : FLOAT =
              fmul v1 w0
            in
            fadd Td1806 Td1807
          in
          let Td1809 : FLOAT =
            app
              o_param_r3
              m
          in
          fmul Td1808 Td1809
        in
        fadd Td1805 Td1810
      in
      app
        fhalf
        Td1811
    in
    fadd diag_part Td1812
in
letrec solver_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Td1760 : FLOAT =
      let Ti1759 : INT =
        int 0
      in
      dirvec.(Ti1759)
    in
    let Td1762 : FLOAT =
      let Ti1761 : INT =
        int 1
      in
      dirvec.(Ti1761)
    in
    let Td1764 : FLOAT =
      let Ti1763 : INT =
        int 2
      in
      dirvec.(Ti1763)
    in
    app
      quadratic
      m
      Td1760
      Td1762
      Td1764
  in
  if aa == 0.0 
    int 0
    let bb : FLOAT =
      let Td1766 : FLOAT =
        let Ti1765 : INT =
          int 0
        in
        dirvec.(Ti1765)
      in
      let Td1768 : FLOAT =
        let Ti1767 : INT =
          int 1
        in
        dirvec.(Ti1767)
      in
      let Td1770 : FLOAT =
        let Ti1769 : INT =
          int 2
        in
        dirvec.(Ti1769)
      in
      app
        bilinear
        m
        Td1766
        Td1768
        Td1770
        b0
        b1
        b2
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1771 : INT =
        app
          o_form
          m
      in
      let Ti1772 : INT =
        int 3
      in
      if Ti1771 == Ti1772
        let Td1773 : FLOAT =
          float 1.
        in
        fsub cc0 Td1773
        cc0
    in
    let d : FLOAT =
      let Td1774 : FLOAT =
        app
          fsqr
          bb
      in
      let Td1775 : FLOAT =
        fmul aa cc
      in
      fsub Td1774 Td1775
    in
    let Tb1776 : BOOL =
      app
        fispos
        d
    in
    let Ti1777 : INT =
      int 0
    in
    if Tb1776 == Ti1777
      int 0
      let sd : FLOAT =
        app
          sqrt
          d
      in
      let t1 : FLOAT =
        let Tb1778 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1779 : INT =
          int 0
        in
        if Tb1778 == Ti1779
          app
            fneg
            sd
          sd
      in
      let Tu77 : UNIT =
        let Ti1780 : INT =
          int 0
        in
        let Td1782 : FLOAT =
          let Td1781 : FLOAT =
            fsub t1 bb
          in
          fdiv Td1781 aa
        in
        solver_dist.(Ti1780) <- Td1782
      in
      int 1
in
letrec solver : (INT -> (Array of FLOAT -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : Array of FLOAT), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1749 : FLOAT =
      let Ti1748 : INT =
        int 0
      in
      org.(Ti1748)
    in
    let Td1750 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1749 Td1750
  in
  let b1 : FLOAT =
    let Td1752 : FLOAT =
      let Ti1751 : INT =
        int 1
      in
      org.(Ti1751)
    in
    let Td1753 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1752 Td1753
  in
  let b2 : FLOAT =
    let Td1755 : FLOAT =
      let Ti1754 : INT =
        int 2
      in
      org.(Ti1754)
    in
    let Td1756 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1755 Td1756
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1757 : INT =
    int 1
  in
  if m_shape == Ti1757
    app
      solver_rect
      m
      dirvec
      b0
      b1
      b2
    let Ti1758 : INT =
      int 2
    in
    if m_shape == Ti1758
      app
        solver_surface
        m
        dirvec
        b0
        b1
        b2
      app
        solver_second
        m
        dirvec
        b0
        b1
        b2
in
letrec solver_rect_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (v : Array of FLOAT), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let d0 : FLOAT =
    let Td1672 : FLOAT =
      let Td1671 : FLOAT =
        let Ti1670 : INT =
          int 0
        in
        dconst.(Ti1670)
      in
      fsub Td1671 b0
    in
    let Td1674 : FLOAT =
      let Ti1673 : INT =
        int 1
      in
      dconst.(Ti1673)
    in
    fmul Td1672 Td1674
  in
  let Ti1693 : INT =
    let Tb1681 : BOOL =
      let Td1679 : FLOAT =
        let Td1678 : FLOAT =
          let Td1677 : FLOAT =
            let Td1676 : FLOAT =
              let Ti1675 : INT =
                int 1
              in
              v.(Ti1675)
            in
            fmul d0 Td1676
          in
          fadd Td1677 b1
        in
        app
          fabs
          Td1678
      in
      let Td1680 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fless
        Td1679
        Td1680
    in
    let Ti1682 : INT =
      int 0
    in
    if Tb1681 == Ti1682
      int 0
      let Tb1689 : BOOL =
        let Td1687 : FLOAT =
          let Td1686 : FLOAT =
            let Td1685 : FLOAT =
              let Td1684 : FLOAT =
                let Ti1683 : INT =
                  int 2
                in
                v.(Ti1683)
              in
              fmul d0 Td1684
            in
            fadd Td1685 b2
          in
          app
            fabs
            Td1686
        in
        let Td1688 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1687
          Td1688
      in
      let Ti1690 : INT =
        int 0
      in
      if Tb1689 == Ti1690
        int 0
        let Td1692 : FLOAT =
          let Ti1691 : INT =
            int 1
          in
          dconst.(Ti1691)
        in
        if Td1692 == 0.0 
          int 0
          int 1
  in
  let Ti1694 : INT =
    int 0
  in
  if Ti1693 == Ti1694
    let d1 : FLOAT =
      let Td1697 : FLOAT =
        let Td1696 : FLOAT =
          let Ti1695 : INT =
            int 2
          in
          dconst.(Ti1695)
        in
        fsub Td1696 b1
      in
      let Td1699 : FLOAT =
        let Ti1698 : INT =
          int 3
        in
        dconst.(Ti1698)
      in
      fmul Td1697 Td1699
    in
    let Ti1718 : INT =
      let Tb1706 : BOOL =
        let Td1704 : FLOAT =
          let Td1703 : FLOAT =
            let Td1702 : FLOAT =
              let Td1701 : FLOAT =
                let Ti1700 : INT =
                  int 0
                in
                v.(Ti1700)
              in
              fmul d1 Td1701
            in
            fadd Td1702 b0
          in
          app
            fabs
            Td1703
        in
        let Td1705 : FLOAT =
          app
            o_param_a
            m
        in
        app
          fless
          Td1704
          Td1705
      in
      let Ti1707 : INT =
        int 0
      in
      if Tb1706 == Ti1707
        int 0
        let Tb1714 : BOOL =
          let Td1712 : FLOAT =
            let Td1711 : FLOAT =
              let Td1710 : FLOAT =
                let Td1709 : FLOAT =
                  let Ti1708 : INT =
                    int 2
                  in
                  v.(Ti1708)
                in
                fmul d1 Td1709
              in
              fadd Td1710 b2
            in
            app
              fabs
              Td1711
          in
          let Td1713 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fless
            Td1712
            Td1713
        in
        let Ti1715 : INT =
          int 0
        in
        if Tb1714 == Ti1715
          int 0
          let Td1717 : FLOAT =
            let Ti1716 : INT =
              int 3
            in
            dconst.(Ti1716)
          in
          if Td1717 == 0.0 
            int 0
            int 1
    in
    let Ti1719 : INT =
      int 0
    in
    if Ti1718 == Ti1719
      let d2 : FLOAT =
        let Td1722 : FLOAT =
          let Td1721 : FLOAT =
            let Ti1720 : INT =
              int 4
            in
            dconst.(Ti1720)
          in
          fsub Td1721 b2
        in
        let Td1724 : FLOAT =
          let Ti1723 : INT =
            int 5
          in
          dconst.(Ti1723)
        in
        fmul Td1722 Td1724
      in
      let Ti1743 : INT =
        let Tb1731 : BOOL =
          let Td1729 : FLOAT =
            let Td1728 : FLOAT =
              let Td1727 : FLOAT =
                let Td1726 : FLOAT =
                  let Ti1725 : INT =
                    int 0
                  in
                  v.(Ti1725)
                in
                fmul d2 Td1726
              in
              fadd Td1727 b0
            in
            app
              fabs
              Td1728
          in
          let Td1730 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fless
            Td1729
            Td1730
        in
        let Ti1732 : INT =
          int 0
        in
        if Tb1731 == Ti1732
          int 0
          let Tb1739 : BOOL =
            let Td1737 : FLOAT =
              let Td1736 : FLOAT =
                let Td1735 : FLOAT =
                  let Td1734 : FLOAT =
                    let Ti1733 : INT =
                      int 1
                    in
                    v.(Ti1733)
                  in
                  fmul d2 Td1734
                in
                fadd Td1735 b1
              in
              app
                fabs
                Td1736
            in
            let Td1738 : FLOAT =
              app
                o_param_b
                m
            in
            app
              fless
              Td1737
              Td1738
          in
          let Ti1740 : INT =
            int 0
          in
          if Tb1739 == Ti1740
            int 0
            let Td1742 : FLOAT =
              let Ti1741 : INT =
                int 5
              in
              dconst.(Ti1741)
            in
            if Td1742 == 0.0 
              int 0
              int 1
      in
      let Ti1744 : INT =
        int 0
      in
      if Ti1743 == Ti1744
        int 0
        let Tu80 : UNIT =
          let Ti1745 : INT =
            int 0
          in
          solver_dist.(Ti1745) <- d2
        in
        int 3
      let Tu79 : UNIT =
        let Ti1746 : INT =
          int 0
        in
        solver_dist.(Ti1746) <- d1
      in
      int 2
    let Tu78 : UNIT =
      let Ti1747 : INT =
        int 0
      in
      solver_dist.(Ti1747) <- d0
    in
    int 1
in
letrec solver_surface_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1656 : BOOL =
    let Td1655 : FLOAT =
      let Ti1654 : INT =
        int 0
      in
      dconst.(Ti1654)
    in
    app
      fisneg
      Td1655
  in
  let Ti1657 : INT =
    int 0
  in
  if Tb1656 == Ti1657
    int 0
    let Tu81 : UNIT =
      let Ti1658 : INT =
        int 0
      in
      let Td1669 : FLOAT =
        let Td1665 : FLOAT =
          let Td1661 : FLOAT =
            let Td1660 : FLOAT =
              let Ti1659 : INT =
                int 1
              in
              dconst.(Ti1659)
            in
            fmul Td1660 b0
          in
          let Td1664 : FLOAT =
            let Td1663 : FLOAT =
              let Ti1662 : INT =
                int 2
              in
              dconst.(Ti1662)
            in
            fmul Td1663 b1
          in
          fadd Td1661 Td1664
        in
        let Td1668 : FLOAT =
          let Td1667 : FLOAT =
            let Ti1666 : INT =
              int 3
            in
            dconst.(Ti1666)
          in
          fmul Td1667 b2
        in
        fadd Td1665 Td1668
      in
      solver_dist.(Ti1658) <- Td1669
    in
    int 1
in
letrec solver_second_fast : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1622 : INT =
      int 0
    in
    dconst.(Ti1622)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1629 : FLOAT =
        let Td1625 : FLOAT =
          let Td1624 : FLOAT =
            let Ti1623 : INT =
              int 1
            in
            dconst.(Ti1623)
          in
          fmul Td1624 b0
        in
        let Td1628 : FLOAT =
          let Td1627 : FLOAT =
            let Ti1626 : INT =
              int 2
            in
            dconst.(Ti1626)
          in
          fmul Td1627 b1
        in
        fadd Td1625 Td1628
      in
      let Td1632 : FLOAT =
        let Td1631 : FLOAT =
          let Ti1630 : INT =
            int 3
          in
          dconst.(Ti1630)
        in
        fmul Td1631 b2
      in
      fadd Td1629 Td1632
    in
    let cc0 : FLOAT =
      app
        quadratic
        m
        b0
        b1
        b2
    in
    let cc : FLOAT =
      let Ti1633 : INT =
        app
          o_form
          m
      in
      let Ti1634 : INT =
        int 3
      in
      if Ti1633 == Ti1634
        let Td1635 : FLOAT =
          float 1.
        in
        fsub cc0 Td1635
        cc0
    in
    let d : FLOAT =
      let Td1636 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1637 : FLOAT =
        fmul aa cc
      in
      fsub Td1636 Td1637
    in
    let Tb1638 : BOOL =
      app
        fispos
        d
    in
    let Ti1639 : INT =
      int 0
    in
    if Tb1638 == Ti1639
      int 0
      let Tu82 : UNIT =
        let Tb1640 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1641 : INT =
          int 0
        in
        if Tb1640 == Ti1641
          let Ti1642 : INT =
            int 0
          in
          let Td1647 : FLOAT =
            let Td1644 : FLOAT =
              let Td1643 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1643
            in
            let Td1646 : FLOAT =
              let Ti1645 : INT =
                int 4
              in
              dconst.(Ti1645)
            in
            fmul Td1644 Td1646
          in
          solver_dist.(Ti1642) <- Td1647
          let Ti1648 : INT =
            int 0
          in
          let Td1653 : FLOAT =
            let Td1650 : FLOAT =
              let Td1649 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1649
            in
            let Td1652 : FLOAT =
              let Ti1651 : INT =
                int 4
              in
              dconst.(Ti1651)
            in
            fmul Td1650 Td1652
          in
          solver_dist.(Ti1648) <- Td1653
      in
      int 1
in
letrec solver_fast : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> INT))) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (org : Array of FLOAT)
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let b0 : FLOAT =
    let Td1611 : FLOAT =
      let Ti1610 : INT =
        int 0
      in
      org.(Ti1610)
    in
    let Td1612 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1611 Td1612
  in
  let b1 : FLOAT =
    let Td1614 : FLOAT =
      let Ti1613 : INT =
        int 1
      in
      org.(Ti1613)
    in
    let Td1615 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1614 Td1615
  in
  let b2 : FLOAT =
    let Td1617 : FLOAT =
      let Ti1616 : INT =
        int 2
      in
      org.(Ti1616)
    in
    let Td1618 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1617 Td1618
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1619 : INT =
    int 1
  in
  if m_shape == Ti1619
    let Ta1620 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1620
      dconst
      b0
      b1
      b2
    let Ti1621 : INT =
      int 2
    in
    if m_shape == Ti1621
      app
        solver_surface_fast
        m
        dconst
        b0
        b1
        b2
      app
        solver_second_fast
        m
        dconst
        b0
        b1
        b2
in
letrec solver_surface_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let Tb1602 : BOOL =
    let Td1601 : FLOAT =
      let Ti1600 : INT =
        int 0
      in
      dconst.(Ti1600)
    in
    app
      fisneg
      Td1601
  in
  let Ti1603 : INT =
    int 0
  in
  if Tb1602 == Ti1603
    int 0
    let Tu83 : UNIT =
      let Ti1604 : INT =
        int 0
      in
      let Td1609 : FLOAT =
        let Td1606 : FLOAT =
          let Ti1605 : INT =
            int 0
          in
          dconst.(Ti1605)
        in
        let Td1608 : FLOAT =
          let Ti1607 : INT =
            int 3
          in
          sconst.(Ti1607)
        in
        fmul Td1606 Td1608
      in
      solver_dist.(Ti1604) <- Td1609
    in
    int 1
in
letrec solver_second_fast2 : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> INT)))))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dconst : Array of FLOAT), (sconst : Array of FLOAT), (b0 : FLOAT), (b1 : FLOAT), (b2 : FLOAT)
  let aa : FLOAT =
    let Ti1570 : INT =
      int 0
    in
    dconst.(Ti1570)
  in
  if aa == 0.0 
    int 0
    let neg_bb : FLOAT =
      let Td1577 : FLOAT =
        let Td1573 : FLOAT =
          let Td1572 : FLOAT =
            let Ti1571 : INT =
              int 1
            in
            dconst.(Ti1571)
          in
          fmul Td1572 b0
        in
        let Td1576 : FLOAT =
          let Td1575 : FLOAT =
            let Ti1574 : INT =
              int 2
            in
            dconst.(Ti1574)
          in
          fmul Td1575 b1
        in
        fadd Td1573 Td1576
      in
      let Td1580 : FLOAT =
        let Td1579 : FLOAT =
          let Ti1578 : INT =
            int 3
          in
          dconst.(Ti1578)
        in
        fmul Td1579 b2
      in
      fadd Td1577 Td1580
    in
    let cc : FLOAT =
      let Ti1581 : INT =
        int 3
      in
      sconst.(Ti1581)
    in
    let d : FLOAT =
      let Td1582 : FLOAT =
        app
          fsqr
          neg_bb
      in
      let Td1583 : FLOAT =
        fmul aa cc
      in
      fsub Td1582 Td1583
    in
    let Tb1584 : BOOL =
      app
        fispos
        d
    in
    let Ti1585 : INT =
      int 0
    in
    if Tb1584 == Ti1585
      int 0
      let Tu84 : UNIT =
        let Tb1586 : BOOL =
          app
            o_isinvert
            m
        in
        let Ti1587 : INT =
          int 0
        in
        if Tb1586 == Ti1587
          let Ti1588 : INT =
            int 0
          in
          let Td1593 : FLOAT =
            let Td1590 : FLOAT =
              let Td1589 : FLOAT =
                app
                  sqrt
                  d
              in
              fsub neg_bb Td1589
            in
            let Td1592 : FLOAT =
              let Ti1591 : INT =
                int 4
              in
              dconst.(Ti1591)
            in
            fmul Td1590 Td1592
          in
          solver_dist.(Ti1588) <- Td1593
          let Ti1594 : INT =
            int 0
          in
          let Td1599 : FLOAT =
            let Td1596 : FLOAT =
              let Td1595 : FLOAT =
                app
                  sqrt
                  d
              in
              fadd neg_bb Td1595
            in
            let Td1598 : FLOAT =
              let Ti1597 : INT =
                int 4
              in
              dconst.(Ti1597)
            in
            fmul Td1596 Td1598
          in
          solver_dist.(Ti1594) <- Td1599
      in
      int 1
in
letrec solver_fast2 : (INT -> ((Array of FLOAT * Array of Array of FLOAT) -> INT)) =
variables : (index : INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
    objects.(index)
  in
  let sconst : Array of FLOAT =
    app
      o_param_ctbl
      m
  in
  let b0 : FLOAT =
    let Ti1564 : INT =
      int 0
    in
    sconst.(Ti1564)
  in
  let b1 : FLOAT =
    let Ti1565 : INT =
      int 1
    in
    sconst.(Ti1565)
  in
  let b2 : FLOAT =
    let Ti1566 : INT =
      int 2
    in
    sconst.(Ti1566)
  in
  let dconsts : Array of Array of FLOAT =
    app
      d_const
      dirvec
  in
  let dconst : Array of FLOAT =
    dconsts.(index)
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1567 : INT =
    int 1
  in
  if m_shape == Ti1567
    let Ta1568 : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    app
      solver_rect_fast
      m
      Ta1568
      dconst
      b0
      b1
      b2
    let Ti1569 : INT =
      int 2
    in
    if m_shape == Ti1569
      app
        solver_surface_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
      app
        solver_second_fast2
        m
        dconst
        sconst
        b0
        b1
        b2
in
letrec setup_rect_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1511 : INT =
      int 6
    in
    let Td1512 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1511
      Td1512
  in
  let Tu90 : UNIT =
    let Td1514 : FLOAT =
      let Ti1513 : INT =
        int 0
      in
      vec.(Ti1513)
    in
    if Td1514 == 0.0 
      let Ti1515 : INT =
        int 1
      in
      let Td1516 : FLOAT =
        float 0.
      in
      const.(Ti1515) <- Td1516
      let Tu85 : UNIT =
        let Ti1517 : INT =
          int 0
        in
        let Td1524 : FLOAT =
          let Tb1522 : BOOL =
            let Tb1518 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1521 : BOOL =
              let Td1520 : FLOAT =
                let Ti1519 : INT =
                  int 0
                in
                vec.(Ti1519)
              in
              app
                fisneg
                Td1520
            in
            app
              xor
              Tb1518
              Tb1521
          in
          let Td1523 : FLOAT =
            app
              o_param_a
              m
          in
          app
            fneg_cond
            Tb1522
            Td1523
        in
        const.(Ti1517) <- Td1524
      in
      let Ti1525 : INT =
        int 1
      in
      let Td1529 : FLOAT =
        let Td1526 : FLOAT =
          float 1.
        in
        let Td1528 : FLOAT =
          let Ti1527 : INT =
            int 0
          in
          vec.(Ti1527)
        in
        fdiv Td1526 Td1528
      in
      const.(Ti1525) <- Td1529
  in
  let Tu89 : UNIT =
    let Td1531 : FLOAT =
      let Ti1530 : INT =
        int 1
      in
      vec.(Ti1530)
    in
    if Td1531 == 0.0 
      let Ti1532 : INT =
        int 3
      in
      let Td1533 : FLOAT =
        float 0.
      in
      const.(Ti1532) <- Td1533
      let Tu86 : UNIT =
        let Ti1534 : INT =
          int 2
        in
        let Td1541 : FLOAT =
          let Tb1539 : BOOL =
            let Tb1535 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1538 : BOOL =
              let Td1537 : FLOAT =
                let Ti1536 : INT =
                  int 1
                in
                vec.(Ti1536)
              in
              app
                fisneg
                Td1537
            in
            app
              xor
              Tb1535
              Tb1538
          in
          let Td1540 : FLOAT =
            app
              o_param_b
              m
          in
          app
            fneg_cond
            Tb1539
            Td1540
        in
        const.(Ti1534) <- Td1541
      in
      let Ti1542 : INT =
        int 3
      in
      let Td1546 : FLOAT =
        let Td1543 : FLOAT =
          float 1.
        in
        let Td1545 : FLOAT =
          let Ti1544 : INT =
            int 1
          in
          vec.(Ti1544)
        in
        fdiv Td1543 Td1545
      in
      const.(Ti1542) <- Td1546
  in
  let Tu88 : UNIT =
    let Td1548 : FLOAT =
      let Ti1547 : INT =
        int 2
      in
      vec.(Ti1547)
    in
    if Td1548 == 0.0 
      let Ti1549 : INT =
        int 5
      in
      let Td1550 : FLOAT =
        float 0.
      in
      const.(Ti1549) <- Td1550
      let Tu87 : UNIT =
        let Ti1551 : INT =
          int 4
        in
        let Td1558 : FLOAT =
          let Tb1556 : BOOL =
            let Tb1552 : BOOL =
              app
                o_isinvert
                m
            in
            let Tb1555 : BOOL =
              let Td1554 : FLOAT =
                let Ti1553 : INT =
                  int 2
                in
                vec.(Ti1553)
              in
              app
                fisneg
                Td1554
            in
            app
              xor
              Tb1552
              Tb1555
          in
          let Td1557 : FLOAT =
            app
              o_param_c
              m
          in
          app
            fneg_cond
            Tb1556
            Td1557
        in
        const.(Ti1551) <- Td1558
      in
      let Ti1559 : INT =
        int 5
      in
      let Td1563 : FLOAT =
        let Td1560 : FLOAT =
          float 1.
        in
        let Td1562 : FLOAT =
          let Ti1561 : INT =
            int 2
          in
          vec.(Ti1561)
        in
        fdiv Td1560 Td1562
      in
      const.(Ti1559) <- Td1563
  in
  const
in
letrec setup_surface_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (vec : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1477 : INT =
      int 4
    in
    let Td1478 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1477
      Td1478
  in
  let d : FLOAT =
    let Td1487 : FLOAT =
      let Td1482 : FLOAT =
        let Td1480 : FLOAT =
          let Ti1479 : INT =
            int 0
          in
          vec.(Ti1479)
        in
        let Td1481 : FLOAT =
          app
            o_param_a
            m
        in
        fmul Td1480 Td1481
      in
      let Td1486 : FLOAT =
        let Td1484 : FLOAT =
          let Ti1483 : INT =
            int 1
          in
          vec.(Ti1483)
        in
        let Td1485 : FLOAT =
          app
            o_param_b
            m
        in
        fmul Td1484 Td1485
      in
      fadd Td1482 Td1486
    in
    let Td1491 : FLOAT =
      let Td1489 : FLOAT =
        let Ti1488 : INT =
          int 2
        in
        vec.(Ti1488)
      in
      let Td1490 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1489 Td1490
    in
    fadd Td1487 Td1491
  in
  let Tu94 : UNIT =
    let Tb1492 : BOOL =
      app
        fispos
        d
    in
    let Ti1493 : INT =
      int 0
    in
    if Tb1492 == Ti1493
      let Ti1494 : INT =
        int 0
      in
      let Td1495 : FLOAT =
        float 0.
      in
      const.(Ti1494) <- Td1495
      let Tu93 : UNIT =
        let Ti1496 : INT =
          int 0
        in
        let Td1498 : FLOAT =
          let Td1497 : FLOAT =
            float -1.
          in
          fdiv Td1497 d
        in
        const.(Ti1496) <- Td1498
      in
      let Tu92 : UNIT =
        let Ti1499 : INT =
          int 1
        in
        let Td1502 : FLOAT =
          let Td1501 : FLOAT =
            let Td1500 : FLOAT =
              app
                o_param_a
                m
            in
            fdiv Td1500 d
          in
          app
            fneg
            Td1501
        in
        const.(Ti1499) <- Td1502
      in
      let Tu91 : UNIT =
        let Ti1503 : INT =
          int 2
        in
        let Td1506 : FLOAT =
          let Td1505 : FLOAT =
            let Td1504 : FLOAT =
              app
                o_param_b
                m
            in
            fdiv Td1504 d
          in
          app
            fneg
            Td1505
        in
        const.(Ti1503) <- Td1506
      in
      let Ti1507 : INT =
        int 3
      in
      let Td1510 : FLOAT =
        let Td1509 : FLOAT =
          let Td1508 : FLOAT =
            app
              o_param_c
              m
          in
          fdiv Td1508 d
        in
        app
          fneg
          Td1509
      in
      const.(Ti1507) <- Td1510
  in
  const
in
letrec setup_second_table : (Array of FLOAT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> Array of FLOAT)) =
variables : (v : Array of FLOAT), (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let const : Array of FLOAT =
    let Ti1412 : INT =
      int 5
    in
    let Td1413 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti1412
      Td1413
  in
  let aa : FLOAT =
    let Td1415 : FLOAT =
      let Ti1414 : INT =
        int 0
      in
      v.(Ti1414)
    in
    let Td1417 : FLOAT =
      let Ti1416 : INT =
        int 1
      in
      v.(Ti1416)
    in
    let Td1419 : FLOAT =
      let Ti1418 : INT =
        int 2
      in
      v.(Ti1418)
    in
    app
      quadratic
      m
      Td1415
      Td1417
      Td1419
  in
  let c1 : FLOAT =
    let Td1423 : FLOAT =
      let Td1421 : FLOAT =
        let Ti1420 : INT =
          int 0
        in
        v.(Ti1420)
      in
      let Td1422 : FLOAT =
        app
          o_param_a
          m
      in
      fmul Td1421 Td1422
    in
    app
      fneg
      Td1423
  in
  let c2 : FLOAT =
    let Td1427 : FLOAT =
      let Td1425 : FLOAT =
        let Ti1424 : INT =
          int 1
        in
        v.(Ti1424)
      in
      let Td1426 : FLOAT =
        app
          o_param_b
          m
      in
      fmul Td1425 Td1426
    in
    app
      fneg
      Td1427
  in
  let c3 : FLOAT =
    let Td1431 : FLOAT =
      let Td1429 : FLOAT =
        let Ti1428 : INT =
          int 2
        in
        v.(Ti1428)
      in
      let Td1430 : FLOAT =
        app
          o_param_c
          m
      in
      fmul Td1429 Td1430
    in
    app
      fneg
      Td1431
  in
  let Tu101 : UNIT =
    let Ti1432 : INT =
      int 0
    in
    const.(Ti1432) <- aa
  in
  let Tu100 : UNIT =
    let Ti1433 : INT =
      app
        o_isrot
        m
    in
    let Ti1434 : INT =
      int 0
    in
    if Ti1433 == Ti1434
      let Tu98 : UNIT =
        let Ti1435 : INT =
          int 1
        in
        const.(Ti1435) <- c1
      in
      let Tu97 : UNIT =
        let Ti1436 : INT =
          int 2
        in
        const.(Ti1436) <- c2
      in
      let Ti1437 : INT =
        int 3
      in
      const.(Ti1437) <- c3
      let Tu96 : UNIT =
        let Ti1438 : INT =
          int 1
        in
        let Td1449 : FLOAT =
          let Td1448 : FLOAT =
            let Td1447 : FLOAT =
              let Td1442 : FLOAT =
                let Td1440 : FLOAT =
                  let Ti1439 : INT =
                    int 2
                  in
                  v.(Ti1439)
                in
                let Td1441 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul Td1440 Td1441
              in
              let Td1446 : FLOAT =
                let Td1444 : FLOAT =
                  let Ti1443 : INT =
                    int 1
                  in
                  v.(Ti1443)
                in
                let Td1445 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1444 Td1445
              in
              fadd Td1442 Td1446
            in
            app
              fhalf
              Td1447
          in
          fsub c1 Td1448
        in
        const.(Ti1438) <- Td1449
      in
      let Tu95 : UNIT =
        let Ti1450 : INT =
          int 2
        in
        let Td1461 : FLOAT =
          let Td1460 : FLOAT =
            let Td1459 : FLOAT =
              let Td1454 : FLOAT =
                let Td1452 : FLOAT =
                  let Ti1451 : INT =
                    int 2
                  in
                  v.(Ti1451)
                in
                let Td1453 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul Td1452 Td1453
              in
              let Td1458 : FLOAT =
                let Td1456 : FLOAT =
                  let Ti1455 : INT =
                    int 0
                  in
                  v.(Ti1455)
                in
                let Td1457 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul Td1456 Td1457
              in
              fadd Td1454 Td1458
            in
            app
              fhalf
              Td1459
          in
          fsub c2 Td1460
        in
        const.(Ti1450) <- Td1461
      in
      let Ti1462 : INT =
        int 3
      in
      let Td1473 : FLOAT =
        let Td1472 : FLOAT =
          let Td1471 : FLOAT =
            let Td1466 : FLOAT =
              let Td1464 : FLOAT =
                let Ti1463 : INT =
                  int 1
                in
                v.(Ti1463)
              in
              let Td1465 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul Td1464 Td1465
            in
            let Td1470 : FLOAT =
              let Td1468 : FLOAT =
                let Ti1467 : INT =
                  int 0
                in
                v.(Ti1467)
              in
              let Td1469 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul Td1468 Td1469
            in
            fadd Td1466 Td1470
          in
          app
            fhalf
            Td1471
        in
        fsub c3 Td1472
      in
      const.(Ti1462) <- Td1473
  in
  let Tu99 : UNIT =
    if aa == 0.0 
      unit ()
      let Ti1474 : INT =
        int 4
      in
      let Td1476 : FLOAT =
        let Td1475 : FLOAT =
          float 1.
        in
        fdiv Td1475 aa
      in
      const.(Ti1474) <- Td1476
  in
  const
in
letrec iter_setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti1404 : INT =
    int 0
  in
  if Ti1404 <= index
    let m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let dconst : Array of Array of FLOAT =
      app
        d_const
        dirvec
    in
    let v : Array of FLOAT =
      app
        d_vec
        dirvec
    in
    let m_shape : INT =
      app
        o_form
        m
    in
    let Tu102 : UNIT =
      let Ti1405 : INT =
        int 1
      in
      if m_shape == Ti1405
        let Ta1406 : Array of FLOAT =
          app
            setup_rect_table
            v
            m
        in
        dconst.(index) <- Ta1406
        let Ti1407 : INT =
          int 2
        in
        if m_shape == Ti1407
          let Ta1408 : Array of FLOAT =
            app
              setup_surface_table
              v
              m
          in
          dconst.(index) <- Ta1408
          let Ta1409 : Array of FLOAT =
            app
              setup_second_table
              v
              m
          in
          dconst.(index) <- Ta1409
    in
    let Ti1411 : INT =
      let Ti1410 : INT =
        int 1
      in
      sub index Ti1410
    in
    app
      iter_setup_dirvec_constants
      dirvec
      Ti1411
    unit ()
in
letrec setup_dirvec_constants : ((Array of FLOAT * Array of Array of FLOAT) -> UNIT) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Ti1403 : INT =
    let Ti1401 : INT =
      let Ti1400 : INT =
        int 0
      in
      n_objects.(Ti1400)
    in
    let Ti1402 : INT =
      int 1
    in
    sub Ti1401 Ti1402
  in
  app
    iter_setup_dirvec_constants
    dirvec
    Ti1403
in
letrec setup_startp_constants : (Array of FLOAT -> (INT -> UNIT)) =
variables : (p : Array of FLOAT), (index : INT)
  let Ti1361 : INT =
    int 0
  in
  if Ti1361 <= index
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(index)
    in
    let sconst : Array of FLOAT =
      app
        o_param_ctbl
        obj
    in
    let m_shape : INT =
      app
        o_form
        obj
    in
    let Tu106 : UNIT =
      let Ti1362 : INT =
        int 0
      in
      let Td1366 : FLOAT =
        let Td1364 : FLOAT =
          let Ti1363 : INT =
            int 0
          in
          p.(Ti1363)
        in
        let Td1365 : FLOAT =
          app
            o_param_x
            obj
        in
        fsub Td1364 Td1365
      in
      sconst.(Ti1362) <- Td1366
    in
    let Tu105 : UNIT =
      let Ti1367 : INT =
        int 1
      in
      let Td1371 : FLOAT =
        let Td1369 : FLOAT =
          let Ti1368 : INT =
            int 1
          in
          p.(Ti1368)
        in
        let Td1370 : FLOAT =
          app
            o_param_y
            obj
        in
        fsub Td1369 Td1370
      in
      sconst.(Ti1367) <- Td1371
    in
    let Tu104 : UNIT =
      let Ti1372 : INT =
        int 2
      in
      let Td1376 : FLOAT =
        let Td1374 : FLOAT =
          let Ti1373 : INT =
            int 2
          in
          p.(Ti1373)
        in
        let Td1375 : FLOAT =
          app
            o_param_z
            obj
        in
        fsub Td1374 Td1375
      in
      sconst.(Ti1372) <- Td1376
    in
    let Tu103 : UNIT =
      let Ti1377 : INT =
        int 2
      in
      if m_shape == Ti1377
        let Ti1378 : INT =
          int 3
        in
        let Td1386 : FLOAT =
          let Ta1379 : Array of FLOAT =
            app
              o_param_abc
              obj
          in
          let Td1381 : FLOAT =
            let Ti1380 : INT =
              int 0
            in
            sconst.(Ti1380)
          in
          let Td1383 : FLOAT =
            let Ti1382 : INT =
              int 1
            in
            sconst.(Ti1382)
          in
          let Td1385 : FLOAT =
            let Ti1384 : INT =
              int 2
            in
            sconst.(Ti1384)
          in
          app
            veciprod2
            Ta1379
            Td1381
            Td1383
            Td1385
        in
        sconst.(Ti1378) <- Td1386
        let Ti1387 : INT =
          int 2
        in
        if m_shape <= Ti1387
          unit ()
          let cc0 : FLOAT =
            let Td1389 : FLOAT =
              let Ti1388 : INT =
                int 0
              in
              sconst.(Ti1388)
            in
            let Td1391 : FLOAT =
              let Ti1390 : INT =
                int 1
              in
              sconst.(Ti1390)
            in
            let Td1393 : FLOAT =
              let Ti1392 : INT =
                int 2
              in
              sconst.(Ti1392)
            in
            app
              quadratic
              obj
              Td1389
              Td1391
              Td1393
          in
          let Ti1394 : INT =
            int 3
          in
          let Td1397 : FLOAT =
            let Ti1395 : INT =
              int 3
            in
            if m_shape == Ti1395
              let Td1396 : FLOAT =
                float 1.
              in
              fsub cc0 Td1396
              cc0
          in
          sconst.(Ti1394) <- Td1397
    in
    let Ti1399 : INT =
      let Ti1398 : INT =
        int 1
      in
      sub index Ti1398
    in
    app
      setup_startp_constants
      p
      Ti1399
    unit ()
in
letrec setup_startp : (Array of FLOAT -> UNIT) =
variables : (p : Array of FLOAT)
  let Tu107 : UNIT =
    app
      veccpy
      startp_fast
      p
  in
  let Ti1360 : INT =
    let Ti1358 : INT =
      let Ti1357 : INT =
        int 0
      in
      n_objects.(Ti1357)
    in
    let Ti1359 : INT =
      int 1
    in
    sub Ti1358 Ti1359
  in
  app
    setup_startp_constants
    p
    Ti1360
in
letrec is_rect_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let Ti1353 : INT =
    let Tb1345 : BOOL =
      let Td1343 : FLOAT =
        app
          fabs
          p0
      in
      let Td1344 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fless
        Td1343
        Td1344
    in
    let Ti1346 : INT =
      int 0
    in
    if Tb1345 == Ti1346
      int 0
      let Tb1349 : BOOL =
        let Td1347 : FLOAT =
          app
            fabs
            p1
        in
        let Td1348 : FLOAT =
          app
            o_param_b
            m
        in
        app
          fless
          Td1347
          Td1348
      in
      let Ti1350 : INT =
        int 0
      in
      if Tb1349 == Ti1350
        int 0
        let Td1351 : FLOAT =
          app
            fabs
            p2
        in
        let Td1352 : FLOAT =
          app
            o_param_c
            m
        in
        app
          fless
          Td1351
          Td1352
  in
  let Ti1354 : INT =
    int 0
  in
  if Ti1353 == Ti1354
    let Tb1355 : BOOL =
      app
        o_isinvert
        m
    in
    let Ti1356 : INT =
      int 0
    in
    if Tb1355 == Ti1356
      int 1
      int 0
    app
      o_isinvert
      m
in
letrec is_plane_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    let Ta1338 : Array of FLOAT =
      app
        o_param_abc
        m
    in
    app
      veciprod2
      Ta1338
      p0
      p1
      p2
  in
  let Tb1341 : BOOL =
    let Tb1339 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1340 : BOOL =
      app
        fisneg
        w
    in
    app
      xor
      Tb1339
      Tb1340
  in
  let Ti1342 : INT =
    int 0
  in
  if Tb1341 == Ti1342
    int 1
    int 0
in
letrec is_second_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p0 : FLOAT), (p1 : FLOAT), (p2 : FLOAT)
  let w : FLOAT =
    app
      quadratic
      m
      p0
      p1
      p2
  in
  let w2 : FLOAT =
    let Ti1331 : INT =
      app
        o_form
        m
    in
    let Ti1332 : INT =
      int 3
    in
    if Ti1331 == Ti1332
      let Td1333 : FLOAT =
        float 1.
      in
      fsub w Td1333
      w
  in
  let Tb1336 : BOOL =
    let Tb1334 : BOOL =
      app
        o_isinvert
        m
    in
    let Tb1335 : BOOL =
      app
        fisneg
        w2
    in
    app
      xor
      Tb1334
      Tb1335
  in
  let Ti1337 : INT =
    int 0
  in
  if Tb1336 == Ti1337
    int 1
    int 0
in
letrec is_outside : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL)))) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let p0 : FLOAT =
    let Td1326 : FLOAT =
      app
        o_param_x
        m
    in
    fsub q0 Td1326
  in
  let p1 : FLOAT =
    let Td1327 : FLOAT =
      app
        o_param_y
        m
    in
    fsub q1 Td1327
  in
  let p2 : FLOAT =
    let Td1328 : FLOAT =
      app
        o_param_z
        m
    in
    fsub q2 Td1328
  in
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1329 : INT =
    int 1
  in
  if m_shape == Ti1329
    app
      is_rect_outside
      m
      p0
      p1
      p2
    let Ti1330 : INT =
      int 2
    in
    if m_shape == Ti1330
      app
        is_plane_outside
        m
        p0
        p1
        p2
      app
        is_second_outside
        m
        p0
        p1
        p2
in
letrec check_all_inside : (INT -> (Array of INT -> (FLOAT -> (FLOAT -> (FLOAT -> BOOL))))) =
variables : (ofs : INT), (iand : Array of INT), (q0 : FLOAT), (q1 : FLOAT), (q2 : FLOAT)
  let head : INT =
    iand.(ofs)
  in
  let Ti1320 : INT =
    let Ti1319 : INT =
      int 1
    in
    neg Ti1319
  in
  if head == Ti1320
    int 1
    let Tb1322 : BOOL =
      let Tt1321 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(head)
      in
      app
        is_outside
        Tt1321
        q0
        q1
        q2
    in
    let Ti1323 : INT =
      int 0
    in
    if Tb1322 == Ti1323
      let Ti1325 : INT =
        let Ti1324 : INT =
          int 1
        in
        add ofs Ti1324
      in
      app
        check_all_inside
        Ti1325
        iand
        q0
        q1
        q2
      int 0
in
letrec shadow_check_and_group : (INT -> (Array of INT -> BOOL)) =
variables : (iand_ofs : INT), (and_group : Array of INT)
  let Ti1285 : INT =
    and_group.(iand_ofs)
  in
  let Ti1287 : INT =
    let Ti1286 : INT =
      int 1
    in
    neg Ti1286
  in
  if Ti1285 == Ti1287
    int 0
    let obj : INT =
      and_group.(iand_ofs)
    in
    let t0 : INT =
      app
        solver_fast
        obj
        light_dirvec
        intersection_point
    in
    let t0p : FLOAT =
      let Ti1288 : INT =
        int 0
      in
      solver_dist.(Ti1288)
    in
    let Ti1291 : INT =
      let Ti1289 : INT =
        int 0
      in
      if t0 == Ti1289
        int 0
        let Td1290 : FLOAT =
          float -0.2
        in
        app
          fless
          t0p
          Td1290
    in
    let Ti1292 : INT =
      int 0
    in
    if Ti1291 == Ti1292
      let Tb1294 : BOOL =
        let Tt1293 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(obj)
        in
        app
          o_isinvert
          Tt1293
      in
      let Ti1295 : INT =
        int 0
      in
      if Tb1294 == Ti1295
        int 0
        let Ti1297 : INT =
          let Ti1296 : INT =
            int 1
          in
          add iand_ofs Ti1296
        in
        app
          shadow_check_and_group
          Ti1297
          and_group
      let t : FLOAT =
        let Td1298 : FLOAT =
          float 0.01
        in
        fadd t0p Td1298
      in
      let q0 : FLOAT =
        let Td1301 : FLOAT =
          let Td1300 : FLOAT =
            let Ti1299 : INT =
              int 0
            in
            light.(Ti1299)
          in
          fmul Td1300 t
        in
        let Td1303 : FLOAT =
          let Ti1302 : INT =
            int 0
          in
          intersection_point.(Ti1302)
        in
        fadd Td1301 Td1303
      in
      let q1 : FLOAT =
        let Td1306 : FLOAT =
          let Td1305 : FLOAT =
            let Ti1304 : INT =
              int 1
            in
            light.(Ti1304)
          in
          fmul Td1305 t
        in
        let Td1308 : FLOAT =
          let Ti1307 : INT =
            int 1
          in
          intersection_point.(Ti1307)
        in
        fadd Td1306 Td1308
      in
      let q2 : FLOAT =
        let Td1311 : FLOAT =
          let Td1310 : FLOAT =
            let Ti1309 : INT =
              int 2
            in
            light.(Ti1309)
          in
          fmul Td1310 t
        in
        let Td1313 : FLOAT =
          let Ti1312 : INT =
            int 2
          in
          intersection_point.(Ti1312)
        in
        fadd Td1311 Td1313
      in
      let Tb1315 : BOOL =
        let Ti1314 : INT =
          int 0
        in
        app
          check_all_inside
          Ti1314
          and_group
          q0
          q1
          q2
      in
      let Ti1316 : INT =
        int 0
      in
      if Tb1315 == Ti1316
        let Ti1318 : INT =
          let Ti1317 : INT =
            int 1
          in
          add iand_ofs Ti1317
        in
        app
          shadow_check_and_group
          Ti1318
          and_group
        int 1
in
letrec shadow_check_one_or_group : (INT -> (Array of INT -> BOOL)) =
variables : (ofs : INT), (or_group : Array of INT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1280 : INT =
    let Ti1279 : INT =
      int 1
    in
    neg Ti1279
  in
  if head == Ti1280
    int 0
    let and_group : Array of INT =
      and_net.(head)
    in
    let shadow_p : BOOL =
      let Ti1281 : INT =
        int 0
      in
      app
        shadow_check_and_group
        Ti1281
        and_group
    in
    let Ti1282 : INT =
      int 0
    in
    if shadow_p == Ti1282
      let Ti1284 : INT =
        let Ti1283 : INT =
          int 1
        in
        add ofs Ti1283
      in
      app
        shadow_check_one_or_group
        Ti1284
        or_group
      int 1
in
letrec shadow_check_one_or_matrix : (INT -> (Array of Array of INT -> BOOL)) =
variables : (ofs : INT), (or_matrix : Array of Array of INT)
  let head : Array of INT =
    or_matrix.(ofs)
  in
  let range_primitive : INT =
    let Ti1257 : INT =
      int 0
    in
    head.(Ti1257)
  in
  let Ti1259 : INT =
    let Ti1258 : INT =
      int 1
    in
    neg Ti1258
  in
  if range_primitive == Ti1259
    int 0
    let Ti1270 : INT =
      let Ti1260 : INT =
        int 99
      in
      if range_primitive == Ti1260
        int 1
        let t : INT =
          app
            solver_fast
            range_primitive
            light_dirvec
            intersection_point
        in
        let Ti1261 : INT =
          int 0
        in
        if t == Ti1261
          int 0
          let Tb1265 : BOOL =
            let Td1263 : FLOAT =
              let Ti1262 : INT =
                int 0
              in
              solver_dist.(Ti1262)
            in
            let Td1264 : FLOAT =
              float -0.1
            in
            app
              fless
              Td1263
              Td1264
          in
          let Ti1266 : INT =
            int 0
          in
          if Tb1265 == Ti1266
            int 0
            let Tb1268 : BOOL =
              let Ti1267 : INT =
                int 1
              in
              app
                shadow_check_one_or_group
                Ti1267
                head
            in
            let Ti1269 : INT =
              int 0
            in
            if Tb1268 == Ti1269
              int 0
              int 1
    in
    let Ti1271 : INT =
      int 0
    in
    if Ti1270 == Ti1271
      let Ti1273 : INT =
        let Ti1272 : INT =
          int 1
        in
        add ofs Ti1272
      in
      app
        shadow_check_one_or_matrix
        Ti1273
        or_matrix
      let Tb1275 : BOOL =
        let Ti1274 : INT =
          int 1
        in
        app
          shadow_check_one_or_group
          Ti1274
          head
      in
      let Ti1276 : INT =
        int 0
      in
      if Tb1275 == Ti1276
        let Ti1278 : INT =
          let Ti1277 : INT =
            int 1
          in
          add ofs Ti1277
        in
        app
          shadow_check_one_or_matrix
          Ti1278
          or_matrix
        int 1
in
letrec solve_each_element : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : Array of FLOAT)
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1218 : INT =
    let Ti1217 : INT =
      int 1
    in
    neg Ti1217
  in
  if iobj == Ti1218
    unit ()
    let t0 : INT =
      app
        solver
        iobj
        dirvec
        startp
    in
    let Ti1219 : INT =
      int 0
    in
    if t0 == Ti1219
      let Tb1221 : BOOL =
        let Tt1220 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1220
      in
      let Ti1222 : INT =
        int 0
      in
      if Tb1221 == Ti1222
        unit ()
        let Ti1224 : INT =
          let Ti1223 : INT =
            int 1
          in
          add iand_ofs Ti1223
        in
        app
          solve_each_element
          Ti1224
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1225 : INT =
          int 0
        in
        solver_dist.(Ti1225)
      in
      let Tu111 : UNIT =
        let Tb1227 : BOOL =
          let Td1226 : FLOAT =
            float 0.
          in
          app
            fless
            Td1226
            t0p
        in
        let Ti1228 : INT =
          int 0
        in
        if Tb1227 == Ti1228
          unit ()
          let Tb1231 : BOOL =
            let Td1230 : FLOAT =
              let Ti1229 : INT =
                int 0
              in
              tmin.(Ti1229)
            in
            app
              fless
              t0p
              Td1230
          in
          let Ti1232 : INT =
            int 0
          in
          if Tb1231 == Ti1232
            unit ()
            let t : FLOAT =
              let Td1233 : FLOAT =
                float 0.01
              in
              fadd t0p Td1233
            in
            let q0 : FLOAT =
              let Td1236 : FLOAT =
                let Td1235 : FLOAT =
                  let Ti1234 : INT =
                    int 0
                  in
                  dirvec.(Ti1234)
                in
                fmul Td1235 t
              in
              let Td1238 : FLOAT =
                let Ti1237 : INT =
                  int 0
                in
                startp.(Ti1237)
              in
              fadd Td1236 Td1238
            in
            let q1 : FLOAT =
              let Td1241 : FLOAT =
                let Td1240 : FLOAT =
                  let Ti1239 : INT =
                    int 1
                  in
                  dirvec.(Ti1239)
                in
                fmul Td1240 t
              in
              let Td1243 : FLOAT =
                let Ti1242 : INT =
                  int 1
                in
                startp.(Ti1242)
              in
              fadd Td1241 Td1243
            in
            let q2 : FLOAT =
              let Td1246 : FLOAT =
                let Td1245 : FLOAT =
                  let Ti1244 : INT =
                    int 2
                  in
                  dirvec.(Ti1244)
                in
                fmul Td1245 t
              in
              let Td1248 : FLOAT =
                let Ti1247 : INT =
                  int 2
                in
                startp.(Ti1247)
              in
              fadd Td1246 Td1248
            in
            let Tb1250 : BOOL =
              let Ti1249 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1249
                and_group
                q0
                q1
                q2
            in
            let Ti1251 : INT =
              int 0
            in
            if Tb1250 == Ti1251
              unit ()
              let Tu110 : UNIT =
                let Ti1252 : INT =
                  int 0
                in
                tmin.(Ti1252) <- t
              in
              let Tu109 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu108 : UNIT =
                let Ti1253 : INT =
                  int 0
                in
                intersected_object_id.(Ti1253) <- iobj
              in
              let Ti1254 : INT =
                int 0
              in
              intsec_rectside.(Ti1254) <- t0
      in
      let Ti1256 : INT =
        let Ti1255 : INT =
          int 1
        in
        add iand_ofs Ti1255
      in
      app
        solve_each_element
        Ti1256
        and_group
        dirvec
in
letrec solve_one_or_network : (INT -> (Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : Array of FLOAT)
  let head : INT =
    or_group.(ofs)
  in
  let Ti1213 : INT =
    let Ti1212 : INT =
      int 1
    in
    neg Ti1212
  in
  if head == Ti1213
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu112 : UNIT =
      let Ti1214 : INT =
        int 0
      in
      app
        solve_each_element
        Ti1214
        and_group
        dirvec
    in
    let Ti1216 : INT =
      let Ti1215 : INT =
        int 1
      in
      add ofs Ti1215
    in
    app
      solve_one_or_network
      Ti1216
      or_group
      dirvec
in
letrec trace_or_matrix : (INT -> (Array of Array of INT -> (Array of FLOAT -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : Array of FLOAT)
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1198 : INT =
      int 0
    in
    head.(Ti1198)
  in
  let Ti1200 : INT =
    let Ti1199 : INT =
      int 1
    in
    neg Ti1199
  in
  if range_primitive == Ti1200
    unit ()
    let Tu113 : UNIT =
      let Ti1201 : INT =
        int 99
      in
      if range_primitive == Ti1201
        let Ti1202 : INT =
          int 1
        in
        app
          solve_one_or_network
          Ti1202
          head
          dirvec
        let t : INT =
          app
            solver
            range_primitive
            dirvec
            startp
        in
        let Ti1203 : INT =
          int 0
        in
        if t == Ti1203
          unit ()
          let tp : FLOAT =
            let Ti1204 : INT =
              int 0
            in
            solver_dist.(Ti1204)
          in
          let Tb1207 : BOOL =
            let Td1206 : FLOAT =
              let Ti1205 : INT =
                int 0
              in
              tmin.(Ti1205)
            in
            app
              fless
              tp
              Td1206
          in
          let Ti1208 : INT =
            int 0
          in
          if Tb1207 == Ti1208
            unit ()
            let Ti1209 : INT =
              int 1
            in
            app
              solve_one_or_network
              Ti1209
              head
              dirvec
    in
    let Ti1211 : INT =
      let Ti1210 : INT =
        int 1
      in
      add ofs Ti1210
    in
    app
      trace_or_matrix
      Ti1211
      or_network
      dirvec
in
letrec judge_intersection : (Array of FLOAT -> BOOL) =
variables : (dirvec : Array of FLOAT)
  let Tu115 : UNIT =
    let Ti1188 : INT =
      int 0
    in
    let Td1189 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1188) <- Td1189
  in
  let Tu114 : UNIT =
    let Ti1190 : INT =
      int 0
    in
    let Ta1192 : Array of Array of INT =
      let Ti1191 : INT =
        int 0
      in
      or_net.(Ti1191)
    in
    app
      trace_or_matrix
      Ti1190
      Ta1192
      dirvec
  in
  let t : FLOAT =
    let Ti1193 : INT =
      int 0
    in
    tmin.(Ti1193)
  in
  let Tb1195 : BOOL =
    let Td1194 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1194
      t
  in
  let Ti1196 : INT =
    int 0
  in
  if Tb1195 == Ti1196
    int 0
    let Td1197 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1197
in
letrec solve_each_element_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (iand_ofs : INT), (and_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let vec : Array of FLOAT =
    app
      d_vec
      dirvec
  in
  let iobj : INT =
    and_group.(iand_ofs)
  in
  let Ti1149 : INT =
    let Ti1148 : INT =
      int 1
    in
    neg Ti1148
  in
  if iobj == Ti1149
    unit ()
    let t0 : INT =
      app
        solver_fast2
        iobj
        dirvec
    in
    let Ti1150 : INT =
      int 0
    in
    if t0 == Ti1150
      let Tb1152 : BOOL =
        let Tt1151 : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
          objects.(iobj)
        in
        app
          o_isinvert
          Tt1151
      in
      let Ti1153 : INT =
        int 0
      in
      if Tb1152 == Ti1153
        unit ()
        let Ti1155 : INT =
          let Ti1154 : INT =
            int 1
          in
          add iand_ofs Ti1154
        in
        app
          solve_each_element_fast
          Ti1155
          and_group
          dirvec
      let t0p : FLOAT =
        let Ti1156 : INT =
          int 0
        in
        solver_dist.(Ti1156)
      in
      let Tu119 : UNIT =
        let Tb1158 : BOOL =
          let Td1157 : FLOAT =
            float 0.
          in
          app
            fless
            Td1157
            t0p
        in
        let Ti1159 : INT =
          int 0
        in
        if Tb1158 == Ti1159
          unit ()
          let Tb1162 : BOOL =
            let Td1161 : FLOAT =
              let Ti1160 : INT =
                int 0
              in
              tmin.(Ti1160)
            in
            app
              fless
              t0p
              Td1161
          in
          let Ti1163 : INT =
            int 0
          in
          if Tb1162 == Ti1163
            unit ()
            let t : FLOAT =
              let Td1164 : FLOAT =
                float 0.01
              in
              fadd t0p Td1164
            in
            let q0 : FLOAT =
              let Td1167 : FLOAT =
                let Td1166 : FLOAT =
                  let Ti1165 : INT =
                    int 0
                  in
                  vec.(Ti1165)
                in
                fmul Td1166 t
              in
              let Td1169 : FLOAT =
                let Ti1168 : INT =
                  int 0
                in
                startp_fast.(Ti1168)
              in
              fadd Td1167 Td1169
            in
            let q1 : FLOAT =
              let Td1172 : FLOAT =
                let Td1171 : FLOAT =
                  let Ti1170 : INT =
                    int 1
                  in
                  vec.(Ti1170)
                in
                fmul Td1171 t
              in
              let Td1174 : FLOAT =
                let Ti1173 : INT =
                  int 1
                in
                startp_fast.(Ti1173)
              in
              fadd Td1172 Td1174
            in
            let q2 : FLOAT =
              let Td1177 : FLOAT =
                let Td1176 : FLOAT =
                  let Ti1175 : INT =
                    int 2
                  in
                  vec.(Ti1175)
                in
                fmul Td1176 t
              in
              let Td1179 : FLOAT =
                let Ti1178 : INT =
                  int 2
                in
                startp_fast.(Ti1178)
              in
              fadd Td1177 Td1179
            in
            let Tb1181 : BOOL =
              let Ti1180 : INT =
                int 0
              in
              app
                check_all_inside
                Ti1180
                and_group
                q0
                q1
                q2
            in
            let Ti1182 : INT =
              int 0
            in
            if Tb1181 == Ti1182
              unit ()
              let Tu118 : UNIT =
                let Ti1183 : INT =
                  int 0
                in
                tmin.(Ti1183) <- t
              in
              let Tu117 : UNIT =
                app
                  vecset
                  intersection_point
                  q0
                  q1
                  q2
              in
              let Tu116 : UNIT =
                let Ti1184 : INT =
                  int 0
                in
                intersected_object_id.(Ti1184) <- iobj
              in
              let Ti1185 : INT =
                int 0
              in
              intsec_rectside.(Ti1185) <- t0
      in
      let Ti1187 : INT =
        let Ti1186 : INT =
          int 1
        in
        add iand_ofs Ti1186
      in
      app
        solve_each_element_fast
        Ti1187
        and_group
        dirvec
in
letrec solve_one_or_network_fast : (INT -> (Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_group : Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : INT =
    or_group.(ofs)
  in
  let Ti1144 : INT =
    let Ti1143 : INT =
      int 1
    in
    neg Ti1143
  in
  if head == Ti1144
    unit ()
    let and_group : Array of INT =
      and_net.(head)
    in
    let Tu120 : UNIT =
      let Ti1145 : INT =
        int 0
      in
      app
        solve_each_element_fast
        Ti1145
        and_group
        dirvec
    in
    let Ti1147 : INT =
      let Ti1146 : INT =
        int 1
      in
      add ofs Ti1146
    in
    app
      solve_one_or_network_fast
      Ti1147
      or_group
      dirvec
in
letrec trace_or_matrix_fast : (INT -> (Array of Array of INT -> ((Array of FLOAT * Array of Array of FLOAT) -> UNIT))) =
variables : (ofs : INT), (or_network : Array of Array of INT), (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let head : Array of INT =
    or_network.(ofs)
  in
  let range_primitive : INT =
    let Ti1129 : INT =
      int 0
    in
    head.(Ti1129)
  in
  let Ti1131 : INT =
    let Ti1130 : INT =
      int 1
    in
    neg Ti1130
  in
  if range_primitive == Ti1131
    unit ()
    let Tu121 : UNIT =
      let Ti1132 : INT =
        int 99
      in
      if range_primitive == Ti1132
        let Ti1133 : INT =
          int 1
        in
        app
          solve_one_or_network_fast
          Ti1133
          head
          dirvec
        let t : INT =
          app
            solver_fast2
            range_primitive
            dirvec
        in
        let Ti1134 : INT =
          int 0
        in
        if t == Ti1134
          unit ()
          let tp : FLOAT =
            let Ti1135 : INT =
              int 0
            in
            solver_dist.(Ti1135)
          in
          let Tb1138 : BOOL =
            let Td1137 : FLOAT =
              let Ti1136 : INT =
                int 0
              in
              tmin.(Ti1136)
            in
            app
              fless
              tp
              Td1137
          in
          let Ti1139 : INT =
            int 0
          in
          if Tb1138 == Ti1139
            unit ()
            let Ti1140 : INT =
              int 1
            in
            app
              solve_one_or_network_fast
              Ti1140
              head
              dirvec
    in
    let Ti1142 : INT =
      let Ti1141 : INT =
        int 1
      in
      add ofs Ti1141
    in
    app
      trace_or_matrix_fast
      Ti1142
      or_network
      dirvec
in
letrec judge_intersection_fast : ((Array of FLOAT * Array of Array of FLOAT) -> BOOL) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT))
  let Tu123 : UNIT =
    let Ti1119 : INT =
      int 0
    in
    let Td1120 : FLOAT =
      float 1000000000.
    in
    tmin.(Ti1119) <- Td1120
  in
  let Tu122 : UNIT =
    let Ti1121 : INT =
      int 0
    in
    let Ta1123 : Array of Array of INT =
      let Ti1122 : INT =
        int 0
      in
      or_net.(Ti1122)
    in
    app
      trace_or_matrix_fast
      Ti1121
      Ta1123
      dirvec
  in
  let t : FLOAT =
    let Ti1124 : INT =
      int 0
    in
    tmin.(Ti1124)
  in
  let Tb1126 : BOOL =
    let Td1125 : FLOAT =
      float -0.1
    in
    app
      fless
      Td1125
      t
  in
  let Ti1127 : INT =
    int 0
  in
  if Tb1126 == Ti1127
    int 0
    let Td1128 : FLOAT =
      float 100000000.
    in
    app
      fless
      t
      Td1128
in
letrec get_nvector_rect : (Array of FLOAT -> UNIT) =
variables : (dirvec : Array of FLOAT)
  let rectside : INT =
    let Ti1111 : INT =
      int 0
    in
    intsec_rectside.(Ti1111)
  in
  let Tu124 : UNIT =
    app
      vecbzero
      nvector
  in
  let Ti1113 : INT =
    let Ti1112 : INT =
      int 1
    in
    sub rectside Ti1112
  in
  let Td1118 : FLOAT =
    let Td1117 : FLOAT =
      let Td1116 : FLOAT =
        let Ti1115 : INT =
          let Ti1114 : INT =
            int 1
          in
          sub rectside Ti1114
        in
        dirvec.(Ti1115)
      in
      app
        sgn
        Td1116
    in
    app
      fneg
      Td1117
  in
  nvector.(Ti1113) <- Td1118
in
letrec get_nvector_plane : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let Tu126 : UNIT =
    let Ti1102 : INT =
      int 0
    in
    let Td1104 : FLOAT =
      let Td1103 : FLOAT =
        app
          o_param_a
          m
      in
      app
        fneg
        Td1103
    in
    nvector.(Ti1102) <- Td1104
  in
  let Tu125 : UNIT =
    let Ti1105 : INT =
      int 1
    in
    let Td1107 : FLOAT =
      let Td1106 : FLOAT =
        app
          o_param_b
          m
      in
      app
        fneg
        Td1106
    in
    nvector.(Ti1105) <- Td1107
  in
  let Ti1108 : INT =
    int 2
  in
  let Td1110 : FLOAT =
    let Td1109 : FLOAT =
      app
        o_param_c
        m
    in
    app
      fneg
      Td1109
  in
  nvector.(Ti1108) <- Td1110
in
letrec get_nvector_second : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let p0 : FLOAT =
    let Td1061 : FLOAT =
      let Ti1060 : INT =
        int 0
      in
      intersection_point.(Ti1060)
    in
    let Td1062 : FLOAT =
      app
        o_param_x
        m
    in
    fsub Td1061 Td1062
  in
  let p1 : FLOAT =
    let Td1064 : FLOAT =
      let Ti1063 : INT =
        int 1
      in
      intersection_point.(Ti1063)
    in
    let Td1065 : FLOAT =
      app
        o_param_y
        m
    in
    fsub Td1064 Td1065
  in
  let p2 : FLOAT =
    let Td1067 : FLOAT =
      let Ti1066 : INT =
        int 2
      in
      intersection_point.(Ti1066)
    in
    let Td1068 : FLOAT =
      app
        o_param_z
        m
    in
    fsub Td1067 Td1068
  in
  let d0 : FLOAT =
    let Td1069 : FLOAT =
      app
        o_param_a
        m
    in
    fmul p0 Td1069
  in
  let d1 : FLOAT =
    let Td1070 : FLOAT =
      app
        o_param_b
        m
    in
    fmul p1 Td1070
  in
  let d2 : FLOAT =
    let Td1071 : FLOAT =
      app
        o_param_c
        m
    in
    fmul p2 Td1071
  in
  let Tu131 : UNIT =
    let Ti1072 : INT =
      app
        o_isrot
        m
    in
    let Ti1073 : INT =
      int 0
    in
    if Ti1072 == Ti1073
      let Tu128 : UNIT =
        let Ti1074 : INT =
          int 0
        in
        nvector.(Ti1074) <- d0
      in
      let Tu127 : UNIT =
        let Ti1075 : INT =
          int 1
        in
        nvector.(Ti1075) <- d1
      in
      let Ti1076 : INT =
        int 2
      in
      nvector.(Ti1076) <- d2
      let Tu130 : UNIT =
        let Ti1077 : INT =
          int 0
        in
        let Td1084 : FLOAT =
          let Td1083 : FLOAT =
            let Td1082 : FLOAT =
              let Td1079 : FLOAT =
                let Td1078 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p1 Td1078
              in
              let Td1081 : FLOAT =
                let Td1080 : FLOAT =
                  app
                    o_param_r2
                    m
                in
                fmul p2 Td1080
              in
              fadd Td1079 Td1081
            in
            app
              fhalf
              Td1082
          in
          fadd d0 Td1083
        in
        nvector.(Ti1077) <- Td1084
      in
      let Tu129 : UNIT =
        let Ti1085 : INT =
          int 1
        in
        let Td1092 : FLOAT =
          let Td1091 : FLOAT =
            let Td1090 : FLOAT =
              let Td1087 : FLOAT =
                let Td1086 : FLOAT =
                  app
                    o_param_r3
                    m
                in
                fmul p0 Td1086
              in
              let Td1089 : FLOAT =
                let Td1088 : FLOAT =
                  app
                    o_param_r1
                    m
                in
                fmul p2 Td1088
              in
              fadd Td1087 Td1089
            in
            app
              fhalf
              Td1090
          in
          fadd d1 Td1091
        in
        nvector.(Ti1085) <- Td1092
      in
      let Ti1093 : INT =
        int 2
      in
      let Td1100 : FLOAT =
        let Td1099 : FLOAT =
          let Td1098 : FLOAT =
            let Td1095 : FLOAT =
              let Td1094 : FLOAT =
                app
                  o_param_r2
                  m
              in
              fmul p0 Td1094
            in
            let Td1097 : FLOAT =
              let Td1096 : FLOAT =
                app
                  o_param_r1
                  m
              in
              fmul p1 Td1096
            in
            fadd Td1095 Td1097
          in
          app
            fhalf
            Td1098
        in
        fadd d2 Td1099
      in
      nvector.(Ti1093) <- Td1100
  in
  let Tb1101 : BOOL =
    app
      o_isinvert
      m
  in
  app
    vecunit_sgn
    nvector
    Tb1101
in
letrec get_nvector : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (dirvec : Array of FLOAT)
  let m_shape : INT =
    app
      o_form
      m
  in
  let Ti1058 : INT =
    int 1
  in
  if m_shape == Ti1058
    app
      get_nvector_rect
      dirvec
    let Ti1059 : INT =
      int 2
    in
    if m_shape == Ti1059
      app
        get_nvector_plane
        m
      app
        get_nvector_second
        m
in
letrec utexture : ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> (Array of FLOAT -> UNIT)) =
variables : (m : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT)), (p : Array of FLOAT)
  let m_tex : INT =
    app
      o_texturetype
      m
  in
  let Tu136 : UNIT =
    let Ti934 : INT =
      int 0
    in
    let Td935 : FLOAT =
      app
        o_color_red
        m
    in
    texture_color.(Ti934) <- Td935
  in
  let Tu135 : UNIT =
    let Ti936 : INT =
      int 1
    in
    let Td937 : FLOAT =
      app
        o_color_green
        m
    in
    texture_color.(Ti936) <- Td937
  in
  let Tu134 : UNIT =
    let Ti938 : INT =
      int 2
    in
    let Td939 : FLOAT =
      app
        o_color_blue
        m
    in
    texture_color.(Ti938) <- Td939
  in
  let Ti940 : INT =
    int 1
  in
  if m_tex == Ti940
    let w1 : FLOAT =
      let Td942 : FLOAT =
        let Ti941 : INT =
          int 0
        in
        p.(Ti941)
      in
      let Td943 : FLOAT =
        app
          o_param_x
          m
      in
      fsub Td942 Td943
    in
    let flag1 : BOOL =
      let d1 : FLOAT =
        let Td946 : FLOAT =
          let Td945 : FLOAT =
            let Td944 : FLOAT =
              float 0.05
            in
            fmul w1 Td944
          in
          app
            floor
            Td945
        in
        let Td947 : FLOAT =
          float 20.
        in
        fmul Td946 Td947
      in
      let Td948 : FLOAT =
        fsub w1 d1
      in
      let Td949 : FLOAT =
        float 10.
      in
      app
        fless
        Td948
        Td949
    in
    let w3 : FLOAT =
      let Td951 : FLOAT =
        let Ti950 : INT =
          int 2
        in
        p.(Ti950)
      in
      let Td952 : FLOAT =
        app
          o_param_z
          m
      in
      fsub Td951 Td952
    in
    let flag2 : BOOL =
      let d2 : FLOAT =
        let Td955 : FLOAT =
          let Td954 : FLOAT =
            let Td953 : FLOAT =
              float 0.05
            in
            fmul w3 Td953
          in
          app
            floor
            Td954
        in
        let Td956 : FLOAT =
          float 20.
        in
        fmul Td955 Td956
      in
      let Td957 : FLOAT =
        fsub w3 d2
      in
      let Td958 : FLOAT =
        float 10.
      in
      app
        fless
        Td957
        Td958
    in
    let Ti959 : INT =
      int 1
    in
    let Td963 : FLOAT =
      let Ti960 : INT =
        int 0
      in
      if flag1 == Ti960
        let Ti961 : INT =
          int 0
        in
        if flag2 == Ti961
          float 255.
          float 0.
        let Ti962 : INT =
          int 0
        in
        if flag2 == Ti962
          float 0.
          float 255.
    in
    texture_color.(Ti959) <- Td963
    let Ti964 : INT =
      int 2
    in
    if m_tex == Ti964
      let w2 : FLOAT =
        let Td969 : FLOAT =
          let Td968 : FLOAT =
            let Td966 : FLOAT =
              let Ti965 : INT =
                int 1
              in
              p.(Ti965)
            in
            let Td967 : FLOAT =
              float 0.25
            in
            fmul Td966 Td967
          in
          app
            sin
            Td968
        in
        app
          fsqr
          Td969
      in
      let Tu132 : UNIT =
        let Ti970 : INT =
          int 0
        in
        let Td972 : FLOAT =
          let Td971 : FLOAT =
            float 255.
          in
          fmul Td971 w2
        in
        texture_color.(Ti970) <- Td972
      in
      let Ti973 : INT =
        int 1
      in
      let Td977 : FLOAT =
        let Td974 : FLOAT =
          float 255.
        in
        let Td976 : FLOAT =
          let Td975 : FLOAT =
            float 1.
          in
          fsub Td975 w2
        in
        fmul Td974 Td976
      in
      texture_color.(Ti973) <- Td977
      let Ti978 : INT =
        int 3
      in
      if m_tex == Ti978
        let w1 : FLOAT =
          let Td980 : FLOAT =
            let Ti979 : INT =
              int 0
            in
            p.(Ti979)
          in
          let Td981 : FLOAT =
            app
              o_param_x
              m
          in
          fsub Td980 Td981
        in
        let w3 : FLOAT =
          let Td983 : FLOAT =
            let Ti982 : INT =
              int 2
            in
            p.(Ti982)
          in
          let Td984 : FLOAT =
            app
              o_param_z
              m
          in
          fsub Td983 Td984
        in
        let w2 : FLOAT =
          let Td988 : FLOAT =
            let Td987 : FLOAT =
              let Td985 : FLOAT =
                app
                  fsqr
                  w1
              in
              let Td986 : FLOAT =
                app
                  fsqr
                  w3
              in
              fadd Td985 Td986
            in
            app
              sqrt
              Td987
          in
          let Td989 : FLOAT =
            float 10.
          in
          fdiv Td988 Td989
        in
        let w4 : FLOAT =
          let Td991 : FLOAT =
            let Td990 : FLOAT =
              app
                floor
                w2
            in
            fsub w2 Td990
          in
          let Td992 : FLOAT =
            float 3.1415927
          in
          fmul Td991 Td992
        in
        let cws : FLOAT =
          let Td993 : FLOAT =
            app
              cos
              w4
          in
          app
            fsqr
            Td993
        in
        let Tu133 : UNIT =
          let Ti994 : INT =
            int 1
          in
          let Td996 : FLOAT =
            let Td995 : FLOAT =
              float 255.
            in
            fmul cws Td995
          in
          texture_color.(Ti994) <- Td996
        in
        let Ti997 : INT =
          int 2
        in
        let Td1001 : FLOAT =
          let Td999 : FLOAT =
            let Td998 : FLOAT =
              float 1.
            in
            fsub Td998 cws
          in
          let Td1000 : FLOAT =
            float 255.
          in
          fmul Td999 Td1000
        in
        texture_color.(Ti997) <- Td1001
        let Ti1002 : INT =
          int 4
        in
        if m_tex == Ti1002
          let w1 : FLOAT =
            let Td1006 : FLOAT =
              let Td1004 : FLOAT =
                let Ti1003 : INT =
                  int 0
                in
                p.(Ti1003)
              in
              let Td1005 : FLOAT =
                app
                  o_param_x
                  m
              in
              fsub Td1004 Td1005
            in
            let Td1008 : FLOAT =
              let Td1007 : FLOAT =
                app
                  o_param_a
                  m
              in
              app
                sqrt
                Td1007
            in
            fmul Td1006 Td1008
          in
          let w3 : FLOAT =
            let Td1012 : FLOAT =
              let Td1010 : FLOAT =
                let Ti1009 : INT =
                  int 2
                in
                p.(Ti1009)
              in
              let Td1011 : FLOAT =
                app
                  o_param_z
                  m
              in
              fsub Td1010 Td1011
            in
            let Td1014 : FLOAT =
              let Td1013 : FLOAT =
                app
                  o_param_c
                  m
              in
              app
                sqrt
                Td1013
            in
            fmul Td1012 Td1014
          in
          let w4 : FLOAT =
            let Td1015 : FLOAT =
              app
                fsqr
                w1
            in
            let Td1016 : FLOAT =
              app
                fsqr
                w3
            in
            fadd Td1015 Td1016
          in
          let w7 : FLOAT =
            let Tb1019 : BOOL =
              let Td1017 : FLOAT =
                app
                  fabs
                  w1
              in
              let Td1018 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1017
                Td1018
            in
            let Ti1020 : INT =
              int 0
            in
            if Tb1019 == Ti1020
              let w5 : FLOAT =
                let Td1021 : FLOAT =
                  fdiv w3 w1
                in
                app
                  fabs
                  Td1021
              in
              let Td1024 : FLOAT =
                let Td1022 : FLOAT =
                  app
                    atan
                    w5
                in
                let Td1023 : FLOAT =
                  float 30.
                in
                fmul Td1022 Td1023
              in
              let Td1025 : FLOAT =
                float 3.1415927
              in
              fdiv Td1024 Td1025
              float 15.
          in
          let w9 : FLOAT =
            let Td1026 : FLOAT =
              app
                floor
                w7
            in
            fsub w7 Td1026
          in
          let w2 : FLOAT =
            let Td1030 : FLOAT =
              let Td1028 : FLOAT =
                let Ti1027 : INT =
                  int 1
                in
                p.(Ti1027)
              in
              let Td1029 : FLOAT =
                app
                  o_param_y
                  m
              in
              fsub Td1028 Td1029
            in
            let Td1032 : FLOAT =
              let Td1031 : FLOAT =
                app
                  o_param_b
                  m
              in
              app
                sqrt
                Td1031
            in
            fmul Td1030 Td1032
          in
          let w8 : FLOAT =
            let Tb1035 : BOOL =
              let Td1033 : FLOAT =
                app
                  fabs
                  w4
              in
              let Td1034 : FLOAT =
                float 0.0001
              in
              app
                fless
                Td1033
                Td1034
            in
            let Ti1036 : INT =
              int 0
            in
            if Tb1035 == Ti1036
              let w6 : FLOAT =
                let Td1037 : FLOAT =
                  fdiv w2 w4
                in
                app
                  fabs
                  Td1037
              in
              let Td1040 : FLOAT =
                let Td1038 : FLOAT =
                  app
                    atan
                    w6
                in
                let Td1039 : FLOAT =
                  float 30.
                in
                fmul Td1038 Td1039
              in
              let Td1041 : FLOAT =
                float 3.1415927
              in
              fdiv Td1040 Td1041
              float 15.
          in
          let w10 : FLOAT =
            let Td1042 : FLOAT =
              app
                floor
                w8
            in
            fsub w8 Td1042
          in
          let w11 : FLOAT =
            let Td1047 : FLOAT =
              let Td1043 : FLOAT =
                float 0.15
              in
              let Td1046 : FLOAT =
                let Td1045 : FLOAT =
                  let Td1044 : FLOAT =
                    float 0.5
                  in
                  fsub Td1044 w9
                in
                app
                  fsqr
                  Td1045
              in
              fsub Td1043 Td1046
            in
            let Td1050 : FLOAT =
              let Td1049 : FLOAT =
                let Td1048 : FLOAT =
                  float 0.5
                in
                fsub Td1048 w10
              in
              app
                fsqr
                Td1049
            in
            fsub Td1047 Td1050
          in
          let w12 : FLOAT =
            let Tb1051 : BOOL =
              app
                fisneg
                w11
            in
            let Ti1052 : INT =
              int 0
            in
            if Tb1051 == Ti1052
              w11
              float 0.
          in
          let Ti1053 : INT =
            int 2
          in
          let Td1057 : FLOAT =
            let Td1055 : FLOAT =
              let Td1054 : FLOAT =
                float 255.
              in
              fmul Td1054 w12
            in
            let Td1056 : FLOAT =
              float 0.3
            in
            fdiv Td1055 Td1056
          in
          texture_color.(Ti1053) <- Td1057
          unit ()
in
letrec add_light : (FLOAT -> (FLOAT -> (FLOAT -> UNIT))) =
variables : (bright : FLOAT), (hilight : FLOAT), (hilight_scale : FLOAT)
  let Tu139 : UNIT =
    let Tb916 : BOOL =
      app
        fispos
        bright
    in
    let Ti917 : INT =
      int 0
    in
    if Tb916 == Ti917
      unit ()
      app
        vecaccum
        rgb
        bright
        texture_color
  in
  let Tb918 : BOOL =
    app
      fispos
      hilight
  in
  let Ti919 : INT =
    int 0
  in
  if Tb918 == Ti919
    unit ()
    let ihl : FLOAT =
      let Td921 : FLOAT =
        let Td920 : FLOAT =
          app
            fsqr
            hilight
        in
        app
          fsqr
          Td920
      in
      fmul Td921 hilight_scale
    in
    let Tu138 : UNIT =
      let Ti922 : INT =
        int 0
      in
      let Td925 : FLOAT =
        let Td924 : FLOAT =
          let Ti923 : INT =
            int 0
          in
          rgb.(Ti923)
        in
        fadd Td924 ihl
      in
      rgb.(Ti922) <- Td925
    in
    let Tu137 : UNIT =
      let Ti926 : INT =
        int 1
      in
      let Td929 : FLOAT =
        let Td928 : FLOAT =
          let Ti927 : INT =
            int 1
          in
          rgb.(Ti927)
        in
        fadd Td928 ihl
      in
      rgb.(Ti926) <- Td929
    in
    let Ti930 : INT =
      int 2
    in
    let Td933 : FLOAT =
      let Td932 : FLOAT =
        let Ti931 : INT =
          int 2
        in
        rgb.(Ti931)
      in
      fadd Td932 ihl
    in
    rgb.(Ti930) <- Td933
in
letrec trace_reflections : (INT -> (FLOAT -> (FLOAT -> (Array of FLOAT -> UNIT)))) =
variables : (index : INT), (diffuse : FLOAT), (hilight_scale : FLOAT), (dirvec : Array of FLOAT)
  let Ti896 : INT =
    int 0
  in
  if Ti896 <= index
    let rinfo : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
      reflections.(index)
    in
    let dvec : (Array of FLOAT * Array of Array of FLOAT) =
      app
        r_dvec
        rinfo
    in
    let Tu140 : UNIT =
      let Tb897 : BOOL =
        app
          judge_intersection_fast
          dvec
      in
      let Ti898 : INT =
        int 0
      in
      if Tb897 == Ti898
        unit ()
        let surface_id : INT =
          let Ti901 : INT =
            let Ti900 : INT =
              let Ti899 : INT =
                int 0
              in
              intersected_object_id.(Ti899)
            in
            mul Ti900 4
          in
          let Ti903 : INT =
            let Ti902 : INT =
              int 0
            in
            intsec_rectside.(Ti902)
          in
          add Ti901 Ti903
        in
        let Ti904 : INT =
          app
            r_surface_id
            rinfo
        in
        if surface_id == Ti904
          let Tb908 : BOOL =
            let Ti905 : INT =
              int 0
            in
            let Ta907 : Array of Array of INT =
              let Ti906 : INT =
                int 0
              in
              or_net.(Ti906)
            in
            app
              shadow_check_one_or_matrix
              Ti905
              Ta907
          in
          let Ti909 : INT =
            int 0
          in
          if Tb908 == Ti909
            let p : FLOAT =
              let Ta910 : Array of FLOAT =
                app
                  d_vec
                  dvec
              in
              app
                veciprod
                nvector
                Ta910
            in
            let scale : FLOAT =
              app
                r_bright
                rinfo
            in
            let bright : FLOAT =
              let Td911 : FLOAT =
                fmul scale diffuse
              in
              fmul Td911 p
            in
            let hilight : FLOAT =
              let Td913 : FLOAT =
                let Ta912 : Array of FLOAT =
                  app
                    d_vec
                    dvec
                in
                app
                  veciprod
                  dirvec
                  Ta912
              in
              fmul scale Td913
            in
            app
              add_light
              bright
              hilight
              hilight_scale
            unit ()
          unit ()
    in
    let Ti915 : INT =
      let Ti914 : INT =
        int 1
      in
      sub index Ti914
    in
    app
      trace_reflections
      Ti915
      diffuse
      hilight_scale
      dirvec
    unit ()
in
letrec trace_ray : (INT -> (FLOAT -> (Array of FLOAT -> ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (FLOAT -> UNIT))))) =
variables : (nref : INT), (energy : FLOAT), (dirvec : Array of FLOAT), (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (dist : FLOAT)
  let Ti818 : INT =
    int 4
  in
  if nref <= Ti818
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Tb819 : BOOL =
      app
        judge_intersection
        dirvec
    in
    let Ti820 : INT =
      int 0
    in
    if Tb819 == Ti820
      let Tu157 : UNIT =
        let Ti822 : INT =
          let Ti821 : INT =
            int 1
          in
          neg Ti821
        in
        surface_ids.(nref) <- Ti822
      in
      let Ti823 : INT =
        int 0
      in
      if nref == Ti823
        unit ()
        let hl : FLOAT =
          let Td824 : FLOAT =
            app
              veciprod
              dirvec
              light
          in
          app
            fneg
            Td824
        in
        let Tb825 : BOOL =
          app
            fispos
            hl
        in
        let Ti826 : INT =
          int 0
        in
        if Tb825 == Ti826
          unit ()
          let ihl : FLOAT =
            let Td829 : FLOAT =
              let Td828 : FLOAT =
                let Td827 : FLOAT =
                  app
                    fsqr
                    hl
                in
                fmul Td827 hl
              in
              fmul Td828 energy
            in
            let Td831 : FLOAT =
              let Ti830 : INT =
                int 0
              in
              beam.(Ti830)
            in
            fmul Td829 Td831
          in
          let Tu156 : UNIT =
            let Ti832 : INT =
              int 0
            in
            let Td835 : FLOAT =
              let Td834 : FLOAT =
                let Ti833 : INT =
                  int 0
                in
                rgb.(Ti833)
              in
              fadd Td834 ihl
            in
            rgb.(Ti832) <- Td835
          in
          let Tu155 : UNIT =
            let Ti836 : INT =
              int 1
            in
            let Td839 : FLOAT =
              let Td838 : FLOAT =
                let Ti837 : INT =
                  int 1
                in
                rgb.(Ti837)
              in
              fadd Td838 ihl
            in
            rgb.(Ti836) <- Td839
          in
          let Ti840 : INT =
            int 2
          in
          let Td843 : FLOAT =
            let Td842 : FLOAT =
              let Ti841 : INT =
                int 2
              in
              rgb.(Ti841)
            in
            fadd Td842 ihl
          in
          rgb.(Ti840) <- Td843
      let obj_id : INT =
        let Ti844 : INT =
          int 0
        in
        intersected_object_id.(Ti844)
      in
      let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
        objects.(obj_id)
      in
      let m_surface : INT =
        app
          o_reflectiontype
          obj
      in
      let diffuse : FLOAT =
        let Td845 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td845 energy
      in
      let Tu154 : UNIT =
        app
          get_nvector
          obj
          dirvec
      in
      let Tu153 : UNIT =
        app
          veccpy
          startp
          intersection_point
      in
      let Tu152 : UNIT =
        app
          utexture
          obj
          intersection_point
      in
      let Tu151 : UNIT =
        let Ti849 : INT =
          let Ti846 : INT =
            mul obj_id 4
          in
          let Ti848 : INT =
            let Ti847 : INT =
              int 0
            in
            intsec_rectside.(Ti847)
          in
          add Ti846 Ti848
        in
        surface_ids.(nref) <- Ti849
      in
      let intersection_points : Array of Array of FLOAT =
        app
          p_intersection_points
          pixel
      in
      let Tu150 : UNIT =
        let Ta850 : Array of FLOAT =
          intersection_points.(nref)
        in
        app
          veccpy
          Ta850
          intersection_point
      in
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu149 : UNIT =
        let Tb853 : BOOL =
          let Td851 : FLOAT =
            app
              o_diffuse
              obj
          in
          let Td852 : FLOAT =
            float 0.5
          in
          app
            fless
            Td851
            Td852
        in
        let Ti854 : INT =
          int 0
        in
        if Tb853 == Ti854
          let Tu143 : UNIT =
            let Ti855 : INT =
              int 1
            in
            calc_diffuse.(nref) <- Ti855
          in
          let energya : Array of Array of FLOAT =
            app
              p_energy
              pixel
          in
          let Tu142 : UNIT =
            let Ta856 : Array of FLOAT =
              energya.(nref)
            in
            app
              veccpy
              Ta856
              texture_color
          in
          let Tu141 : UNIT =
            let Ta857 : Array of FLOAT =
              energya.(nref)
            in
            let Td861 : FLOAT =
              let Td860 : FLOAT =
                let Td858 : FLOAT =
                  float 1.
                in
                let Td859 : FLOAT =
                  float 256.
                in
                fdiv Td858 Td859
              in
              fmul Td860 diffuse
            in
            app
              vecscale
              Ta857
              Td861
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let Ta862 : Array of FLOAT =
            nvectors.(nref)
          in
          app
            veccpy
            Ta862
            nvector
          let Ti863 : INT =
            int 0
          in
          calc_diffuse.(nref) <- Ti863
      in
      let w : FLOAT =
        let Td864 : FLOAT =
          float -2.
        in
        let Td865 : FLOAT =
          app
            veciprod
            dirvec
            nvector
        in
        fmul Td864 Td865
      in
      let Tu148 : UNIT =
        app
          vecaccum
          dirvec
          w
          nvector
      in
      let hilight_scale : FLOAT =
        let Td866 : FLOAT =
          app
            o_hilight
            obj
        in
        fmul energy Td866
      in
      let Tu147 : UNIT =
        let Tb870 : BOOL =
          let Ti867 : INT =
            int 0
          in
          let Ta869 : Array of Array of INT =
            let Ti868 : INT =
              int 0
            in
            or_net.(Ti868)
          in
          app
            shadow_check_one_or_matrix
            Ti867
            Ta869
        in
        let Ti871 : INT =
          int 0
        in
        if Tb870 == Ti871
          let bright : FLOAT =
            let Td873 : FLOAT =
              let Td872 : FLOAT =
                app
                  veciprod
                  nvector
                  light
              in
              app
                fneg
                Td872
            in
            fmul Td873 diffuse
          in
          let hilight : FLOAT =
            let Td874 : FLOAT =
              app
                veciprod
                dirvec
                light
            in
            app
              fneg
              Td874
          in
          app
            add_light
            bright
            hilight
            hilight_scale
          unit ()
      in
      let Tu146 : UNIT =
        app
          setup_startp
          intersection_point
      in
      let Tu145 : UNIT =
        let Ti878 : INT =
          let Ti876 : INT =
            let Ti875 : INT =
              int 0
            in
            n_reflections.(Ti875)
          in
          let Ti877 : INT =
            int 1
          in
          sub Ti876 Ti877
        in
        app
          trace_reflections
          Ti878
          diffuse
          hilight_scale
          dirvec
      in
      let Tb880 : BOOL =
        let Td879 : FLOAT =
          float 0.1
        in
        app
          fless
          Td879
          energy
      in
      let Ti881 : INT =
        int 0
      in
      if Tb880 == Ti881
        unit ()
        let Tu144 : UNIT =
          let Ti882 : INT =
            int 4
          in
          if Ti882 <= nref
            unit ()
            let Ti884 : INT =
              let Ti883 : INT =
                int 1
              in
              add nref Ti883
            in
            let Ti886 : INT =
              let Ti885 : INT =
                int 1
              in
              neg Ti885
            in
            surface_ids.(Ti884) <- Ti886
        in
        let Ti887 : INT =
          int 2
        in
        if m_surface == Ti887
          let energy2 : FLOAT =
            let Td890 : FLOAT =
              let Td888 : FLOAT =
                float 1.
              in
              let Td889 : FLOAT =
                app
                  o_diffuse
                  obj
              in
              fsub Td888 Td889
            in
            fmul energy Td890
          in
          let Ti892 : INT =
            let Ti891 : INT =
              int 1
            in
            add nref Ti891
          in
          let Td895 : FLOAT =
            let Td894 : FLOAT =
              let Ti893 : INT =
                int 0
              in
              tmin.(Ti893)
            in
            fadd dist Td894
          in
          app
            trace_ray
            Ti892
            energy2
            dirvec
            pixel
            Td895
          unit ()
    unit ()
in
letrec trace_diffuse_ray : ((Array of FLOAT * Array of Array of FLOAT) -> (FLOAT -> UNIT)) =
variables : (dirvec : (Array of FLOAT * Array of Array of FLOAT)), (energy : FLOAT)
  let Tb802 : BOOL =
    app
      judge_intersection_fast
      dirvec
  in
  let Ti803 : INT =
    int 0
  in
  if Tb802 == Ti803
    unit ()
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      let Ti805 : INT =
        let Ti804 : INT =
          int 0
        in
        intersected_object_id.(Ti804)
      in
      objects.(Ti805)
    in
    let Tu159 : UNIT =
      let Ta806 : Array of FLOAT =
        app
          d_vec
          dirvec
      in
      app
        get_nvector
        obj
        Ta806
    in
    let Tu158 : UNIT =
      app
        utexture
        obj
        intersection_point
    in
    let Tb810 : BOOL =
      let Ti807 : INT =
        int 0
      in
      let Ta809 : Array of Array of INT =
        let Ti808 : INT =
          int 0
        in
        or_net.(Ti808)
      in
      app
        shadow_check_one_or_matrix
        Ti807
        Ta809
    in
    let Ti811 : INT =
      int 0
    in
    if Tb810 == Ti811
      let br : FLOAT =
        let Td812 : FLOAT =
          app
            veciprod
            nvector
            light
        in
        app
          fneg
          Td812
      in
      let bright : FLOAT =
        let Tb813 : BOOL =
          app
            fispos
            br
        in
        let Ti814 : INT =
          int 0
        in
        if Tb813 == Ti814
          float 0.
          br
      in
      let Td817 : FLOAT =
        let Td815 : FLOAT =
          fmul energy bright
        in
        let Td816 : FLOAT =
          app
            o_diffuse
            obj
        in
        fmul Td815 Td816
      in
      app
        vecaccum
        diffuse_ray
        Td817
        texture_color
      unit ()
in
letrec iter_trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> (INT -> UNIT)))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT), (index : INT)
  let Ti787 : INT =
    int 0
  in
  if Ti787 <= index
    let p : FLOAT =
      let Ta789 : Array of FLOAT =
        let Tt788 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        app
          d_vec
          Tt788
      in
      app
        veciprod
        Ta789
        nvector
    in
    let Tu160 : UNIT =
      let Tb790 : BOOL =
        app
          fisneg
          p
      in
      let Ti791 : INT =
        int 0
      in
      if Tb790 == Ti791
        let Tt792 : (Array of FLOAT * Array of Array of FLOAT) =
          dirvec_group.(index)
        in
        let Td794 : FLOAT =
          let Td793 : FLOAT =
            float 150.
          in
          fdiv p Td793
        in
        app
          trace_diffuse_ray
          Tt792
          Td794
        let Tt797 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti796 : INT =
            let Ti795 : INT =
              int 1
            in
            add index Ti795
          in
          dirvec_group.(Ti796)
        in
        let Td799 : FLOAT =
          let Td798 : FLOAT =
            float -150.
          in
          fdiv p Td798
        in
        app
          trace_diffuse_ray
          Tt797
          Td799
    in
    let Ti801 : INT =
      let Ti800 : INT =
        int 2
      in
      sub index Ti800
    in
    app
      iter_trace_diffuse_rays
      dirvec_group
      nvector
      org
      Ti801
    unit ()
in
letrec trace_diffuse_rays : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (dirvec_group : Array of (Array of FLOAT * Array of Array of FLOAT)), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu161 : UNIT =
    app
      setup_startp
      org
  in
  let Ti786 : INT =
    int 118
  in
  app
    iter_trace_diffuse_rays
    dirvec_group
    nvector
    org
    Ti786
in
letrec trace_diffuse_ray_80percent : (INT -> (Array of FLOAT -> (Array of FLOAT -> UNIT))) =
variables : (group_id : INT), (nvector : Array of FLOAT), (org : Array of FLOAT)
  let Tu165 : UNIT =
    let Ti771 : INT =
      int 0
    in
    if group_id == Ti771
      unit ()
      let Ta773 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti772 : INT =
          int 0
        in
        dirvecs.(Ti772)
      in
      app
        trace_diffuse_rays
        Ta773
        nvector
        org
  in
  let Tu164 : UNIT =
    let Ti774 : INT =
      int 1
    in
    if group_id == Ti774
      unit ()
      let Ta776 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti775 : INT =
          int 1
        in
        dirvecs.(Ti775)
      in
      app
        trace_diffuse_rays
        Ta776
        nvector
        org
  in
  let Tu163 : UNIT =
    let Ti777 : INT =
      int 2
    in
    if group_id == Ti777
      unit ()
      let Ta779 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti778 : INT =
          int 2
        in
        dirvecs.(Ti778)
      in
      app
        trace_diffuse_rays
        Ta779
        nvector
        org
  in
  let Tu162 : UNIT =
    let Ti780 : INT =
      int 3
    in
    if group_id == Ti780
      unit ()
      let Ta782 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti781 : INT =
          int 3
        in
        dirvecs.(Ti781)
      in
      app
        trace_diffuse_rays
        Ta782
        nvector
        org
  in
  let Ti783 : INT =
    int 4
  in
  if group_id == Ti783
    unit ()
    let Ta785 : Array of (Array of FLOAT * Array of Array of FLOAT) =
      let Ti784 : INT =
        int 4
      in
      dirvecs.(Ti784)
    in
    app
      trace_diffuse_rays
      Ta785
      nvector
      org
in
letrec calc_diffuse_using_1point : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let ray20p : Array of Array of FLOAT =
    app
      p_received_ray_20percent
      pixel
  in
  let nvectors : Array of Array of FLOAT =
    app
      p_nvectors
      pixel
  in
  let intersection_points : Array of Array of FLOAT =
    app
      p_intersection_points
      pixel
  in
  let energya : Array of Array of FLOAT =
    app
      p_energy
      pixel
  in
  let Tu167 : UNIT =
    let Ta766 : Array of FLOAT =
      ray20p.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta766
  in
  let Tu166 : UNIT =
    let Ti767 : INT =
      app
        p_group_id
        pixel
    in
    let Ta768 : Array of FLOAT =
      nvectors.(nref)
    in
    let Ta769 : Array of FLOAT =
      intersection_points.(nref)
    in
    app
      trace_diffuse_ray_80percent
      Ti767
      Ta768
      Ta769
  in
  let Ta770 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta770
    diffuse_ray
in
letrec calc_diffuse_using_5points : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let r_up : Array of Array of FLOAT =
    let Tt750 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      p_received_ray_20percent
      Tt750
  in
  let r_left : Array of Array of FLOAT =
    let Tt753 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti752 : INT =
        let Ti751 : INT =
          int 1
        in
        sub x Ti751
      in
      cur.(Ti752)
    in
    app
      p_received_ray_20percent
      Tt753
  in
  let r_center : Array of Array of FLOAT =
    let Tt754 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_received_ray_20percent
      Tt754
  in
  let r_right : Array of Array of FLOAT =
    let Tt757 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Ti756 : INT =
        let Ti755 : INT =
          int 1
        in
        add x Ti755
      in
      cur.(Ti756)
    in
    app
      p_received_ray_20percent
      Tt757
  in
  let r_down : Array of Array of FLOAT =
    let Tt758 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      next.(x)
    in
    app
      p_received_ray_20percent
      Tt758
  in
  let Tu172 : UNIT =
    let Ta759 : Array of FLOAT =
      r_up.(nref)
    in
    app
      veccpy
      diffuse_ray
      Ta759
  in
  let Tu171 : UNIT =
    let Ta760 : Array of FLOAT =
      r_left.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta760
  in
  let Tu170 : UNIT =
    let Ta761 : Array of FLOAT =
      r_center.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta761
  in
  let Tu169 : UNIT =
    let Ta762 : Array of FLOAT =
      r_right.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta762
  in
  let Tu168 : UNIT =
    let Ta763 : Array of FLOAT =
      r_down.(nref)
    in
    app
      vecadd
      diffuse_ray
      Ta763
  in
  let energya : Array of Array of FLOAT =
    let Tt764 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      p_energy
      Tt764
  in
  let Ta765 : Array of FLOAT =
    energya.(nref)
  in
  app
    vecaccumv
    rgb
    Ta765
    diffuse_ray
in
letrec do_without_neighbors : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti743 : INT =
    int 4
  in
  if nref <= Ti743
    let surface_ids : Array of INT =
      app
        p_surface_ids
        pixel
    in
    let Ti744 : INT =
      int 0
    in
    let Ti745 : INT =
      surface_ids.(nref)
    in
    if Ti744 <= Ti745
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu173 : UNIT =
        let Tb746 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti747 : INT =
          int 0
        in
        if Tb746 == Ti747
          unit ()
          app
            calc_diffuse_using_1point
            pixel
            nref
      in
      let Ti749 : INT =
        let Ti748 : INT =
          int 1
        in
        add nref Ti748
      in
      app
        do_without_neighbors
        pixel
        Ti749
      unit ()
    unit ()
in
letrec neighbors_exist : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> BOOL))) =
variables : (x : INT), (y : INT), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti734 : INT =
    let Ti733 : INT =
      int 1
    in
    image_size.(Ti733)
  in
  let Ti736 : INT =
    let Ti735 : INT =
      int 1
    in
    add y Ti735
  in
  if Ti734 <= Ti736
    int 0
    let Ti737 : INT =
      int 0
    in
    if y <= Ti737
      int 0
      let Ti739 : INT =
        let Ti738 : INT =
          int 0
        in
        image_size.(Ti738)
      in
      let Ti741 : INT =
        let Ti740 : INT =
          int 1
        in
        add x Ti740
      in
      if Ti739 <= Ti741
        int 0
        let Ti742 : INT =
          int 0
        in
        if x <= Ti742
          int 0
          int 1
in
letrec get_surface_id : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> INT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (index : INT)
  let surface_ids : Array of INT =
    app
      p_surface_ids
      pixel
  in
  surface_ids.(index)
in
letrec neighbors_are_available : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> BOOL))))) =
variables : (x : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let sid_center : INT =
    let Tt720 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      cur.(x)
    in
    app
      get_surface_id
      Tt720
      nref
  in
  let Ti722 : INT =
    let Tt721 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      prev.(x)
    in
    app
      get_surface_id
      Tt721
      nref
  in
  if Ti722 == sid_center
    let Ti724 : INT =
      let Tt723 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        next.(x)
      in
      app
        get_surface_id
        Tt723
        nref
    in
    if Ti724 == sid_center
      let Ti728 : INT =
        let Tt727 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          let Ti726 : INT =
            let Ti725 : INT =
              int 1
            in
            sub x Ti725
          in
          cur.(Ti726)
        in
        app
          get_surface_id
          Tt727
          nref
      in
      if Ti728 == sid_center
        let Ti732 : INT =
          let Tt731 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
            let Ti730 : INT =
              let Ti729 : INT =
                int 1
              in
              add x Ti729
            in
            cur.(Ti730)
          in
          app
            get_surface_id
            Tt731
            nref
        in
        if Ti732 == sid_center
          int 1
          int 0
        int 0
      int 0
    int 0
in
letrec try_exploit_neighbors : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    cur.(x)
  in
  let Ti710 : INT =
    int 4
  in
  if nref <= Ti710
    let Ti711 : INT =
      int 0
    in
    let Ti712 : INT =
      app
        get_surface_id
        pixel
        nref
    in
    if Ti711 <= Ti712
      let Tb713 : BOOL =
        app
          neighbors_are_available
          x
          prev
          cur
          next
          nref
      in
      let Ti714 : INT =
        int 0
      in
      if Tb713 == Ti714
        let Tt715 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          do_without_neighbors
          Tt715
          nref
        let calc_diffuse : Array of BOOL =
          app
            p_calc_diffuse
            pixel
        in
        let Tu174 : UNIT =
          let Tb716 : BOOL =
            calc_diffuse.(nref)
          in
          let Ti717 : INT =
            int 0
          in
          if Tb716 == Ti717
            unit ()
            app
              calc_diffuse_using_5points
              x
              prev
              cur
              next
              nref
        in
        let Ti719 : INT =
          let Ti718 : INT =
            int 1
          in
          add nref Ti718
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti719
      unit ()
    unit ()
in
letrec write_ppm_header : (UNIT -> UNIT) =
variables : (Tu175 : UNIT)
  let Tu183 : UNIT =
    let Ti697 : INT =
      int 80
    in
    app
      print_char
      Ti697
  in
  let Tu182 : UNIT =
    let Ti700 : INT =
      let Ti698 : INT =
        int 48
      in
      let Ti699 : INT =
        int 3
      in
      add Ti698 Ti699
    in
    app
      print_char
      Ti700
  in
  let Tu181 : UNIT =
    let Ti701 : INT =
      int 10
    in
    app
      print_char
      Ti701
  in
  let Tu180 : UNIT =
    let Ti703 : INT =
      let Ti702 : INT =
        int 0
      in
      image_size.(Ti702)
    in
    app
      print_int
      Ti703
  in
  let Tu179 : UNIT =
    let Ti704 : INT =
      int 32
    in
    app
      print_char
      Ti704
  in
  let Tu178 : UNIT =
    let Ti706 : INT =
      let Ti705 : INT =
        int 1
      in
      image_size.(Ti705)
    in
    app
      print_int
      Ti706
  in
  let Tu177 : UNIT =
    let Ti707 : INT =
      int 32
    in
    app
      print_char
      Ti707
  in
  let Tu176 : UNIT =
    let Ti708 : INT =
      int 255
    in
    app
      print_int
      Ti708
  in
  let Ti709 : INT =
    int 10
  in
  app
    print_char
    Ti709
in
letrec write_rgb_element : (FLOAT -> UNIT) =
variables : (x : FLOAT)
  let ix : INT =
    ftoi x
  in
  let elem : INT =
    let Ti695 : INT =
      int 255
    in
    if ix <= Ti695
      let Ti696 : INT =
        int 0
      in
      if Ti696 <= ix
        ix
        int 0
      int 255
  in
  app
    print_int
    elem
in
letrec write_rgb : (UNIT -> UNIT) =
variables : (Tu184 : UNIT)
  let Tu189 : UNIT =
    let Td687 : FLOAT =
      let Ti686 : INT =
        int 0
      in
      rgb.(Ti686)
    in
    app
      write_rgb_element
      Td687
  in
  let Tu188 : UNIT =
    let Ti688 : INT =
      int 32
    in
    app
      print_char
      Ti688
  in
  let Tu187 : UNIT =
    let Td690 : FLOAT =
      let Ti689 : INT =
        int 1
      in
      rgb.(Ti689)
    in
    app
      write_rgb_element
      Td690
  in
  let Tu186 : UNIT =
    let Ti691 : INT =
      int 32
    in
    app
      print_char
      Ti691
  in
  let Tu185 : UNIT =
    let Td693 : FLOAT =
      let Ti692 : INT =
        int 2
      in
      rgb.(Ti692)
    in
    app
      write_rgb_element
      Td693
  in
  let Ti694 : INT =
    int 10
  in
  app
    print_char
    Ti694
in
letrec pretrace_diffuse_rays : ((Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (pixel : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (nref : INT)
  let Ti676 : INT =
    int 4
  in
  if nref <= Ti676
    let sid : INT =
      app
        get_surface_id
        pixel
        nref
    in
    let Ti677 : INT =
      int 0
    in
    if Ti677 <= sid
      let calc_diffuse : Array of BOOL =
        app
          p_calc_diffuse
          pixel
      in
      let Tu192 : UNIT =
        let Tb678 : BOOL =
          calc_diffuse.(nref)
        in
        let Ti679 : INT =
          int 0
        in
        if Tb678 == Ti679
          unit ()
          let group_id : INT =
            app
              p_group_id
              pixel
          in
          let Tu191 : UNIT =
            app
              vecbzero
              diffuse_ray
          in
          let nvectors : Array of Array of FLOAT =
            app
              p_nvectors
              pixel
          in
          let intersection_points : Array of Array of FLOAT =
            app
              p_intersection_points
              pixel
          in
          let Tu190 : UNIT =
            let Ta680 : Array of (Array of FLOAT * Array of Array of FLOAT) =
              dirvecs.(group_id)
            in
            let Ta681 : Array of FLOAT =
              nvectors.(nref)
            in
            let Ta682 : Array of FLOAT =
              intersection_points.(nref)
            in
            app
              trace_diffuse_rays
              Ta680
              Ta681
              Ta682
          in
          let ray20p : Array of Array of FLOAT =
            app
              p_received_ray_20percent
              pixel
          in
          let Ta683 : Array of FLOAT =
            ray20p.(nref)
          in
          app
            veccpy
            Ta683
            diffuse_ray
      in
      let Ti685 : INT =
        let Ti684 : INT =
          int 1
        in
        add nref Ti684
      in
      app
        pretrace_diffuse_rays
        pixel
        Ti685
      unit ()
    unit ()
in
letrec pretrace_pixels : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (x : INT), (group_id : INT), (lc0 : FLOAT), (lc1 : FLOAT), (lc2 : FLOAT)
  let Ti640 : INT =
    int 0
  in
  if Ti640 <= x
    let xdisp : FLOAT =
      let Td642 : FLOAT =
        let Ti641 : INT =
          int 0
        in
        scan_pitch.(Ti641)
      in
      let Td646 : FLOAT =
        let Ti645 : INT =
          let Ti644 : INT =
            let Ti643 : INT =
              int 0
            in
            image_center.(Ti643)
          in
          sub x Ti644
        in
        itof Ti645
      in
      fmul Td642 Td646
    in
    let Tu202 : UNIT =
      let Ti647 : INT =
        int 0
      in
      let Td651 : FLOAT =
        let Td650 : FLOAT =
          let Td649 : FLOAT =
            let Ti648 : INT =
              int 0
            in
            screenx_dir.(Ti648)
          in
          fmul xdisp Td649
        in
        fadd Td650 lc0
      in
      ptrace_dirvec.(Ti647) <- Td651
    in
    let Tu201 : UNIT =
      let Ti652 : INT =
        int 1
      in
      let Td656 : FLOAT =
        let Td655 : FLOAT =
          let Td654 : FLOAT =
            let Ti653 : INT =
              int 1
            in
            screenx_dir.(Ti653)
          in
          fmul xdisp Td654
        in
        fadd Td655 lc1
      in
      ptrace_dirvec.(Ti652) <- Td656
    in
    let Tu200 : UNIT =
      let Ti657 : INT =
        int 2
      in
      let Td661 : FLOAT =
        let Td660 : FLOAT =
          let Td659 : FLOAT =
            let Ti658 : INT =
              int 2
            in
            screenx_dir.(Ti658)
          in
          fmul xdisp Td659
        in
        fadd Td660 lc2
      in
      ptrace_dirvec.(Ti657) <- Td661
    in
    let Tu199 : UNIT =
      let Ti662 : INT =
        int 0
      in
      app
        vecunit_sgn
        ptrace_dirvec
        Ti662
    in
    let Tu198 : UNIT =
      app
        vecbzero
        rgb
    in
    let Tu197 : UNIT =
      app
        veccpy
        startp
        viewpoint
    in
    let Tu196 : UNIT =
      let Ti663 : INT =
        int 0
      in
      let Td664 : FLOAT =
        float 1.
      in
      let Tt665 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Td666 : FLOAT =
        float 0.
      in
      app
        trace_ray
        Ti663
        Td664
        ptrace_dirvec
        Tt665
        Td666
    in
    let Tu195 : UNIT =
      let Ta668 : Array of FLOAT =
        let Tt667 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          line.(x)
        in
        app
          p_rgb
          Tt667
      in
      app
        veccpy
        Ta668
        rgb
    in
    let Tu194 : UNIT =
      let Tt669 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      app
        p_set_group_id
        Tt669
        group_id
    in
    let Tu193 : UNIT =
      let Tt670 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        line.(x)
      in
      let Ti671 : INT =
        int 0
      in
      app
        pretrace_diffuse_rays
        Tt670
        Ti671
    in
    let Ti673 : INT =
      let Ti672 : INT =
        int 1
      in
      sub x Ti672
    in
    let Ti675 : INT =
      let Ti674 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti674
    in
    app
      pretrace_pixels
      line
      Ti673
      Ti675
      lc0
      lc1
      lc2
    unit ()
in
letrec pretrace_line : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> (INT -> UNIT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (y : INT), (group_id : INT)
  let ydisp : FLOAT =
    let Td616 : FLOAT =
      let Ti615 : INT =
        int 0
      in
      scan_pitch.(Ti615)
    in
    let Td620 : FLOAT =
      let Ti619 : INT =
        let Ti618 : INT =
          let Ti617 : INT =
            int 1
          in
          image_center.(Ti617)
        in
        sub y Ti618
      in
      itof Ti619
    in
    fmul Td616 Td620
  in
  let lc0 : FLOAT =
    let Td623 : FLOAT =
      let Td622 : FLOAT =
        let Ti621 : INT =
          int 0
        in
        screeny_dir.(Ti621)
      in
      fmul ydisp Td622
    in
    let Td625 : FLOAT =
      let Ti624 : INT =
        int 0
      in
      screenz_dir.(Ti624)
    in
    fadd Td623 Td625
  in
  let lc1 : FLOAT =
    let Td628 : FLOAT =
      let Td627 : FLOAT =
        let Ti626 : INT =
          int 1
        in
        screeny_dir.(Ti626)
      in
      fmul ydisp Td627
    in
    let Td630 : FLOAT =
      let Ti629 : INT =
        int 1
      in
      screenz_dir.(Ti629)
    in
    fadd Td628 Td630
  in
  let lc2 : FLOAT =
    let Td633 : FLOAT =
      let Td632 : FLOAT =
        let Ti631 : INT =
          int 2
        in
        screeny_dir.(Ti631)
      in
      fmul ydisp Td632
    in
    let Td635 : FLOAT =
      let Ti634 : INT =
        int 2
      in
      screenz_dir.(Ti634)
    in
    fadd Td633 Td635
  in
  let Ti639 : INT =
    let Ti637 : INT =
      let Ti636 : INT =
        int 0
      in
      image_size.(Ti636)
    in
    let Ti638 : INT =
      int 1
    in
    sub Ti637 Ti638
  in
  app
    pretrace_pixels
    line
    Ti639
    group_id
    lc0
    lc1
    lc2
in
letrec scan_pixel : (INT -> (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> UNIT))))) =
variables : (x : INT), (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))
  let Ti604 : INT =
    let Ti603 : INT =
      int 0
    in
    image_size.(Ti603)
  in
  if Ti604 <= x
    unit ()
    let Tu205 : UNIT =
      let Ta606 : Array of FLOAT =
        let Tt605 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        app
          p_rgb
          Tt605
      in
      app
        veccpy
        rgb
        Ta606
    in
    let Tu204 : UNIT =
      let Tb607 : BOOL =
        app
          neighbors_exist
          x
          y
          next
      in
      let Ti608 : INT =
        int 0
      in
      if Tb607 == Ti608
        let Tt609 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
          cur.(x)
        in
        let Ti610 : INT =
          int 0
        in
        app
          do_without_neighbors
          Tt609
          Ti610
        let Ti611 : INT =
          int 0
        in
        app
          try_exploit_neighbors
          x
          y
          prev
          cur
          next
          Ti611
    in
    let Tu203 : UNIT =
      let Tu612 : UNIT =
        unit ()
      in
      app
        write_rgb
        Tu612
    in
    let Ti614 : INT =
      let Ti613 : INT =
        int 1
      in
      add x Ti613
    in
    app
      scan_pixel
      Ti614
      y
      prev
      cur
      next
in
letrec scan_line : (INT -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> UNIT))))) =
variables : (y : INT), (prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (group_id : INT)
  let Ti591 : INT =
    let Ti590 : INT =
      int 1
    in
    image_size.(Ti590)
  in
  if Ti591 <= y
    unit ()
    let Tu207 : UNIT =
      let Ti595 : INT =
        let Ti593 : INT =
          let Ti592 : INT =
            int 1
          in
          image_size.(Ti592)
        in
        let Ti594 : INT =
          int 1
        in
        sub Ti593 Ti594
      in
      if Ti595 <= y
        unit ()
        let Ti597 : INT =
          let Ti596 : INT =
            int 1
          in
          add y Ti596
        in
        app
          pretrace_line
          next
          Ti597
          group_id
    in
    let Tu206 : UNIT =
      let Ti598 : INT =
        int 0
      in
      app
        scan_pixel
        Ti598
        y
        prev
        cur
        next
    in
    let Ti600 : INT =
      let Ti599 : INT =
        int 1
      in
      add y Ti599
    in
    let Ti602 : INT =
      let Ti601 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti601
    in
    app
      scan_line
      Ti600
      cur
      next
      prev
      Ti602
in
letrec create_float5x3array : (UNIT -> Array of Array of FLOAT) =
variables : (Tu208 : UNIT)
  let vec : Array of FLOAT =
    let Ti571 : INT =
      int 3
    in
    let Td572 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti571
      Td572
  in
  let array : Array of Array of FLOAT =
    let Ti573 : INT =
      int 5
    in
    extfunapp
      create_array
      Ti573
      vec
  in
  let Tu212 : UNIT =
    let Ti574 : INT =
      int 1
    in
    let Ta577 : Array of FLOAT =
      let Ti575 : INT =
        int 3
      in
      let Td576 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti575
        Td576
    in
    array.(Ti574) <- Ta577
  in
  let Tu211 : UNIT =
    let Ti578 : INT =
      int 2
    in
    let Ta581 : Array of FLOAT =
      let Ti579 : INT =
        int 3
      in
      let Td580 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti579
        Td580
    in
    array.(Ti578) <- Ta581
  in
  let Tu210 : UNIT =
    let Ti582 : INT =
      int 3
    in
    let Ta585 : Array of FLOAT =
      let Ti583 : INT =
        int 3
      in
      let Td584 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti583
        Td584
    in
    array.(Ti582) <- Ta585
  in
  let Tu209 : UNIT =
    let Ti586 : INT =
      int 4
    in
    let Ta589 : Array of FLOAT =
      let Ti587 : INT =
        int 3
      in
      let Td588 : FLOAT =
        float 0.
      in
      extfunapp
        create_float_array
        Ti587
        Td588
    in
    array.(Ti586) <- Ta589
  in
  array
in
letrec create_pixel : (UNIT -> (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu213 : UNIT)
  let m_rgb : Array of FLOAT =
    let Ti559 : INT =
      int 3
    in
    let Td560 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti559
      Td560
  in
  let m_isect_ps : Array of Array of FLOAT =
    let Tu561 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu561
  in
  let m_sids : Array of INT =
    let Ti562 : INT =
      int 5
    in
    let Ti563 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti562
      Ti563
  in
  let m_cdif : Array of BOOL =
    let Ti564 : INT =
      int 5
    in
    let Ti565 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti564
      Ti565
  in
  let m_engy : Array of Array of FLOAT =
    let Tu566 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu566
  in
  let m_r20p : Array of Array of FLOAT =
    let Tu567 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu567
  in
  let m_gid : Array of INT =
    let Ti568 : INT =
      int 1
    in
    let Ti569 : INT =
      int 0
    in
    extfunapp
      create_array
      Ti568
      Ti569
  in
  let m_nvectors : Array of Array of FLOAT =
    let Tu570 : UNIT =
      unit ()
    in
    app
      create_float5x3array
      Tu570
  in
  Tuple
    m_rgb
    m_isect_ps
    m_sids
    m_cdif
    m_engy
    m_r20p
    m_gid
    m_nvectors
in
letrec init_line_elements : (Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) -> (INT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT))) =
variables : (line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)), (n : INT)
  let Ti554 : INT =
    int 0
  in
  if Ti554 <= n
    let Tu214 : UNIT =
      let Tt556 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
        let Tu555 : UNIT =
          unit ()
        in
        app
          create_pixel
          Tu555
      in
      line.(n) <- Tt556
    in
    let Ti558 : INT =
      let Ti557 : INT =
        int 1
      in
      sub n Ti557
    in
    app
      init_line_elements
      line
      Ti558
    line
in
letrec create_pixelline : (UNIT -> Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT)) =
variables : (Tu215 : UNIT)
  let line : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Ti547 : INT =
      let Ti546 : INT =
        int 0
      in
      image_size.(Ti546)
    in
    let Tt549 : (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
      let Tu548 : UNIT =
        unit ()
      in
      app
        create_pixel
        Tu548
    in
    extfunapp
      create_array
      Ti547
      Tt549
  in
  let Ti553 : INT =
    let Ti551 : INT =
      let Ti550 : INT =
        int 0
      in
      image_size.(Ti550)
    in
    let Ti552 : INT =
      int 2
    in
    sub Ti551 Ti552
  in
  app
    init_line_elements
    line
    Ti553
in
letrec tan : (FLOAT -> FLOAT) =
variables : (x : FLOAT)
  let Td544 : FLOAT =
    app
      sin
      x
  in
  let Td545 : FLOAT =
    app
      cos
      x
  in
  fdiv Td544 Td545
in
letrec adjust_position : (FLOAT -> (FLOAT -> FLOAT)) =
variables : (h : FLOAT), (ratio : FLOAT)
  let l : FLOAT =
    let Td541 : FLOAT =
      let Td539 : FLOAT =
        fmul h h
      in
      let Td540 : FLOAT =
        float 0.1
      in
      fadd Td539 Td540
    in
    app
      sqrt
      Td541
  in
  let tan_h : FLOAT =
    let Td542 : FLOAT =
      float 1.
    in
    fdiv Td542 l
  in
  let theta_h : FLOAT =
    app
      atan
      tan_h
  in
  let tan_m : FLOAT =
    let Td543 : FLOAT =
      fmul theta_h ratio
    in
    app
      tan
      Td543
  in
  fmul tan_m l
in
letrec calc_dirvec : (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> (INT -> (INT -> UNIT))))))) =
variables : (icount : INT), (x : FLOAT), (y : FLOAT), (rx : FLOAT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti498 : INT =
    int 5
  in
  if Ti498 <= icount
    let l : FLOAT =
      let Td503 : FLOAT =
        let Td501 : FLOAT =
          let Td499 : FLOAT =
            app
              fsqr
              x
          in
          let Td500 : FLOAT =
            app
              fsqr
              y
          in
          fadd Td499 Td500
        in
        let Td502 : FLOAT =
          float 1.
        in
        fadd Td501 Td502
      in
      app
        sqrt
        Td503
    in
    let vx : FLOAT =
      fdiv x l
    in
    let vy : FLOAT =
      fdiv y l
    in
    let vz : FLOAT =
      let Td504 : FLOAT =
        float 1.
      in
      fdiv Td504 l
    in
    let dgroup : Array of (Array of FLOAT * Array of Array of FLOAT) =
      dirvecs.(group_id)
    in
    let Tu220 : UNIT =
      let Ta506 : Array of FLOAT =
        let Tt505 : (Array of FLOAT * Array of Array of FLOAT) =
          dgroup.(index)
        in
        app
          d_vec
          Tt505
      in
      app
        vecset
        Ta506
        vx
        vy
        vz
    in
    let Tu219 : UNIT =
      let Ta510 : Array of FLOAT =
        let Tt509 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti508 : INT =
            let Ti507 : INT =
              int 40
            in
            add index Ti507
          in
          dgroup.(Ti508)
        in
        app
          d_vec
          Tt509
      in
      let Td511 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta510
        vx
        vz
        Td511
    in
    let Tu218 : UNIT =
      let Ta515 : Array of FLOAT =
        let Tt514 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti513 : INT =
            let Ti512 : INT =
              int 80
            in
            add index Ti512
          in
          dgroup.(Ti513)
        in
        app
          d_vec
          Tt514
      in
      let Td516 : FLOAT =
        app
          fneg
          vx
      in
      let Td517 : FLOAT =
        app
          fneg
          vy
      in
      app
        vecset
        Ta515
        vz
        Td516
        Td517
    in
    let Tu217 : UNIT =
      let Ta521 : Array of FLOAT =
        let Tt520 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti519 : INT =
            let Ti518 : INT =
              int 1
            in
            add index Ti518
          in
          dgroup.(Ti519)
        in
        app
          d_vec
          Tt520
      in
      let Td522 : FLOAT =
        app
          fneg
          vx
      in
      let Td523 : FLOAT =
        app
          fneg
          vy
      in
      let Td524 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta521
        Td522
        Td523
        Td524
    in
    let Tu216 : UNIT =
      let Ta528 : Array of FLOAT =
        let Tt527 : (Array of FLOAT * Array of Array of FLOAT) =
          let Ti526 : INT =
            let Ti525 : INT =
              int 41
            in
            add index Ti525
          in
          dgroup.(Ti526)
        in
        app
          d_vec
          Tt527
      in
      let Td529 : FLOAT =
        app
          fneg
          vx
      in
      let Td530 : FLOAT =
        app
          fneg
          vz
      in
      app
        vecset
        Ta528
        Td529
        Td530
        vy
    in
    let Ta534 : Array of FLOAT =
      let Tt533 : (Array of FLOAT * Array of Array of FLOAT) =
        let Ti532 : INT =
          let Ti531 : INT =
            int 81
          in
          add index Ti531
        in
        dgroup.(Ti532)
      in
      app
        d_vec
        Tt533
    in
    let Td535 : FLOAT =
      app
        fneg
        vz
    in
    app
      vecset
      Ta534
      Td535
      vx
      vy
    let x2 : FLOAT =
      app
        adjust_position
        y
        rx
    in
    let Ti537 : INT =
      let Ti536 : INT =
        int 1
      in
      add icount Ti536
    in
    let Td538 : FLOAT =
      app
        adjust_position
        x2
        ry
    in
    app
      calc_dirvec
      Ti537
      x2
      Td538
      rx
      ry
      group_id
      index
in
letrec calc_dirvecs : (INT -> (FLOAT -> (INT -> (INT -> UNIT)))) =
variables : (col : INT), (ry : FLOAT), (group_id : INT), (index : INT)
  let Ti477 : INT =
    int 0
  in
  if Ti477 <= col
    let rx : FLOAT =
      let Td480 : FLOAT =
        let Td478 : FLOAT =
          itof col
        in
        let Td479 : FLOAT =
          float 0.2
        in
        fmul Td478 Td479
      in
      let Td481 : FLOAT =
        float 0.9
      in
      fsub Td480 Td481
    in
    let Tu222 : UNIT =
      let Ti482 : INT =
        int 0
      in
      let Td483 : FLOAT =
        float 0.
      in
      let Td484 : FLOAT =
        float 0.
      in
      app
        calc_dirvec
        Ti482
        Td483
        Td484
        rx
        ry
        group_id
        index
    in
    let rx2 : FLOAT =
      let Td487 : FLOAT =
        let Td485 : FLOAT =
          itof col
        in
        let Td486 : FLOAT =
          float 0.2
        in
        fmul Td485 Td486
      in
      let Td488 : FLOAT =
        float 0.1
      in
      fadd Td487 Td488
    in
    let Tu221 : UNIT =
      let Ti489 : INT =
        int 0
      in
      let Td490 : FLOAT =
        float 0.
      in
      let Td491 : FLOAT =
        float 0.
      in
      let Ti493 : INT =
        let Ti492 : INT =
          int 2
        in
        add index Ti492
      in
      app
        calc_dirvec
        Ti489
        Td490
        Td491
        rx2
        ry
        group_id
        Ti493
    in
    let Ti495 : INT =
      let Ti494 : INT =
        int 1
      in
      sub col Ti494
    in
    let Ti497 : INT =
      let Ti496 : INT =
        int 1
      in
      app
        add_mod5
        group_id
        Ti496
    in
    app
      calc_dirvecs
      Ti495
      ry
      Ti497
      index
    unit ()
in
letrec calc_dirvec_rows : (INT -> (INT -> (INT -> UNIT))) =
variables : (row : INT), (group_id : INT), (index : INT)
  let Ti465 : INT =
    int 0
  in
  if Ti465 <= row
    let ry : FLOAT =
      let Td468 : FLOAT =
        let Td466 : FLOAT =
          itof row
        in
        let Td467 : FLOAT =
          float 0.2
        in
        fmul Td466 Td467
      in
      let Td469 : FLOAT =
        float 0.9
      in
      fsub Td468 Td469
    in
    let Tu223 : UNIT =
      let Ti470 : INT =
        int 4
      in
      app
        calc_dirvecs
        Ti470
        ry
        group_id
        index
    in
    let Ti472 : INT =
      let Ti471 : INT =
        int 1
      in
      sub row Ti471
    in
    let Ti474 : INT =
      let Ti473 : INT =
        int 2
      in
      app
        add_mod5
        group_id
        Ti473
    in
    let Ti476 : INT =
      let Ti475 : INT =
        int 4
      in
      add index Ti475
    in
    app
      calc_dirvec_rows
      Ti472
      Ti474
      Ti476
    unit ()
in
letrec create_dirvec : (UNIT -> (Array of FLOAT * Array of Array of FLOAT)) =
variables : (Tu224 : UNIT)
  let v3 : Array of FLOAT =
    let Ti461 : INT =
      int 3
    in
    let Td462 : FLOAT =
      float 0.
    in
    extfunapp
      create_float_array
      Ti461
      Td462
  in
  let consts : Array of Array of FLOAT =
    let Ti464 : INT =
      let Ti463 : INT =
        int 0
      in
      n_objects.(Ti463)
    in
    extfunapp
      create_array
      Ti464
      v3
  in
  Tuple
    v3
    consts
in
letrec create_dirvec_elements : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (d : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti456 : INT =
    int 0
  in
  if Ti456 <= index
    let Tu225 : UNIT =
      let Tt458 : (Array of FLOAT * Array of Array of FLOAT) =
        let Tu457 : UNIT =
          unit ()
        in
        app
          create_dirvec
          Tu457
      in
      d.(index) <- Tt458
    in
    let Ti460 : INT =
      let Ti459 : INT =
        int 1
      in
      sub index Ti459
    in
    app
      create_dirvec_elements
      d
      Ti460
    unit ()
in
letrec create_dirvecs : (INT -> UNIT) =
variables : (index : INT)
  let Ti447 : INT =
    int 0
  in
  if Ti447 <= index
    let Tu227 : UNIT =
      let Ta451 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        let Ti448 : INT =
          int 120
        in
        let Tt450 : (Array of FLOAT * Array of Array of FLOAT) =
          let Tu449 : UNIT =
            unit ()
          in
          app
            create_dirvec
            Tu449
        in
        extfunapp
          create_array
          Ti448
          Tt450
      in
      dirvecs.(index) <- Ta451
    in
    let Tu226 : UNIT =
      let Ta452 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti453 : INT =
        int 118
      in
      app
        create_dirvec_elements
        Ta452
        Ti453
    in
    let Ti455 : INT =
      let Ti454 : INT =
        int 1
      in
      sub index Ti454
    in
    app
      create_dirvecs
      Ti455
    unit ()
in
letrec init_dirvec_constants : (Array of (Array of FLOAT * Array of Array of FLOAT) -> (INT -> UNIT)) =
variables : (vecset : Array of (Array of FLOAT * Array of Array of FLOAT)), (index : INT)
  let Ti443 : INT =
    int 0
  in
  if Ti443 <= index
    let Tu228 : UNIT =
      let Tt444 : (Array of FLOAT * Array of Array of FLOAT) =
        vecset.(index)
      in
      app
        setup_dirvec_constants
        Tt444
    in
    let Ti446 : INT =
      let Ti445 : INT =
        int 1
      in
      sub index Ti445
    in
    app
      init_dirvec_constants
      vecset
      Ti446
    unit ()
in
letrec init_vecset_constants : (INT -> UNIT) =
variables : (index : INT)
  let Ti438 : INT =
    int 0
  in
  if Ti438 <= index
    let Tu229 : UNIT =
      let Ta439 : Array of (Array of FLOAT * Array of Array of FLOAT) =
        dirvecs.(index)
      in
      let Ti440 : INT =
        int 119
      in
      app
        init_dirvec_constants
        Ta439
        Ti440
    in
    let Ti442 : INT =
      let Ti441 : INT =
        int 1
      in
      sub index Ti441
    in
    app
      init_vecset_constants
      Ti442
    unit ()
in
letrec init_dirvecs : (UNIT -> UNIT) =
variables : (Tu230 : UNIT)
  let Tu232 : UNIT =
    let Ti433 : INT =
      int 4
    in
    app
      create_dirvecs
      Ti433
  in
  let Tu231 : UNIT =
    let Ti434 : INT =
      int 9
    in
    let Ti435 : INT =
      int 0
    in
    let Ti436 : INT =
      int 0
    in
    app
      calc_dirvec_rows
      Ti434
      Ti435
      Ti436
  in
  let Ti437 : INT =
    int 4
  in
  app
    init_vecset_constants
    Ti437
in
letrec add_reflection : (INT -> (INT -> (FLOAT -> (FLOAT -> (FLOAT -> (FLOAT -> UNIT)))))) =
variables : (index : INT), (surface_id : INT), (bright : FLOAT), (v0 : FLOAT), (v1 : FLOAT), (v2 : FLOAT)
  let dvec : (Array of FLOAT * Array of Array of FLOAT) =
    let Tu430 : UNIT =
      unit ()
    in
    app
      create_dirvec
      Tu430
  in
  let Tu234 : UNIT =
    let Ta431 : Array of FLOAT =
      app
        d_vec
        dvec
    in
    app
      vecset
      Ta431
      v0
      v1
      v2
  in
  let Tu233 : UNIT =
    app
      setup_dirvec_constants
      dvec
  in
  let Tt432 : (INT * (Array of FLOAT * Array of Array of FLOAT) * FLOAT) =
    Tuple
      surface_id
      dvec
      bright
  in
  reflections.(index) <- Tt432
in
letrec setup_rect_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    mul obj_id 4
  in
  let nr : INT =
    let Ti402 : INT =
      int 0
    in
    n_reflections.(Ti402)
  in
  let br : FLOAT =
    let Td403 : FLOAT =
      float 1.
    in
    let Td404 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td403 Td404
  in
  let n0 : FLOAT =
    let Td406 : FLOAT =
      let Ti405 : INT =
        int 0
      in
      light.(Ti405)
    in
    app
      fneg
      Td406
  in
  let n1 : FLOAT =
    let Td408 : FLOAT =
      let Ti407 : INT =
        int 1
      in
      light.(Ti407)
    in
    app
      fneg
      Td408
  in
  let n2 : FLOAT =
    let Td410 : FLOAT =
      let Ti409 : INT =
        int 2
      in
      light.(Ti409)
    in
    app
      fneg
      Td410
  in
  let Tu237 : UNIT =
    let Ti412 : INT =
      let Ti411 : INT =
        int 1
      in
      add sid Ti411
    in
    let Td414 : FLOAT =
      let Ti413 : INT =
        int 0
      in
      light.(Ti413)
    in
    app
      add_reflection
      nr
      Ti412
      br
      Td414
      n1
      n2
  in
  let Tu236 : UNIT =
    let Ti416 : INT =
      let Ti415 : INT =
        int 1
      in
      add nr Ti415
    in
    let Ti418 : INT =
      let Ti417 : INT =
        int 2
      in
      add sid Ti417
    in
    let Td420 : FLOAT =
      let Ti419 : INT =
        int 1
      in
      light.(Ti419)
    in
    app
      add_reflection
      Ti416
      Ti418
      br
      n0
      Td420
      n2
  in
  let Tu235 : UNIT =
    let Ti422 : INT =
      let Ti421 : INT =
        int 2
      in
      add nr Ti421
    in
    let Ti424 : INT =
      let Ti423 : INT =
        int 3
      in
      add sid Ti423
    in
    let Td426 : FLOAT =
      let Ti425 : INT =
        int 2
      in
      light.(Ti425)
    in
    app
      add_reflection
      Ti422
      Ti424
      br
      n0
      n1
      Td426
  in
  let Ti427 : INT =
    int 0
  in
  let Ti429 : INT =
    let Ti428 : INT =
      int 3
    in
    add nr Ti428
  in
  n_reflections.(Ti427) <- Ti429
in
letrec setup_surface_reflection : (INT -> ((INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) -> UNIT)) =
variables : (obj_id : INT), (obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT))
  let sid : INT =
    let Ti372 : INT =
      mul obj_id 4
    in
    let Ti373 : INT =
      int 1
    in
    add Ti372 Ti373
  in
  let nr : INT =
    let Ti374 : INT =
      int 0
    in
    n_reflections.(Ti374)
  in
  let br : FLOAT =
    let Td375 : FLOAT =
      float 1.
    in
    let Td376 : FLOAT =
      app
        o_diffuse
        obj
    in
    fsub Td375 Td376
  in
  let p : FLOAT =
    let Ta377 : Array of FLOAT =
      app
        o_param_abc
        obj
    in
    app
      veciprod
      light
      Ta377
  in
  let Tu238 : UNIT =
    let Td384 : FLOAT =
      let Td381 : FLOAT =
        let Td380 : FLOAT =
          let Td378 : FLOAT =
            float 2.
          in
          let Td379 : FLOAT =
            app
              o_param_a
              obj
          in
          fmul Td378 Td379
        in
        fmul Td380 p
      in
      let Td383 : FLOAT =
        let Ti382 : INT =
          int 0
        in
        light.(Ti382)
      in
      fsub Td381 Td383
    in
    let Td391 : FLOAT =
      let Td388 : FLOAT =
        let Td387 : FLOAT =
          let Td385 : FLOAT =
            float 2.
          in
          let Td386 : FLOAT =
            app
              o_param_b
              obj
          in
          fmul Td385 Td386
        in
        fmul Td387 p
      in
      let Td390 : FLOAT =
        let Ti389 : INT =
          int 1
        in
        light.(Ti389)
      in
      fsub Td388 Td390
    in
    let Td398 : FLOAT =
      let Td395 : FLOAT =
        let Td394 : FLOAT =
          let Td392 : FLOAT =
            float 2.
          in
          let Td393 : FLOAT =
            app
              o_param_c
              obj
          in
          fmul Td392 Td393
        in
        fmul Td394 p
      in
      let Td397 : FLOAT =
        let Ti396 : INT =
          int 2
        in
        light.(Ti396)
      in
      fsub Td395 Td397
    in
    app
      add_reflection
      nr
      sid
      br
      Td384
      Td391
      Td398
  in
  let Ti399 : INT =
    int 0
  in
  let Ti401 : INT =
    let Ti400 : INT =
      int 1
    in
    add nr Ti400
  in
  n_reflections.(Ti399) <- Ti401
in
letrec setup_reflections : (INT -> UNIT) =
variables : (obj_id : INT)
  let Ti363 : INT =
    int 0
  in
  if Ti363 <= obj_id
    let obj : (INT * INT * INT * INT * Array of FLOAT * Array of FLOAT * BOOL * Array of FLOAT * Array of FLOAT * Array of FLOAT * Array of FLOAT) =
      objects.(obj_id)
    in
    let Ti364 : INT =
      app
        o_reflectiontype
        obj
    in
    let Ti365 : INT =
      int 2
    in
    if Ti364 == Ti365
      let Tb368 : BOOL =
        let Td366 : FLOAT =
          app
            o_diffuse
            obj
        in
        let Td367 : FLOAT =
          float 1.
        in
        app
          fless
          Td366
          Td367
      in
      let Ti369 : INT =
        int 0
      in
      if Tb368 == Ti369
        unit ()
        let m_shape : INT =
          app
            o_form
            obj
        in
        let Ti370 : INT =
          int 1
        in
        if m_shape == Ti370
          app
            setup_rect_reflection
            obj_id
            obj
          let Ti371 : INT =
            int 2
          in
          if m_shape == Ti371
            app
              setup_surface_reflection
              obj_id
              obj
            unit ()
      unit ()
    unit ()
in
letrec rt : (INT -> (INT -> UNIT)) =
variables : (size_x : INT), (size_y : INT)
  let Tu250 : UNIT =
    let Ti338 : INT =
      int 0
    in
    image_size.(Ti338) <- size_x
  in
  let Tu249 : UNIT =
    let Ti339 : INT =
      int 1
    in
    image_size.(Ti339) <- size_y
  in
  let Tu248 : UNIT =
    let Ti340 : INT =
      int 0
    in
    let Ti341 : INT =
      div size_x 2
    in
    image_center.(Ti340) <- Ti341
  in
  let Tu247 : UNIT =
    let Ti342 : INT =
      int 1
    in
    let Ti343 : INT =
      div size_y 2
    in
    image_center.(Ti342) <- Ti343
  in
  let Tu246 : UNIT =
    let Ti344 : INT =
      int 0
    in
    let Td347 : FLOAT =
      let Td345 : FLOAT =
        float 128.
      in
      let Td346 : FLOAT =
        itof size_x
      in
      fdiv Td345 Td346
    in
    scan_pitch.(Ti344) <- Td347
  in
  let prev : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu348 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu348
  in
  let cur : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu349 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu349
  in
  let next : Array of (Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of BOOL * Array of Array of FLOAT * Array of Array of FLOAT * Array of INT * Array of Array of FLOAT) =
    let Tu350 : UNIT =
      unit ()
    in
    app
      create_pixelline
      Tu350
  in
  let Tu245 : UNIT =
    let Tu351 : UNIT =
      unit ()
    in
    app
      read_parameter
      Tu351
  in
  let Tu244 : UNIT =
    let Tu352 : UNIT =
      unit ()
    in
    app
      write_ppm_header
      Tu352
  in
  let Tu243 : UNIT =
    let Tu353 : UNIT =
      unit ()
    in
    app
      init_dirvecs
      Tu353
  in
  let Tu242 : UNIT =
    let Ta354 : Array of FLOAT =
      app
        d_vec
        light_dirvec
    in
    app
      veccpy
      Ta354
      light
  in
  let Tu241 : UNIT =
    app
      setup_dirvec_constants
      light_dirvec
  in
  let Tu240 : UNIT =
    let Ti358 : INT =
      let Ti356 : INT =
        let Ti355 : INT =
          int 0
        in
        n_objects.(Ti355)
      in
      let Ti357 : INT =
        int 1
      in
      sub Ti356 Ti357
    in
    app
      setup_reflections
      Ti358
  in
  let Tu239 : UNIT =
    let Ti359 : INT =
      int 0
    in
    let Ti360 : INT =
      int 0
    in
    app
      pretrace_line
      cur
      Ti359
      Ti360
  in
  let Ti361 : INT =
    int 0
  in
  let Ti362 : INT =
    int 2
  in
  app
    scan_line
    Ti361
    prev
    cur
    next
    Ti362
in
let Ti336 : INT =
  int 512
in
let Ti337 : INT =
  int 512
in
app
  rt
  Ti336
  Ti337
