lis $d C
ori %d %a C
======================
lui $d C
ori $d $d C


mr $d $b
======================
or $d $r0 $a

neg (multiply -1)
======================
sub $d $r0 $a

add
addi
sub
subi


slw (shift)
======================
sllv $d $a $b

slwi
======================
sll $d $a C

lwzx rD,rA,rB     (4 byte)
# rD = Memory[rA + rB]
======================
add $r27 $a $b
lw $d $r27 0

lwz rD,d(rA)
# rD = Memory[rA + d]
======================
lw $d $a d

stwx rS,rA,rB
# Memory[rA + rB] = rS
======================
add $r27 $a $b
sw $d $r27 0

stw rS,d(rA)
# Memory[rA + d] = rS
======================
sw $d $a C

lfd (load float double)


fmr (move)


fneg


fadd


fsub


fmul


fdiv


lfdx


lfd


stfdx


stfd


fcmpu cr7


fcmpw

cmpw cr7, L, rA, rB
rAとrBを数値比較した結果をcr7に格納する。
cmp cr7, 0, rA, SIMMで実現。

(
if a < b then c ← 0b100
else if a > b then c ← 0b010
else c ← 0b001
)

cmpwi cr7, rA, SIMM
rAと符号あり16bit即値を数値比較した結果をcr7に格納する。
cmpi cr7, 0, rA, SIMMで実現。


cmpw cr7 $a $b
bne cr7 label
=========
beq $b $a label

cmpw cr7 $a $b
bgt cr7 label
=========
slt r28 $b $a
beq r28 r0 label

cmpw cr7 $a $b
bgt cr7 label
=========
slt r28 $a $b
beq r28 r0 label






mtctr  $r + bctr
mtctr  $r + bctrl
(mtctr rS
カウンタレジスタの内容を汎用レジスタrDで置き換える。
関数ポインタへのジャンプや、繰り返し条件分岐用の値を
セットするのによく使われる。mtspr 9, rSで実現。)
(bctr
カウンタレジスタに格納されたアドレスへのジャンプを
無条件で行う。bcctr 20, cr0で実現。)
======================
bctr のとき
mv r26 $rD
jr r26

bctrl のとき
mv r26 $rD
jalr r26




b label
======================
j label




bl target_addr
ジャンプ命令の次の命令のアドレスを
リンクレジスタに格納してからジャンプを行う。
関数を呼び出した時、関数を呼び出した場所に帰って
こなければならないので、この命令でジャンプ位置を保存する。
======================
jal label



blr
リンクレジスタに格納されたアドレスへのジャンプ
関数から出るのに使われる。
======================
jr $31



mtlr rS
リンクレジスタの内容を汎用レジスタrSで置き換える。
=====================
or $r31 $r0 $rS


%%%%%%%%%%%%%%%%%%%%%%
mflr rD
リンクレジスタの内容を汎用レジスタrDに格納する。
mfspr rD, 8で実現。
======================
or $rd $r0 $r31
%%%%%%%%%%%%%%%%%%%%%%


stmw rS, d(rA)
rAに格納された値(r0の場合は0)とdとの和のアドレスを始点として、
メモリを4byte単位で、r31から順番に、rSに与えられた番号のレジスタまで。
正方向に順番に書き込む。書き込み先メモリのアドレスは4の倍数でなければならない。
スタックにレジスタの内容をまとめて退避するのに便利だが、普通のストア命令より遅い。
EA = (rA) - 8
x = rS
do while x ≤ 31
Memory[EA] = $r(x)
x += 1
EA = EA + 4
======================


mflr r0
stmw r30, -8(r1)
stw r0, 8(r1)
stwu r1, -96(r1)


stwu rS, d(rA)
rSの4byte全てを、rAと16bit符号付き即値dとの和のアドレスのメモリに格納する。
さらに、rAにはこの命令で書き出したメモリアドレスが格納される。
メモリアドレスが4の倍数であるほうが効率がいい。


lmw rD, d(rA)
rAに格納された値(r0の場合は0)とdとの和のアドレスを始点として、
メモリを4byte単位で、正方向に順番に読み込み、
r31から順番に、rDに与えられた番号のレジスタまで格納する。
読み込み先メモリのアドレスは4の倍数でなければならない。
スタックにレジスタの内容をまとめて退避から復帰するのに便利だが、
普通のロード命令より遅い



(comment #)
