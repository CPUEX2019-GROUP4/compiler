nop
#

add $d,$s,$t
# $d = $s + $t

sub $d,$s,$t
# $d = $s - $t

addi $t,$s,C
# $t = $s + C (signed)

subi $t,$s,C
# $t = $s - C (signed)

lw $t,C($s) (4 byte = 32 bit)
# $t = Memory[$s + C]

sw $t,C($s) (4 byte = 32 bit)
# Memory[$s + C] = $t

lui $t,C (load immidiate (32 bit) 1st)
# $t = C << 16

and $d,$s,$t
# $d = $s & $t

andi $t,$s,C
# $t = $s & C

or $d,$s,$t
# $d = $s | $t

ori $t,$s,C
# $t = $s | C

slt $d,$s,$t
# $d = ($s < $t) ($s,$t は符号付き)

slti $t,$s,C
# $t = ($s < C)  (C は符号拡張)

sll $d,$t,C
# $d = $t << C

sllv $d,$t,$s
# $d = $t << C

sra $d,$t,C
# $sの内容をCビットだけ右にシフト.
シフトされた空いた上位ビットは元の値を
符号付整数と解釈して符号拡張する.
2の補数で表された符号付整数を 2^C
で割ったのと同等.

beq $s,$t,C
# if ($s == $t) go to PC+4+4*C

bne $s,$t,C
if ($s != $t) go to PC+4+4*C

j C
# PC = PC+4[31:28] . C*4

jr $s
# goto address $s

jal C
# $31 = PC + 8; PC = PC+4[31:28] . C*4

